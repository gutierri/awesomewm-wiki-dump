---
title: Awesome 3 configuration ru
permalink: /Awesome_3_configuration/ru/
---

Описание
========

**awesome 3** теперь использует конфигурационный файл основанный на языке [Lua](http://www.lua.org). Большинство переходящих с awesome 2 будут разочарованы увидев, что старый формат кофигурационного файла в libconfuse исчез, некоторые будут сожалеть по этому поводу, так как они никогда не могли понять формат конфигов [ion'a](http://modeemi.fi/~tuomov/ion/).

Почему Lua? Потому что этот язык дает больше управляемости. Если предположить подобную ситуацию: вам нужно сделать что-то при некотором условии, ранее такого бы не получилось. Но теперь вы можете сделать это. Вы можете сделать практически **все** (конечно в пределах возможностей WM'а).

Файлы
=====

-   ~/.config/awesome/rc.lua
-   /etc/xdg/awesome/rc.lua

По умолчанию если система находит файл в ~/.config/awesome/rc.lua, то используется он. Но если в нем присутсвуют ошибки, либо его нет, то загружается дефолтная конфигурация из /etc/xdg/awesome/rc.lua (никогда не трогайте это файл, чтобы коректно загрузиться в случае сбоев или ошибок в основном файле).

Основы Lua
==========

[Lua](http://www.lua.org) - очень простой язык. Хотя глубокое понимание этого языка не является обязательным условием для использования Awesome, знание Lua напрямую влияет на возможность кастомизации и полной реализации потенциала Awesome.

awesome 3 разработан для опытных пользователей, которые имеют хотя бы минимальные представления о компьютерных технологиях. В любом случае, если у вас есть желание, то выучить основы настройки и управления awesome не составит труда.

Лучший способ выучить Lua - это тратить по паре часов в день на чтение книги [Programming In Lua](http://www.lua.org/pil/), которая даст представление о возможностях языка. В ходе чтения создавайте закладки важных страниц описывающих управление плавающими окнами, содержащих полезную информацию и проч. Это поможет, глупо было бы подглядывать синтаксис цикла *for* в ходе написания кода, не так ли?

Типы объектов awesome
=====================

Для тех людей, что ранее не использовали awesome, в этом разделе представлены базовые объекты, которыми вы сможете управлять.

Screen
------

На самом деле screen — это не объект, но мы подробно рассмотрим этот момент позднее. А пока вам необходимо знать, что screen это реальный монитор (устройство), подключенное к вашему компьютеру. Если вы имеете несколько мониторов, то они будут представлены своими индексами, начиная с единицы.

Client
------

Клиент - это окно приложения.

Tag
---

Тэги - это что-то подобное рабочим столам, но это понятие менее жесткое. Каждый клиент имеет по крайней мере один тэг, ему соответсвующий. Каждый экран также содержит как минимум один тэг. В любой момент на экране вы можете просматривать любое количество тэгов. Отображение без тэгов скроет все клиенты. Просмотр одного и более тэгов отобразит на экране все приложения с этими тэгами.

Widget
------

Виджеты - это объекты выводящие информацию на экран. Существует несколько типов виджетов, которые отображают определенный тип информации: текстовые виджеты, виджеты отображающие иконки.

Titlebar
--------

Заголовок окна - это полоса вокруг приложения и присоединенная к нему. На него можно добавлять виджеты.

Statusbar
---------

Строка состояния - это полоса которая закреплена на границе экрана. На ней так же можно размещать виджеты.

Создание собственного интерфейса
================================

Для создания интерфейса, необходимо использовать функции и методы awesome: **все** описано в [Lua API documentation](http://awesome.naquadah.org/doc/api/) и в man-странице awesomerc(5). Прочтите их, они ваше руководство по разработке.

Создание тэгов
--------------

Если вы запустите awesome без какого либо кода Lua, у вас будет 0 тэгов, что фатально. awesome необходим хотя бы один тэг.

Итак во-первых, нам нужно создать тэг. Как это сделать? Мы ищем описание tag(), функции для создания тегов в man-странице. Там говорится что параметром функции должна являться таблица, которая содержит хотя бы имя атрибута. Сделаем это.

`mytagone = tag({ name = "one" })`

Только что вы создали объект *mytagone* с типом tag и атрибутом name со значением *one*. Если мы захотим установить метод компоновки окон (layout) по умолчанию для этого объекта, мы можем сделать это, добавив пару ключ/значение в таблицу, как описано в документации.

`mytagtwo = tag({name = "two", layout = "floating" })`

Теперь у нас есть второй объект типа tag — "mytagtwo" c атрибутом name со значением *two* и по умолчанию приложения (clients) будут располагаться на нем согласно "плавающему" алгоритму (подобным образом окна располагаются в большинстве WM, например в kwin, metacity etc), который, как видно из его названия, позволяет их перемещать.(? lets the clients float.)

Теперь мы имеем общее представление о создании объектов, но смотря правде в глаза, в данный момент это не приносит нам особой пользы, так как кроме этого мы пока ничего не умеем. Пока запомните: каждый "объект" screen (физический монитор) должен иметь по крайней мере один тэг. Что же, теперь мы хотим добавить только что созданные тэги на наш первый (и возможно единственный) монитор. Атрибут "screen" tag-объекта сделает это за нас, все что нам нужно — это присвоить цифровое значение (индекс, соответствующий монитору) атрибуту screen.

`mytagone.screen = 1`

Только что мы добавили тэг на screen (монитор) \#1. Если у нас есть второй монитор (multi-head: Zaphod, Xinerama или XRandR — для awesome не имеет значения), мы можем добавить наш второй тэг для этого монитора:

`mytagtwo.screen = 2`

Соответственно если у нас 3 монитора нам нужно... Впрочем, я думаю это понятно. :)

Если вы хотите узнать сколько у вас мониторов, вы можете использовать функцию *screen.count()*.

Вы можете управлять отображением тэгов, используя атрибут *selected*. Например, если вы хотите увидеть ваш тэг 'one' (по сути все окна, "привязанные" к этому тэгу):

`mytagone.selected = true`

Если вы хотите скрыть его, вы, очевидно, должны установить установить значение *false* для атрибута *selected*.

Вы можете управлять всеми настройками тэгов, используя их атрибуты. Подробнее смотрите в документации.

Управление приложением (client)
-------------------------------

Иногда вам придется работать с объектами приложений (clients). Чаще всего это используется в hook-функциях, которые мы рассмотрим позднее.

Приложение (client) это такой же объект, который тоже имеет методы, подобно, например, тэгам. Для следующих примеров условимся, что наш объект приложения будет хранится в переменной *c*. Например, если мы хотим установить floating компоновку для приложения мы можем использовать *floating* атрибут таким образом:

`c.floating = true`

Некоторые методы возвращают значения, которые могут быть использованы позднее для анализа. Так, если мы хотим узнать, является ли компоновка приложения (client) *floating*, мы можем получить значение *floating* атрибута:

`is_client_floating = c.floating`

Переменная *is_client_floating* теперь содержит булево (boolean) значение: *true* в случае¸ если компоновка приложения floating, или *false* в обратном случае.

Используя полученные знания, мы можем написать функцию-*переключатель*, которая будет устанавливать атрибут floating приложения (client) в *true*, если режим компоновки *не* floating , и в *false* в обратном случае (когда режим компоновки floating).

`function client_floating_toggle(c)`
`    if c then`
`        c.floating = not c.floating`
`    end`
`end`

Так же мы можем использовать подобную функцию для изменения (*переключения*) тэгов нашего приложения (client):

`function client_tag_with_tag_one(c)`
`    if c then`
`        local t = c:tags()`
`        table.insert(t, one)`
`        c:tags(t)`
`    end`
`end`

Создание виджетов (widget)
--------------------------

Виджеты — это небольшие объекты, которые могут быть расположены (добавлены) в заголовок окна (приложения) или в строку состояния. Подобно тэгам, если вы не добавите их куда-нибудь, они будут полностью бесполезны, вы попросту не сможете их использовать. Для того, чтобы создать виджет вы должны использовать функцию *widget()*:

`mytextbox = widget({ type = "textbox", name = "mytextbox" })`

*mytextbox* теперь содержит объект виджета. Вы можете использовать различные атрибуты для различных типов виджетов. Например, следующая команда устанавливает текст, который будет отображен в только что созданном виджете (тип *textbox*).

`mytextbox.text = "Hello, world!`

Создаем строку состояния (statusbar)
------------------------------------

Строка состояния (statusbar) — это контейнер для виджетов, который вы можете расположить у верхней, нижней, левой или правой границы экрана.

Для начала создадим строку состояния:

`mystatusbar = wibox({ position = "top", name = "mystatusbar" })`

Теперь *mystatysbar* это переменная, содержащая объект строки состояния. Если мы установим значение *top* для атрибута *position* строка состояния будет помещена рядом с верхней границей экрана. Очевидно, что пока мы не "привяжем" строку состояния к нашему монитору, мы не сможем ее видеть и пользоваться ей. Сделаем это:

`mystatusbar.screen = 1`

Наша строка состояния теперь видна рядом с верхней границей экрана. Пока ее никак нельзя использовать, но поверьте — ее функционал очень широк. Давайте добавим на нее виджеты!

`-- Создаем textbox`
`mytextbox = widget({ type = "textbox", name = "mytextbox" })`
`-- Устанавливаем текст для textbox`
`mytextbox.text = "Hello, world!"`
`-- Создаем строку состояния (statusbar)`
`mystatusbar = awful.wibox({ position = "top", name = "mystatusbar" })`
`--Добавляем виджеты на строку состояния`
`mystatusbar:widgets({ mytextbox })`
`-- "Привязываем" строку состояния к первому монитору`
`mystatusbar.screen = 1`

Вуаля. Теперь у нас есть строка состояния, расположенная у верхней границы экрана, на которой напечатано *Hello, world!*. Используя этот метод, вы можете настроить параметры строки состояния и разместить на ней виджеты перед тем как запустить awesome, в вашем конфигурационном файле.

Создание заголовка окна (titlebar)
----------------------------------

Как уже было сказано заголовки окна (titlebars) похожи на строку состояния (statusbar), за тем исключением, что они находятся вокруг окна, а не у границ экрана. Для создания заголовка окна вы должны сделать следующее:

`mytitlebar = titlebar({ position = "top" })`

Потом, возможно, вы захотите поместить на заголовок окна (titlebar) какие-нибудь виджеты. Используем тот же принцип, что и для строки состояния:

`mytitlebartitle = widget({ type = "textbox", name = "mytitlebartitle" })`
`mytitlebar:widgets({ mytitlebartitle })`

Заголовок окна должен быть добавлен (привязан к объекту приложения) в объект приложения (*client object*). Мы можем определить, какое приложение в данный момент находится в фокусе (активное приложение), используя переменную (атрибут) *client.focus*. Давайте попробуем:

`-- Определяем активное приложение (client)`
`c = client.focus`
`-- Устанавливаем для него заголовок окна (titlebar)`
`c.titlebar = mytitlebar`

Теперь у активного окна (focused client) есть милый заголовок (titlebar) сверху. Но пока в заголовоке пусто. Нет, подождите! Мы же добавили в заголовок окна *textbox widget*. Теперь с его помощью мы можем напечатать в заголовке название запущенного приложения (client):

`mytitlebartitle.text = c.name`

Атрибут *name* это строка, содержащая название приложения (client), и мы устанавливаем ее как текст, который будет отображаться внутри виджета. Теперь в заголовке мы можем видеть название запущенного приложения.

Помните: заголовок окна это один объект, а приложение это другой объект. Следовательно вам нужно создать заголовки окна для каждого приложения (client), рядом с которым вы хотите видеть заголовок (titlebar).

Использование ловушек (hooks)
-----------------------------

С тем, что мы рассмотрели ранее, вы можете создать неплохой интерфейс. Однако, представьте, что вам нужно обновить текст в заголовке (titlebar) приложения (client): вы не можете этого сделать. Стойте! Вот решение: ловушки (hooks).

С помощью ловушек (hooks) вы можете определять функции, которые вызываются когда случается какое-либо событие. Давайте разберём это на примере.

Когда новое приложение (client) появляется на экране, awesome запускает функцию, связанную с ловушкой (hook) *manage*. Эта функция вызывается с новым приложением (client) в качестве аргумента. Вот пример:

`function hook_manage(c)`
`    if c.name:find("mplayer") then`
`        c.floating = true`
`    end`
`end`

Прежде всего мы определили функцию *hook_manage* с аргументом *c*, который и будет приложением (client). После этого мы пытаемся найти строку *"mplayer"* в имени приложения, и если находим, устанавливаем для приложения компоновку floating.

` awful.hooks.manage.register(hook_manage)`

Далее мы определяем, что функцией, которая вызывается при появлении каждого нового приложения, будет *hook_manage*.

Есть много ловушек (hooks), которые вы можете использовать и определять: focus, unfocus, manage, unmanage, mouseover, arrange, titleupdate, urgent, timer, … За более подробной информацией загляните на страницу справочника. (Refer to the manpage for more information.)

Запуск команд и скриптов
------------------------

Вы можете запускать команды и скрипты на lua. Вот пример функции, в качестве параметра принимает команду, а возвращает ее вывод. Это может быть полезно при помещении вывода команды в тестовые поля (textboxes)

    -- Запускаем команду и возвращаем ее вывод. Вы можете запускать команды со множеством выходящих строк
    function execute_command(command)
       local fh = io.popen(command)
       local str = ""
       for i in fh:lines() do
          str = str .. i
       end
       io.close(fh)
       return str
    end

Это пример помещения содержимого /proc/loadavg в mytextbox:

     mytextbox.text = " " .. execute_command("cat /proc/loadavg") .. " "

При подключенной библиотеке awful, то же самое можно сделать намного проще, для этого всего лишь в нчале файла rc.lua добавляем

`require("awful")`

А затем в нужном месте вызываем функцию 'awful.util.pread', которая и возвратит вывод скрипта в наш виджет:

`mytextbox.text = awful('наша скриптовая команда')`

Lua-библиотеки awesome
======================

awful
-----

[awful](/awful "wikilink") -- основная библиотека для взаимодействия с awesome (действия мыши, клавиатурные сочетания).

beautiful
---------

[Beautiful](/Beautiful "wikilink") -- библиотека для работы с темами для awesome.

eminent
-------

[Eminent](/Eminent "wikilink") -- библиотека, которая позволяет динамически работать с тэгами. Это означает, что все тэги не являются жестко заданными. Вы можете изменять имена тэгов. Также, переключаясь на следующий тег, когда уже находитесь на последнем, вы получите совершенно новый тег. Это позволяет работать с тегами, не меняя конфигурационный файл.

Shifty
------

[Shifty](/Shifty "wikilink") -- новейшая динамическая библиотека тегов + согласование работы клиентских приложений

naughty
-------

[Naughty](/Naughty/ru "wikilink") -- библиотека для сообщений.

wicked
------

[Wicked](/Wicked "wikilink") -- библиотека, которая предоставляет дополнительные виджеты для awesome, такие как виджеты MPD, загрузка CPU, использование памяти и пр.

[Category: Awesome3](/Category:_Awesome3 "wikilink")