<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.9/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.9/ http://www.mediawiki.org/xml/export-0.9.xsd" version="0.9" xml:lang="en">
  <siteinfo>
    <sitename>awesome</sitename>
    <dbname>awesome</dbname>
    <base>https://awesomewm.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.24.2</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">awesome</namespace>
      <namespace key="5" case="first-letter">awesome talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Absurd-Mind Diskusage Widget</title>
    <ns>0</ns>
    <id>569</id>
    <revision>
      <id>4350</id>
      <parentid>4348</parentid>
      <timestamp>2010-07-05T14:29:14Z</timestamp>
      <contributor>
        <username>Absurd-Mind</username>
        <id>428</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="4001">A nice little diskusage widget

== Screenshot ==
[[File:diskusage-screen.png]]

== How to use ==

put this in 'rc.lua'
&lt;pre&gt;
diskwidget = widget({ type = 'textbox' })
diskwidget.text = &quot;du&quot;
disk = require(&quot;diskusage&quot;)
-- the first argument is the widget to trigger the diskusage
-- the second/third is the percentage at which a line gets orange/red
-- true = show only local filesystems
disk.addToWidget(diskwidget, 75, 90, true)
&lt;/pre&gt;


and this in your 'diskusage.lua'
&lt;pre&gt;
-- @author Peter J. Kranz (Absurd-Mind, peter@myref.net)
-- Any questions, criticism or praise just drop me an email

-- {{{ init environment
local M = {}
local capi = {
    mouse = mouse,
    screen = screen
}
units = {&quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;, &quot;TB&quot;, &quot;PB&quot;, &quot;EB&quot;}
local usage = {}
-- }}}

-- {{{ local functions
-- {{{ Unit formatter
-- formats a value to the corresponding unit
local function uformat(value)
    local ret = tonumber(value)
    for i, u in pairs(units) do
        if ret &lt; 1024 then
            return string.format(&quot;%.1f&quot; .. u, ret)
        end
        ret = ret / 1024;
    end
    return &quot;N/A&quot;
end
-- }}}

-- {{{ getData
-- gets the required data from df
local function getData(onlyLocal)
    -- Fallback to listing local filesystems
    local warg = &quot;&quot;
    if onlyLocal == true then
        warg = &quot;-l&quot;
    end

    local fs_info = {} -- Get data from df
    local f = io.popen(&quot;LC_ALL=C df -kP &quot; .. warg)

    for line in f:lines() do -- Match: (size) (used)(avail)(use%) (mount)
        local s     = string.match(line, &quot;^.-[%s]([%d]+)&quot;)
        local u,a,p = string.match(line, &quot;([%d]+)[%D]+([%d]+)[%D]+([%d]+)%%&quot;)
        local m     = string.match(line, &quot;%%[%s]([%p%w]+)&quot;)

        if u and m then -- Handle 1st line and broken regexp
            fs_info[m] = {}
            fs_info[m][&quot;size&quot;] = s
            fs_info[m][&quot;used&quot;] = u
            fs_info[m][&quot;avail&quot;] = a
            fs_info[m][&quot;used_p&quot;]  = tonumber(p)
            fs_info[m][&quot;avail_p&quot;] = 100 - tonumber(p)
        end
    end
    f:close()
    return fs_info
end
-- }}}

-- {{{ display
-- formats the lines for the notify
local function display(orange, red, onlyLocal)
    data = getData(onlyLocal)
    local lines = &quot;&lt;u&gt;diskusage:&lt;/u&gt;\n&quot;

    local longest = 0
    local longestSize = 0;
    local longestUsed = 0;
    for i, m in pairs(data) do
        if i:len() &gt; longest then
            longest = i:len()
        end

        local s = uformat(m[&quot;size&quot;])
        if s:len() &gt; longestSize then
            longestSize = s:len()
        end

        local u = uformat(m[&quot;used&quot;])
        if u:len() &gt; longestUsed then
            longestUsed = u:len()
        end
    end
    longest = longest + 8

    for i, m in pairs(data) do
        local u = uformat(m[&quot;used&quot;])
        local s = uformat(m[&quot;size&quot;])

        if m[&quot;used_p&quot;] &gt;= red then 
            lines = lines .. &quot;&lt;span color='red'&gt;&quot;
        elseif m[&quot;used_p&quot;] &gt;= orange then
            lines = lines .. &quot;&lt;span color='orange'&gt;&quot;
        else
            lines = lines .. &quot;&lt;span color='green'&gt;&quot;
        end

        lines = lines
                .. &quot;\n&quot;
                .. i
                .. string.rep(&quot; &quot;, longest + longestSize - i:len() - u:len())
                .. u
                .. &quot; / &quot;
                .. s
                .. string.rep(&quot; &quot;, longestUsed - s:len())
                .. &quot; (&quot;
                .. m[&quot;used_p&quot;]
                .. &quot;%)&lt;/span&gt;&quot;
    end

    return lines
end
-- }}}
-- }}}

-- {{{ global functions
function M.addToWidget(mywidget, orange, red, onlyLocal)

  mywidget:add_signal('mouse::enter', function ()
        
        usage = naughty.notify({
                text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, display(orange, red, onlyLocal)),
                timeout = 0,
                hover_timeout = 0.5,
                screen = capi.mouse.screen
        })
  
  end)
  mywidget:add_signal('mouse::leave', function () naughty.destroy(usage) end)
end
-- }}}

return M
&lt;/pre&gt;

[[Category:Widgets]]

[[Category:awesome3]]</text>
      <sha1>ipyq74nti4jxxtjt9zjwl0h3qzcxazj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Acc/ru</title>
    <ns>0</ns>
    <id>454</id>
    <revision>
      <id>3427</id>
      <parentid>3426</parentid>
      <timestamp>2009-08-14T16:00:43Z</timestamp>
      <contributor>
        <username>Atragor</username>
        <id>120</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="3011">{{DISPLAYTITLE:Acc}}
{{Template:Languages|Acc}}

== Awesome Configuration Converter ==
&lt;b&gt;acc находится в стадии разработки.&lt;/b&gt; (во-первых, у него отстойное название и во-вторых, в данный момент ничего не работает).


=== Цель проекта ===
Помочь пользователям перейти с Awesome 2 на Awesome 3, предоставив слой совместимости.


=== Как это будет реализовано ===
Идея состоит в написании библиотеки Lua для интерпретации конфигурационных файлов Awesome 2.X. Файл, использующий acc, будет выглядеть примерно так:
    require(&quot;acc&quot;)
    acc.translate(&quot;/путь/к/файлу/конфигурации/awesome/2.X&quot;)

После этих строк пользователь сможет добавлять код на Lua, постепенно удаляя настройки из файла от версии 2.X. В конечном счете конфигурация будет полностью переписана на Lua и приведённые выше строки можно будет удалить. Звучит неплохо, не так ли? :)


=== Это то, что мне нужно! Как бы попробовать этот acc в деле? ===
Пока никак, он ещё не работает.


=== Так... А я могу чем-нибудь помочь? ===
Вы можете помочь мне его написать. От Вас потребуется хорошее знание настроек Awesome 2.X (и 3.X) и основ Lua (ну их то Вы наверняка знаете, раз смогли настроить Awesome 3 ;)). Вот и всё!
Я создал репозиторий mercurial:
* [[http://hg.kaworu.ch/acc Репозиторий ACC]]

Вы также можете помочь, отправив мне свой конфигурационный файл Awesome 2.X и приняв участие в тестировании acc, когда он заработает. Это сильно ускорит процесс разработки.

=== Разработка ===
Я думаю, что процесс нужно разбить на 4 шага:
* лексический анализатор
* парсер
* анализатор
* интерпретатор

The lexer/parser are used to parse the libconfuse config file in Lua.
The analyzer ensure that the config file looks like an awesome config (for example, should reject &quot;keys { screen 2 { ... } }&quot;)
The interpreter setup a default config and then translate the AST into awesome's Lua calls.

* The Lexer seems ok, and I'm currently working on the parser.
* update at 1231124037 time_t : parser seems ok, will begin the analyzer soon

[[Category:Awesome2]]
[[Category:Awesome3]]</text>
      <sha1>fuhp8cwxxj0xexwt6tdlvcmtmiqscgy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>According awesomerc</title>
    <ns>0</ns>
    <id>84</id>
    <revision>
      <id>1237</id>
      <timestamp>2008-10-15T16:10:30Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="13810">  screen 0
  {
    general
    {
      sloppy_focus_raise = false
      border = 2
      resize_hints = false
      snap = 50
      new_become_master = true
    }

    styles
    {
      #light
      focus { font = &quot;terminus 10&quot; fg = &quot;#081408&quot; border = &quot;#444400&quot; bg = &quot;#cccc33&quot; }
      normal { font = &quot;terminus 10&quot;  fg = &quot;#111111&quot; border = &quot;#000000&quot; bg = &quot;#ffffcc&quot; }
    }

    tags
    {
      tag 1 { layout = &quot;tile&quot; mwfact = 0.68 nmaster = 3 }
      tag F { layout = &quot;max&quot; mwfact = 0.68 nmaster = 3 }
      tag 3 { layout = &quot;tile&quot; mwfact = 0.68 nmaster = 3 }
      tag M { layout = &quot;tile&quot; mwfact = 0.68 nmaster = 3 }
      tag 5 { layout = &quot;max&quot; mwfact = 0.68 nmaster = 3 }
      tag 6 { layout = &quot;floating&quot; mwfact = 0.68 nmaster = 3 }
      tag 7 { layout = &quot;tile&quot; mwfact = 0.68 nmaster = 3 }
      tag 8 { layout = &quot;floating&quot; mwfact = 0.68 nmaster = 3 }
      tag 9 { layout = &quot;tile&quot; nmaster = 3 }
    }

    layouts
    {
      layout tile { image = &quot;/home/calmar/pics/icons/awesome/layouts/tile_grey_small.png&quot; }
      layout max { image = &quot;/home/calmar/pics/icons/awesome/layouts/max_grey_small.png&quot; }
      layout floating { image = &quot;/home/calmar/pics/icons/awesome/layouts/floating_grey_small.png&quot; }
    }

    statusbar sbtop
    {
      position = &quot;top&quot;
      height = 22
      taglist tl
      {
        mouse { button = &quot;1&quot; command = &quot;tag_view&quot; }
        mouse { button = &quot;1&quot; modkey = {&quot;Mod1&quot;} command = &quot;client_tag&quot; }
        mouse { button = &quot;3&quot; command = &quot;tag_toggleview&quot; }
        mouse { button = &quot;3&quot; modkey = {&quot;Mod1&quot;} command = &quot;client_toggletag&quot; }
        mouse { button = &quot;4&quot; command = &quot;tag_viewnext&quot; }
        mouse { button = &quot;5&quot; command = &quot;tag_viewprev&quot; }
      }

      ######
      layoutinfo li
      {
        mouse { button = &quot;1&quot; command = &quot;tag_setlayout&quot; arg = &quot;+1&quot; }
        mouse { button = &quot;4&quot; command = &quot;tag_setlayout&quot; arg = &quot;+1&quot; }
        mouse { button = &quot;3&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot; }
        mouse { button = &quot;5&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot; }
      }

      ######
      focusicon fi {}

      tasklist tasktop
      {
        show_icons = false
        #text_align=&quot;left&quot; font = &quot;Sans-7&quot;
        mouse { button = &quot;2&quot; command = &quot;client_kill&quot; }
        mouse { button = &quot;3&quot; command = &quot;spawn&quot; arg = &quot;9menu_open&quot; }
        #mouse { button = &quot;3&quot; command = &quot;client_togglemax&quot; }
        mouse { button = &quot;4&quot; command = &quot;client_focusnext&quot; }
        mouse { button = &quot;5&quot; command = &quot;client_focusprev&quot; }
        mouse { modkey = {&quot;Mod1&quot;} button = &quot;4&quot; command = &quot;client_swapnext&quot; }
        mouse { modkey = {&quot;Mod1&quot;} button = &quot;5&quot; command = &quot;client_swapprev&quot; }
      }

      #textbox tb_cpu { style { fg = &quot;#669966&quot; }  text = &quot; CPU:&quot; }

      iconbox ib_cpu { image=&quot;/home/calmar/pics/icons/awesome/cpu.png&quot; }

      graph gr_cpu
      {
        #light
        data total { scale = false max = 100  draw_style = bottom
          vertical_gradient = &quot;true&quot; fg = &quot;#996666&quot; fg_center = &quot;#aa7777&quot; fg_end = &quot;#cc9999&quot; }
        data user { scale = false max = 100  draw_style = bottom
          vertical_gradient = &quot;true&quot;  fg = &quot;#009900&quot; fg_center = &quot;#00aa00&quot; fg_end = &quot;#00ff00&quot;  }
        data nice { scale = false max = 100  draw_style = bottom 
          vertical_gradient = &quot;true&quot; fg = &quot;#999999&quot; fg_center = &quot;#aaaaaa&quot; fg_end = &quot;#ffffff&quot; }
        width = 50
        height = &quot;0.80&quot;
        #light
        bg = &quot;#ffffee&quot;
        #dark
        #bg = &quot;#000000&quot;
        grow = left
        bordercolor = &quot;#225522&quot;
      }

      iconbox ib_mem { image=&quot;/home/calmar/pics/icons/awesome/memory.png&quot; }

      progressbar pb_mem
      {
        #light
        data mem { bg = &quot;#ffffee&quot; fg = &quot;#6666cc&quot; fg_center = &quot;#9999ee&quot; fg_end = &quot;#ccccff&quot; fg_off = &quot;#ffffff&quot; bordercolor = &quot;#666699&quot; }
        data swap { bg = &quot;#ffffee&quot;  fg = &quot;#991111&quot; fg_center = &quot;#cc1111&quot; fg_end = &quot;#ff0000&quot; fg_off = &quot;#ffffff&quot; bordercolor = &quot;#666699&quot; }
        width = &quot;32&quot; height = &quot;0.80&quot; 
        gap = 1
        border_padding = 0
        border_width = 1
        ticks_count = 0
        vertical=&quot;true&quot;
      }

      textbox tb_net_in { style {fg = &quot;#009966&quot; } text = &quot; In&quot; }
      textbox tb2 { style {fg = &quot;#666666&quot; } text = &quot;/&quot; }
      textbox tb_net_out { style {fg = &quot;#996600&quot; } text = &quot;Out&quot; }

      emptybox BC { width = 3 }
      #iconbox ib_net { image=&quot;/home/calmar/pics/icons/awesome/internet.png&quot; }

      graph gr_net
      {
        data in {  vertical_gradient = true scale = true max = 80 fg = &quot;#33cc33&quot; fg_end = &quot;#339933&quot; draw_style = bottom}
        data out { vertical_gradient = true scale = true max = 8 fg = &quot;#993300&quot; fg_end = &quot;#cc6600&quot; draw_style = line}
        #light
        bg = &quot;#ffffee&quot; bordercolor = &quot;#444466&quot;
        width = 50 
        height = &quot;0.80&quot;
        grow = left
      }

      iconbox ib_df { image=&quot;/home/calmar/pics/icons/awesome/diskfree.png&quot; }

      emptybox B { width = 3 }

      progressbar pb_df_1
      {
        #light
        data root { fg = &quot;#666699&quot; fg_center = &quot;#6666cc&quot; fg_end = &quot;#9999cc&quot; fg_off = &quot;#ffffee&quot; bordercolor = &quot;#4444cc&quot; }
        data home { fg = &quot;#669966&quot; fg_center = &quot;#99cc99&quot; fg_end = &quot;#99ff99&quot; fg_off = &quot;#ffffee&quot; bordercolor = &quot;#336633&quot; }
        data multi { fg = &quot;#cc6666&quot; fg_center = &quot;#dd9999&quot; fg_end = &quot;#ff9999&quot; fg_off = &quot;#ffffee&quot; bordercolor = &quot;#663333&quot; }
        width = &quot;28&quot; height = &quot;0.80&quot; gap = 1
        vertical=&quot;true&quot;
        border_width = 1
        border_padding = 0
        ticks_gap = 1
        ticks_count = 0
      }

      textbox tb3 { style { fg = &quot;#663333&quot; } text = &quot; [&quot; }
      textbox tb_mail { style { fg = &quot;#993333&quot; } }
      textbox tb4 { style { fg = &quot;#663333&quot; } text = &quot;] &quot; }

      textbox tb_date
      {
        style { fg = &quot;#009933&quot; } text = &quot; -  &quot;
        mouse { button = &quot;5&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot; }
        mouse { button = &quot;4&quot; command = &quot;tag_viewprev&quot;}
      }

    }
    statusbar sbbottom
    {
      position = &quot;bottom&quot;
      height = 14
      tasklist taskbottom
      {
        show_icons = true
        show = all
        styles { normal { font = &quot;Terminus 8&quot; } focus { font = &quot;Terminus 8&quot; }}
        mouse { button = &quot;2&quot; command = &quot;client_kill&quot; }
        mouse { button = &quot;3&quot; command = &quot;spawn&quot; arg = &quot;9menu_open&quot; }
        #mouse { button = &quot;3&quot; command = &quot;client_togglemax&quot; }
        mouse { button = &quot;4&quot; command = &quot;client_focusnext&quot; }
        mouse { button = &quot;5&quot; command = &quot;client_focusprev&quot; }
        mouse { modkey = {&quot;Mod1&quot;} button = &quot;4&quot; command = &quot;client_swapnext&quot; }
        mouse { modkey = {&quot;Mod1&quot;} button = &quot;5&quot; command = &quot;client_swapprev&quot; }
      }
    }
  }

  menu &gt;
  {
    styles #light
    {
      normal { font = &quot;fixed 13&quot; bg = &quot;#cccc00&quot; fg = &quot;#000033&quot; }
      focus {  font = &quot;fixed 13&quot;bg = &quot;#ffff00&quot; fg = &quot;#000011&quot; }
    }
    y = &quot;995&quot;
  }

  rules {
    rule { name = &quot;MPlayer&quot; float = true }
    rule { name = &quot;ding&quot; float = true }
    rule { name = &quot;feh&quot; float = true }
    rule { name = &quot;firefox&quot; float = true tags = &quot;2&quot; }
    rule { name = &quot;fritz&quot; float = true }
    rule { name = &quot;gimp&quot; float = true }
    rule { name = &quot;gvim&quot; icon = &quot;/home/calmar/pics/icons/awesome/apps/gvim.png&quot; }
    rule { name = &quot;urxvt&quot; icon = &quot;/home/calmar/pics/icons/awesome/apps/konsole.png&quot; }
    rule { name = &quot;wine&quot; float = true }
    rule { name = &quot;xclock&quot; float = true }
    rule { name = &quot;xvkbd&quot; float = true }
  }

  mouse {
      root { button = &quot;3&quot; command = &quot;spawn&quot; arg = &quot;9menu_open&quot; }
      client { modkey = {&quot;Mod1&quot;} button = &quot;1&quot; command = &quot;client_movemouse&quot; }
      client { modkey = {&quot;Mod1&quot;} button = &quot;2&quot; command = &quot;client_zoom&quot; }
      client { modkey = {&quot;Mod1&quot;} button = &quot;3&quot; command = &quot;client_resizemouse&quot; }
  }

  keys {
    #spawn programs
    #--------------
    key { modkey = {&quot;Mod1&quot;} key = &quot;Return&quot;                command = &quot;spawn&quot; arg = &quot;exec urxvt 2&gt;/dev/null&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;o&quot;                     command = &quot;spawn&quot; arg = &quot;awesome-menu.sh&quot; }

    ###############################################################################
    #often
    #
    key { modkey = {&quot;Mod1&quot;} key = &quot;j&quot;                     command = &quot;client_focusnext&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;k&quot;                     command = &quot;client_focusprev&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;j&quot;          command = &quot;client_swapnext&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;k&quot;          command = &quot;client_swapprev&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;F11&quot;                   command = &quot;client_focusnext&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;F10&quot;                   command = &quot;client_focusprev&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;c&quot;                     command = &quot;client_kill&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;m&quot;                     command = &quot;client_togglemax&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;m&quot;            command = &quot;client_toggleverticalmax&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;m&quot;          command = &quot;client_togglehorizontalmax&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;f&quot;                     command = &quot;client_togglefloating&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;s&quot;                     command = &quot;client_togglescratch&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;s&quot;          command = &quot;client_setscratch&quot; }
    #view tag ...
    key { modkey = {&quot;Mod1&quot;} key = &quot;0&quot;                     command = &quot;tag_view&quot; }
    keylist { modkey = {&quot;Mod1&quot;}
              keylist = {1, 2, 3, 4, 5, 6, 7, 8, 9}
              command = &quot;tag_view&quot;
              arglist = {1, 2, 3, 4, 5, 6, 7, 8, 9} }
    key { modkey = {&quot;Mod1&quot;} key = &quot;Escape&quot;                command = &quot;tag_prev_selected&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;F12&quot;                   command = &quot;tag_viewnext&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;F9&quot;                    command = &quot;tag_viewprev&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;h&quot;                     command = &quot;tag_viewprev&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;l&quot;                     command = &quot;tag_viewnext&quot; }
    #
    key { modkey = {&quot;Mod1&quot;} key = &quot;comma&quot;                 command = &quot;tag_setmwfact&quot; arg = &quot;-0.05&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;period&quot;                command = &quot;tag_setmwfact&quot; arg = &quot;+0.05&quot; }
    #toggle layouts
    key { modkey = {&quot;Mod1&quot;} key = &quot;space&quot;                 command = &quot;tag_setlayout&quot; arg = &quot;+1&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;space&quot;      command = &quot;tag_setlayout&quot; arg = &quot;-1&quot; }

    #moving/resizing client
    key { modkey = {&quot;Mod1&quot;} key = &quot;Up&quot;                    command = &quot;client_moveresize&quot; arg = &quot;+0 -18 +0 +0&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;Down&quot;                  command = &quot;client_moveresize&quot; arg = &quot;+0 +18 +0 +0&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;Left&quot;                  command = &quot;client_moveresize&quot; arg = &quot;-18 +0 +0 +0&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;Right&quot;                 command = &quot;client_moveresize&quot; arg = &quot;+18 +0 +0 +0&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;Up&quot;         command = &quot;client_moveresize&quot; arg = &quot;+0 +0 +0 -18&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;Down&quot;       command = &quot;client_moveresize&quot; arg = &quot;+0 +0 +0 +18&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;Right&quot;      command = &quot;client_moveresize&quot; arg = &quot;+0 +0 +18 +0&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;Left&quot;       command = &quot;client_moveresize&quot; arg = &quot;+0 +0 -18 +0&quot; }
    # tile hints
    key { modkey = {&quot;Mod1&quot;} key = &quot;F6&quot;  command = &quot;client_settilefact&quot; arg = &quot;1.0&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;F7&quot;  command = &quot;client_settilefact&quot; arg = &quot;-0.1&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;F8&quot;  command = &quot;client_settilefact&quot; arg = &quot;+0.1&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;F5&quot;  command = &quot;client_toggletitlebar&quot; }

    ###############################################################################
    #less often
    #
    #move clients around: Mod1 + Control + Number
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;0&quot;          command = &quot;client_tag&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;0&quot;          command = &quot;client_toggletag&quot; }
    keylist { modkey = {&quot;Mod1&quot;, &quot;Control&quot;}
              keylist = {1, 2, 3, 4, 5, 6, 7, 8, 9}
              command = &quot;client_tag&quot;
              arglist = {1, 2, 3, 4, 5, 6, 7, 8, 9} }
    keylist { modkey = {&quot;Mod1&quot;, &quot;Control&quot;}
              keylist = {1, 2, 3, 4, 5, 6, 7, 8, 9}
              command = &quot;client_toggletag&quot;
              arglist = {1, 2, 3, 4, 5, 6, 7, 8, 9} }
    #layout
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;h&quot;          command = &quot;tag_setnmaster&quot; arg = &quot;+1&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;l&quot;          command = &quot;tag_setnmaster&quot; arg = &quot;-1&quot; }
    #awesome
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;r&quot;          command = &quot;exec&quot; arg = &quot;/usr/local/bin/awesome&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;q&quot;          command = &quot;quit&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;b&quot;          command = &quot;statusbar_toggle&quot; }
    #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;s&quot;          command = &quot;client_moveresize&quot; }

    ###############################################################################
    #seldom
    #
    #additionally view tag &lt;nr&gt;: Mod1 + Shift + Number
    key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;0&quot;            command = &quot;tag_toggleview&quot; }
    keylist { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;}
              keylist = {1, 2, 3, 4, 5, 6, 7, 8, 9}
              command = &quot;tag_toggleview&quot;
              arglist = {1, 2, 3, 4, 5, 6, 7, 8, 9} }
    #inc/dec number of columns
    key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;h&quot;            command = &quot;tag_setncol&quot; arg = &quot;-1&quot; }
    key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;l&quot;            command = &quot;tag_setncol&quot; arg = &quot;+1&quot; }
    #number of master clients

    key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;t&quot;         command = &quot;client_settrans&quot; arg = &quot;+0.1&quot; }
    key { modkey = {&quot;Mod1&quot;} key = &quot;t&quot;                    command = &quot;client_settrans&quot; arg = &quot;-0.1&quot; }
    #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;Return&quot;      command = &quot;client_zoom&quot; arg=&quot;-0.10&quot; }
  }

[[Category:Awesome2]]</text>
      <sha1>sbp7hib3e33mnwa05a2nhprjj9g2snl</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Accueil</title>
    <ns>0</ns>
    <id>405</id>
    <redirect title="Main Page/fr" />
    <revision>
      <id>3030</id>
      <timestamp>2009-06-25T20:20:15Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Accueil]] to [[Main Page/fr]] over redirect: This should be grouped with its english version and [[Template:Languages]] was kinda broken due to this.</comment>
      <text xml:space="preserve" bytes="26">#REDIRECT [[Main Page/fr]]</text>
      <sha1>f2hlnff0q5fp3k8oo43x6hwmlsbycym</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Acpitools-based battery widget</title>
    <ns>0</ns>
    <id>538</id>
    <revision>
      <id>6096</id>
      <parentid>4043</parentid>
      <timestamp>2013-08-30T21:42:07Z</timestamp>
      <contributor>
        <username>Lowkey</username>
        <id>696</id>
      </contributor>
      <text xml:space="preserve" bytes="2740">And here's my personal battery widget. It's using [http://freeunix.dyndns.org:8000/site2/acpitool.shtml acpitool] as a battery information source (so install that first), and uses &lt;span&gt; colors for an added touch (you might need to change the specific colors for contrastual reasons). Other than that, it's heavily based on [[Battery Widget using powersave]].

&lt;pre&gt;
mybattmon = widget({ type = &quot;textbox&quot;, name = &quot;mybattmon&quot;, align = &quot;right&quot; })
function battery_status ()
    local output={} --output buffer
    local fd=io.popen(&quot;acpitool -b&quot;, &quot;r&quot;) --list present batteries
    local line=fd:read()
    while line do --there might be several batteries.
        local battery_num = string.match(line, &quot;Battery \#(%d+)&quot;)
        local battery_load = string.match(line, &quot; (%d*\.%d+)%%&quot;)
        local time_rem = string.match(line, &quot;(%d+\:%d+)\:%d+&quot;)
	local discharging
	if string.match(line, &quot;discharging&quot;)==&quot;discharging&quot; then --discharging: always red
		discharging=&quot;&lt;span color=\&quot;#CC7777\&quot;&gt;&quot;
	elseif tonumber(battery_load)&gt;85 then --almost charged
		discharging=&quot;&lt;span color=\&quot;#77CC77\&quot;&gt;&quot;
	else --charging
		discharging=&quot;&lt;span color=\&quot;#CCCC77\&quot;&gt;&quot;
	end
        if battery_num and battery_load and time_rem then
            table.insert(output,discharging..&quot;BAT#&quot;..battery_num..&quot; &quot;..battery_load..&quot;%% &quot;..time_rem..&quot;&lt;/span&gt;&quot;)
        elseif battery_num and battery_load then --remaining time unavailable
            table.insert(output,discharging..&quot;BAT#&quot;..battery_num..&quot; &quot;..battery_load..&quot;%%&lt;/span&gt;&quot;)
        end --even more data unavailable: we might be getting an unexpected output format, so let's just skip this line.
        line=fd:read() --read next line
    end
    return table.concat(output,&quot; &quot;) --FIXME: better separation for several batteries. maybe a pipe?
end
mybattmon.text = &quot; &quot; .. battery_status() .. &quot; &quot;
my_battmon_timer=timer({timeout=30})
my_battmon_timer:add_signal(&quot;timeout&quot;, function()
    --mytextbox.text = &quot; &quot; .. os.date() .. &quot; &quot;
    mybattmon.text = &quot; &quot; .. battery_status() .. &quot; &quot;
end)
my_battmon_timer:start()
&lt;/pre&gt;

Don't forget to register mybattmon.

----





Here's a version for acpitool using bashets and tested in Awesome 3.5

  bashets = require(&quot;bashets&quot;)
  batterystatus = wibox.widget.textbox()
  bashets.register(&quot;/usr/bin/acpitool -b | cut -d: -f2-&quot;, 
                   {
                       widget = batterystatus,
                       update_time = 60, 
                       separator = '|',
                       format = &quot;  Battery: $1&quot; 
                   })

Then just make sure that:
  right_layout:add(batterystatus) 
has been added to your mywibox configuration and you're ready to go.

Simple and it updates once a minute.  

- lowkey  

[[Category:Awesome3]]
[[Category:Widgets]]</text>
      <sha1>oagxipe8r9477enop2jpmgb6fpyfsrm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Active RAM</title>
    <ns>0</ns>
    <id>277</id>
    <revision>
      <id>6682</id>
      <parentid>6681</parentid>
      <timestamp>2014-05-28T17:05:08Z</timestamp>
      <contributor>
        <username>Rvalencia</username>
        <id>3305</id>
      </contributor>
      <text xml:space="preserve" bytes="3547">= IceBrain's Active RAM Widget =

This function returns the Active memory usage, according to /proc/meminfo. It is a &quot;light&quot; function as it doesn't spawn any processes and it's composed of plain Lua, so it should work on all Awesome versions.

== Function code ==

Paste this inside your rc.lua:

There are two versions, copy only one, according to your taste. The first prints the usage in MB:

  function activeram()
      local active
      for line in io.lines('/proc/meminfo') do
          for key, value in string.gmatch(line, &quot;(%w+):\ +(%d+).+&quot;) do
              if key == &quot;Active&quot; then active = tonumber(value) end
          end
      end
       
      return string.format(&quot;%.2fMB&quot;,(active/1024))
  end

This prints in percentage of total RAM used:

  function activeram()
  	local active, total
  	for line in io.lines('/proc/meminfo') do
  		for key, value in string.gmatch(line, &quot;(%w+):\ +(%d+).+&quot;) do
  			if key == &quot;Active&quot; then active = tonumber(value)
  			elseif key == &quot;MemTotal&quot; then total = tonumber(value) end
  		end
  	end
  	
  	return string.format(&quot;%.0f%%&quot;,(active/total)*100)
  end

== Usage ==

Now, you can use a normal textbox to show you RAM usage:

First, create the widget:
  meminfo = widget({ type = &quot;textbox&quot;, align = &quot;right&quot; })

Then, assign a hook to update it:
  awful.hooks.timer.register(10, function() meminfo.text = activeram() end)

Finally, assign it to your wibox:
  mywibox[s].widgets = {   ...
                           meminfo,
                           ...
                           s == 1 and mysystray or nil }


== Update for version 3.5.5 ==

1. Create a file called '''activeram.lua''' and paste one of the following two versions:

1a. The first version (in MB)

    local wibox = require(&quot;wibox&quot;)
    local awful = require(&quot;awful&quot;)
    
    activeram_widget = wibox.widget.textbox()
    activeram_widget:set_align(&quot;right&quot;)
    
    function update_activeram(widget)
        local active
        for line in io.lines('/proc/meminfo') do
            for key, value in string.gmatch(line, &quot;(%w+):\ +(%d+).+&quot;) do
                if key == &quot;Active&quot; then active = tonumber(value) end
            end
        end
    
        widget:set_markup(string.format(&quot;%.2fMB&quot;,(active/1024)))
    end
    
    update_activeram(activeram_widget)
    
    memtimer = timer({ timeout = 10 })
    memtimer:connect_signal(&quot;timeout&quot;, function () update_activeram(activeram_widget) end)
    memtimer:start()


1b. The second version (in percentage)
    local wibox = require(&quot;wibox&quot;)
    local awful = require(&quot;awful&quot;)
    
    activeram_widget = wibox.widget.textbox()
    activeram_widget:set_align(&quot;right&quot;)
    
    function update_activeram(widget)
        local active, total
  	for line in io.lines('/proc/meminfo') do
  		for key, value in string.gmatch(line, &quot;(%w+):\ +(%d+).+&quot;) do
  			if key == &quot;Active&quot; then active = tonumber(value)
  			elseif key == &quot;MemTotal&quot; then total = tonumber(value) end
  		end
  	end
    
        widget:set_markup(string.format(&quot;%.2fMB&quot;,(active/1024)))
    end
    
    update_activeram(activeram_widget)
    
    memtimer = timer({ timeout = 10 })
    memtimer:connect_signal(&quot;timeout&quot;, function () update_activeram(activeram_widget) end)
    memtimer:start()

2. Paste the below line in '''rc.lua''' near the top where other require lines are:

    require(&quot;activeram&quot;)

3. Paste the below line in '''rc.lua''' as well, except it should be just before the line with '''&quot;right_layout:add(mylayoutbox[s])&quot;''':

    right_layout:add(activeram_widget)


[[Category:Awesome3]]</text>
      <sha1>1jlu7vief5pt7bf1nv9ez3awy3mb4do</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Add Persian keyboard keyoaut</title>
    <ns>0</ns>
    <id>1251</id>
    <revision>
      <id>7279</id>
      <parentid>7166</parentid>
      <timestamp>2015-01-12T02:32:28Z</timestamp>
      <contributor>
        <username>MohsenPahlevanzadeh</username>
        <id>4089</id>
      </contributor>
      <text xml:space="preserve" bytes="886">However [https://awesome.naquadah.org/wiki/Change_keyboard_maps Changing Keyboard map] explains how to in details, But I decide to wrote a function to change my layout to [http://en.wikipedia.org/wiki/Persian_language Persian Language] map, You can add the following code to rc.lua for using it:
  -- the following code has been tested on 3.5 
  keyboard_layout = {&quot;us&quot;,&quot;ir&quot;}
  current_layout =  keyboard_layout[1]
  switch = function() 
    if current_layout == &quot;us&quot; then current_layout = keyboard_layout[2]
    else current_layout =  keyboard_layout[1] end
    os.execute(&quot;setxkbmap &quot; .. current_layout)
    naughty.notify{text=&quot;Keyboard layout has been changed to &quot; .. current_layout}
  end  
  globalkeys = awful.util.table.join(globalkeys, awful.key({ &quot;Mod1&quot;  }, &quot;Shift_L&quot;, function()  switch() end ))

You can change between English and Persian language with ALT_L + SHIFT_L keys.</text>
      <sha1>cyt80u61e3omx2n6slzfgt7d4v13efi</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Adding widget to wibox</title>
    <ns>0</ns>
    <id>880</id>
    <revision>
      <id>6505</id>
      <parentid>5700</parentid>
      <timestamp>2014-05-14T08:27:11Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <minor/>
      <comment>Add [[Template:Outdated]]</comment>
      <text xml:space="preserve" bytes="1685">{{Outdated}}
{{VersionSpecific
| goodversions = 3.4.x
| otherversions = [[Adding_widget_to_wibox/3.5|3.5]]
}}

== Howto ==

In order to add a widget (for example named '''cpuwidget''') to the main wibox (statusbar, top panel, the thing you see at the top of your screen) do the following steps:

1. Open your '''rc.lua''' configuration file.

2. Locate the line 
   mywibox[s].widgets = {

'''mywibox[s].widgets''' is practically a list of widgets for the statusbar on the screen '''s'''.

* To add the widget to the left insert it somewhere into the first internal table. The definition should become something like:

    mywibox[s].widgets = {
        {
            mylauncher,
            mytaglist[s],
            cpuwidget, -- This is our custom widget. It will appear after the taglist on the statusbar.
            mypromptbox[s],
            layout = awful.widget.layout.horizontal.leftright
        },
        mylayoutbox[s],
        mytextclock,
        s == 1 and mysystray or nil,
        mytasklist[s],
        layout = awful.widget.layout.horizontal.rightleft
    }

* To add the widget to the right insert it somewhere into top-level table. The definition should become something like:

    mywibox[s].widgets = {
        {
            mylauncher,
            mytaglist[s],
            mypromptbox[s],
            layout = awful.widget.layout.horizontal.leftright
        },
        mylayoutbox[s],
        mytextclock,
        cpuwidget, -- This is our custom widget. It will appear between clock and tray.
        s == 1 and mysystray or nil,
        mytasklist[s],
        layout = awful.widget.layout.horizontal.rightleft
    }

3. Restart Awesome to see the effect.</text>
      <sha1>8mq8ffpls6whmc9ynfdi4wkx2iz69mh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Aero snap</title>
    <ns>0</ns>
    <id>966</id>
    <revision>
      <id>6174</id>
      <timestamp>2013-12-06T17:44:44Z</timestamp>
      <contributor>
        <username>Zarkone</username>
        <id>3119</id>
      </contributor>
      <comment>Created page with &quot;There is a small module for manual window tiling (also known as Aero Snap function in Windows or Grid plugin in Compiz).   [https://github.com/zarkone/hand-tiler https://github.c...&quot;</comment>
      <text xml:space="preserve" bytes="238">There is a small module for manual window tiling (also known as Aero Snap function in Windows or Grid plugin in Compiz). 

[https://github.com/zarkone/hand-tiler https://github.com/zarkone/hand-tiler https://github.com/zarkone/hand-tiler]</text>
      <sha1>plc5vgf5s1qvmql3915lqlkiqnwb5dj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Alternative Menu</title>
    <ns>0</ns>
    <id>595</id>
    <revision>
      <id>4503</id>
      <timestamp>2010-10-02T06:16:36Z</timestamp>
      <contributor>
        <username>Batz</username>
        <id>525</id>
      </contributor>
      <comment>Created page with '== Batz Alternative Menu ==  === Introduction === I really liked the built-in menu for selecting a particular window quickly.  However, the up/down mechanism was too limiting (no…'</comment>
      <text xml:space="preserve" bytes="1702">== Batz Alternative Menu ==

=== Introduction ===
I really liked the built-in menu for selecting a particular window quickly.  However, the up/down mechanism was too limiting (not efficient).  I modified the menu.lua code to add a hint to quickly raise a window.

=== Diff from awesome 3.4.6 menu.lua ===
 32c32
 &lt; module(&quot;awful.menu&quot;)
 ---
 &gt; module(&quot;batz.menu&quot;)
 34a35,36
 &gt; --keys = &quot;aoeuidhtns',.pyfgcrl;qjkxbmwvz1234567890&quot;
 &gt; keys = &quot;asdfghjkl;qwertyuiopzxcvbnm,./1234567890&quot;
 189c191,197
 &lt;         check_access_key(cur_menu, key)
 ---
 &gt;         local i = keys:find(key)
 &gt;         if not(i == nil) and i &lt;= #cur_menu.items then
 &gt;             item_enter(cur_menu, i)
 &gt;             exec(cur_menu, i)
 &gt;         else
 &gt;             check_access_key(cur_menu, key)
 &gt;         end
 278a287
 &gt;     local keys_index = 1
 280c289
 &lt;         cls_t[#cls_t + 1] = { util.escape(c.name) or &quot;&quot;,
 ---
 &gt;         cls_t[#cls_t + 1] = { keys:sub(keys_index, keys_index) .. &quot; &quot; .. util.escape(c.name) or &quot;&quot;,
 288a298
 &gt;         keys_index = keys_index + 1

=== Usage ===
* Place in ~/.config/awesome/
* Add the following to the imports of rc.lua
  require(&quot;menu&quot;)
* To change the hint keys add the following to rc.lua (e.g. a dvorak layout)
  batz.menu.keys = &quot;aoeuidhtns',.pyfgcrl;qjkxbmwvz123456789&quot;
* Usage is just like awesome.menu (in rc.lua)
  awful.key({ altkey,           }, &quot;Escape&quot;,
    function ()
      batz.menu.menu_keys.down = { &quot;j&quot;, &quot;Down&quot; }
      batz.menu.menu_keys.up = { &quot;k&quot;, &quot;Up&quot; }
      local cmenu = batz.menu.clients({width=245}, { keygrabber=true, coords={x=525, y=330} })
    end)
* Now when M-Esc is pressed the menu is show, and pressing the key associated with the item raises it.</text>
      <sha1>mw9oyvz4raabxf1gmgtsxnwtsiqo2qy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Amazing</title>
    <ns>0</ns>
    <id>39</id>
    <revision>
      <id>1238</id>
      <timestamp>2008-10-15T16:10:53Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="945">Amazing is a widget engine written in ruby designed for awesome.

Amazing is not complete at this point, but is much more lightweight than conky, and doesn't require modifying source code to make work properly.

One important thing to know is that in awesome 2.2 the way that the data is updated using awesome-client is different than that of post-2.2. In post-2.2, you must specify the data type, and in 2.2, this isn't needed. More information about this issue [http://github.com/dag/amazing/wikis/beyond-awesome-2-2 here].

Amazing can be downloaded from [http://github.com/dag/amazing/tree/master Dag/Donri's github]. Additionally, there are instructions there on how to [http://github.com/dag/amazing/wikis/configuration configure and use] amazing.

Some additional widgets [http://sharpe.no-ip.org/downloads/temp/amazing are available] and written by emsi.

How-to: [[Status Bar with Amazing]]

[[Category:Awesome2]][[Category:StatusBars]]</text>
      <sha1>kvaylc3xdukubv8eucrvf66t9xhj5td</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Analog Clock</title>
    <ns>0</ns>
    <id>356</id>
    <redirect title="Analog Gages" />
    <revision>
      <id>2819</id>
      <timestamp>2009-05-29T23:48:34Z</timestamp>
      <contributor>
        <username>R d</username>
        <id>316</id>
      </contributor>
      <comment>moved [[Analog Clock]] to [[Analog Gages]]:&amp;#32;Adding related widgets.</comment>
      <text xml:space="preserve" bytes="26">#REDIRECT [[Analog Gages]]</text>
      <sha1>8mo434vu0ggsemwduaude49yvgmwewn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Analog Gages</title>
    <ns>0</ns>
    <id>354</id>
    <revision>
      <id>3750</id>
      <parentid>3749</parentid>
      <timestamp>2009-10-31T01:23:41Z</timestamp>
      <contributor>
        <username>Erdnaxeli</username>
        <id>380</id>
      </contributor>
      <text xml:space="preserve" bytes="7097">This article provides code for four simple widgets that provide a memory usage indicator, a CPU utilization gage, a user &quot;jiffies&quot; counter, and a simple analog clock.  No external scripts are required, just standard Awesome/Lua libraries and the Linux /proc filesystem.  All code was tested and verified to work on awesome v3.4 (Closing In).

From left to right: Memory, CPU, jiffies, clock
[[File:Analoggages.png]]

== Analog Clock ==

This creates a little analog clock widget.  Simply add the following code to your rc.lua:

   analogclock = widget({type = &quot;imagebox&quot;})
   analogclock.image = image.argb32(24, 24, nil)
   function drawclock(ib, d, bg, fg)
       ib.image:draw_rectangle(0, 0, d, d, true, bg)
       local r = (d - (d % 2))/2
       ib.image:draw_circle(r, r, r-1, r-1, false, fg)
       local t = os.date(&quot;*t&quot;)
       local ht =  ((t.hour % 12) / 12 + t.min / 720 + t.sec / 43200) * 2 * math.pi
       local hx =  math.floor(0.60 * r * math.sin(ht))
       local hy = -math.floor(0.60 * r * math.cos(ht))
       local mt =  (t.min / 60 + t.sec / 3600) * 2 * math.pi
       local mx =  math.floor(0.90 * r * math.sin(mt))
       local my = -math.floor(0.90 * r * math.cos(mt))
       local st =  t.sec / 60 * 2 * math.pi
       local sx =  math.floor(0.90 * r * math.sin(st))
       local sy = -math.floor(0.90 * r * math.cos(st))
       ib.image:draw_line(r, r, r+sx, r+sy, &quot;#d80000&quot;)
       ib.image:draw_line(r, r, r+mx, r+my, fg)
       ib.image:draw_line(r, r, r+hx, r+hy, fg)
       ib.image = ib.image
   end
   analogtimer = timer { timeout = 1 }
   analogtimer:add_signal(&quot;timeout&quot;, function()
       drawclock(analogclock, 24, beautiful.bg_normal, beautiful.fg_normal)
   end)
   analogtimer:start()

And add &quot;analogclock&quot; to your status bar:

    statusbar.widgets = { analogclock }

== Memory Gage ==

Adds a memory usage indicator.  Paste this code in your rc.lua:

    function analogmem(ib, d, bg, fg)
        local r = (d - (d % 2))/2
        ib.image:draw_rectangle(0, 0, d, d, true, bg)
        ib.image:draw_circle(r, r, r-1, r-1, false, fg)
        ib.image:draw_line(r + math.floor((r - 1) * math.cos(1.25*math.pi)),
                     r - math.floor((r - 1) * math.sin(1.25*math.pi)),
                     r + math.floor(0.75 * r * math.cos(1.25*math.pi)),
                     r - math.floor(0.75 * r * math.sin(1.25*math.pi)), fg)
        ib.image:draw_line(r + math.floor((r - 1) * math.cos(1.75*math.pi)),
                     r - math.floor((r - 1) * math.sin(1.75*math.pi)),
                     r + math.floor(0.75 * r * math.cos(1.75*math.pi)),
                     r - math.floor(0.75 * r * math.sin(1.75*math.pi)), fg)
        local total    = nil
        local active   = nil
        for line in io.lines(&quot;/proc/meminfo&quot;) do
            local name, value = string.match(line, &quot;(%w+):\ +(%d+)&quot;)
            if name == &quot;MemTotal&quot; then
                total  = value
            else
                if name == &quot;Active&quot; then
                    active = value
                end
            end
        end
        if total and active then
            local t =  1.25 * math.pi - (math.pi * 1.5 * active / total)
            local x =  math.floor(0.90 * r * math.cos(t))
            local y = -math.floor(0.90 * r * math.sin(t))
            ib.image:draw_line(r, r, r + x, r + y, &quot;#d80000&quot;)
        end
        ib.image = ib.image
    end
    meminfo = widget({ type = &quot;imagebox&quot; })
    meminfo.image = image.argb32(24, 24, nil)
    memtimer = timer { timeout = 1 }
    memtimer:add_signal(&quot;timeout&quot;, function()
        analogmem(meminfo, 24, beautiful.bg_normal, beautiful.fg_normal)
    end)
    memtimer:start()

And add &quot;meminfo&quot; to your status bar widgets.

== CPU Gage ==

A CPU utilization indicator.  Paste this code in your rc.lua:

    jiffies = {}
    function analogcpu(ib, d, bg, fg)
        local r = (d - (d % 2))/2
        ib.image:draw_rectangle(0, 0, d, d, true, bg)
        ib.image:draw_circle(r, r, r-1, r-1, false, fg)
        ib.image:draw_line(r + math.floor((r - 1) * math.cos(1.25*math.pi)),
                     r - math.floor((r - 1) * math.sin(1.25*math.pi)),
                     r + math.floor(0.75 * r * math.cos(1.25*math.pi)),
                     r - math.floor(0.75 * r * math.sin(1.25*math.pi)), fg)
        ib.image:draw_line(r + math.floor((r - 1) * math.cos(1.75*math.pi)),
                     r - math.floor((r - 1) * math.sin(1.75*math.pi)),
                     r + math.floor(0.75 * r * math.cos(1.75*math.pi)),
                     r - math.floor(0.75 * r * math.sin(1.75*math.pi)), fg)
        for line in io.lines(&quot;/proc/stat&quot;) do
            local cpu, newjiffies = string.match(line, &quot;(cpu%d+)\ +(%d+)&quot;)
            if cpu and newjiffies then
                if not jiffies[cpu] then
                    jiffies[cpu] = newjiffies
                end
                local t =  1.25 * math.pi - math.pi * 1.5 * (newjiffies - jiffies[cpu]) / 50
                local x =  math.floor(0.90 * r * math.cos(t))
                local y = -math.floor(0.90 * r * math.sin(t))
                ib.image:draw_line(r, r, r + x, r + y, fg)
                jiffies[cpu] = newjiffies
            end
        end
        ib.image = ib.image
    end
    cpuinfo = widget({ type = &quot;imagebox&quot; })
    cpuinfo.image = image.argb32(24, 24, nil)
    cputimer = timer { timeout = 0.5 }
    cputimer:add_signal(&quot;timeout&quot;, function()
        analogcpu(cpuinfo, 24, beautiful.bg_normal, beautiful.fg_normal)
    end)
    cputimer:start()

This code uses the technique described in [[CPU Usage]].  Note that the update/sample rate is important to the calculation.

Again, add &quot;cpuinfo&quot; to your statusbar widgets.

== User Jiffies Counter == 
This counts the number of &quot;jiffies&quot; (1/100ths of a second of processor time) dedicated to user processes.  Each jiffy spent on a user process will increment the needle for that processor.
Paste this code into your rc.lua:

    function analogjiffies(ib, d, bg, fg)
        local r = (d - (d % 2))/2
        ib.image:draw_rectangle(0, 0, d, d, true, bg)
        ib.image:draw_circle(r, r, r-1, r-1, false, fg)
        for line in io.lines(&quot;/proc/stat&quot;) do
            local cpu, jiffies = string.match(line, &quot;(cpu%d*)\ +(%d+)&quot;)
            if cpu and jiffies then
                local t = -jiffies / 100 * 2 * math.pi
                local x =  math.floor(0.90 * r * math.cos(t))
                local y = -math.floor(0.90 * r * math.sin(t))
                if cpu == &quot;cpu&quot; then
                    ib.image:draw_line(r, r, r+x, r+y, &quot;#d80000&quot;)
                else
                    ib.image:draw_line(r, r, r+x, r+y, fg)
                end
            end
        end
        -- Ridiculous, but necessary:
        ib.image = ib.image
    end
    jiffyinfo = widget({ type = &quot;imagebox&quot; })
    jiffyinfo.image = image.argb32(24, 24, nil)
    jiffytimer = timer { timeout = 0.05 }
    jiffytimer:add_signal(&quot;timeout&quot;, function()
        analogjiffies(jiffyinfo, 24, beautiful.bg_normal, beautiful.fg_normal)
    end)
    jiffytimer:start()

And add &quot;jiffyinfo&quot; to your status bar.</text>
      <sha1>hh4il7ia0fy2e8b4d0kdzdm9nnqy1ch</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anon theme</title>
    <ns>0</ns>
    <id>210</id>
    <revision>
      <id>2778</id>
      <parentid>1622</parentid>
      <timestamp>2009-05-23T11:21:02Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Themes]]</comment>
      <text xml:space="preserve" bytes="805">[[Image:Anon1.png|thumb|Screenshot]]
[[Image:Anon2.png|thumb|Screenshot]]

&lt;pre&gt;
font          = sans 8

bg_normal     = #252525
bg_focus      = #252525
bg_urgent     = #ff0000

fg_normal     = #aaaaaa
fg_focus      = #ffffff
fg_urgent     = #ffffff

border_width  = 0
border_normal = #252525
border_focus  = #252525
border_marked = #91231c

# Display the taglist squares
taglist_squares = true

# You can add as many variables as
# you wish and access them by using
# beautiful.variable in your rc.lua
#bg_widget    = #cc0000

# Display close button inside titlebar
titlebar_close_button = true

# You can use your own command to set your wallpaper
# wallpaper_cmd = awsetbg /home/mudkip/.config/awesome/bg.png&lt;/pre&gt;

The background image is from [[Twoism theme]]
[[Category:Awesome3]][[Category:Themes]]</text>
      <sha1>7ehcgije81msi2anypqkk6ea3krmw94</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Another battery widget</title>
    <ns>0</ns>
    <id>198</id>
    <revision>
      <id>2787</id>
      <parentid>2698</parentid>
      <timestamp>2009-05-23T11:26:04Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Widgets]]</comment>
      <text xml:space="preserve" bytes="2355">This is ased on something similar for Ion3 (by Jari Eskelinen).

It shows the current charge of the battery and the time remaining until
the battery is full or empty.
If the system is on AC the prefix is 'AC', otherwise it's 'Battery'.

It doesn't do any error checking, so I don't even know what can happen
if your system isn't exactly like mine. Use at your own risk, yada, yada, yada.

  -- {{{ Battery state Widget
  
  batterywidget = widget({
      type = 'textbox',
      name = 'batterywidget',
      align = 'right'
      })
  
  wicked.register(batterywidget, 'function', function (widget, args)
      local f = io.open('/proc/acpi/battery/BAT0/info')
      local infocontents = f:read('*all')
      f:close()
  
      f = io.open('/proc/acpi/battery/BAT0/state')
      local statecontents = f:read('*all')
      f:close()
  
      local status, _
      -- Find the full capacity (from info)
      local full_cap
      
      status, _, full_cap = string.find(infocontents, &quot;last full capacity:%s+(%d+).*&quot;)
  
      -- Find the current capacity, state and (dis)charge rate (from state)
      local state, rate, current_cap
      
      status, _, state = string.find(statecontents, &quot;charging state:%s+(%w+)&quot;)
      status, _, rate  = string.find(statecontents, &quot;present rate:%s+(%d+).*&quot;)
      status, _, current_cap = string.find(statecontents, &quot;remaining capacity:%s+(%d+).*&quot;)
  
      local prefix, percent, time
      percent = current_cap / full_cap * 100
      if state == &quot;charged&quot; then
          return &quot;AC: &quot; .. fg(&quot;green&quot;, &quot;100%&quot;)
      elseif state == &quot;charging&quot; then
          prefix = &quot;AC: &quot;
          time = (full_cap - current_cap) / rate
      elseif state == &quot;discharging&quot; then
          prefix = &quot;Battery: &quot;
          time = current_cap / rate
      end
  
      time_hour = math.floor(time)
      time_minute = math.floor((time - time_hour) * 60)
      
      percent = math.floor(percent)
      local percent_string
      if percent &lt; 25 then
          percent_string = fg(&quot;red&quot;, percent .. &quot;%&quot;)
      elseif percent &lt; 50 then
          percent_string = fg(&quot;orange&quot;, percent .. &quot;%&quot;)
      else
          percent_string = fg(&quot;green&quot;, percent .. &quot;%&quot;)
      end
  
      return prefix .. percent_string .. &quot; &quot; .. string.format(&quot;(%02d:%02d)&quot;, time_hour, time_minute)
  end, 2)
  -- }}}

[[Category:Awesome3]]
[[Category:Widgets]]</text>
      <sha1>5l9ft9k3olfy12to6weeecaupt3apgc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Another pomodoro widget</title>
    <ns>0</ns>
    <id>863</id>
    <revision>
      <id>5628</id>
      <parentid>5627</parentid>
      <timestamp>2012-11-03T15:25:10Z</timestamp>
      <contributor>
        <username>S5unty</username>
        <id>244</id>
      </contributor>
      <text xml:space="preserve" bytes="1227">[[File:2012-11-03-222148 511x63 scrot.png]]

There is a 25+5 seconds [http://www.youtube.com/watch?v=3YpaDRuyApA&amp;feature=plcp screencast]

  #!/bin/sh
  # inspired from http://feedelli.org/2012/07/29/bash-command-line-pomodoro-timer.html
  # punch-time-tracking: http://code.google.com/p/punch-time-tracking/
  #
  # with awesome-client, you need do something in your rc.lua:
  #
  #     ...
  #     require(&quot;awful.remote&quot;) -- make `awesome-client` work
  #     ...
  #     pomodoro = awful.widget.progressbar()
  #     pomodoro:set_max_value(100)
  #     pomodoro:set_background_color('#494B4F')
  #     pomodoro:set_color('#AECF96')
  #     pomodoro:set_gradient_colors({ '#AECF96', '#88A175', '#FF5656' })
  #     pomodoro:set_ticks(true)
  #     ...
  #     mywibox[s].widgets = {
  #             ...
  #             mytaglist[s],
  #             pomodoro.widget, -- right here
  #     ...
  #
  work=$((25*60))
  rest=$((5*60))
  
  for i in $(seq 100); do
      echo &quot;pomodoro:set_value(${i})&quot; | awesome-client
      sleep $(echo &quot;scale=3;${work}/100&quot; | bc)
  done
  
  for i in $(seq 100); do
      j=$((100-i))
      echo &quot;pomodoro:set_value(${j})&quot; | awesome-client
      sleep $(echo &quot;scale=3;${rest}/100&quot; | bc)
  done</text>
      <sha1>08wug337grls0fbkie1a6qrkrtvja6v</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anrxcs Calculator Prompt</title>
    <ns>0</ns>
    <id>479</id>
    <revision>
      <id>6649</id>
      <parentid>5320</parentid>
      <timestamp>2014-05-24T18:24:37Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1130">{{Languages}}

== Description ==
This is a simple calculator prompt using eval to calculate results.

== Using xmessage ==

 -- globalkeys = awful.util.table.join(
 -- ...
     awful.key({ modkey            }, &quot;F11&quot;, function ()
         awful.prompt.run({ prompt = &quot;Calculate: &quot; }, mypromptbox[mouse.screen].widget,
             function (expr)
                 local result = awful.util.eval(&quot;return (&quot; .. expr .. &quot;)&quot;)
                 local xmessage = &quot;xmessage -timeout 10 -file -&quot;
                 awful.util.spawn_with_shell(&quot;echo '&quot; .. expr .. ' = ' .. result .. &quot;' | &quot; .. xmessage, false)
             end
         )
     end),

== Using [[Naughty]] ==

 require(&quot;naughty&quot;)
 -- ...
 -- globalkeys = awful.util.table.join(
 -- ...
     awful.key({ modkey            }, &quot;F11&quot;, function ()
         awful.prompt.run({ prompt = &quot;Calculate: &quot; }, mypromptbox[mouse.screen].widget,
             function (expr)
                 local result = awful.util.eval(&quot;return (&quot; .. expr .. &quot;)&quot;)
                 naughty.notify({ text = expr .. &quot; = &quot; .. result, timeout = 10 })
             end
         )
     end),

[[Category:Awesome3]]</text>
      <sha1>0vi0a9bafl4zavsr3e8puvf5k9gnbp2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anrxcs Calculator Prompt/ru</title>
    <ns>0</ns>
    <id>1084</id>
    <revision>
      <id>6651</id>
      <timestamp>2014-05-25T16:42:43Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Anrxcs Calculator Prompt (translating page)</comment>
      <text xml:space="preserve" bytes="1648">{{Languages|Anrxcs Calculator Prompt}}
{{DISPLAYTITLE:Anrxcs Калькулятор}}

== Описание ==
Это простой калькулятор для строки prompt использующий  eval для расчета результата.

== Использование xmessage ==

Добавльте следующий код в секцию globalkeys  в rc.lua

     awful.key({ modkey            }, &quot;F11&quot;, function ()
         awful.prompt.run({ prompt = &quot;Calculate: &quot; }, mypromptbox[mouse.screen].widget,
             function (expr)
                 local result = awful.util.eval(&quot;return (&quot; .. expr .. &quot;)&quot;)
                 local xmessage = &quot;xmessage -timeout 10 -file -&quot;
                 awful.util.spawn_with_shell(&quot;echo '&quot; .. expr .. ' = ' .. result .. &quot;' | &quot; .. xmessage, false)
             end
         )
     end),

Теперь при нажатии Mod+F11 в строке promptbox вы вводите выражение, и после нажатия Enter вам выводится результат.

== Использование [[Naughty/ru|Naughty]] ==

В начало файла rc.lua добавьте:

 require(&quot;naughty&quot;)

Добавльте следующий код в секцию globalkeys  в rc.lua

     awful.key({ modkey            }, &quot;F11&quot;, function ()
         awful.prompt.run({ prompt = &quot;Calculate: &quot; }, mypromptbox[mouse.screen].widget,
             function (expr)
                 local result = awful.util.eval(&quot;return (&quot; .. expr .. &quot;)&quot;)
                 naughty.notify({ text = expr .. &quot; = &quot; .. result, timeout = 10 })
             end
         )
     end),

[[Category:Awesome3]]</text>
      <sha1>3r02wl6858l9rq441yp0cr524r70r6m</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anrxcs Manual Prompt</title>
    <ns>0</ns>
    <id>358</id>
    <revision>
      <id>6655</id>
      <parentid>3575</parentid>
      <timestamp>2014-05-25T17:27:59Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1806">{{Languages}}

== Description ==
I use this run prompt to read manual pages all the time. It has fast completion and is often faster to access a page then switching tags or focus to your 'reader'. I put examples for a terminal emulator, KDE help center and GNU Emacs (which runs as a server or daemon (in version 23)). This version searches through your whole MANPATH.

== Keybinding and function code ==
&lt;pre&gt;
-- Prompt menus
-- ...
-- ...
-- ...
awful.key({ modkey }, &quot;F4&quot;, function ()
    awful.prompt.run({ prompt = &quot;Manual: &quot; }, mypromptbox[mouse.screen].widget,
    --  Use GNU Emacs for manual page display
    --  function (page) awful.util.spawn(&quot;emacsclient --eval '(manual-entry \&quot;'&quot; .. page .. &quot;'\&quot;)'&quot;, false) end,
    --  Use the KDE Help Center for manual page display
    --  function (page) awful.util.spawn(&quot;khelpcenter man:&quot; .. page, false) end,
    --  Use the terminal emulator for manual page display
        function (page) awful.util.spawn(&quot;urxvt -e man &quot; .. page, false) end,
        function(cmd, cur_pos, ncomp)
            local pages = {}
            local m = 'IFS=: &amp;&amp; find $(manpath||echo &quot;$MANPATH&quot;) -type f -printf &quot;%f\n&quot;| cut -d. -f1'
            local c, err = io.popen(m)
            if c then while true do
                local manpage = c:read(&quot;*line&quot;)
                if not manpage then break end
                if manpage:find(&quot;^&quot; .. cmd:sub(1, cur_pos)) then
                    table.insert(pages, manpage)
                end
              end
              c:close()
            else io.stderr:write(err) end
            if #cmd == 0 then return cmd, cur_pos end
            if #pages == 0 then return end
            while ncomp &gt; #pages do ncomp = ncomp - #pages end
            return pages[ncomp], cur_pos
        end)
end),
&lt;/pre&gt;


[[Category:Awesome3]]</text>
      <sha1>filb4dtzpfqj52679wg51v6633vd01b</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anrxcs Manual Prompt/ru</title>
    <ns>0</ns>
    <id>1086</id>
    <revision>
      <id>6657</id>
      <timestamp>2014-05-25T17:42:22Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Anrxcs Manual Prompt (translating page)</comment>
      <text xml:space="preserve" bytes="2473">{{Languages|Anrxcs Manual Prompt}}
{{DISPLAYTITLE:Чтение man-страниц}}

== Описание ==
Я использую строку запуска для чтения man-страниц все время. Она позволяет быстрее завершить или зачастую быстрее получить доступ к странице, а затем переключить теги и/или сфокусироваться на вашем 'reader'. Я прилагаю примеры для терминала, справочного центра KDE и GNU Emacs (запущенного как сервер или демон (в версии 23)). Эта версия позволяет вести поиск по всему MANPATH.

== Сочетание клавиш и код ==

Добавьте следующий код в раздел prompt menu вашего rc.lua
&lt;pre&gt;
-- Prompt menus
-- ...
awful.key({ modkey }, &quot;F4&quot;, function ()
    awful.prompt.run({ prompt = &quot;Manual: &quot; }, mypromptbox[mouse.screen].widget,
    --  Использование GNU Emacs для отображения man-страниц
    --  function (page) awful.util.spawn(&quot;emacsclient --eval '(manual-entry \&quot;'&quot; .. page .. &quot;'\&quot;)'&quot;, false) end,
    --  Использование Справочного Центра KDE  для отображения man-страниц
    --  function (page) awful.util.spawn(&quot;khelpcenter man:&quot; .. page, false) end,
    --  Использование эмулятора терминал  для отображения man-страниц
        function (page) awful.util.spawn(&quot;urxvt -e man &quot; .. page, false) end,
        function(cmd, cur_pos, ncomp)
            local pages = {}
            local m = 'IFS=: &amp;&amp; find $(manpath||echo &quot;$MANPATH&quot;) -type f -printf &quot;%f\n&quot;| cut -d. -f1'
            local c, err = io.popen(m)
            if c then while true do
                local manpage = c:read(&quot;*line&quot;)
                if not manpage then break end
                if manpage:find(&quot;^&quot; .. cmd:sub(1, cur_pos)) then
                    table.insert(pages, manpage)
                end
              end
              c:close()
            else io.stderr:write(err) end
            if #cmd == 0 then return cmd, cur_pos end
            if #pages == 0 then return end
            while ncomp &gt; #pages do ncomp = ncomp - #pages end
            return pages[ncomp], cur_pos
        end)
end),
&lt;/pre&gt;


[[Category:Awesome3]]</text>
      <sha1>6yu1lipkew1rnmstyhtu4zpjvlwmlbz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anrxcs OrgMode Widget</title>
    <ns>0</ns>
    <id>319</id>
    <revision>
      <id>3549</id>
      <parentid>3231</parentid>
      <timestamp>2009-08-30T20:15:16Z</timestamp>
      <contributor>
        <username>Anrxc</username>
        <id>258</id>
      </contributor>
      <minor/>
      <comment>Added a link to wicked.</comment>
      <text xml:space="preserve" bytes="2870">* This widget for Emacs org-mode is based on the org-awesome module - copyright of Damien Leone.

* This is a cheap hack on the org-awesome module to work with [http://awesome.naquadah.org/wiki/Wicked wicked]. For most purposes you are better of with the [http://dleone.fensalir.fr/index.php?tag/org-awesome original].

* Excerpt from rc.lua:
&lt;pre&gt;
-- 
-- Agenda and Todo (Emacs org-mode)
--   * Derived from the org-awesome module, copyright of Damien Leone
--   * Licensed under the terms of the GNU General Public License version 2
--     as published by the Free Software Foundation.

myorgwidget = widget({ type = &quot;textbox&quot;, name = &quot;myorgwidget&quot;, align = &quot;right&quot; })

function get_agenda()
   local agenda_files = {
       os.getenv(&quot;HOME&quot;) .. &quot;/.org/work.org&quot;,
       os.getenv(&quot;HOME&quot;) .. &quot;/.org/index.org&quot;,
       os.getenv(&quot;HOME&quot;) .. &quot;/.org/personal.org&quot;
   }
   local today  = os.time{year=os.date(&quot;%Y&quot;), month=os.date(&quot;%m&quot;), day=os.date(&quot;%d&quot;)}
   local soon   = today+24*3600*3 -- 3 days ahead is close
   local future = today+24*3600*7 -- 7 days ahead max
   local count  = { past = 0, today = 0, soon = 0, future = 0 }

   for i = 1, #agenda_files do
      local filedescriptor = io.open(agenda_files[i], &quot;r&quot;)
      for line in filedescriptor:lines() do
         local scheduled = string.find(line, &quot;SCHEDULED:&quot;)
         local closed    = string.find(line, &quot;CLOSED:&quot;)
         local deadline  = string.find(line, &quot;DEADLINE:&quot;)
         if (scheduled and not closed) or (deadline and not closed) then
            local b, e, y, m, d = string.find(line, &quot;(%d%d%d%d)-(%d%d)-(%d%d)&quot;)
            if b then
               local  t  = os.time{year=y, month=m, day=d}
               if     t  &lt; today  then count.past   = count.past   + 1
               elseif t == today  then count.today  = count.today  + 1
               elseif t &lt;= soon   then count.soon   = count.soon   + 1
               elseif t &lt;= future then count.future = count.future + 1
               end
            end
         end
      end
      filedescriptor:close()
   end
   local value = &quot;$past|$today|$soon|$future&quot;
   value = string.gsub(value, &quot;$past&quot;,   &quot;&lt;span color='&quot; .. beautiful.fg_urgent .. &quot;'&gt;&quot;       .. count.past ..   &quot;&lt;/span&gt;&quot;)
   value = string.gsub(value, &quot;$today&quot;,  &quot;&lt;span color='&quot; .. beautiful.fg_normal .. &quot;'&gt;&quot;       .. count.today ..  &quot;&lt;/span&gt;&quot;)
   value = string.gsub(value, &quot;$soon&quot;,   &quot;&lt;span color='&quot; .. beautiful.fg_widget .. &quot;'&gt;&quot;       .. count.soon ..   &quot;&lt;/span&gt;&quot;)
   value = string.gsub(value, &quot;$future&quot;, &quot;&lt;span color='&quot; .. beautiful.fg_netup_widget .. &quot;'&gt;&quot; .. count.future .. &quot;&lt;/span&gt;&quot;)
   return value
end

wicked.register(myorgwidget, get_agenda, &quot;$1&quot;, 240)

myorgwidget:buttons(awful.util.table.join(
    awful.button({ }, 1, function () awful.util.spawn(&quot;emacsclient --eval '(org-agenda-list)'&quot;, false) end)
))
&lt;/pre&gt;

[[Category:Awesome3]]
[[Category:Widgets]]</text>
      <sha1>6i3zj4z5pf3w2rt8o6eakgfqyftn7si</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anrxcs WebSearch Prompt</title>
    <ns>0</ns>
    <id>359</id>
    <revision>
      <id>6652</id>
      <parentid>3680</parentid>
      <timestamp>2014-05-25T16:44:35Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2083">{{Languages}}

== Description ==
This is a web search prompt utilizing the YubNub.org (social) command line for the web. YubNub enables you to submit your search to just about any search form on the web thus giving you access to the whole web from only one run prompt. Let's explain how it works:

* Web search: &lt;b&gt;awesome window manager&lt;/b&gt;
** will search google.com for &quot;awesome window manager&quot; because google is the default search engine
** Web search: &lt;b&gt;g awesome window manager&lt;/b&gt;
*** will do the same because 'g' is the command for google
* Web search: &lt;b&gt;gim awesome window manager&lt;/b&gt;
** will search google images for &quot;awesome window manager&quot;
* Web search: &lt;b&gt;apr awesome&lt;/b&gt;
** will search Arch Linux repositories for &quot;awesome&quot;
* Web search: &lt;b&gt;aur awesome&lt;/b&gt;
** will search Arch Linux user repository for 'awesome'
* Web search: &lt;b&gt;wp awesome window manager&lt;/b&gt;
** will search Wikipedia for &quot;awesome window manager&quot;
* ...and so on, you get the point.

There are already thousands of commands available, to learn them or even define your own commands visit http://yubnub.org &lt;br /&gt;
Just to be clear, there is no need to do any data or command parsing in your rc.lua, YubNub takes care of all that, you just need to know the correct command for your search.

Code below will submit your search to YubNub trough Firefox and then automatically switch to the tag where Firefox is - in the current code there is no auto-discovery, but the Firefox tag is hardcoded, in my case that is tag &lt;b&gt;3&lt;/b&gt;.

== Keybinding and function code ==
&lt;pre&gt;
-- Prompt menus
-- ...
-- ...
-- ...
    awful.key({ altkey }, &quot;F12&quot;, function ()
        awful.prompt.run({ prompt = &quot;Web search: &quot; }, mypromptbox[mouse.screen].widget,
            function (command)
                awful.util.spawn(&quot;firefox 'http://yubnub.org/parser/parse?command=&quot;..command..&quot;'&quot;, false)
                -- Switch to the web tag, where Firefox is, in this case tag 3
                if tags[mouse.screen][3] then awful.tag.viewonly(tags[mouse.screen][3]) end
            end)
    end),
&lt;/pre&gt;



[[Category:Awesome3]]</text>
      <sha1>daudlgues7oprxnrq0w5p0ihmxesn3n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anrxcs WebSearch Prompt/ru</title>
    <ns>0</ns>
    <id>1085</id>
    <revision>
      <id>6654</id>
      <timestamp>2014-05-25T17:26:46Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевоада Anrxcs WebSearch Prompt (translating page)</comment>
      <text xml:space="preserve" bytes="3272">{{Languages|Anrxcs WebSearch Prompt}}
{{DISPLAYTITLE:Anrxcs Вебпоиск-приглашение}}

== Описание ==
Это приглашение для веб-поиска использующее YubNub.org. YubNub позволяет вам передавать ваш поисковый запрос практически в любую поисковую систему, таким образом предоставляя вам доступ ко всему интернету всего лишь из одной строки. Давайте разберем как это работает:


* Поисковый запрос: &lt;b&gt;awesome window manager&lt;/b&gt;
** будет производить поиск на google.com строку &quot;awesome window manager&quot; поскольку google является поисковиком по умолчанию
** Поисковый запрос: &lt;b&gt;g awesome window manager&lt;/b&gt;
*** будет делать то же самое, т.к. 'g' это команда для поиска в google
* Поисковый запрос: &lt;b&gt;gim awesome window manager&lt;/b&gt;
** будет искать изображения по запросу &quot;awesome window manager&quot;
* Поисковый запрос: &lt;b&gt;apr awesome&lt;/b&gt;
** Будет искать репозитории Arch Linux содержащие &quot;awesome&quot;
* Поисковый запрос: &lt;b&gt;aur awesome&lt;/b&gt;
** будет искать пользовательские репозитории Arch Linux содержащие 'awesome'
* Поисковый запрос: &lt;b&gt;wp awesome window manager&lt;/b&gt;
** будет искать в Wikipedia строку &quot;awesome window manager&quot;
* ...и так далее.

Уже доступны тысячи команд, для изучения их, или даже для определения собственных посетите http://yubnub.org &lt;br /&gt;
Еще раз, для понимания, вам нет необходимости вносить дополнительные данные или команды в rc.lua, YubNub берез всю заботу об этом на себя, все что вам нужно, это составить корректный поисковый запрос. 

Код приведенный ниже осуществляет поиск в YubNub через Firefox, а затем автоматически переключаясь на тег присвоенный Firefox - в данном коде не производится поиска тега, т.к. зачастую он уже жестко прописан, в нашем примере это тег &lt;b&gt;3&lt;/b&gt;.

== Клавиатурное сочетание и код ==
&lt;pre&gt;
-- Prompt menus
-- ...
-- ...
-- ...
    awful.key({ altkey }, &quot;F12&quot;, function ()
        awful.prompt.run({ prompt = &quot;Web search: &quot; }, mypromptbox[mouse.screen].widget,
            function (command)
                awful.util.spawn(&quot;firefox 'http://yubnub.org/parser/parse?command=&quot;..command..&quot;'&quot;, false)
                -- Switch to the web tag, where Firefox is, in this case tag 3
                if tags[mouse.screen][3] then awful.tag.viewonly(tags[mouse.screen][3]) end
            end)
    end),
&lt;/pre&gt;



[[Category:Awesome3]]</text>
      <sha1>5nxrd955y6o2f0krs8j3em0jrssav7x</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Anrxcs Widget Set</title>
    <ns>0</ns>
    <id>280</id>
    <revision>
      <id>3548</id>
      <parentid>3547</parentid>
      <timestamp>2009-08-30T20:13:36Z</timestamp>
      <contributor>
        <username>Anrxc</username>
        <id>258</id>
      </contributor>
      <minor/>
      <comment>Removed deprecated file system widget</comment>
      <text xml:space="preserve" bytes="2823">* This is a small collection of &lt;i&gt;custom&lt;/i&gt; functions to be used with [http://awesome.naquadah.org/wiki/Wicked wicked].

* All the &lt;b&gt;&lt;i&gt;beautiful.*.widget&lt;/i&gt;&lt;/b&gt; references can be replaced with custom colors (i.e. &lt;i&gt;&quot;#ffffff&quot;&lt;/i&gt; for white), or include them in your theme file.

* Where data parsing is required '''only awk is used''', so there are no &quot;cat+head+tail+sed+awk&quot; combinations

&lt;pre&gt;
-- {{{ 
-- 
-- All functions are licensed under the Creative Commons Attribution-Share Alike License.
-- To view a copy of this license, visit http://creativecommons.org/licenses/by-sa/3.0/

-- Battery percentage and state indicator
--   - example output +95% or -95% when discharging
mybatwidget = widget({ type = &quot;textbox&quot;, name = &quot;mybatwidget&quot;, align = &quot;right&quot; })
function get_batstate()
    local filedescriptor = io.popen('acpitool -b | awk \'{sub(/discharging,/,&quot;-&quot;)sub(/charging,|charged,/,&quot;+&quot;)sub(/\\./,&quot; &quot;); print $4 substr($5,1,3)}\'')
    local value = filedescriptor:read()
    filedescriptor:close()
    return {value}
end
wicked.register(mybatwidget, get_batstate, &quot;$1%&quot;, 60)


-- Mail widget
--   - displays subject of the last e-mail using nail/mailx (heirloom implementation)
mymailwidget = widget({ type = &quot;textbox&quot;, name = &quot;mymailwidget&quot;, align = &quot;right&quot; })
function get_mailsubject()
    local filedescriptor = io.popen('mailx -H -f ~/mail/Inbox | awk \'{ field = $NF }; END{sub(/%/,&quot;&quot;); print $10,$11,$12,$13}\'')
    local value = filedescriptor:read()
    filedescriptor:close()
    return {value}
end
wicked.register(mymailwidget, get_mailsubject, &quot;$1&quot;, 60)


-- Volume level
--   - textual volume level of the PCM channel
myvolwidget    = widget({ type = &quot;textbox&quot;, name = &quot;myvolwidget&quot;, align = &quot;right&quot; })
function get_volstate()
    local filedescriptor = io.popen('amixer get PCM | awk \'{ field = $NF }; END{sub(/%/,&quot; &quot;); print substr($5,2,3)}\'')
    local value = filedescriptor:read()
    filedescriptor:close()
    return {value}
end
wicked.register(myvolwidget, get_volstate, &quot;$1%&quot;, 2)


-- CPU temperature
mycputempwidget  = widget({ type = &quot;textbox&quot;, name = &quot;mycputempwidget&quot;, align = &quot;right&quot; })
function get_temp()
    local filedescriptor = io.popen('awk \'{print $2 &quot;°C&quot;}\' /proc/acpi/thermal_zone/TZS0/temperature')
    local value = filedescriptor:read()
    filedescriptor:close()
    return {value}
end
wicked.register(mycputempwidget, get_temp, &quot;$1&quot;, 60)


-- Date, time and a simple calendar launcher
mydatewidget = widget({ type = &quot;textbox&quot;, name = &quot;mydatewidget&quot;, align = &quot;right&quot; })
wicked.register(mydatewidget, wicked.widgets.date, &quot;%b %e, %R&quot;, 1)
mydatewidget:buttons(awful.util.table.join(
    awful.button({ }, 1, function () awful.util.spawn_with_shell(&quot;cal -m | xmessage -geometry +1135+17 -file -&quot;) end)
))

-- }}} 
&lt;/pre&gt;

[[Category:Awesome3]]
[[Category:Widgets]]</text>
      <sha1>k2ff72f77g6zhrrr7q0oejlg2rn1n4r</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Antel MPD-Ruby</title>
    <ns>0</ns>
    <id>257</id>
    <revision>
      <id>2092</id>
      <timestamp>2009-01-05T02:14:46Z</timestamp>
      <contributor>
        <username>Voldor</username>
        <id>229</id>
      </contributor>
      <text xml:space="preserve" bytes="2133">We will create a MPD widget using a MPD client written in Lua (that doesn't use mpc/netcat/telnet).

== The MPD Ruby Library ==
Install ruby, then with rubygem install librmpd

Linux-Freebsd: gem i librmpd

== MPD Widget ==
We want to take the output from our app, so we write this wimple widget:

&lt;pre&gt;
function get_command_output (command)
    local c = io.popen(command)
    local output = {}
    i = 0
   return c:read(&quot;*line&quot;)
end

mympd = widget({ type = &quot;textbox&quot;, name = &quot;mympd&quot;, align = &quot;left&quot; })
&lt;/pre&gt;

Remember to add &quot;mympd,&quot; to statusbar.
To make it working, you need to call it, so you can add it to hook_timer[every second] that's included default on rc.lua or create your own:

&lt;pre&gt;
function hook_timer ()
    mytextbox.text = &quot; &quot; .. os.date() .. &quot; &quot;
	mympd.text = &quot; &quot; .. get_command_output(&quot;ruby /MODIFY/YOUR/PATH/mpdr.rb&quot;) .. &quot; &quot;
end
&lt;/pre&gt;

Then be sure to register the hook:
&lt;pre&gt;
[INCLUDED IN DEFAULT RC.LUA]
awful.hooks.timer.register(1, hook_timer)
&lt;/pre&gt;

Code of mpdr.rb:

&lt;pre&gt;
#Ruby MPD wrapper

require 'rubygems'
require 'librmpd'

HOST = &quot;localhost&quot;
PORT = 6000

mpd = MPD.new HOST, PORT

mpd.connect
#mpd.password('mypassword')
if mpd.stopped?
    mpd.play
end
song = mpd.current_song

#Time calculation
time = mpd.status[&quot;time&quot;]
time = time.split(':')
elapsed = time[0].to_i
el_min = elapsed / 60
el_sec = elapsed % 60
elapsed = &quot;#{el_min}:#{el_sec}&quot;

total = time[1].to_i
tot_min = total / 60
tot_sec = total % 60
total = &quot;#{tot_min}:#{tot_sec}&quot;

time = &quot;#{elapsed}/#{total}&quot;


#Adjusting output of Artist
artist = &quot;#{song.artist}&quot;
artist.gsub!(/ &amp; /, '/')

#Adjusting output of Title
title = &quot;#{song.title}&quot;
title.gsub!(/_/, ' ')
title.gsub!(/ &amp; /, '/')
title.gsub!(/feat/i, 'Ft')
title.gsub!(/remix/i, 'rmx')

#Some hacky to get correct output if id3tags are strange
if artist.empty?
    puts &quot;[#{song.file} - #{time}]&quot;
elsif title.empty?
    puts &quot;[#{song.file} - #{time}]&quot;
elsif artist =~ /artist/i
    puts &quot;[#{song.file} - #{time}]&quot;
elsif title =~ /track/i
    puts &quot;[#{song.file} - #{time}]&quot;
else
    puts &quot;[#{artist} - #{title} - #{time}]&quot;
end

mpd.disconnect
&lt;/pre&gt;


[[Category:awesome3]]</text>
      <sha1>q1jxbtoogdis22o36etushvo1qcgaxm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Arbitarily shaped wiboxes</title>
    <ns>0</ns>
    <id>366</id>
    <redirect title="Arbitrarily shaped wiboxes" />
    <revision>
      <id>2866</id>
      <timestamp>2009-06-24T15:01:44Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Arbitarily shaped wiboxes]] to [[Arbitrarily shaped wiboxes]]:&amp;#32;Spelling fail</comment>
      <text xml:space="preserve" bytes="40">#REDIRECT [[Arbitrarily shaped wiboxes]]</text>
      <sha1>7e8oo5rn3adm0a8rcsix0orbdcrr8fn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Arbitrarily shaped wiboxes</title>
    <ns>0</ns>
    <id>365</id>
    <revision>
      <id>2865</id>
      <parentid>2864</parentid>
      <timestamp>2009-06-24T15:01:44Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <minor/>
      <comment>moved [[Arbitarily shaped wiboxes]] to [[Arbitrarily shaped wiboxes]]:&amp;#32;Spelling fail</comment>
      <text xml:space="preserve" bytes="1708">This page documents the XShape extension. With this extension, one can manipulate two different shapes for a window. The ''clipping shape'' and the ''bounding shape''.

== Definition ==
In the following examples, the left-most image shows the bounding shape used. In the middle is the clipping shape used and to the right there is the resulting wibox. The dark blue area is the wibox' border while the light blue area is the wibox' content where you can display anything (the border is always filled with the border color).

Let's start with the default values for both shapes:

[[File:Shape-default.png|200px]]

If we now modify the ''bounding shape'',  we get a round wibox:

[[File:Shape-bound-circle.png|200px]]

If we modify the ''clipping shape'' instead, the outline of the wibox is the same, but the border gets thicker at the edges:

[[File:Shape-clip-circle.png|200px]]

If we now modify both shapes, we can get a round wibox with a border:

[[File:Shape-both-circle.png|200px]]

As you can easily see, the ''border_width'' property of a wibox doesn't have any effect as soon as you start to use the shape extension.

== Code ==
To modify some of a wibox' shape, you set the '''shape_bounding''' or '''shape_clip''' properties of a wibox to an image.
 -- Create a 30x30px image
 local img = image.argb32(30, 30, nil)
 -- Fill it with white (= not part of the shape)
 img:draw_rectangle(0, 0, 30, 30, true, &quot;#ffffff&quot;)
 -- Draw a black circle to the center of the image
 img:draw_circle(15, 15, 14, 14, true, &quot;#000000&quot;)
 -- Set the bounding shape of wibox &quot;w&quot; to our image
 w.shape_bounding = img

If you want to reset a shape to its default value, you can do this easily too:
 w.shape_bounding = nil</text>
      <sha1>72taz5vdqanq96vaffan2g9di1i27s4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Arch Linux</title>
    <ns>0</ns>
    <id>158</id>
    <revision>
      <id>6202</id>
      <parentid>5603</parentid>
      <timestamp>2014-01-06T18:32:29Z</timestamp>
      <contributor>
        <username>S1ckn3ss</username>
        <id>3144</id>
      </contributor>
      <minor/>
      <comment>Link korrigiert.</comment>
      <text xml:space="preserve" bytes="1234">= How to install awesome =
== Awesome 3 ==
You can install the latest stable version from the official repository:

&lt;pre&gt;
# pacman -S awesome
&lt;/pre&gt;

== Awesome-git ==
There is a PKGBUILD for awesome-git in the AUR. There are several ways to install it.

The easiest is to use &quot;yaourt&quot; (also available in the AUR).  If you have yaourt installed, simply:
&lt;pre&gt;
# yaourt -S awesome-git
&lt;/pre&gt;

Or you can do it manually, and get the PKGBUILD [http://aur.archlinux.org/packages/aw/awesome-git/PKGBUILD here].

Create a new directory called &quot;awesome-git&quot; somewhere, put the PKGBUILD in there, and run:
&lt;pre&gt;
# makepkg -fi
&lt;/pre&gt;
'''Note:''' the -i flag automatically installs it aswell, to just create the package without installing first, remove that flag.

= How to start awesome =
== Setup xinitrc ==
Setup ~/.xinitrc file, add line for start awesome

&lt;pre&gt;
exec awesome
&lt;/pre&gt;

== Setup for Slim ==
1) Edit slim.conf for start awesome session, add awesome to sessions line

&lt;pre&gt;
sessions               awesome,wmii,xmonad
&lt;/pre&gt;

2) Edit ~/.xinitrc file

&lt;pre&gt;
DEFAULT_SESSION=awesome
case $1 in
  awesome) exec awesome ;;
  wmii) exec wmii ;;
  xmonad) exec xmonad ;;
  *) exec $DEFAULT_SESSION ;;
esac
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>5fhpwzsfkwte6k41zoano0wen23fwbw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Arch theme</title>
    <ns>0</ns>
    <id>157</id>
    <revision>
      <id>2781</id>
      <parentid>1240</parentid>
      <timestamp>2009-05-23T11:21:27Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Themes]]</comment>
      <text xml:space="preserve" bytes="624">&lt;pre&gt;
---------------------------------
-- arch awesome theme --
---------------------------------
 
font = terminus 8
 
bg_normal = #000000
bg_focus = #ffffff
bg_urgent = #ff0000
 
fg_normal = #1793d1
fg_focus = #1793d1
fg_urgent = #ffffff
 
border_width = 1
border_normal = #ffffff
border_focus = #000000
border_marked = #ff0000
 
# You can use your own command to
# set your wallpaper
#wallpaper_cmd = awsetbg ~/Images/wallpaper/wall_039.jpg
 
# You can add as many variables as
# you wish and access them by using
# beautiful.variable in your rc.lua
#bg_widget = #cc0000
&lt;/pre&gt;

[[Category:Awesome3]]
[[Category:Themes]]</text>
      <sha1>hfh82ll8zvsc15rc62oujjiqeccxnvy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Asmer imap mail widget</title>
    <ns>0</ns>
    <id>287</id>
    <revision>
      <id>5790</id>
      <parentid>5789</parentid>
      <timestamp>2013-02-18T15:05:44Z</timestamp>
      <contributor>
        <username>Luke bonham</username>
        <id>2753</id>
      </contributor>
      <comment>/* Porting to 3.5 */</comment>
      <text xml:space="preserve" bytes="2228">[[Image:indicator_email_dmj.png]]

This widget shows count of new mail in your mailbox, checked via python script by IMAP

= Python script =

&lt;pre&gt;
#!/usr/bin/python

import imaplib

#first field is imap server, second - port (993 for gmail SSL IMAP)
M=imaplib.IMAP4_SSL(&quot;imap.gmail.com&quot;, 993)
#first field is imap login (gmail uses login with domain and '@' character), second - password
M.login(&quot;user@gmail.com&quot;,&quot;password&quot;)

status, counts = M.status(&quot;Inbox&quot;,&quot;(MESSAGES UNSEEN)&quot;)

unread = counts[0].split()[4][:-1]
if int(unread) == 0:
    print &quot;  0  &quot;
else:
    print &quot;&lt;span color='red'&gt;  &lt;b&gt;&quot;+unread+&quot;&lt;/b&gt;  &lt;/span&gt;&quot;

M.logout()
&lt;/pre&gt;

Save this script in ~/scripts/unread.py and set executable permission to it.

= rc.lua configuration= 

&lt;pre&gt;
--- Mail updater
mymail = widget({ type = &quot;textbox&quot;, align = &quot;right&quot; })
mymail.text = &quot;  ?  &quot;
&lt;/pre&gt;

Hook (check mail every 30 seconds)

&lt;pre&gt;
awful.hooks.timer.register(30, function ()
    local f = io.open(&quot;/home/YOUR_USER/tmp/gmail&quot;) 
    local l = nil
    if f ~= nil then
       l = f:read() -- read output of command
    else
       l = &quot;  ?  &quot;
    end
    f:close()

    mymail.text = l
    os.execute(&quot;~/scripts/unread.py &gt; ~/tmp/gmail &amp;&quot;)
end)
&lt;/pre&gt;

----


= Porting to 3.5 =
&lt;b&gt;~/scripts/unread.py&lt;/b&gt;:
&lt;pre&gt;
#!/usr/bin/python

## change YOUR* pseudo-variables according to your needs

import imaplib

#default imap port is 993, change otherwise
M=imaplib.IMAP4_SSL(&quot;YOUR.IMAP.SERVER&quot;, 993)
M.login(&quot;YOUR_MAIL&quot;,&quot;YOUR_PASSWORD&quot;)

status, counts = M.status(&quot;Inbox&quot;,&quot;(MESSAGES UNSEEN)&quot;)

unread = counts[0].split()[4][:-1]

print(int(unread))

M.logout()
&lt;/pre&gt;

in &lt;b&gt;rc.lua&lt;/b&gt;:
&lt;pre&gt;
-- My mail updater widget
function mailcount()
    os.execute(&quot;~/scripts/unread.py &gt; ~/.mailcount&quot;)
    local f = io.open(home .. &quot;/.mailcount&quot;)
    local l = nil
    if f ~= nil then
          l = f:read()
    else
          l = &quot;?&quot;
    end
    f:close()
    return l
end

mymail = wibox.widget.textbox( mailcount() )
mymail.timer = timer{timeout=60}
mymail.timer:connect_signal(&quot;timeout&quot;, function () mymail:set_text ( mailcount() ) end)
&lt;/pre&gt;
where
&lt;pre&gt;
home = os.getenv(&quot;HOME&quot;)
&lt;/pre&gt;

--[[User:Luke Bonham|Luke Bonham]] 18:40, 17 February 2013 (CET)

[[Category:Awesome3]]</text>
      <sha1>ryp4u36pde1paahhmegqdcaoreqvi1m</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Aurantium theme</title>
    <ns>0</ns>
    <id>297</id>
    <revision>
      <id>2774</id>
      <parentid>2713</parentid>
      <timestamp>2009-05-23T11:20:06Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Themes]]</comment>
      <text xml:space="preserve" bytes="894">== About ==
[[Image:Awesome-aurantium.jpg|200px|thumb|right|screenshot of aurantium]]

This is a really simple orange and black theme to complement the MurrinaAurantium GTK theme.

== Colors and Fonts ==

The terminus font is recommended because it pwns but of course you can change it to anything you want. Clean is another good choice.
&lt;pre&gt;
-----------------------------
-- aurantium awesome theme --
-----------------------------

font          = terminus 8

bg_normal     = #000000
bg_focus      = #000000
bg_urgent     = #000000
bg_minimize   = #000000

fg_normal     = #eeeeee
fg_focus      = #ff6600
fg_urgent     = #0099FF
fg_minimize  =  #888888

border_width  = 1
border_normal = #000000
border_focus  = #888888
border_marked = #ff6600
&lt;/pre&gt;

== Wallpaper ==
You can get the wallpaper here: [http://gnome-look.org/content/show.php/awesome+orange?content=100587]

[[Category:Themes]]</text>
      <sha1>a50jv66bpkmwdq3qjqt25axw6wpdn35</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>AuroraUX</title>
    <ns>0</ns>
    <id>262</id>
    <revision>
      <id>2136</id>
      <timestamp>2009-01-16T17:11:19Z</timestamp>
      <contributor>
        <username>Evocallaghan</username>
        <id>236</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="853">The latest port version of awesome for AuroraUX (OpenSolaris) is awesome-2-Current and awesome-3-Current.
== Download ==
Simply download the awesome 'current' src version.

You may need to build extra dep in the README file if not on AuroraUX.

=== Versions ===
* The 3.1.1 port has an option for DBUS.
* If you don't know which version you need, take the latest stable (3.1.1).

== Building &amp; Installing Awesome ==

 export LIBS=&quot;-lX11 -lXext&quot;
 ./autogen
 ./configure --prefix=/usr
 gmake
 gmake install

== Post Installation Notes ==
You need to have a configuration file: &lt;code&gt;$HOME/.config/awesome/rc.lua&lt;/code&gt; Copy the default configuration file with:

 mkdir -p $HOME/.config/awesome
 cp /usr/local/share/examples/awesome/awesomerc.lua $HOME/.config/awesome/rc.lua

Cheers,
&lt;br&gt;
[[User:Evocallaghan|Evocallaghan]]

[[Category:Awesome3|Awesome2]]</text>
      <sha1>m63mzjkm6wfdjtv1tujx8wmoqr4vo3l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Automounting</title>
    <ns>0</ns>
    <id>94</id>
    <revision>
      <id>6219</id>
      <parentid>5668</parentid>
      <timestamp>2014-01-16T09:38:20Z</timestamp>
      <contributor>
        <username>Umod.47</username>
        <id>3156</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="7434">{{Languages}}

In popular desktop environment (Gnome, KDE, XFCE), automounting is installed automatically. You just have to plug-in your USB key to access all your data in Nautilus, D3lphin or Thunar. Since '''awesome''' is not a desktop environment but a window manager, this feature is not provided by default.

To remain to this, there is a standalone application (without any dependencies) that does automounting very well, you can check below solutions.
ivman does the job pretty well, and was nice for not having dependencies, but seems dead since 2007.
halevt seems to be its successor.

=Halevt=

Ivman project seems to be dead (the last release was in 2007), and it does not work with latest versions of hal and dbus. Its successor is halevt [http://www.nongnu.org/halevt/]. The configuration file for halevt has very much in common with ivman.

Debian users may install halevt from testing branch with:

&lt;pre&gt;
# aptitude install halevt
&lt;/pre&gt;

Also, /etc/PolicyKit/PolicyKit.conf should contain something like 

&lt;pre&gt;
&lt;match user=&quot;halevt&quot;&gt;
    &lt;match action=&quot;org.freedesktop.hal.storage.mount-removable&quot;&gt;
        &lt;return result=&quot;yes&quot;/&gt;
    &lt;/match&gt;
&lt;/match&gt;
&lt;/pre&gt;
for things to work.

=ivman=

On a Debian-based distribution, you can install this software by typing in a terminal:

   sudo apt-get install ivman

On Archlinux, you can install this software from AUR:

   http://aur.archlinux.org/packages.php?ID=18938

On FreeBSD, you can install this software by typing in a terminal:

   su root -c pkg_add\ -r\ ivman

On Gentoo Linux:

   # emerge sys-apps/ivman
   # /etc/init.d/ivman start

Or add it to runlevel:

   # rc-update -a ivman default

Not for Gentoo Linux: After it is installed, simply add [http://ivman.sourceforge.net/ Ivman] to your ''~/.xinitrc''. Here's an example of what it may look like:

   #!/bin/sh
   ivman &amp;
   exec awesome

Or, simply start ivman and enjoy automounting.



=Udisks and udisks-glue=

I think this is the better solution. It uses [http://hal.freedesktop.org/releases/ udisks] and [http://github.com/fernandotcl/udisks-glue udisks-glue]. Its configuration file syntax is simple, if you've used awesome 2.x, you'll like it (libconfuse-base ;)).

example of udisks-glue configuration file:
this configuration generate popup each time udisks-glue mount or unmount a device:

  filter disks {
           optical = false
           partition_table = false
           usage = filesystem
  }
  match disks {
           automount = true
           automount_options = sync
           post_mount_command = &quot;echo \'naughty.notify({title = \&quot;USB:\&quot;, text =\&quot;mounted %device_file on %mount_point\&quot;, timeout = 10})\' | awesome-client&quot;
           post_unmount_command = &quot;echo \'naughty.notify({title = \&quot;USB:\&quot;, text =\&quot;unmounted %device_file on %mount_point\&quot;, timeout = 10})\' | awesome-client&quot;
  }
  filter optical {
          optical = true
  }
  match optical {
          automount = true
          automount_options = ro
          post_mount_command = &quot;echo \'naughty.notify({title = \&quot;CD-Rom:\&quot;, text =\&quot;mounted %device_file on %mount_point\&quot;, timeout = 10})\' | awesome-client&quot;
          post_mount_command = &quot;echo \'udisks_glue:mount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Cdrom\&quot;)\' | awesome-client&quot;
          post_unmount_command = &quot;echo \'naughty.notify({title = \&quot;CD-Rom:\&quot;, text =\&quot;unmounted %device_file on %mount_point\&quot;, timeout = 10})\' | awesome-client&quot;
  }

See also the [[Blingbling#example_of_udisks-glue_menu:|module blingbling for a menu based on the udisks-glue events]].

=Autofs=

Good ol' peace of software that allows to make mounting and unmounting some devices automagic. Only drawback is obscure mount point names. If someone knows a more universal solution using automount, please contribute. The root configuration file is auto.master, which is read at start by the autofs management script. The daemon run by autofs script - automount - must run at all times for the automounting to actually work.

Autofs mounts devices on demand, e.g. when trying to auto-complete the directory name or just typing in the full path to a known file on the device and trying to access it. Autofs is able to unmount devices when they are not used, after a delay.
From man autofs:
For each of those mount points (in config file) automount(8) will mount  and  start  a thread, with the appropriate parameters, to manage the mount point.

Debian:
&lt;pre&gt;
# aptitude install autofs
&lt;/pre&gt;
Some options trough /etc/default/autofs. E.g. i changed the location of auto.master to /etc/autofs/auto.master as i like autofs to have a separate directory. Script resides in /etc/init.d/autofs

Arch Linux:
&lt;pre&gt;
# pacman -Sy autofs
&lt;/pre&gt;
Root configuration file is /etc/autofs/auto.master by default. Script in /etc/rc.d/autofs

Config. Read the manual aswell ;)

auto.master
&lt;pre&gt;
+auto.master
#As far as i know, any number of files from any location can be sourced from here.
#automount anything described in auto.auto at /media, unmounting after 2 idle seconds.
/media  /etc/autofs/auto.auto --timeout 2
&lt;/pre&gt;

auto.auto
&lt;pre&gt;
#linux		-ro,soft,intr		ftp.example.org:/pub/linux
# all sd devices with the directory names as 2 last chars (b1, c1, e.g. /media/b1 for /dev/sdb1)
*   -fstype=auto,async,nodev,nosuid,gid=100,uid=1000       :/dev/sd&amp;
#mounts devices/partitions with known names
devname   -fstype=auto,async,nodev,nosuid,gid=100,uid=1000       LABEL=&quot;DEVNAME&quot;
my   -fstype=auto,async,nodev,nosuid,gid=100,uid=1000       LABEL=&quot;My Passport&quot;
# mount a single device
cd  -fstype=auto,ro,nodev,nosuid :/dev/cdrom
&lt;/pre&gt;

As seen from examples, autofs can also automount network shares and the like.

= udev and uam =

== udev ==

udev can be configured to automount.  The main advantage of this is that if you are already running udev it does not require additional daemons.  However the unmount command can't be used by non-root users to unmount things mounted this way.  One option is to set it up use synchronous transfers so that it is safe to remove the device as long as you let saves finish, and to unmount things after they are removed; this may shorten the lifespan of some flash memory devices, though as far as I know this is not a serious issue for most uses of most current flash devices.  The other option is to use pmount instead of mount.  One place to find examples of how to set this up is [https://wiki.archlinux.org/index.php/Udev#Auto_mounting_USB_devices the udev page on ArchWiki].

== uam ==

[https://wiki.archlinux.org/index.php/Udev#Auto_mounting_USB_devices uam] will automatically set up udev to provide you with nicely automounted things.

On gentoo:

   # emerge uam pmount
   # usermod -aG plugdev username-you-want-to-be-able-to-use-automounted-things
   # /etc/init.d/udev restart

Automounted things will appear as /media/$LABEL, and can be unmounted with &lt;code&gt;uam-pumount /media/$LABEL&lt;/code&gt;.

=Udiskie=
Another fine solution, using [http://hal.freedesktop.org/releases/ udisks] is a python script - [http://comapt.freecode.com/projects/udiskie udiskie]. This tool works in background and mounts new media automatically. You can use '''udiskie-mount''' and '''udiskie-umount''' tools to explicitly mount and unmount partitions and devices.

Additionally, if you have PyGTK installed and want a system tray icon to handle mounts, launch udiskie the following way:&lt;br&gt;
'''udiskie --icon'''

&lt;pre&gt;
awful.util.spawn(&quot;udiskie --tray&quot;)
&lt;/pre&gt;</text>
      <sha1>svi5j4zxhufzsu2g41hcrs4jbjhuor2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Automounting/fr</title>
    <ns>0</ns>
    <id>431</id>
    <revision>
      <id>3623</id>
      <parentid>3335</parentid>
      <timestamp>2009-09-27T18:02:34Z</timestamp>
      <contributor>
        <username>Nim65s</username>
        <id>309</id>
      </contributor>
      <minor/>
      <comment>UBS =&gt; USB</comment>
      <text xml:space="preserve" bytes="1819">{{DISPLAYTITLE:Montage automatique des volumes}}
{{Languages|Automounting}}

Dans les environnements de bureau célèbres tels que Gnome, KDE ou XFCE, le montage automatique des volumes est installé par défaut. Vous n’avez qu’à brancher votre clé USB pour accéder à vos données dans Nautilus, D3lphin ou Thunar. Puisqu’awesome n’est pas un environnement de bureau mais un gestionnaire de fenêtres, cette fonctionnalité n’est pas fournie par défaut.

Pour récupérer ce comportement, une application auto suffisante sans aucune dépendance qui fait très bien du montage automatique est disponible : [http://ivman.sourceforge.net/ Ivman]

;Remarque.
:''Le projet Ivman semble mort : la dernière version date de 2007. De plus, il ne semble plus fonctionner avec les dernières versions de Hal et D-Bus. Son successeur est [http://www.nongnu.org/halevt/ Halevt]. Le fichier de configuration de Halevt est très proche de celui d’Ivman.''
__NOTOC__
== Installation ==
=== Arch Linux ===
Sur Archlinux, vous pouvez installer Ivman depuis AUR :
 http://aur.archlinux.org/packages.php?ID=18938

=== Debian et assimilées ===
Sur une distribution de type Debian, vous pouvez installer ce programme en tapant la ligne suivante en ''root'' dans une console virtuelle :
 aptitude install ivman

=== FreeBSD ===
Sur FreeBSD, vous pouvez l’installer en tapant dans une console virtuelle :
 su root -c pkg_add\ -r\ ivman

=== Gentoo Linux ===
Pour Gentoo Linux :
 # emerge sys-apps/ivman
 # /etc/init.d/ivman start

ou en l’ajoutant au runlevel :
 # rc-update -a ivman default

Après l’avoir installé, ajoutez ''ivman'' à votre '''~/.xinitrc'''. Voici à quoi ça devrait ressembler.
 #!/bin/sh
 ivman &amp;
 exec awesome

Ou lancez simplement ''ivman'' et à vous les joies du montage automatique !</text>
      <sha1>13grjg6gzp3eh1dpig5sp3zaof2lwc9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Automounting/ru</title>
    <ns>0</ns>
    <id>464</id>
    <revision>
      <id>6726</id>
      <parentid>6221</parentid>
      <timestamp>2014-06-08T04:44:13Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Обновление перевода(update translating)</comment>
      <text xml:space="preserve" bytes="11643">{{DISPLAYTITLE:Автомонтирование}}
{{Languages|Automounting}}

В популярных окружениях рабочего стола (Gnome, KDE, XFCE) автомонтирование работает &quot;из коробки&quot;. Для получения доступа к данным через Nautilus, Dolphin или Thunar нужно просто вставить флешку.  Так как '''awesome''' это не окружение рабочего стола, а оконный менеджер, он не предоставляет такую возможность по умолчанию.
Чтобы сделать это, существуют отдельные приложения (без зависимостей), которые осуществляют автоматическое монтирование очень хорошо, вы можете познакомится с этими приложениями ниже. ivman великолепно выполняет эту работу, и не имеет зависимостей, но кажется более не развивается с 2007, Halvet является его приемником.

=Ivman=

[http://ivman.sourceforge.net/ Ivman]

В дистрибутивах, основанных на Debian, эту программу можно установить, набрав в консоли:

   sudo apt-get install ivman

В Archlinux ivman находится в AUR:

   http://aur.archlinux.org/packages.php?ID=18938

Если у Вас FreeBSD, наберите в консоли:

   su root -c pkg_add\ -r\ ivman

В Gentoo Linux:

   # emerge sys-apps/ivman
   # /etc/init.d/ivman start

Или добавьте его на уровень запуска default:

   # rc-update -a ivman default

Не для Gentoo Linux: После установки просто добавьте [http://ivman.sourceforge.net/ Ivman] в файл ''~/.xinitrc''. Пример:

   #!/bin/sh
   ivman &amp;
   exec awesome

Или же просто запустите ivman и наслаждайтесь автомонтированием.

=Halevt=

Ivman, похоже, больше не разрабатывается (последняя версия вышла в 2007 году) и не работает с последними версиями hal и dbus. Его преемником является halevt [http://www.nongnu.org/halevt/]. Формат конфигурационного файла halevt очень похож на используемый в ivman.

В Debian halevt доступен в ветке testing и устанавливается командой:

    # aptitude install halevt

Теперь сменные носители будут монтироваться автоматически. Если этого не происходит, возможно, потребуется добавить в /etc/PolicyKit/PolicyKit.conf что-нибудь вроде:

    &lt;match user=&quot;halevt&quot;&gt;
                &lt;match action=&quot;org.freedesktop.hal.storage.mount-removable&quot;&gt;
                        &lt;return result=&quot;yes&quot;/&gt;
                &lt;/match&gt;
    &lt;/match&gt;

и перезапустить HAL.

=Udisks и udisks-glue=

Я думаю, что это лучшее решение. Здесь используются [http://hal.freedesktop.org/releases/ udisks] и [http://github.com/fernandotcl/udisks-glue udisks-glue]. Синтаксис файла конфигурации очень прост, если вы пользовались ранее awesome 2.x, он вам понравится (libconfuse-base ;)).

Пример файла конфигурации udisks-glue:
эта конфигурация генерирует уведомление каждый раз когда udisks-glue монтирует или размонтирует устройство:

  filter disks {
           optical = false
           partition_table = false
           usage = filesystem
  }
  match disks {
           automount = true
           automount_options = sync
           post_mount_command = &quot;echo \'naughty.notify({title = \&quot;USB:\&quot;, text =\&quot;mounted %device_file on %mount_point\&quot;, timeout = 10})\' | awesome-client&quot;
           post_unmount_command = &quot;echo \'naughty.notify({title = \&quot;USB:\&quot;, text =\&quot;unmounted %device_file on %mount_point\&quot;, timeout = 10})\' | awesome-client&quot;
  }
  filter optical {
          optical = true
  }
  match optical {
          automount = true
          automount_options = ro
          post_mount_command = &quot;echo \'naughty.notify({title = \&quot;CD-Rom:\&quot;, text =\&quot;mounted %device_file on %mount_point\&quot;, timeout = 10})\' | awesome-client&quot;
          post_mount_command = &quot;echo \'udisks_glue:mount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Cdrom\&quot;)\' | awesome-client&quot;
          post_unmount_command = &quot;echo \'naughty.notify({title = \&quot;CD-Rom:\&quot;, text =\&quot;unmounted %device_file on %mount_point\&quot;, timeout = 10})\' | awesome-client&quot;
  }

Смотрите также [[Blingbling/ru#Пример меню udisks-glue:|модуль blingbling основанный на меню для событий udisks-glue]].

=Autofs/udev/uam=

ivman (как и halevt) являются клиентами службы HAL и потому не могут работать без него. В случае, если по какой-либо причине использование HAL нежелательно, следует рассмотреть возможность использования udev и/или файловой системы autofs.

==Autofs==

Старый добрый мир программного обеспечения позволяет монтировать и размонтировать некоторые устройства автоматически. Единственным недостатком является названия точек монтирования. Если кто то знает универсальное решение по использованию автомонтирования, внесите пожалуйста свой вклад. Главным конфигурационным файлом является auto.master, который считывается при старте скриптом управления autofs. Демон запускается скриптом autofs - automount - должен работать постоянно, чтобы автомонтирование работало.

Autofs монтирует устройства по требованию, т.е. когда вы пытаетесь использовать авто завершение названия каталога или просто набираете полный путь к известному вам файлу на устройстве и пытаетесь получить к нему доступ. Autofs позволяет также размонтировать устройство, когда оно не используется какое то время
.
Из man autofs:
Для каждой точки монтирования (в файле конфигурации) automount(8) будет монтировать и запускать поток с соответствующими параметрами, для управления этой точкой доступа.

Debian:
&lt;pre&gt;
# aptitude install autofs
&lt;/pre&gt;
Некоторые опции можно найти в /etc/default/autofs. Например, я изменил расположение файла auto.master на /etc/autofs/auto.master, так как мне хочется, чтобы autofs имел отдельный каталог. Скрипт находится в /etc/init.d/autofs

Arch Linux:
&lt;pre&gt;
# pacman -Sy autofs
&lt;/pre&gt;
Главный конфигурационный файл по умолчанию /etc/autofs/auto.maste. Скрипт располагается  /etc/rc.d/autofs

Настраивайте. Читаетй man aswell ;)

auto.master
&lt;pre&gt;
+auto.master
#As far as i know, any number of files from any location can be sourced from here.
#automount anything described in auto.auto at /media, unmounting after 2 idle seconds.
/media  /etc/autofs/auto.auto --timeout 2
&lt;/pre&gt;

auto.auto
&lt;pre&gt;
#linux		-ro,soft,intr		ftp.example.org:/pub/linux
# all sd devices with the directory names as 2 last chars (b1, c1, e.g. /media/b1 for /dev/sdb1)
*   -fstype=auto,async,nodev,nosuid,gid=100,uid=1000       :/dev/sd&amp;
#mounts devices/partitions with known names
devname   -fstype=auto,async,nodev,nosuid,gid=100,uid=1000       LABEL=&quot;DEVNAME&quot;
my   -fstype=auto,async,nodev,nosuid,gid=100,uid=1000       LABEL=&quot;My Passport&quot;
# mount a single device
cd  -fstype=auto,ro,nodev,nosuid :/dev/cdrom
&lt;/pre&gt;

Как видно из примеров, autofs также может автомонтировать сеть и т.д.

== Udev ==

Udev может быть настроен на автомонтирование.  Главное преимущество в том, что если у вас уже запущен udev, вам не понадобится никаких дополнительных демонов.  Однако команда размонтирования может быть использована только под root пользователем.  Одна из опций позволяет вам установить возможность использования синхронного трансфера, что позволяет безопасно удалить устройство по завершении, и размонтирует после его удаления; это может уменьшить срок службы некоторых флешек, хотя насколько мне известно, это не является проблемой для большинства современных флеш-устройств.  Другим вариантом является использование pmount вместо mount.  Примеры как это настроить вы можете найти на [https://wiki.archlinux.org/index.php/Udev#Auto_mounting_USB_devices the udev page on ArchWiki].

== Uam ==

[https://wiki.archlinux.org/index.php/Udev#Auto_mounting_USB_devices uam] подскажет как настроит Udeb, что позволит вам использовать автомонтирование.

В gentoo:

   # emerge uam pmount
   # usermod -aG plugdev username-you-want-to-be-able-to-use-automounted-things
   # /etc/init.d/udev restart

Автомонтирование будет происходить в /media/$LABEL, и может быть размонтированно с помощью &lt;code&gt;uam-pumount /media/$LABEL&lt;/code&gt;.

=Udiskie=
При наличии udisks, автомонтирование можно обеспечить утилитой [http://comapt.freecode.com/projects/udiskie udiskie], написанной на python. После запуска udiskie находит и автоматически монтирует разделы на съемных устройствах. Можно принудительно смонтировать и размонтировать раздел командами '''udiskie-mount''' и '''udiskie-umount'''.

В случае, если в системе установлен PyGTK, можно запустить udiskie с иконкой в трее при помощи ключа --icon
&lt;pre&gt;
awful.util.spawn(&quot;udiskie --tray&quot;)
&lt;/pre&gt;</text>
      <sha1>c9g8slvweis3zh5zbnrijhy9xtm9n6f</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Autostart</title>
    <ns>0</ns>
    <id>171</id>
    <revision>
      <id>7340</id>
      <parentid>7116</parentid>
      <timestamp>2015-09-13T08:25:58Z</timestamp>
      <contributor>
        <username>Deap</username>
        <id>326</id>
      </contributor>
      <comment>/* The native lua way */</comment>
      <text xml:space="preserve" bytes="16875">{{Languages}}
Awesome does not provide autostart functionality; not in the sense of freedesktop autostart specification and using ''*.desktop'' files. Below are some solutions for you to consider.

== Traditional way ==
The '''xinit''' program is used to start the X server and clients on systems that don't have, or use, a display login manager like GDM/KDM/XDM. When ''xinit'' is run without specific client options it looks for a file called '''.xinitrc''' in the user's home directory and runs it as a shell script. This configuration file/script is used to start up client programs.

You can run any application from your ''~/.xinitrc'' file but keep in mind that programs which do not return or exit right way you need to send to the background, so they don't block other programs from starting. Only the last started program, your window manager (awesome in this case), should be left in the foreground so the script doesn't exit until you quit awesome, and so ''xinit'' can clean up after it.

If you are used to start the X server with the '''startx''' command, and by now wondering how this will affect you, do not worry the ''startx'' command is only a front-end to ''xinit'', and your ''~/.xinitrc'' file will also be executed. Very simple ''.xinitrc'' file as an example:

  #!/bin/sh
  #
  # User's .xinitrc file
  
  # Merge custom X resources
  xrdb -merge &quot;${HOME}/.Xresources&quot;
  
  # Play a startup sound, in the background
  ogg123 -q &quot;${HOME}/.config/awesome/login.ogg&quot; &amp;
  
  # Start a terminal emulator in the background
  urxvt -T Terminal &amp;
  
  # Start the window manager
  exec awesome


Here is a good example of a more complex ''.xinitrc'' file you can learn from: http://git.sysphere.org/dotfiles/tree/xinitrc

'''Note:''' If you start awesome with ''ck-launch-session'', you might want to create a separate start script and exec awesome from there or you can use an alternative way of starting the apps from inside rc.lua. Link to a related issue:  https://bbs.archlinux.org/viewtopic.php?pid=1085191

If you are using a login manager, most will expect you to use the window manager to autostart applications; continue reading for various methods to do that with awesome.  However some read .xprofile and some read .xsession.  gdm, kdm, and lightdm all use .xprofile.  It is run before the window manager is started so it can't be used to start graphical applications but it is a good way autostart background things or set environment variables that you would normally do in .xinitrc if you weren't using a login manager.

== Freedesktop autostart way ==
As stated in the first sentence on this page awesome does not implement the
Freedesktop way of spawning applications at startup but this shouldn't hinder
you to use it anyway.

The '''dex''' program interprets *.desktop files in the locations specified by
Freedesktop autostart documentation. Just run it like this via one of the ways described above/below:
   dex -a -e Awesome

For specifying which applications shall be started use
'''gnome-session-properties''' or similar programs from Gnome or KDE.

You should also be able to symlink autostart entries from /usr/share/applications into ~/.config/autostart.
Dex will then be able to find your user-specific autostart apps and run them. Verify with:
   dex -a -e Awesome -d

Dex can be downloaded here: http://github.com/jceb/dex.
Or can be installed directly from Archlinux by running &quot;pacman -S [https://www.archlinux.org/packages/community/any/dex/ dex]&quot;.

== Simple way ==

Just add lines to end of your ~/.config/awesome/rc.lua:

&lt;pre&gt;
awful.util.spawn_with_shell(&quot;COMMAND1&quot;)
awful.util.spawn_with_shell(&quot;COMMAND2&quot;)
&lt;/pre&gt;



'''My Example:'''

&lt;pre&gt;
awful.util.spawn_with_shell(&quot;kdeinit&quot;)
awful.util.spawn_with_shell(&quot;lineakd&quot;)
awful.util.spawn_with_shell(&quot;anyremote -f ~/.anyRemote/amarok.cfg&quot;)
awful.util.spawn_with_shell(&quot;~/scripts/trm&quot;)
awful.util.spawn_with_shell(&quot;xchat&quot;)
awful.util.spawn_with_shell(&quot;psi&quot;)
awful.util.spawn_with_shell(&quot;firefox-bin&quot;)
awful.util.spawn_with_shell(&quot;gvim +Project&quot;)
awful.util.spawn_with_shell(&quot;kchmviewer&quot;)
awful.util.spawn_with_shell(&quot;amarok&quot;)
awful.util.spawn_with_shell(&quot;kmix&quot;)
awful.util.spawn_with_shell(&quot;kbluetoothd&quot;)
awful.util.spawn_with_shell(&quot;sudo killall mplayer&quot;)
&lt;/pre&gt;

If you want to run your apps only once and not every time awesome is restarted, create this simple script:

&lt;pre&gt;
#! /bin/bash

# Run program unless it's already running.

if [ -z &quot;`ps -Af | grep -o -w &quot;.*$1&quot; | grep -v grep | grep -v run-once`&quot; ]; then
  $@
fi
&lt;/pre&gt;
Or this:
&lt;pre&gt;
#!/bin/bash
#Alternative
pgrep $@ &gt; /dev/null || ($@ &amp;)
&lt;/pre&gt;

Save it as &quot;run_once&quot; somewhere in your $PATH and make it executable. Then autostart your apps like this:

&lt;pre&gt;awful.util.spawn_with_shell(&quot;run_once amarok&quot;)&lt;/pre&gt;

Alternatively you can use the following to avoid an external script (this also ignore commands running as other users than yourself):

&lt;pre&gt;
function run_once(cmd)
  findme = cmd
  firstspace = cmd:find(&quot; &quot;)
  if firstspace then
    findme = cmd:sub(0, firstspace-1)
  end
  awful.util.spawn_with_shell(&quot;pgrep -u $USER -x &quot; .. findme .. &quot; &gt; /dev/null || (&quot; .. cmd .. &quot;)&quot;)
end

run_once(&quot;amarok&quot;)
run_once(&quot;xscreensaver -no-splash&quot;)
&lt;/pre&gt;

Or this slightly more advanced version which permits to use command line options and to specify on which screen to launch your programs. It also allows for the case when the name of the process is different from the name of the command used to launch it (e.g. with wicd-client).

&lt;pre&gt;
function run_once(prg,arg_string,pname,screen)
    if not prg then
        do return nil end
    end

    if not pname then
       pname = prg
    end

    if not arg_string then 
        awful.util.spawn_with_shell(&quot;pgrep -f -u $USER -x '&quot; .. pname .. &quot;' || (&quot; .. prg .. &quot;)&quot;,screen)
    else
        awful.util.spawn_with_shell(&quot;pgrep -f -u $USER -x '&quot; .. pname .. &quot; &quot;.. arg_string ..&quot;' || (&quot; .. prg .. &quot; &quot; .. arg_string .. &quot;)&quot;,screen)
    end
end

run_once(&quot;xscreensaver&quot;,&quot;-no-splash&quot;)
run_once(&quot;pidgin&quot;,nil,nil,2)
run_once(&quot;wicd-client&quot;,nil,&quot;/usr/bin/python2 -O /usr/share/wicd/gtk/wicd-client.py&quot;)

&lt;/pre&gt;

Alternatively, if you want to start multiple instances of terminal with different window names, it is possible to use a variation of the above, though this also requires installation of wmctrl.

Save this small bash file somewhere on your $PATH and make it executable:

&lt;pre&gt;
#!/bin/bash
EXPECTED_ARGS=2

if [ $# -ne $EXPECTED_ARGS ]
then
  exit 1
fi

COUNT=`wmctrl -l -x | grep $1 | wc -l`

if [ &quot;$COUNT&quot; -lt &quot;$2&quot; ]
then
  exit 0
else
  exit 1
fi
&lt;/pre&gt;
The autostart commands will look something like this. Usually with rules to place name=&quot;SSH&quot; on a different tag from name=&quot;log&quot;:
&lt;pre&gt;
awful.util.spawn_with_shell(&quot;run_limited SSH 4 &amp;&amp; urxvt -name SSH&quot;);
awful.util.spawn_with_shell(&quot;run_limited SSH 4 &amp;&amp; urxvt -name SSH&quot;);
awful.util.spawn_with_shell(&quot;run_limited SSH 4 &amp;&amp; urxvt -name SSH&quot;);
awful.util.spawn_with_shell(&quot;run_limited SSH 4 &amp;&amp; urxvt -name SSH&quot;);
awful.util.spawn_with_shell(&quot;run_limited log 2 &amp;&amp; urxvt -name log&quot;);
awful.util.spawn_with_shell(&quot;run_limited log 2 &amp;&amp; urxvt -name log&quot;);
&lt;/pre&gt;

== Directory way ==
&lt;pre&gt;
-- Autostart
function autostart(dir)
    if not dir then
        do return nil end
    end
    local fd = io.popen(&quot;ls -1 -F &quot; .. dir)
    if not fd then
        do return nil end
    end
    for file in fd:lines() do
        local c= string.sub(file,-1)   -- last char
        if c=='*' then  -- executables
            executable = string.sub( file, 1,-2 )
            print(&quot;Awesome Autostart: Executing: &quot; .. executable)
            awful.util.spawn_with_shell(dir .. &quot;/&quot; .. executable .. &quot;&quot;) -- launch in bg
        elseif c=='@' then  -- symbolic links
            print(&quot;Awesome Autostart: Not handling symbolic links: &quot; .. file)
        else
            print (&quot;Awesome Autostart: Skipping file &quot; .. file .. &quot; not executable.&quot;)
        end
    end
    io.close(fd)
end

autostart_dir = os.getenv(&quot;HOME&quot;) .. &quot;/.config/autostart&quot;
autostart(autostart_dir)
&lt;/pre&gt;

Be aware of the following drawbacks (and maybe fix them):
* the files in the autostart directory will be run everytime you re-parse the config file. If you re-parse the config file multiple times during a session this might cause strange behavior. If an application should only be run once, please handle this in the corresponding autostart script.
* The function currently ignores symlinks (I do not need them).

== PID way ==
Put this in runonce.lua
&lt;pre&gt;
-- @author Peter J. Kranz (Absurd-Mind, peter@myref.net)
-- Any questions, criticism or praise just drop me an email

local M = {}

-- get the current Pid of awesome
local function getCurrentPid()
    -- get awesome pid from pgrep
    local fpid = io.popen(&quot;pgrep -u &quot; .. os.getenv(&quot;USER&quot;) .. &quot; -o awesome&quot;)
    local pid = fpid:read(&quot;*n&quot;)
    fpid:close()

    -- sanity check
    if pid == nil then
        return -1
    end

    return pid
end

local function getOldPid(filename)
    -- open file
    local pidFile = io.open(filename)
    if pidFile == nil then
        return -1
    end

    -- read number
    local pid = pidFile:read(&quot;*n&quot;)
    pidFile:close()

    -- sanity check
    if pid &lt;= 0 then
        return -1
    end

    return pid;
end

local function writePid(filename, pid)
    local pidFile = io.open(filename, &quot;w+&quot;)
    pidFile:write(pid)
    pidFile:close()
end

local function shallExecute(oldPid, newPid)
    -- simple check if equivalent
    if oldPid == newPid then
        return false
    end

    return true
end

local function getPidFile()
    local host = io.lines(&quot;/proc/sys/kernel/hostname&quot;)()
    return awful.util.getdir(&quot;cache&quot;) .. &quot;/awesome.&quot; .. host .. &quot;.pid&quot;
end

-- run Once per real awesome start (config reload works)
-- does not cover &quot;pkill awesome &amp;&amp; awesome&quot;
function M.run(shellCommand)
    -- check and Execute
    if shallExecute(M.oldPid, M.currentPid) then
        awful.util.spawn_with_shell(shellCommand)
    end
end

M.pidFile = getPidFile()
M.oldPid = getOldPid(M.pidFile)
M.currentPid = getCurrentPid()
writePid(M.pidFile, M.currentPid)

return M
&lt;/pre&gt;

Use it this way:
&lt;pre&gt;
local r = require(&quot;runonce&quot;)

r.run(&quot;urxvtd -q -o -f&quot;)
r.run(&quot;urxvtc&quot;)
r.run(&quot;urxvtc&quot;)
r.run(&quot;wmname LG3D&quot;)
&lt;/pre&gt;

'''NOTE:''' the runonce.lua will only work if the window manager is started as &quot;awesome&quot;. If it is started from a symlink (say, as x-window-manager on Debian), it will fail. An alternative is to replace the &lt;code&gt;--get awesome pid from pgrep&lt;/code&gt; part to retrieve its PID directly from /proc instead of relying on pgrep and an unstable name:

&lt;pre&gt;
-- get awesome pid from /proc
local fpid = assert(io.open(&quot;/proc/self/stat&quot;, &quot;r&quot;))
local pid = fpid:read(&quot;*all&quot;)
fpid:close()
pid = string.match(t, &quot;%S+&quot;)
&lt;/pre&gt;

==The native lua way==
This solution doesn't depend on external tools, which speed up your startup.

To use this code snippet luafilesystem alias lfs is required.

It should be avaible for every system: debian (lua-filesystem), freebsd (ports/devel/luafilesystem/), gentoo (dev-lua/luafilesystem), ubuntu (liblua5.1-filesystem0), archlinux (lua-filesystem)

@bsdguys: don't forget to mount procfs (:
&lt;pre&gt;
require(&quot;lfs&quot;) 
-- {{{ Run programm once
local function processwalker()
   local function yieldprocess()
      for dir in lfs.dir(&quot;/proc&quot;) do
        -- All directories in /proc containing a number, represent a process
        if tonumber(dir) ~= nil then
          local f, err = io.open(&quot;/proc/&quot;..dir..&quot;/cmdline&quot;)
          if f then
            local cmdline = f:read(&quot;*all&quot;)
            f:close()
            if cmdline ~= &quot;&quot; then
              coroutine.yield(cmdline)
            end
          end
        end
      end
    end
    return coroutine.wrap(yieldprocess)
end

local function run_once(process, cmd)
   assert(type(process) == &quot;string&quot;)
   local regex_killer = {
      [&quot;+&quot;]  = &quot;%+&quot;, [&quot;-&quot;] = &quot;%-&quot;,
      [&quot;*&quot;]  = &quot;%*&quot;, [&quot;?&quot;]  = &quot;%?&quot; }

   for p in processwalker() do
      if p:find(process:gsub(&quot;[-+?*]&quot;, regex_killer)) then
	 return
      end
   end
   return awful.util.spawn(cmd or process)
end
-- }}}

-- Usage Example
run_once(&quot;firefox&quot;)
run_once(&quot;dropboxd&quot;)
-- Use the second argument, if the programm you wanna start, 
-- differs from the what you want to search.
run_once(&quot;redshift&quot;, &quot;nice -n19 redshift -l 51:14 -t 5700:4500&quot;)

&lt;/pre&gt;

==The X way==

Another way to detect if a process is already running is to check if there is a window for it. This only works for processes that connect to the X server. There are two drawbacks with this approach. First, awesome does not maintain a list of all clients, just for clients that have regular windows. If a client is window-less (for example, a systray icon), it is not listed by awesome. Second, the list of clients is only available once awesome has started completely, not during the initialization.

We can circumvent the first problem by using (as a fallback) xwininfo. The second problem is worked around with a timer. Here is the code:

&lt;pre&gt;
local xrun_now = function(name, cmd)
   -- Try first the list of clients from awesome (which is available
   -- only if awesome has fully started, therefore, this function
   -- should be run inside a 0 timer)
   local squid = { name, name:sub(1,1):upper() .. name:sub(2) }
   if awful.client.cycle(
      function(c)
	 return awful.rules.match_any(c,
				      { name = squid,
					class = squid,
					instance = squid })
      end)() then
      return
   end

   -- Not found, let's check with xwininfo. We can only check name but
   -- we can catch application without a window...
   if os.execute(&quot;xwininfo -name '&quot; .. name .. &quot;' &gt; /dev/null 2&gt; /dev/null&quot;) == 0 then
      return
   end
   awful.util.spawn_with_shell(cmd or name)
end

-- Run a command if not already running.
xrun = function(name, cmd)
   -- We need to wait for awesome to be ready. Hence the timer.
   local stimer = timer { timeout = 0 }
   local run = function()
      stimer:stop()
      xrun_now(name, cmd)
   end
   stimer:add_signal(&quot;timeout&quot;, run)
   stimer:start()
end
&lt;/pre&gt;

Example of use:

&lt;pre&gt;
xrun(&quot;chromium&quot;)
xrun(&quot;pidgin&quot;, &quot;pidgin -n&quot;)
&lt;/pre&gt;

First argument is the name of the program (name of window, instance or class, it will also be searched capitalized). The second is the command to run. The first argument is used as a command if no second argument is provided.

== The X Resources way ==

This script sets an XResource property to indicate that autorun was already run. This method is in my opinion the most reliable one. XResources exist only in RAM so no cleanup is necessary and XResources exist for as long as the X session exist.

The code also redirects the output of all methods started by dex to a tempfile instead of ~/.xsession-errors.

&lt;pre&gt;
#!/bin/sh

PROP=autostart.wasrun
HASPROP=$(xrdb -query|grep $PROP)

if [ &quot;$HASPROP&quot; != &quot;&quot; ]
then
  exit 0;
fi

TEMPLATE=xsession-$USER-$PPID-XXX
TEMPFILE=$(mktemp --tmpdir $TEMPLATE)

echo &quot;logging to $TEMPFILE&quot;

echo &quot;$PROP: on&quot; | xrdb -merge

( $HOME/bin/dex -v -a 2&gt;&amp;1 1&gt;$TEMPFILE ) &amp;
&lt;/pre&gt;

I have no deeper knowledge on X resources so I'd be happy if somebody would 
like to review this.

This is a similar approach that runs in lua instead of shell:

&lt;pre&gt;
xrun = function(cmd, late)
    local xresources = awful.util.pread(&quot;xrdb -query&quot;)
    local myxr = xresources:match(&quot;^awesome%.xrun:%s+.-\n&quot;)
                 or xresources:match(&quot;\nawesome%.xrun:%s+.-\n&quot;)
                 or &quot;awesome.xrun:&quot;
    myxr = myxr:gsub(&quot;\n&quot;, &quot;&quot;)
    if not string.find(myxr, cmd, 1, true) then
        -- use pread so that this runs synchronously
        awful.util.pread(&quot;echo '&quot; .. myxr .. &quot; &quot; .. cmd:gsub(&quot;'&quot;, &quot;\\'&quot;) .. &quot;'|xrdb -merge&quot;)
        if late then
            local stimer = timer { timeout = late }
            local run = function()
                stimer:stop()
                awful.util.spawn(cmd, false)
            end
            stimer:connect_signal(&quot;timeout&quot;, run)
            stimer:start()
        else
            awful.util.spawn(cmd, false)
        end
    end
end
&lt;/pre&gt;
Or using a more general method to do anything on start but not restart
&lt;pre&gt;
local xresources_name = &quot;awesome.started&quot;
local xresources = awful.util.pread(&quot;xrdb -query&quot;)
if not xresources:match(xresources_name) then
    -- Execute once for X server
    os.execute(&quot;dex -a -e Awesome&quot;)
end
awful.util.spawn_with_shell(&quot;xrdb -merge &lt;&lt;&lt; &quot; .. &quot;'&quot; .. xresources_name .. &quot;: true'&quot;)
&lt;/pre&gt;

* Wouldn't it be nice if awesome lua would have functions to manipulate and query X resources?

* Wouldn't it be nice if awesome would by itself already set an X resource property once it has completed the processing of its configuration? Later restarts could then check whether this property is already set.

* Wouldn't it be nice if there'd actually be some free desktop standard property to be set once a window manager has fully started up?

[[Category:Awesome3]]</text>
      <sha1>gj9sqaga3eldg1sqxd18rq7s344ysc2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Autostart/ru</title>
    <ns>0</ns>
    <id>476</id>
    <revision>
      <id>7346</id>
      <parentid>7146</parentid>
      <timestamp>2015-09-20T17:14:16Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>recent changes</comment>
      <text xml:space="preserve" bytes="23809">{{DISPLAYTITLE:Автозапуск}}
{{Languages|Autostart}}

В Awesome отсутствует встроенная поддержка автозапуска приложений. Чтобы настроить
автозапуск, Вы можете отредактировать либо .xinitrc, либо сессионный скрипт, выполняемый gdm
или kdm, или же найти какой-то другой способ запускать приложения вместе с Awesome.

== Обычный способ ==
'''xinit''' используется для запуска X сервера и приложений, на системах не имеющих вообще, или использующих login менеджеры, такие как GDM/KDM/XDM. При запуске ''xinit'' без специальных опций приложений, он ищет файл '''.xinitrc''' в домашнем каталоге и запускает его как shell скрипт. Этот конфигурационный файл/скрипт используется для запуска клиентских приложений.

Вы можете запускать любые приложения из вашего файла ''~/.xinitrc'', но имейте в виду, что программы которые не завершаются или не должны завершаться, вы должны отправлять в фоновый режим работы, поскольку они не блокируют другие приложения при старте. Только последняя запускаемая программа, ваш оконный менеджер (в нашем случае awesome), должен запускаться на переднем плане (т.к. она блокирует дальнейшее выполнение скрипта), поэтому скрипт не завершается до вашего выхода из awesome, и поэтому ''xinit'' может произвести очистку, только после выхода.

Если вы используете запуск X сервера с помощью команды '''startx''', и беспокоитесь на то как это влияет на запуск приложений, не беспокойтесь, команда ''startx'' считывает ''xinit'', и ваш файл ''~/.xinitrc'' также будет выполнен. Простейший пример файла ''.xinitrc'' приведен ниже:

  #!/bin/sh
  #
  # User's .xinitrc file
  
  # Считывание пользовательского файла X resources
  xrdb -merge &quot;${HOME}/.Xresources&quot;
  
  # Воспроизведение звука запуска в фоновом режиме
  ogg123 -q &quot;${HOME}/.config/awesome/login.ogg&quot; &amp;
  
  # Запуск эмулятора терминала в фоновом режиме
  urxvt -T Terminal &amp;
  
  # Запуск оконного менеджера
  exec awesome


Более сложный пример использования файла ''.xinitrc'' вы можете найти на здесь: http://git.sysphere.org/dotfiles/tree/xinitrc

'''Примечание:''' Если вы запускаете awesome используя ''ck-launch-session'', вы можете захотеть создать раздельный старт скриптов и запуск awesome , или вы можете исплользовать альтернативный способ запуска приложений в rc.lua. Ссылка на этот способ:  https://bbs.archlinux.org/viewtopic.php?pid=1085191

Если вы используете login manager, то вы можете использовать оконный менеджер для автозапуска приложений; продолжайте чтение, для изучения различных способов как это реализовать в awesome.  Однако, какие то менеджеры считывают .xprofile, а другие .xsession.  gdm, kdm, и lightdm используют .xprofile.  Но поспольку он обрабатывается до запуска оконного менеджера, то вы не сможете использовать его для запуска графических приложений, зато этот способ отлично подходит для автозапуска фоновых приложений, или для установки переменных окружения, которые обычно прописываются в .xinitrc, когда вы не используете login manager.

== Способ от Freedesktop ==
Как уже говорилось выше, awesome не поддерживает способ запуска приложений Freedesktop, но это не должно мешать вам использовать его.

Программа '''dex''' позволяет обработать файлы  *.desktop расположенные в определенных спецификацией Freedesktop местах автозапуска. Просто запустите его, используюя способ описанный ниже:
   dex -a -e Awesome

Для определения запускаемых программ используйте '''gnome-session-properties''' или аналогичных программ из Gnome или KDE.

Вы также можете сделать симлинк(symlink)  на список автозапуска из /usr/share/applications в ~/.config/autostart. После этого dex сможет найти определеные пользователем автоматически запускаемые приложения и запустить их. Проверьте следующий код:
   dex -a -e Awesome -d

Вы можете скачать Dex здесь: http://github.com/jceb/dex.
Или можете установить его в Archlinux используя &quot;pacman -S [https://www.archlinux.org/packages/community/any/dex/ dex]&quot;.

== Простой способ ==

Просто добавьте несколько строк в конец файла ~/.config/awesome/rc.lua:

&lt;pre&gt;
awful.util.spawn_with_shell(&quot;КОМАНДА1&quot;)
awful.util.spawn_with_shell(&quot;КОМАНДА2&quot;)
&lt;/pre&gt;

...и так далее.

'''Пример:'''

&lt;pre&gt;
awful.util.spawn_with_shell(&quot;kdeinit&quot;)
awful.util.spawn_with_shell(&quot;lineakd&quot;)
awful.util.spawn_with_shell(&quot;anyremote -f ~/.anyRemote/amarok.cfg&quot;)
awful.util.spawn_with_shell(&quot;~/scripts/trm&quot;)
awful.util.spawn_with_shell(&quot;xchat&quot;)
awful.util.spawn_with_shell(&quot;psi&quot;)
awful.util.spawn_with_shell(&quot;firefox-bin&quot;)
awful.util.spawn_with_shell(&quot;gvim +Project&quot;)
awful.util.spawn_with_shell(&quot;kchmviewer&quot;)
awful.util.spawn_with_shell(&quot;amarok&quot;)
awful.util.spawn_with_shell(&quot;kmix&quot;)
awful.util.spawn_with_shell(&quot;kbluetoothd&quot;)
awful.util.spawn_with_shell(&quot;sudo killall mplayer&quot;)
&lt;/pre&gt;

Чтобы запускать приложения только один раз, а не при каждом перезапуске Awesome, создайте такой скрипт:

&lt;pre&gt;
#! /bin/bash

# Запустить программу, если она ещё не запущена.

if [ -z &quot;`ps -Af | grep -o -w &quot;.*$1&quot; | grep -v grep | grep -v run-once`&quot; ]; then
  $@
fi
&lt;/pre&gt;
Или так:
&lt;pre&gt;
#!/bin/bash
#Alternative
pgrep $@ &gt; /dev/null || ($@ &amp;)
&lt;/pre&gt;

Сохраните скрипт под именем &quot;run_once&quot; где-нибудь в $PATH и сделайте исполняемым. Затем используйте его для автозапуска:

&lt;pre&gt;awful.util.spawn_with_shell(&quot;run_once amarok&quot;)&lt;/pre&gt;

В качестве альтернативы отдельному shell-скрипту можно добавить в rc.lua следующий код (который к тому же будет игнорировать приложения, запущенные другими пользователями):

&lt;pre&gt;
function run_once(cmd)
  findme = cmd
  firstspace = cmd:find(&quot; &quot;)
  if firstspace then
    findme = cmd:sub(0, firstspace-1)
  end
  awful.util.spawn_with_shell(&quot;pgrep -u $USER -x &quot; .. findme .. &quot; &gt; /dev/null || (&quot; .. cmd .. &quot;)&quot;)
end

run_once(&quot;amarok&quot;)
run_once(&quot;xscreensaver -no-splash&quot;)
&lt;/pre&gt;


Или более продвинутую версию, которая позволяет использовать опции командной строки и позволяющая указать, на каком экране запускать приложение. Этот код также позволяет коректно обрабатывать ситуации, когда запускаемое приложение и имя процесса различаются (например wicd-client).

&lt;pre&gt;
function run_once(prg,arg_string,pname,screen)
    if not prg then
        do return nil end
    end

    if not pname then
       pname = prg
    end

    if not arg_string then 
        awful.util.spawn_with_shell(&quot;pgrep -f -u $USER -x '&quot; .. pname .. &quot;' || (&quot; .. prg .. &quot;)&quot;,screen)
    else
        awful.util.spawn_with_shell(&quot;pgrep -f -u $USER -x '&quot; .. pname .. &quot; &quot;.. arg_string ..&quot;' || (&quot; .. prg .. &quot; &quot; .. arg_string .. &quot;)&quot;,screen)
    end
end

run_once(&quot;xscreensaver&quot;,&quot;-no-splash&quot;)
run_once(&quot;pidgin&quot;,nil,nil,2)
run_once(&quot;wicd-client&quot;,nil,&quot;/usr/bin/python2 -O /usr/share/wicd/gtk/wicd-client.py&quot;)

&lt;/pre&gt;

С друкой стороноы, если вы захотите запустить несколько экземпляров терминала с различными именами,это также возможно используя способ указанный выше, но это потребует дополнительной установки wmctrl.

Сохраните этот маленький скрипт, где нибудь в указанном в $PATH каталоге и сделайте его исполняемым:

&lt;pre&gt;
#!/bin/bash
EXPECTED_ARGS=2

if [ $# -ne $EXPECTED_ARGS ]
then
  exit 1
fi

COUNT=`wmctrl -l -x | grep $1 | wc -l`

if [ &quot;$COUNT&quot; -lt &quot;$2&quot; ]
then
  exit 0
else
  exit 1
fi
&lt;/pre&gt;
В этом случае команды автозапуска будут выглядеть следующим образом. Используя ''name=&quot;SSH&quot;'' и ''name=&quot;log'' вы будете размещать их в разных тегах:
&lt;pre&gt;
awful.util.spawn_with_shell(&quot;run_limited SSH 4 &amp;&amp; urxvt -name SSH&quot;);
awful.util.spawn_with_shell(&quot;run_limited SSH 4 &amp;&amp; urxvt -name SSH&quot;);
awful.util.spawn_with_shell(&quot;run_limited SSH 4 &amp;&amp; urxvt -name SSH&quot;);
awful.util.spawn_with_shell(&quot;run_limited SSH 4 &amp;&amp; urxvt -name SSH&quot;);
awful.util.spawn_with_shell(&quot;run_limited log 2 &amp;&amp; urxvt -name log&quot;);
awful.util.spawn_with_shell(&quot;run_limited log 2 &amp;&amp; urxvt -name log&quot;);
&lt;/pre&gt;

== Способ, использующий директорию автозапуска ==
&lt;pre&gt;
-- Автозапуск
function autostart(dir)
    if not dir then
        do return nil end
    end
    local fd = io.popen(&quot;ls -1 -F &quot; .. dir)
    if not fd then
        do return nil end
    end
    for file in fd:lines() do
        local c= string.sub(file,-1)   -- последний символ
        if c=='*' then  -- исполняемые файлы
            executable = string.sub( file, 1,-2 )
            print(&quot;Автозапуск Awesome. Запускается: &quot; .. executable)
            awful.util.spawn_with_shell(dir .. &quot;/&quot; .. executable .. &quot;&quot;) -- запуск в фоне
        elseif c=='@' then  -- символические ссылки
            print(&quot;Автозапуск Awesome. Симнолические ссылки пропускаются: &quot; .. file)
        else
            print (&quot;Автозапуск Awesome. Игнорируем файл &quot; .. file .. &quot; , т.к. не является исполняемым.&quot;)
        end
    end
    io.close(fd)
end

autostart_dir = os.getenv(&quot;HOME&quot;) .. &quot;/.config/autostart&quot;
autostart(autostart_dir)
&lt;/pre&gt;

Учтите (и по возможности исправьте) следующие недостатки:
* файлы в директории автозапуска будут выполняться при каждом чтении конфигурационного файла, что может привести к неожиданным последствиям, если Вы делаете это несколько раз за сеанс. Чтобы избежать повторных запусков, обрабатывайте их в соответствующем скрипте.
* функция игнорирует символьные ссылки.

== Способ использующий идентификаторы(PID) ==
Поместите следующий код в runonce.lua
&lt;pre&gt;
-- @автор Peter J. Kranz (Absurd-Mind, peter@myref.net)
-- Любые вопросы, критику или благодарности отправляйте на электронную почту

local M = {}

-- получаем текущий идентификатор(Pid) awesome
local function getCurrentPid()
    -- получаем идентификатор awesome используя pgrep
    local fpid = io.popen(&quot;pgrep -u &quot; .. os.getenv(&quot;USER&quot;) .. &quot; -o awesome&quot;)
    local pid = fpid:read(&quot;*n&quot;)
    fpid:close()

    -- проверка корректности
    if pid == nil then
        return -1
    end

    return pid
end

local function getOldPid(filename)
    -- открыаем файл
    local pidFile = io.open(filename)
    if pidFile == nil then
        return -1
    end

    -- считываем колличество
    local pid = pidFile:read(&quot;*n&quot;)
    pidFile:close()

    -- проверка на то, что колличество больше 0
    if pid &lt;= 0 then
        return -1
    end

    return pid;
end

local function writePid(filename, pid)
    local pidFile = io.open(filename, &quot;w+&quot;)
    pidFile:write(pid)
    pidFile:close()
end

local function shallExecute(oldPid, newPid)
    -- простая проверка на равенство
    if oldPid == newPid then
        return false
    end

    return true
end

local function getPidFile()
    local host = io.lines(&quot;/proc/sys/kernel/hostname&quot;)()
    return awful.util.getdir(&quot;cache&quot;) .. &quot;/awesome.&quot; .. host .. &quot;.pid&quot;
end

-- запускаем один раз при первом запуске awesome (настройка перезапуска работает)
-- не распростраянется на &quot;pkill awesome &amp;&amp; awesome&quot;
function M.run(shellCommand)
    -- проверяем и запускаем
    if shallExecute(M.oldPid, M.currentPid) then
        awful.util.spawn_with_shell(shellCommand)
    end
end

M.pidFile = getPidFile()
M.oldPid = getOldPid(M.pidFile)
M.currentPid = getCurrentPid()
writePid(M.pidFile, M.currentPid)

return M
&lt;/pre&gt;

Для запуска используем следующий код:
&lt;pre&gt;
local r = require(&quot;runonce&quot;)  -- в начало файла

r.run(&quot;urxvtd -q -o -f&quot;)
r.run(&quot;urxvtc&quot;)
r.run(&quot;urxvtc&quot;)
r.run(&quot;wmname LG3D&quot;)
&lt;/pre&gt;

'''Примечание:''' runonce.lua будет работать только если оконный менеджер запущен напрямую, как &quot;awesome&quot;. Но, если он запущен через симлинк (например,как x-window-manager в Debian), то он будет работать некорректно. В качестве альтернативы, замените часть &lt;code&gt;--get awesome pid from pgrep&lt;/code&gt; на получение его PID непосредственно из /proc а не полагайтесь на pgrep с его нестабильными именами:

&lt;pre&gt;
-- get awesome pid from /proc
local fpid = assert(io.open(&quot;/proc/self/stat&quot;, &quot;r&quot;))
local pid = fpid:read(&quot;*all&quot;)
fpid:close()
pid = string.match(t, &quot;%S+&quot;)
&lt;/pre&gt;

== Встроенный способ lua ==

Этот способ не зависит от внешних утилит, которые ускоряют запуск системы.

Для использования этого кода lua-filesystem требуется lfs.

Он должен быть доступн для большинства систем: debian (lua-filesystem), freebsd (ports/devel/luafilesystem/), gentoo (dev-lua/luafilesystem), ubuntu (liblua5.1-filesystem0), archlinux (luafilesystem)

@bsdguys: не забудьте смонтировать procfs (:
&lt;pre&gt;
require(&quot;lfs&quot;) 
-- {{{ Зупускаем программу единожны(run-once)
local function processwalker()
   local function yieldprocess()
      for dir in lfs.dir(&quot;/proc&quot;) do
        -- Все каталоги в /proc содержат число, представляющее процесс
        if tonumber(dir) ~= nil then
          local f, err = io.open(&quot;/proc/&quot;..dir..&quot;/cmdline&quot;)
          if f then
            local cmdline = f:read(&quot;*all&quot;)
            f:close()
            if cmdline ~= &quot;&quot; then
              coroutine.yield(cmdline)
            end
          end
        end
      end
    end
    return coroutine.wrap(yieldprocess)
end

local function run_once(process, cmd)
   assert(type(process) == &quot;string&quot;)
   local regex_killer = {
      [&quot;+&quot;]  = &quot;%+&quot;, [&quot;-&quot;] = &quot;%-&quot;,
      [&quot;*&quot;]  = &quot;%*&quot;, [&quot;?&quot;]  = &quot;%?&quot; }

   for p in processwalker() do
      if p:find(process:gsub(&quot;[-+?*]&quot;, regex_killer)) then
	 return
      end
   end
   return awful.util.spawn(cmd or process)
end
-- }}}

-- Пример использования
run_once(&quot;firefox&quot;)
run_once(&quot;dropboxd&quot;)
-- Use the second argument, if the programm you wanna start, 
-- differs from the what you want to search.
run_once(&quot;redshift&quot;, &quot;nice -n19 redshift -l 51:14 -t 5700:4500&quot;)

&lt;/pre&gt;

== Способ X сервера ==

Еще одним способом проверить запущен ли процесс, является проверка наличия у него окна. Эта возоможность работает только для процессов подключенных к X server. Есть два недостатка у этого подхода. Первый, awesome не имеет списка всех приложений, только тех приложений, которые имеют постоянное окно. Если приложение не имеет окна (например приложения в трее), его не будет в списке awesome. Второй недостаток, заключается в том, что список приложений будет доступен только после полного старта awesome, т.е. во время инициализации, он не доступен.

Обойти первую проблему можно используя (как вариант) xwininfo. Вторую проблему можно решить используя таймер. Вот код:

&lt;pre&gt;
local xrun_now = function(name, cmd)
   -- Сначала получаем список приложения из awesome (которые доступны
   -- только  если awesome уже полностью запущен, поэтому, эта функция
   -- должна запускаться внутри 0 таймера)
   local squid = { name, name:sub(1,1):upper() .. name:sub(2) }
   if awful.client.cycle(
      function(c)
	 return awful.rules.match_any(c,
				      { name = squid,
					class = squid,
					instance = squid })
      end)() then
      return
   end

   -- Не найденно, проверяем с помощью xwininfo. Мы можем получить приложения имеющие имя,
   -- но мы не получим приложения без окон...
   if os.execute(&quot;xwininfo -name '&quot; .. name .. &quot;' &gt; /dev/null 2&gt; /dev/null&quot;) == 0 then
      return
   end
   awful.util.spawn_with_shell(cmd or name)
end

-- Выполняем команду, если еще не запушена.
xrun = function(name, cmd)
   -- Нам нужно дождаться когда awesome полностью запустится. Поэтому используем таймер.
   local stimer = timer { timeout = 0 }
   local run = function()
      stimer:stop()
      xrun_now(name, cmd)
   end
   stimer:add_signal(&quot;timeout&quot;, run)
   stimer:start()
end
&lt;/pre&gt;
Пример использования:

&lt;pre&gt;
xrun(&quot;chromium&quot;)
xrun(&quot;pidgin&quot;, &quot;pidgin -n&quot;)
&lt;/pre&gt;

Первый аргумента, это название программы (название окна, экземпляр объекта или класс. Второй аргумент, это команда запуска. Первый параметр используется как команда, если второй не определен.

== Способ использующий файлы X конфигурации ==

Этот скрипт устанавливает свойства XResource отображающее, что приложение уже запущено. Этот метод по моему мнению является самым надежным. XResources существует только в памяти, поэтому необходимость в очистке отсутсвует до тех пор пока существует Х сессия.

Этот код также перенаправляет вывод всех запущенных процессов dex во временный файл вместо ~/.xsession-errors.

&lt;pre&gt;
#!/bin/sh

PROP=autostart.wasrun
HASPROP=$(xrdb -query|grep $PROP)

if [ &quot;$HASPROP&quot; != &quot;&quot; ]
then
  exit 0;
fi

TEMPLATE=xsession-$USER-$PPID-XXX
TEMPFILE=$(mktemp --tmpdir $TEMPLATE)

echo &quot;logging to $TEMPFILE&quot;

echo &quot;$PROP: on&quot; | xrdb -merge

( $HOME/bin/dex -v -a 2&gt;&amp;1 1&gt;$TEMPFILE ) &amp;
&lt;/pre&gt;

У меня нет глубоких познаний в X resources, поэтому было бы неплохо, если бы кто нибудь проверил этот код.
Похожий способ используется для запуска в lua вместо оболочки:

&lt;pre&gt;
xrun = function(cmd, late)
    local xresources = awful.util.pread(&quot;xrdb -query&quot;)
    local myxr = xresources:match(&quot;^awesome%.xrun:%s+.-\n&quot;)
                 or xresources:match(&quot;\nawesome%.xrun:%s+.-\n&quot;)
                 or &quot;awesome.xrun:&quot;
    myxr = myxr:gsub(&quot;\n&quot;, &quot;&quot;)
    if not string.find(myxr, cmd, 1, true) then
        -- use pread so that this runs synchronously
        awful.util.pread(&quot;echo '&quot; .. myxr .. &quot; &quot; .. cmd:gsub(&quot;'&quot;, &quot;\\'&quot;) .. &quot;'|xrdb -merge&quot;)
        if late then
            local stimer = timer { timeout = late }
            local run = function()
                stimer:stop()
                awful.util.spawn(cmd, false)
            end
            stimer:connect_signal(&quot;timeout&quot;, run)
            stimer:start()
        else
            awful.util.spawn(cmd, false)
        end
    end
end
&lt;/pre&gt;

Или используйте более базовый метод для старта приложений при запуске.
&lt;pre&gt;
	
local xresources_name = &quot;awesome.started&quot;
local xresources = awful.util.pread(&quot;xrdb -query&quot;)
if not xresources:match(xresources_name) then
    -- Execute once for X server
    os.execute(&quot;dex -a -e Awesome&quot;)
end
awful.util.spawn_with_shell(&quot;xrdb -merge &lt;&lt;&lt; &quot; .. &quot;'&quot; .. xresources_name .. &quot;: true'&quot;)
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>1qs1lkgjq5l40ze509rpcgmfbkdmt9n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Autostart/zh</title>
    <ns>0</ns>
    <id>837</id>
    <revision>
      <id>5466</id>
      <parentid>5465</parentid>
      <timestamp>2012-05-08T09:17:38Z</timestamp>
      <contributor>
        <username>Nkiy</username>
        <id>984</id>
      </contributor>
      <text xml:space="preserve" bytes="10456">{{DISPLAYTITLE:自动启动}}
{{Languages|Autostart}}
Awesome不提供自动启动功能；也不理会freedesktop的autostart标准和''*.desktop''文件。你可以考虑如下几种方式。

== 传统方式 ==
在那些没或没有使用如GDM/KDM/XDM这样的登陆管理器的系统上使用'''xinit'''程序来启动X服务器和客户端程序。如果没有指定参数的话''xinit''会去寻找用户家目录下一个叫做'''.xinitrc'''的文件然后把它作为shell脚本执行。这个配置文件/脚本就用来启动客户端程序。

你可以在你的''~/.xinitrc''文件中运行任何程序但是要牢记将那些没有返回或退出的程序放到后台去执行，以免阻碍其他程序的启动。只有最后一个启动的程序，你的窗口管理器(当然就是awesome)，需要让它在前台运行从而使得脚本在你退出awesome之前不会退出，这样''xinit''就能够在脚本结束之后做一些清理工作。

如果你使用'''startx'''命令启动X服务器，不用担心这样对你有任何影响，''startx''命令仅仅是''xinit''的一个前端而已，你的''~/.xinitrc''文件会照常执行。示例''.xinitrc''文件相当简单：

  #!/bin/sh
  #
  # 用户 .xinitrc 文件
  
  # 合并自定义 X 资源
  xrdb -merge &quot;${HOME}/.Xresources&quot;
  
  # 后台播放启动音乐
  ogg123 -q &quot;${HOME}/.config/awesome/login.ogg&quot; &amp;
  
  # 后台启动一个终端模拟器
  urxvt -T Terminal &amp;
  
  # 启动窗口管理器
  exec awesome


这是一个比较复杂的''.xinitrc''可以作为很好的学习示例：http://git.sysphere.org/dotfiles/tree/xinitrc

'''注意：''' 如果你使用''ck-launch-session''启动awesome，你也许想要创建独立的启动脚本来启动awesome或者你可以使用另一种方式来启动程序--从rc.lua文件中。相关问题：https://bbs.archlinux.org/viewtopic.php?pid=1085191

如果你使用登陆管理器，大多数会希望你使用窗口管理器来自动启动应用程序；继续阅读以了解如何使用awesome来达到这一目的。还有一些读取.xprofile和.xsession文件。gdm，kdm，和lightdm都使用.xprofile文件。由于在窗口管理器之前运行所以无法启动GUI应用程序但是可以启动一些后台进程或者设置一些环境变量--这都是当你没有使用登陆管理器时在.xinitrc中所做的。

== Freedesktop自动启动方式 ==
正如本页第一句所说awesome并没有实现Freedesktop的启动应用程序的方式，但这并不对你使用它产生任何阻碍。

The '''dex''' program interprets *.desktop files in the locations specified by
Freedesktop autostart documentation. Just run it like this via one of the ways described above/below:
   /home/USER/bin/dex -a

For specifying which applications shall be started use
'''gnome-session-properties''' or similar programs from Gnome or KDE.

You should also be able to symlink autostart entries from /usr/share/applications into ~/.config/autostart.
Dex will then be able to find your user-specific autostart apps and run them. Verify with:
   dex -d -a

Dex can be downloaded here: http://github.com/jceb/dex

== Simple way ==

Just add lines to end of your ~/.config/awesome/rc.lua:

&lt;pre&gt;
awful.util.spawn_with_shell(&quot;COMMAND1&quot;)
awful.util.spawn_with_shell(&quot;COMMAND2&quot;)
&lt;/pre&gt;

...and so on

'''My Example:'''

&lt;pre&gt;
awful.util.spawn_with_shell(&quot;kdeinit&quot;)
awful.util.spawn_with_shell(&quot;lineakd&quot;)
awful.util.spawn_with_shell(&quot;anyremote -f ~/.anyRemote/amarok.cfg&quot;)
awful.util.spawn_with_shell(&quot;~/scripts/trm&quot;)
awful.util.spawn_with_shell(&quot;xchat&quot;)
awful.util.spawn_with_shell(&quot;psi&quot;)
awful.util.spawn_with_shell(&quot;firefox-bin&quot;)
awful.util.spawn_with_shell(&quot;gvim +Project&quot;)
awful.util.spawn_with_shell(&quot;kchmviewer&quot;)
awful.util.spawn_with_shell(&quot;amarok&quot;)
awful.util.spawn_with_shell(&quot;kmix&quot;)
awful.util.spawn_with_shell(&quot;kbluetoothd&quot;)
awful.util.spawn_with_shell(&quot;sudo killall mplayer&quot;)
&lt;/pre&gt;

If you want to run your apps only once and not every time awesome is restarted, create this simple script:

&lt;pre&gt;
#! /bin/bash

# Run program unless it's already running.

if [ -z &quot;`ps -Af | grep -o -w &quot;.*$1&quot; | grep -v grep | grep -v run-once`&quot; ]; then
  $@
fi
&lt;/pre&gt;
Or this:
&lt;pre&gt;
#!/bin/bash
#Alternative
pgrep $@ &gt; /dev/null || ($@ &amp;)
&lt;/pre&gt;

Save it as &quot;run_once&quot; somewhere in your $PATH and make it executable. Then autostart your apps like this:

&lt;pre&gt;awful.util.spawn_with_shell(&quot;run_once amarok&quot;)&lt;/pre&gt;

Alternatively you can use the following to avoid an external script (this also ignore commands running as other users than yourself):

&lt;pre&gt;
function run_once(cmd)
  findme = cmd
  firstspace = cmd:find(&quot; &quot;)
  if firstspace then
    findme = cmd:sub(0, firstspace-1)
  end
  awful.util.spawn_with_shell(&quot;pgrep -u $USER -x &quot; .. findme .. &quot; &gt; /dev/null || (&quot; .. cmd .. &quot;)&quot;)
end

run_once(&quot;amarok&quot;)
run_once(&quot;xscreensaver -no-splash&quot;)
&lt;/pre&gt;

Or this slightly more advanced version which permits to use command line options and to specify on which screen to launch your programs. It also allows for the case when the name of the process is different from the name of the command used to launch it (e.g. with wicd-client).

&lt;pre&gt;
function run_once(prg,arg_string,pname,screen)
    if not prg then
        do return nil end
    end

    if not pname then
       pname = prg
    end

    if not arg_string then 
        awful.util.spawn_with_shell(&quot;pgrep -f -u $USER -x '&quot; .. pname .. &quot;' || (&quot; .. prg .. &quot;)&quot;,screen)
    else
        awful.util.spawn_with_shell(&quot;pgrep -f -u $USER -x '&quot; .. pname .. &quot;' || (&quot; .. prg .. &quot; &quot; .. arg_string .. &quot;)&quot;,screen)
    end
end

run_once(&quot;xscreensaver&quot;,&quot;-no-splash&quot;)
run_once(&quot;pidgin&quot;,nil,nil,2)
run_once(&quot;wicd-client&quot;,nil,&quot;/usr/bin/python2 -O /usr/share/wicd/gtk/wicd-client.py&quot;)

&lt;/pre&gt;

== Directory way ==
&lt;pre&gt;
-- Autostart
function autostart(dir)
    if not dir then
        do return nil end
    end
    local fd = io.popen(&quot;ls -1 -F &quot; .. dir)
    if not fd then
        do return nil end
    end
    for file in fd:lines() do
        local c= string.sub(file,-1)   -- last char
        if c=='*' then  -- executables
            executable = string.sub( file, 1,-2 )
            print(&quot;Awesome Autostart: Executing: &quot; .. executable)
            awful.util.spawn_with_shell(dir .. &quot;/&quot; .. executable .. &quot;&quot;) -- launch in bg
        elseif c=='@' then  -- symbolic links
            print(&quot;Awesome Autostart: Not handling symbolic links: &quot; .. file)
        else
            print (&quot;Awesome Autostart: Skipping file &quot; .. file .. &quot; not executable.&quot;)
        end
    end
    io.close(fd)
end

autostart_dir = os.getenv(&quot;HOME&quot;) .. &quot;/.config/autostart&quot;
autostart(autostart_dir)
&lt;/pre&gt;

Be aware of the following drawbacks (and maybe fix them):
* the files in the autostart directory will be run everytime you re-parse the config file. If you re-parse the config file multiple times during a session this might cause strange behavior. If an application should only be run once, please handle this in the corresponding autostart script.
* The function currently ignores symlinks (I do not need them).

== PID way ==
Put this in runonce.lua
&lt;pre&gt;
-- @author Peter J. Kranz (Absurd-Mind, peter@myref.net)
-- Any questions, criticism or praise just drop me an email

local M = {}

-- get the current Pid of awesome
local function getCurrentPid()
    -- get awesome pid from pgrep
    local fpid = io.popen(&quot;pgrep -u &quot; .. os.getenv(&quot;USER&quot;) .. &quot; -o awesome&quot;)
    local pid = fpid:read(&quot;*n&quot;)
    fpid:close()

    -- sanity check
    if pid == nil then
        return -1
    end

    return pid
end

local function getOldPid(filename)
    -- open file
    local pidFile = io.open(filename)
    if pidFile == nil then
        return -1
    end

    -- read number
    local pid = pidFile:read(&quot;*n&quot;)
    pidFile:close()

    -- sanity check
    if pid &lt;= 0 then
        return -1
    end

    return pid;
end

local function writePid(filename, pid)
    local pidFile = io.open(filename, &quot;w+&quot;)
    pidFile:write(pid)
    pidFile:close()
end

local function shallExecute(oldPid, newPid)
    -- simple check if equivalent
    if oldPid == newPid then
        return false
    end

    return true
end

local function getPidFile()
    local host = io.lines(&quot;/proc/sys/kernel/hostname&quot;)()
    return awful.util.getdir(&quot;cache&quot;) .. &quot;/awesome.&quot; .. host .. &quot;.pid&quot;
end

-- run Once per real awesome start (config reload works)
-- does not cover &quot;pkill awesome &amp;&amp; awesome&quot;
function M.run(shellCommand)
    -- check and Execute
    if shallExecute(M.oldPid, M.currentPid) then
        awful.util.spawn_with_shell(shellCommand)
    end
end

M.pidFile = getPidFile()
M.oldPid = getOldPid(M.pidFile)
M.currentPid = getCurrentPid()
writePid(M.pidFile, M.currentPid)

return M
&lt;/pre&gt;

Use it this way:
&lt;pre&gt;
local r = require(&quot;runonce&quot;)

r.run(&quot;urxvtd -q -o -f&quot;)
r.run(&quot;urxvtc&quot;)
r.run(&quot;urxvtc&quot;)
r.run(&quot;wmname LG3D&quot;)
&lt;/pre&gt;

==The native lua way==
This solution doesn't depend on external tools, which speed up your startup.

To use this code snippet luafilesystem alias lfs is required.

It should be avaible for every system: debian (lua-filesystem), freebsd (ports/devel/luafilesystem/), gentoo (dev-lua/luafilesystem), ubuntu (liblua5.1-filesystem0), archlinux (luafilesystem)

@bsdguys: don't forget to mount procfs (:
&lt;pre&gt;
require(&quot;lfs&quot;) 
-- {{{ Run programm once
local function processwalker()
   local function yieldprocess()
      for dir in lfs.dir(&quot;/proc&quot;) do
        -- All directories in /proc containing a number, represent a process
        if tonumber(dir) ~= nil then
          local f, err = io.open(&quot;/proc/&quot;..dir..&quot;/cmdline&quot;)
          if f then
            local cmdline = f:read(&quot;*all&quot;)
            f:close()
            if cmdline ~= &quot;&quot; then
              coroutine.yield(cmdline)
            end
          end
        end
      end
    end
    return coroutine.wrap(yieldprocess)
end

local function run_once(process, cmd)
   assert(type(process) == &quot;string&quot;)
   local regex_killer = {
      [&quot;+&quot;]  = &quot;%+&quot;, [&quot;-&quot;] = &quot;%-&quot;,
      [&quot;*&quot;]  = &quot;%*&quot;, [&quot;?&quot;]  = &quot;%?&quot; }

   for p in processwalker() do
      if p:find(process:gsub(&quot;[-+?*]&quot;, regex_killer)) then
	 return
      end
   end
   return awful.util.spawn(cmd or process)
end
-- }}}

-- Usage Example
run_once(&quot;firefox&quot;)
run_once(&quot;dropboxd&quot;)
-- Use the second argument, if the programm you wanna start, 
-- differs from the what you want to search.
run_once(&quot;redshift&quot;, &quot;nice -n19 redshift -l 51:14 -t 5700:4500&quot;)

&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>1j8zotavwzokoocdk3c2qxcbpbj1xyl</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Autostart with consolekit</title>
    <ns>0</ns>
    <id>851</id>
    <revision>
      <id>6623</id>
      <parentid>5536</parentid>
      <timestamp>2014-05-23T12:25:27Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="5722">{{Languages}}

If you want to use the awesome menu to let your computer restart/shutdown/hibernate/suspend, You should do this:

gentoo:

* You MUST emerge with use +polkit +pam :

&lt;pre&gt;
➜  ~ git:(master) ✗ epv dbus dbus-glib pambase shadow  upower polkit awesome consolekit
zsh: correct 'dbus' to '.dbus' [nyae]? n


These are the packages that would be merged, in order:

Calculating dependencies... done!
[ebuild   R    ] sys-apps/dbus-1.4.20  USE=&quot;X -debug -doc (-selinux) -static-libs -test&quot; 0 kB
[ebuild   R    ] dev-libs/dbus-glib-0.98  USE=&quot;-debug -doc -static-libs -test&quot; 0 kB
[ebuild   R    ] x11-wm/awesome-3.4.11  USE=&quot;dbus -doc&quot; 0 kB
[ebuild   R    ] sys-auth/polkit-0.104-r1  USE=&quot;gtk introspection nls pam -debug -doc -examples -kde (-selinux) (-systemd)&quot; 0 kB
[ebuild   R    ] sys-auth/consolekit-0.4.5_p20120320  USE=&quot;acl pam policykit -debug -doc (-selinux) -test&quot; 0 kB
[ebuild   R    ] sys-power/upower-0.9.16  USE=&quot;introspection -debug -doc -ios&quot; 0 kB
[ebuild   R    ] sys-auth/pambase-20101024-r2  USE=&quot;consolekit cracklib sha512 -debug -gnome-keyring -minimal -mktemp -pam_krb5 -pam_ssh -passwdqc (-selinux)&quot; 0 kB
[ebuild   R    ] sys-apps/shadow-4.1.4.3  USE=&quot;cracklib nls pam -audit (-selinux) -skey&quot; 1,762 kB

Total: 8 packages (8 reinstalls), Size of downloads: 1,762 kB
&lt;/pre&gt;

* kernel MUST enable:

&lt;pre&gt;
➜  ~ git:(master) ✗  grep audit -i  /usr/src/linux/.config  
CONFIG_AUDIT_ARCH=y
CONFIG_AUDIT=y
CONFIG_AUDITSYSCALL=y
CONFIG_AUDIT_WATCH=y
CONFIG_AUDIT_TREE=y
&lt;/pre&gt;

* .xinitrc MUST have:

&lt;pre&gt;
exec ck-launch-session dbus-launch --sh-syntax --exit-with-session awesome &gt;&gt; ~/.awesome_stdout 2&gt;&gt; ~/.awesome_stderr
&lt;/pre&gt;

* dbus, consolekit MUST start:

&lt;pre&gt;
➜  ~ git:(master) ✗ rc-update
                  
           consolekit |      default                   
                 dbus |      default                 
&lt;/pre&gt;

* following the ARCH bash style do the auto login, here is my zsh config:

&lt;pre&gt;
➜  ~ git:(master) ✗ cat /etc/inittab 
#
# /etc/inittab:  This file describes how the INIT process should set up
#                the system in a certain run-level.
#
# Author:  Miquel van Smoorenburg, &lt;miquels@cistron.nl&gt;
# Modified by:  Patrick J. Volkerding, &lt;volkerdi@ftp.cdrom.com&gt;
# Modified by:  Daniel Robbins, &lt;drobbins@gentoo.org&gt;
# Modified by:  Martin Schlemmer, &lt;azarah@gentoo.org&gt;
# Modified by:  Mike Frysinger, &lt;vapier@gentoo.org&gt;
# Modified by:  Robin H. Johnson, &lt;robbat2@gentoo.org&gt;
#
# $Header: /var/cvsroot/gentoo-x86/sys-apps/sysvinit/files/inittab-2.87,v 1.1 2010/01/08 16:55:07 williamh Exp $

# Default runlevel.
id:3:initdefault:

# System initialization, mount local filesystems, etc.
si::sysinit:/sbin/rc sysinit

# Further system initialization, brings up the boot runlevel.
rc::bootwait:/sbin/rc boot

l0:0:wait:/sbin/rc shutdown 
l0s:0:wait:/sbin/halt -dhp
l1:1:wait:/sbin/rc single
l2:2:wait:/sbin/rc nonetwork
l3:3:wait:/sbin/rc default
l4:4:wait:/sbin/rc default
l5:5:wait:/sbin/rc default
l6:6:wait:/sbin/rc reboot
l6r:6:wait:/sbin/reboot -dk
#z6:6:respawn:/sbin/sulogin

# new-style single-user
su0:S:wait:/sbin/rc single
su1:S:wait:/sbin/sulogin

# TERMINALS
#c1:12345:respawn:/sbin/agetty 38400 tty1 linux
c1:5:respawn:/sbin/agetty  -a jinleileiking -8 -s 38400 tty1 linux
c2:2345:respawn:/sbin/agetty 38400 tty2 linux
c3:2345:respawn:/sbin/agetty 38400 tty3 linux
c4:2345:respawn:/sbin/agetty 38400 tty4 linux
c5:2345:respawn:/sbin/agetty 38400 tty5 linux
c6:2345:respawn:/sbin/agetty 38400 tty6 linux

# SERIAL CONSOLES
#s0:12345:respawn:/sbin/agetty 9600 ttyS0 vt100
#s1:12345:respawn:/sbin/agetty 9600 ttyS1 vt100

# What to do at the &quot;Three Finger Salute&quot;.
ca:12345:ctrlaltdel:/sbin/shutdown -r now

# Used by /etc/init.d/xdm to control DM startup.
# Read the comments in /etc/init.d/xdm for more
# info. Do NOT remove, as this will start nothing
# extra at boot if /etc/init.d/xdm is not added
# to the &quot;default&quot; runlevel.
x:a:once:/etc/X11/startDM.sh



➜  ~ git:(master) ✗ cat .zprofile

# New environment setting added by Sourcery CodeBench Lite for ARM EABI on Thu Jul 05 17:04:19 CST 2012 1.
# The unmodified version of this file is saved in /home/jinleileiking/.zprofile2131715756.
# Do NOT modify these lines; they are used to uninstall.
PATH=&quot;/home/jinleileiking/crosstools/CodeSourcery/Sourcery_CodeBench_Lite_for_ARM_EABI/bin:${PATH}&quot;
export PATH
# End comments by InstallAnywhere on Thu Jul 05 17:04:19 CST 2012 1.


if [[ -z $DISPLAY ]] &amp;&amp; [[ $(tty) = /dev/tty1 ]]; then
  #exec startx -- vt01
  exec startx 
  # Could use xinit instead of startx
  #exec xinit -- /usr/bin/X -nolisten tcp vt7
fi
&lt;/pre&gt;

* Modify your rc.lua:

&lt;pre&gt;
local upower = [[dbus-send --print-reply \
--system \
--dest=org.freedesktop.UPower \
/org/freedesktop/UPower \
org.freedesktop.UPower.]]
local consolkit = [[dbus-send --print-reply \
--system \
--dest=&quot;org.freedesktop.ConsoleKit&quot; \
/org/freedesktop/ConsoleKit/Manager \
org.freedesktop.ConsoleKit.Manager.]]

mymainmenu = awful.menu({ items = { { &quot;awesome&quot;, myawesomemenu, beautiful.awesome_icon },
                                    { &quot;terminal&quot;, terminal },
                                    { &quot;chromium&quot;, shell_cmd .. &quot;chromium&quot;},
                                    { &quot;lock&quot;, &quot;slock&quot; },
                                    { &quot;Suspend&quot;, function() awful.util.spawn(upower..&quot;Suspend&quot;) end },
                                    { &quot;Hibernate&quot;, function () awful.util.spawn(upower..&quot;Hibernate&quot;) end },
                                    { &quot;Restart&quot;, consolkit..&quot;Restart&quot;, icon_path..&quot;restart.png&quot; },
                                    { &quot;Shutdown&quot;, consolkit..&quot;Stop&quot;, icon_path..&quot;poweroff.png&quot; },
                                  }
                        })
&lt;/pre&gt;</text>
      <sha1>l59b2j4ewhbqyhnqc84mz5sv69iyior</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Autostop</title>
    <ns>0</ns>
    <id>612</id>
    <revision>
      <id>7058</id>
      <parentid>7057</parentid>
      <timestamp>2014-10-19T19:09:02Z</timestamp>
      <contributor>
        <username>Awaxx</username>
        <id>3762</id>
      </contributor>
      <comment>/* Another way */</comment>
      <text xml:space="preserve" bytes="2611">{{Languages|Autostop}}

There is no hook to execute a lua function at exit; but it is possible to connect a function as 'exit' signal handler.

The exit signal is not only called on real exit, but naturally on restart as well - so this is without additional logic not as practicable as it sounds.

But it's worth experimenting with.

== DBus 'exit' signal handler ==

Add the following line to your rc.lua

  awesome.add_signal(&quot;exit&quot;, function() awful.util.spawn(&quot;atexit.sh&quot;) end)

If you're using Archlinux, you should try the following line instead.
  awesome.connect_signal(&quot;exit&quot;, function () awful.util.spawn(&quot;atexit.sh&quot;) end)

This will execute 'atexit.sh', if such an executable is found in your path. Of course you can do everything in the lua function itself, or spawn another program.
Use your imagination :-).

I use this to stop all the daemons/services I start via dex as described in [[Autostart]].

Tested with awesome 3.4.8

== Alternative: Replace the Quit command ==

I was experimenting with the DBus solution above and I ran into one small issue,  It would exit too fast to complete the scripts I wished to run.

However I found a potential solution.  I changed one line in my rc.lua from:
     awful.key({ modkey, &quot;Shift&quot; }, &quot;q&quot; awesome.quit),
to:
     awful.key({ modkey, &quot;Shift&quot; }, &quot;q&quot;, function awful.util.spawn(&quot;konsole -e bb.sh&quot;) end),

Then in bb.sh, I ran what I wished and then exited awesome like so:
     #!/bin/bash
     bleachbit --delete --overwrite adobe_reader.cache adobe_reader.mru adobe_reader.tmp bash.history elinks.history firefox.cache firefox.cookies firefox.dom firefox.download_history firefox.forms firefox.session_restore firefox.site_preferences firefox.url_history firefox.vacuum flash.cache flash.cookies kde.cache kde.recent_documents kde.tmp konqueror.cookies konqueror.current_session konqueror.url_history links2.history nautilus.history realplayer.cookies realplayer.history realplayer.logs skype.chat_logs system.cache system.clipboard system.desktop_entry system.recent_documents system.tmp system.trash thumbnails.cache vim.history
     echo ; echo
     sudo bleachbit --delete --overwrite apt.autoclean apt.autoremove apt.clean system.localizations system.rotated_logs system.tmp system.trash x11.debug_logs
     # exit awesome
     echo 'awesome.quit()' | awesome-client
     # exit script
     exit 0

So far, it works and it even pauses for me to enter the sudo password.  

Another advantage is that it does not run the script if I trigger a restart, but rather only when I intend to quit and exit.

Tested with Awesome 3.4.10 on Debian -- lowkey</text>
      <sha1>abrmhc19ucdtaao9z0apkeq762sty49</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Autostop/ru</title>
    <ns>0</ns>
    <id>1035</id>
    <revision>
      <id>6436</id>
      <parentid>6435</parentid>
      <timestamp>2014-05-03T09:54:06Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Обработчик сигнал 'exit' DBus */</comment>
      <text xml:space="preserve" bytes="3859">{{DISPLAYTITLE:Запуск приложений при завершении awesome}}
{{Languages|Autostop}}

К сожалению не существует никакого hook для выполнения функций lua при выходе; но возможно создать функцию обработчик сигнала 'exit'.

Сигнал выхода вызывается не только при выходе, но также и при перезапуске - поэтому без использвания дополнительной логики использовать этот сигнал безсмыслено. Но для этого нужно экспериментировать.

== Обработчик сигнала 'exit' DBus ==

Добавьте следующие строки в rc.lua

  awesome.add_signal(&quot;exit&quot;, function() awful.util.spawn(&quot;atexit.sh&quot;) end)

Если вы используете Archlinux, вам необходимо использовать следующий код.
  awesome.connect_signal(&quot;exit&quot;, function () awful.util.spawn(&quot;atexit.sh&quot;) end)

Этот код запустит 'atexit.sh'. Конечно, вы можете сделать то же самое используя встроенные функции lua, или запустить другую программу.
Используйте свое воображение :-).

Я использую этот вариант для завершения демонов/сервисов, которые я запустил используя dex описанные в [[Autostart/ru]].

Проверено в awesome 3.4.8

== Альтернатива: Замена команды Quit ==

При эксперементах с решением на DBus описанным выше, я столкнулся с небольшой проблемой. Выход происходил очень быстро, для запуска и выполнения скрипта.

Поэтому я использовал альтернативный метод. Я изменил строки в моем rc.lua с:
     awful.key({ modkey, &quot;Shift&quot; }, &quot;q&quot; awesome.quit),
на:
     awful.key({ modkey, &quot;Shift&quot; }, &quot;q&quot;, function awful.util.spawn(&quot;konsole -e bb.sh&quot;) end),

Затем в bb.sh, в нем я запускал, то что мне нужно, а затем завершал awesome следующим образом:
     #!/bin/bash
     bleachbit --delete --overwrite adobe_reader.cache adobe_reader.mru adobe_reader.tmp bash.history elinks.history firefox.cache firefox.cookies firefox.dom firefox.download_history firefox.forms firefox.session_restore firefox.site_preferences firefox.url_history firefox.vacuum flash.cache flash.cookies kde.cache kde.recent_documents kde.tmp konqueror.cookies konqueror.current_session konqueror.url_history links2.history nautilus.history realplayer.cookies realplayer.history realplayer.logs skype.chat_logs system.cache system.clipboard system.desktop_entry system.recent_documents system.tmp system.trash thumbnails.cache vim.history
     echo ; echo
     sudo bleachbit --delete --overwrite apt.autoclean apt.autoremove apt.clean system.localizations system.rotated_logs system.tmp system.trash x11.debug_logs
     # exit awesome
     echo 'awesome.quit()' | awesome-client
     # exit script
     exit 0

Таким образом, все работает, и даже дает время для ввода пароля пользователя sudo.  

Еще одним преимуществом является, то, что скрипт не запускается когда я перезагружаюсь, а только когда я завершаю awesome или выхожу из системы.

Проверено в Awesome 3.4.10 на Debian

[[Category:Awesome3]]</text>
      <sha1>7bp1bjl1h6l7tv8yiayb5qpqp1blsop</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-Gentoo-Paludis</title>
    <ns>0</ns>
    <id>126</id>
    <revision>
      <id>3245</id>
      <parentid>1236</parentid>
      <timestamp>2009-06-30T13:50:58Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="714">{{Languages}}

Add the following repository to /etc/paludis/repositories into a [http://paludis.pioto.org/configuration/repositories.html .conf]
 git://gitorious.org/thewtex-repo/mainline.git

There are some awesome-3 ebuilds that can be now found in the gentoo portage repository, but they are masked, which will affect these ebuilds too.  Therefore, you will need to put ''x11-wm/awesome'' in your /etc/paludis/package_unmask.conf.

Keyword ''x11-wm/awesome'' in /etc/paludis/keywords.conf with ''~amd64'' or ''~x86'' if you want the latest release or ''*'' if you want the latest git -scm build.

 paludis --install --pretend awesome

Keyword like a gangster.

 paludis --install awesome


[[Category:Awesome3]]</text>
      <sha1>78l70glw3fyenwz0e83oyrkgtilgtgz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-Gentoo-Paludis/fr</title>
    <ns>0</ns>
    <id>435</id>
    <revision>
      <id>3354</id>
      <parentid>3246</parentid>
      <timestamp>2009-07-15T19:02:59Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>DISPLAYTITLE instead of template title</comment>
      <text xml:space="preserve" bytes="812">{{DISPLAYTITLE:awesome 3 sur Gentoo}}
{{Languages|Awesome-3-Gentoo-Paludis}}

Ajoutez le dépôt suivant à '''/etc/paludis/repositories''' dans un [http://paludis.pioto.org/configuration/repositories.html fichier '''.conf'''] :
 git://gitorious.org/thewtex-repo/mainline.git

On peut maintenant trouver quelques ebuilds d’awesome 3 sur le dépôt de portage de Gentoo, mais ils sont masqués. Il vous faudra donc ajouter « x11-wm/awesome » dans votre fichier '''/etc/paludis/package_unmask.conf'''.

Mettez un mot-clé « x11-wm/awesome » dans '''/etc/paludis/keywords.conf''', avec « ~amd64 » ou « ~x86 » si vous voulez la dernière version, out « * » si vous voulez la dernière compilation du git :
 paludis --install --pretend awesome
 paludis --install awesome

[[Category:Awesome3]]</text>
      <sha1>dog36idnbkx908y69bz5scemda0hgey</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-Gentoo-Portage</title>
    <ns>0</ns>
    <id>585</id>
    <revision>
      <id>4464</id>
      <parentid>4463</parentid>
      <timestamp>2010-09-03T20:44:43Z</timestamp>
      <contributor>
        <username>Cayenne</username>
        <id>516</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="657">If you would prefer the more recent and less tested version:

 # echo x11-wm/awesome &gt;&gt; /etc/portage/package.keywords

Or if you want to install a specific unstable version but don't want to automatically update to newer unstable versions (replace 3.4.6 with the version you want; see available versions at the [http://packages.gentoo.org/package/x11-wm/awesome gentoo package site].)

 # echo &quot;=x11-wm/awesome-3.4.6&quot; &gt;&gt; /etc/portage/package.keywords&quot;

If you want awesome-client to work and don't have the dbus use flag in /etc/make.conf:

 # echo &quot;x11-wm/awesome dbus&quot; &gt;&gt; /etc/portage/package.use

Then emerge:

 # emerge -a awesome

[[Category:Awesome3]]</text>
      <sha1>ab557b9lrdi1qtognu2w4o0i0ouhdb2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-Mandriva-Cooker</title>
    <ns>0</ns>
    <id>357</id>
    <revision>
      <id>3236</id>
      <parentid>2832</parentid>
      <timestamp>2009-06-30T13:29:08Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="607">{{Languages}}

To get Awesome3 working on a Mandriva Cooker, you just need two things :
* cairo recompiled with --enable-xcb
* awesome 3.3

Every other dependency is on the mirrors, I assume you defined yours correctly.

RPMs for both of the previous items are available here :
* http://kenobi.mandriva.com/~shikamaru/cairo-xcb/
* http://kenobi.mandriva.com/~shikamaru/awesome/

To replace cairo if it's already installed you can do rpm -e --nodeps libcairo2 (lib64cairo2 if you're on x86_64).

I also suggest you to put /cairo/ in your /etc/urpmi/skip.list so that it does not get overwritten by an update.</text>
      <sha1>bvmgd33rup7zkq7ncus9zyzy0x9y5hn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-Mandriva-Cooker/fr</title>
    <ns>0</ns>
    <id>433</id>
    <revision>
      <id>3361</id>
      <parentid>3237</parentid>
      <timestamp>2009-07-15T19:08:21Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>DISPLAYTITLE instead of Template:Title</comment>
      <text xml:space="preserve" bytes="889">{{DISPLAYTITLE:awesome 3.3 sur Mandriva Cooker}}
{{Languages|Awesome-3-Mandriva-Cooker}}

Pour avoir awesome 3 sur Mandriva Cooker, vous n’avez qu’à recompiler Cairo avec l’argument ''--enable-xcb'' et à installer awesome 3.3.

En supposant que vos miroirs sont correctement configurés, vous aurez les dépendances nécessaires pour installer les '''.rpm''' des deux éléments cités ci-dessus :
* http://kenobi.mandriva.com/~shikamaru/cairo-xcb/
* http://kenobi.mandriva.com/~shikamaru/awesome/

Si Cairo est déjà installé sur votre système, vous pouvez exécuter :
 rpm -e --nodeps libcairo2
en remplaçant « libcaro2 » par « lib64cairo2 » si vous êtes sur une architecture x86_64.

Il est également mieux de mettre ''/cairo/'' dans votre fichier '''/etc/urpmi/skip.list''' pour que cette version de Cairo ne soit pas écrasée par une éventuelle mise à jour.</text>
      <sha1>qfqa951pwx0lsr0ifreqzy6xtugedmo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-RHEL5</title>
    <ns>0</ns>
    <id>613</id>
    <revision>
      <id>5773</id>
      <parentid>5772</parentid>
      <timestamp>2013-01-29T07:55:16Z</timestamp>
      <contributor>
        <username>Emaadmanzoor</username>
        <id>2746</id>
      </contributor>
      <comment>Added link to obtain CMake for RHEL5</comment>
      <text xml:space="preserve" bytes="4675">Building Awesome 3 on Red Hat Enterprise Linux 5 is a lot of work: almost the entire X client library has to be rebuilt to get the new and shiny features that Awesome wants.  This script does the job (for the specific versions of each component listed), and builds everything in a local prefix, assuming that you don't have root access.


  #!/bin/bash
  
  # Building awesome.
  #
  # References:
  #   http://awesome.naquadah.org/wiki/Awesome-3-RHEL6
  #       Build instructions for RHEL6; not quite complete for RHEL5!
  #
  #   http://www.freedesktop.org/wiki/Software
  
  PREFIX=&quot;$(cd &quot;$(dirname &quot;$0&quot;)&quot;; pwd)&quot;
  
  extract_cd()
  {
      cd &quot;$PREFIX/src&quot;  &amp;&amp;
      case &quot;$1&quot; in
      *.tar.gz)   app_name=&quot;${1%.tar.gz}&quot;;    x=x ;;
      *.tar.bz2)  app_name=&quot;${1%.tar.bz2}&quot;;   x=j ;;
      $)          echo &gt;&amp;2 Whoops ;;
      esac  &amp;&amp;
      tar x${x}f &quot;$PREFIX/tars/$1&quot;  &amp;&amp;
      cd &quot;$app_name&quot;
  }
  
  install_pc()
  {
      sed &quot;/^prefix[ \t]*=/s:=.*$:=$PREFIX:&quot; \
          &lt;&quot;$1&quot; &gt;&quot;$PKG_CONFIG_PATH/$2&quot;
  }
  
  configure_build()
  {
      ./configure --prefix=&quot;$PREFIX&quot; $1  &amp;&amp;
      make  &amp;&amp;
      make install
  }
  
  build()
  {
      extract_cd &quot;$1&quot;  &amp;&amp;
      configure_build $2
  }
  
  build_lua()
  {
      extract_cd &quot;$1&quot;  &amp;&amp;
      patch -p1 &lt;&quot;$PREFIX/tars/lua.patch&quot;  &amp;&amp;
      make linux  &amp;&amp;
      make install INSTALL_TOP=&quot;$PREFIX&quot;  &amp;&amp;
      install_pc etc/lua.pc lua5.1.pc
  }
  
  build_awesome()
  {
      extract_cd &quot;$1&quot;  &amp;&amp;
      mkdir .build  &amp;&amp;
      cd .build  &amp;&amp;
      cmake -DCMAKE_INSTALL_PREFIX=&quot;$PREFIX&quot; . ..  &amp;&amp;
      make  &amp;&amp;
      make install
  }
  
  
  export PKG_CONFIG_PATH=&quot;$PREFIX/lib/pkgconfig&quot;  &amp;&amp;
  mkdir -p &quot;$PKG_CONFIG_PATH&quot; &quot;$PREFIX/src&quot;  &amp;&amp;
  PATH=&quot;$PREFIX/bin:$PATH&quot;  &amp;&amp;
  
  build gperf-3.0.4.tar.gz  &amp;&amp;
  build imlib2-1.4.4.tar.gz  &amp;&amp;
  build libev-4.01.tar.gz  &amp;&amp;
  install_pc &quot;$PREFIX/tars/ev.pc&quot; ev.pc  &amp;&amp;
  build libpthread-stubs-0.3.tar.gz  &amp;&amp;
  build xproto-7.0.20.tar.gz  &amp;&amp;
  build xcb-proto-1.6.tar.gz  &amp;&amp;
  build libxcb-1.7.tar.gz  &amp;&amp;
  build xcb-util-0.3.6.tar.gz  &amp;&amp;
  build libxdg-basedir-1.1.1.tar.gz  &amp;&amp;
  build pixman-0.21.2.tar.gz  &amp;&amp;
  build startup-notification-0.10.tar.gz  &amp;&amp;
  
  build freetype-2.4.4.tar.gz  &amp;&amp;
  build fontconfig-2.8.0.tar.gz  &amp;&amp;
  build gettext-0.18.1.1.tar.gz  &amp;&amp;
  build glib-2.26.1.tar.gz  &amp;&amp;
  build cairo-1.8.10.tar.gz --enable-xcb  &amp;&amp;
  build pango-1.28.3.tar.gz  &amp;&amp;
  
  build_lua lua-5.1.4.tar.gz  &amp;&amp;
  
  build_awesome awesome-3.4.8.tar.bz2


This script should be placed in the prefix directory, and all the source tar files placed in a tars subdirectory. Running this script requires CMake 2.8.x (the default on RHEL5 is 2.6.x) to compile awesome-3.8.4, without which it will fail with the following message:

  CMake Error at CMakeLists.txt:284 (file):
    file does not recognize sub-command COPY

You can obtain a CMake RPM for your RHEL from here: [http://pkgs.repoforge.org/cmake/ CMake on RepoForge]

In this same directory place the following two patch files:

tars/ev.pc:

  prefix=/scratch/awesome
  exec_prefix=${prefix}
  libdir=${exec_prefix}/lib
  includedir=${prefix}/include
  
  Name: ve
  Description: Event loop library
  Version: 4.01
  Libs: -L${libdir} -lev
  Cflags: -I${includedir}
  
tars/lua.patch:

  diff -ur lua-5.1.4/Makefile lua-5.1.4-patched/Makefile
  --- lua-5.1.4/Makefile	2008-08-12 01:40:48.000000000 +0100
  +++ lua-5.1.4-patched/Makefile	2010-12-10 17:23:46.000000000 +0000
  @@ -43,7 +43,7 @@
   # What to install.
   TO_BIN= lua luac
   TO_INC= lua.h luaconf.h lualib.h lauxlib.h ../etc/lua.hpp
  -TO_LIB= liblua.a
  +TO_LIB= liblua.a liblua.so
   TO_MAN= lua.1 luac.1
   
   # Lua version and release.
  diff -ur lua-5.1.4/src/Makefile lua-5.1.4-patched/src/Makefile
  --- lua-5.1.4/src/Makefile	2008-01-19 19:37:58.000000000 +0000
  +++ lua-5.1.4-patched/src/Makefile	2010-12-10 17:32:04.000000000 +0000
  @@ -8,7 +8,7 @@
   PLAT= none
   
   CC= gcc
  -CFLAGS= -O2 -Wall $(MYCFLAGS)
  +CFLAGS= -O2 -Wall $(MYCFLAGS) -fPIC
   AR= ar rcu
   RANLIB= ranlib
   RM= rm -f
  @@ -28,6 +28,7 @@
   	lundump.o lvm.o lzio.o
   LIB_O=	lauxlib.o lbaselib.o ldblib.o liolib.o lmathlib.o loslib.o ltablib.o \
   	lstrlib.o loadlib.o linit.o
  +LUA_SO = liblua.so
   
   LUA_T=	lua
   LUA_O=	lua.o
  @@ -36,7 +37,7 @@
   LUAC_O=	luac.o print.o
   
   ALL_O= $(CORE_O) $(LIB_O) $(LUA_O) $(LUAC_O)
  -ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T)
  +ALL_T= $(LUA_A) $(LUA_T) $(LUAC_T) $(LUA_SO)
   ALL_A= $(LUA_A)
   
   default: $(PLAT)
  @@ -57,6 +58,9 @@
   $(LUAC_T): $(LUAC_O) $(LUA_A)
   	$(CC) -o $@ $(MYLDFLAGS) $(LUAC_O) $(LUA_A) $(LIBS)
   
  +$(LUA_SO): $(CORE_O) $(LIB_O)
  +	$(CC) -o $@ -shared $?
  +
   clean:
   	$(RM) $(ALL_T) $(ALL_O)</text>
      <sha1>kwltgrjx35l5qgo0yqqxx4jrvzrbv0q</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-RHEL6</title>
    <ns>0</ns>
    <id>558</id>
    <revision>
      <id>7423</id>
      <parentid>4290</parentid>
      <timestamp>2016-01-26T03:15:13Z</timestamp>
      <contributor>
        <username>Divyekapoor</username>
        <id>4312</id>
      </contributor>
      <minor/>
      <comment>/* Prerequisite */</comment>
      <text xml:space="preserve" bytes="2827">Steps to build and install Awesome 3 on RHEL6 Beta

== Prerequisite ==

* Install ''Development tools'' and ''Desktop Platform Development''.

  yum groupinstall -y 'Development tools' 'Desktop Platform Development'

* Install ''ImageMagick'', ''startup-notification'' and ''readline''.

  yum install -y ImageMagick startup-notification startup-notification-devel readline readline-devel

* Set PKG_CONFIG_PATH to include ''/usr/local/lib/pkgconfig/''. Note, if you open a new terminal/session, don't forget to set this variable.

  export PKG_CONFIG_PATH=&quot;/usr/local/lib/pkgconfig/&quot;

* Get [http://www.cmake.org/ cmake], build and install it. ''Tested with version 2.8.1''.

  ./bootstrap &amp;&amp; make &amp;&amp; make install

* Get [http://www.gnu.org/software/gperf/ gperf], build and install it. ''Tested with version 3.0.4''.

  ./configure &amp;&amp; make &amp;&amp; make install

* Get [http://sourceforge.net/projects/enlightenment/files/imlib2-src imlib2], build and install it. ''Tested with version 1.4.4''.

  ./configure &amp;&amp; make &amp;&amp; make install

* Get [http://software.schmorp.de/pkg/libev.html libev], build and install it. ''Tested with version 3.9''.

  ./configure &amp;&amp; make &amp;&amp; make install

* Get [http://xcb.freedesktop.org/dist/ libpthread-stubs xcb-proto libxcb xcb-util xcb-util-renderutil xcb-util-image xcb-util-cursor], build and install in this order. ''Tested with version 0.3 of libpthread-stubs, 1.6 of libxcb, 1.6 of xcb-proto, 0.3.6 of xcb-util, 0.3.9 of xcb-util-renderutil, 0.4.0 of xcb-util-image and 0.1.2 of xcb-util-cursor''.
* For all

  ./configure &amp;&amp; make &amp;&amp; make install

* Get [http://n.ethz.ch/~nevillm/download/libxdg-basedir/ libxdg-basedir], build and install it. ''Tested with version 1.1.0''.

  ./configure &amp;&amp; make &amp;&amp; make install

* Get [http://www.lua.org/ Lua], build and install it. ''Tested with version 5.1.4''.

  make linux &amp;&amp; make install

* Get [http://cairographics.org/ Cairo], build and install it. ''Tested with version 1.8.10''.

  ./configure --enable-xcb &amp;&amp; make &amp;&amp; make install

== Awesome ==

* Get [http://awesome.naquadah.org/download/ Awesome], build and install it. ''Tested with version 3.4.5''.

  make &amp;&amp; make install

== After Installation ==

* Awesome is installed in ''/usr/local/''.
* You need a configuration file for awesome in your home (''~/.config/awesome/rc.lua''). The default is in ''/usr/local/etc/xdg/awesome/''.
* To run Awesome you have to add ''/usr/local/lib'' to ''/etc/ld.so.conf'' and run ''ldconfig'', otherwise Awesome is not able to find some libraries.

== Notes ==

* Documentation of Awesome isn't available. To build you need ''xmlto'', ''asciidoc'' and ''luadoc''.
* I tried to rebuild cairo with xcb enabled from SRC-RPM, but no luck I got a error about missing xcb. Furthermore a update of the cairo package from Red Hat will break the awesome build.</text>
      <sha1>s7j91x3mj1eez3u4cg10445kolaldw0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-Slackware</title>
    <ns>0</ns>
    <id>264</id>
    <revision>
      <id>4141</id>
      <parentid>4130</parentid>
      <timestamp>2010-03-14T20:31:30Z</timestamp>
      <contributor>
        <username>Reti</username>
        <id>435</id>
      </contributor>
      <text xml:space="preserve" bytes="2300">To build Awesome 3 on Slackware, you have to recompile Cairo because the version that ships with Slackware does not include xcb support. You also have to install Lua, Imlib2, xcb-util and libev. Let's see how to do this step by step, under Slackware 13:

== CMake == 

I had to upgrade to 2.8 to make it work. If you need to upgrade, download the source, slackbuild, run it and then upgrade the package with upgradepkg command. 

== Cairo ==
Apply this [http://bitbucket.org/jfsantos/slackbuilds/raw/874117ed359d/cairo.SlackBuild.patch patch] to the Slackware's default cairo.SlackBuild (if you do not have the sources disc, retrieve this from a Slackware mirror). After applying this patch and recompiling the package, Cairo will have xcb support. In fact, this patch just adds the flag --enable-xcb when running configure.

== Lua and imlib2 ==
Install Lua and Imlib2 with the [http://www.slackbuilds.org SlackBuilds.org] SlackBuilds: [http://slackbuilds.org/repository/13.0/development/lua/ SlackBuild for Lua], [http://slackbuilds.org/repository/13.0/libraries/imlib2/ SlackBuild for Imlib2].

== xcb-util and libev ==
I made SlackBuilds for these packages. Check my SlackBuilds [http://bitbucket.org/jfsantos/slackbuilds/ repository]. You can get a copy of all my SlackBuilds with this command: &quot;hg clone http://www.bitbucket.org/jfsantos/slackbuilds/&quot;. By the way, this repository includes the patch for Cairo, too.

== xcb, libstartup-notification, libxdg ==
In order to compile version 3.4.4 you need to upgrade these packages as well. For the first two, I grabbed the packages off of -current as they were updated enough to be used. Be warned though, that mixing -stable and -current packages is generally a bad idea. I wanted to test it out, and so far I can see no side effects from using libxcb and libstartup-notification from -current, ymmv. (Note that libxcb is in mirror/x/X11/lib). As for libxdg, I found a slackbuild from vector linux that seemed to work (with some slight edits). [http://pastebin.com/WiUH4DEL Here it is]

== Awesome ==
I also made a SlackBuild for Awesome. Just build it after installing all the above dependencies and install it. The package built by this SlackBuild also adds Awesome to the xwmconfig menu, so just select it and startx :)

[[Category:Awesome3]]</text>
      <sha1>d9e5tsmqb02dogufwgmdfn9qygvditb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-Ubuntu-git</title>
    <ns>0</ns>
    <id>125</id>
    <revision>
      <id>3597</id>
      <parentid>3596</parentid>
      <timestamp>2009-09-16T07:09:58Z</timestamp>
      <contributor>
        <username>Tourette</username>
        <id>357</id>
      </contributor>
      <comment>/* SKIP GIT STEP AND DOWNLOAD 3.0 AT http://awesome.naquadah.org/download */</comment>
      <text xml:space="preserve" bytes="4444">== '''THESE INSTRUCTIONS NO LONGER WORK WITH GIT -- ONLY AWESOME 3.0''' ==

== SKIP GIT STEP AND DOWNLOAD 3.0 AT http://awesome.naquadah.org/download ==



This is based on the [[Ubuntu_Hardy]] guide and you can follow up this to both, build the last release and the git HEAD version. Enjoy ;-)

1) Make sure your system is up-to-date, then install the GNU Toolchain, the git VCS and some debian/ubuntu packages.

&lt;pre&gt;
sudo apt-get install build-essential autoconf automake libtool gperf xmlto dpatch fakeroot git git-core debhelper
&lt;/pre&gt;

2) Next, install the X.org development packages required to build awesome.

&lt;pre&gt;
sudo apt-get install libx11-dev libxinerama-dev libxrandr-dev libpango1.0-dev libimlib2-dev libgtk2.0-dev libxcb-shm0-dev libxcb-render0-dev libxcb-randr0-dev libxcb-shape0-dev libcairo2-dev libxcb-xinerama0-dev liblua5.1-filesystem0 liblua5.1-logging libdirectfb-dev libxt-dev libx11-xcb-dev
&lt;/pre&gt;

3) Optionally you should get asciidoc (to build documentations and developer reference)
&lt;pre&gt;
sudo apt-get install asciidoc
&lt;/pre&gt;

4) Now get the packages related with Lua language:
&lt;pre&gt;
sudo apt-get install lua5.1 liblua5.1-0-dev
&lt;/pre&gt;

5) Get cmake from Ubuntu Intrepid (unreleased at the time of writing)

http://packages.ubuntu.com/intrepid/i386/cmake/download or

http://packages.ubuntu.com/intrepid/amd64/cmake/download
And install it
&lt;pre&gt;
sudo dpkg -i cmake*.deb
&lt;/pre&gt;

6) Get libev from Ubuntu Intrepid (unreleased at the time of writing)

http://packages.ubuntu.com/intrepid/i386/libev3/download or

http://packages.ubuntu.com/intrepid/amd64/libev3/download

http://packages.ubuntu.com/intrepid/i386/libev-dev/download or

http://packages.ubuntu.com/intrepid/amd64/libev-dev/download
And install it
&lt;pre&gt;
sudo dpkg -i libev*.deb
&lt;/pre&gt;

7) Get luadoc from Ubuntu Intrepid (unreleased at the time of writing)

http://packages.ubuntu.com/intrepid/all/luadoc/download

http://packages.ubuntu.com/intrepid/all/liblua5.1-doc0/download

And install it
&lt;pre&gt;
sudo dpkg -i *lua*doc*.deb
&lt;/pre&gt;

8) Build dependencies

get xcb-util:
&lt;pre&gt;
git clone git://anongit.freedesktop.org/git/xcb/util
cd util &amp;&amp; ./autogen.sh &amp;&amp; make &amp;&amp; sudo make install
&lt;/pre&gt;

'''Note:''' If you are following these instructions under Debian it is not necessary to build libcairo2-dev (It does, at least, work with version 1.6.4-6.1 from the Lenny repos)

&lt;pre&gt;
apt-get source libcairo2-dev
cd cairo-1.6.0
sed -i.orig -e '/dh_shlibdeps/s/^/#/;s/--disable-xcb/--enable-xcb/' debian/rules
sudo dpkg-buildpackage -rfakeroot
sudo dpkg -i ../libcairo2_1.6.0-0ubuntu2_i386.deb ../libcairo2-dev_1.6.0-0ubuntu2_i386.deb
cd ../..
&lt;/pre&gt;

'''Note:''' Do not allow libcairo2 and libcairo2-dev to be updated by any package managers. They will be reverted to repo versions, breaking awesome.

9) [http://awesome.naquadah.org/download/ Download awesome] and build and install it.

&lt;pre&gt;
git clone git://git.naquadah.org/awesome.git
cd awesome &amp;&amp; make &amp;&amp; sudo make install
&lt;if cmake complains that something is missing, apt-cache search for it and add it to this wiki as well&gt;
&lt;/pre&gt;

'''Note:''' If the build stops with an 'error stating path', simply create the directory and start again :
&lt;pre&gt;
/usr/bin/lua5.1: /usr/share/lua/5.1/luadoc/taglet/standard.lua:447: error stating path `/path/to/awesome/.build-bill-i486-linux-gnu-4.2.3/luadoc'
stack traceback:
[...]
&lt;/pre&gt;
&lt;pre&gt;
mkdir /path/to/awesome/.build-bill-i486-linux-gnu-4.2.3/luadoc
make
&lt;/pre&gt;
If this doesn't work (my error was slightly different):
&lt;pre&gt;
rm -rf /path/to/awesome/.build-bill-i486-linux-gnu-4.2.3/luadoc
mkdir /path/to/awesome/.build-bill-i486-linux-gnu-4.2.3/luadoc
make
&lt;/pre&gt;

10) Create an ~/.xinitrc file and link it to ~/.Xsession

Create ~/.xinitrc with the following contents:

&lt;pre&gt;
#!/usr/bin/env bash
xsetroot -solid black &amp;
exec /usr/local/bin/awesome
&lt;/pre&gt;

Create a link to ~/.xinitrc and link it to ~/.Xsession:

&lt;pre&gt;
ln -s ~/.xinitrc ~/.Xsession
&lt;/pre&gt;

11) Now, when you're in the login screen (aka gdm), select 'Sessions', and switch to 'Xsession' from the list. This will run your .xinitrc script.

== GNOME and awesome ==

Chances are, however, you still want to use some parts of GNOME with awesome. You can do this! I have the following entries in my ~/.xinitrc:
&lt;pre&gt;
gnome-screensaver &amp;
gnome-settings-daemon &amp;
gnome-power-manager &amp;
nm-applet &amp;
&lt;/pre&gt;

Note: when editing your .xinitrc, always make sure 'exec awesome' is last.

[[Category:Awesome3]]</text>
      <sha1>4741zw4ag7btr3iimzc0gze5wv45g81</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-debian</title>
    <ns>0</ns>
    <id>930</id>
    <revision>
      <id>6022</id>
      <parentid>6017</parentid>
      <timestamp>2013-06-06T03:13:14Z</timestamp>
      <contributor>
        <username>Kardan</username>
        <id>3021</id>
      </contributor>
      <comment>/* 3.5.1 */</comment>
      <text xml:space="preserve" bytes="3205">* Get awesome source: &lt;code&gt;apt-src install awesome&lt;/code&gt;
* (Optional) Build without dbus (D-Bus)
** Edit &lt;code&gt;awesomeConfig.cmake&lt;/code&gt;: change &lt;code&gt;option(WITH_DBUS &quot;build with D-BUS&quot; ON)&lt;/code&gt; to &lt;code&gt;OFF&lt;/code&gt;.
** Edit &lt;code&gt;CMakeLists.txt&lt;/code&gt;: comment out &lt;code&gt;${SOURCE_DIR}/manpages/awesome-client.1.txt&lt;/code&gt; and &lt;code&gt;install(FILES &quot;utils/awesome-client&quot; ...&lt;/code&gt;.
** Edit &lt;code&gt;debian/control&lt;/code&gt;: delete dependency on dbus-x11.
* (Optional) Build with luajit (Tested with awesome 3.4.15)
** &lt;code&gt;apt-get install libluajit-5.1-dev&lt;/code&gt;
** Apply the two commits [https://github.com/raedwulf/awesome/commit/38072991b58befcab619309a1251c40e22669367] [https://github.com/raedwulf/awesome/commit/564576bcd7be437adc02087202f05a6740ace148] ([https://awesome.naquadah.org/bugs/index.php?do=details&amp;task_id=890 see also]). 
* (Optional) Specify local build version
** Edit &lt;code&gt;debian/changelog&lt;/code&gt;: create a new section with the same format and change the version to something like &lt;code&gt;3.4.15-1+local.1&lt;/code&gt;
* &lt;code&gt;apt-src build awesome&lt;/code&gt;
* &lt;code&gt;dpkg -i awesome*.deb&lt;/code&gt;

== 3.4.13 (wheezy) ==
''current stable version is [http://packages.qa.debian.org/a/awesome.html 3.4.13-1]''

&lt;pre&gt;
# optional step if you want to do debugging
sudo apt-get install gdb libx11-6-dbg libpango1.0-0-dbg libpango1.0-0-dbg libglib2.0-0-dbg libglib2.0-0-dbg 
# install prerequisites
sudo apt-get install --no-install-recommends gperf lua5.1 xmlto luadoc libxcb-randr0-dev libxcb-xtest0-dev \
 libxcb-xinerama0-dev  libxcb-shape0-dev libxcb-keysyms1-dev libxcb-icccm4-dev libx11-xcb-dev lua-lgi-dev \
 libstartup-notification0-dev libxdg-basedir-dev libxcb-image0-dev libxcb-util0-dev libimlib2-dev libev-dev
# download stable source
apt-get source awesome
cd awesome-3.4.13
# build .deb-package
debuild -us -uc
 # alternatively use dpkg-buildpackage from dpkg-dev if you have no devscripts installed 
 # (the difference is that debuid runs lintian after the build.
 # lintian is a package checker which finds packaging errors)
# install package
sudo dpkg -i ../awesome_3.4.13-1_i386.deb # or whatever architecture you have
&lt;/pre&gt;

== 3.5.1 ==
''For installation from git see [[Awesome-3-git-debian]].''
* the depency changed:
** Drop luadoc, libpango1.0-dev, libev-dev, libimlib2-dev, and gperf.
** Push libgdk-pixbuf2.0-dev

&lt;pre&gt;
sudo apt-get install --no-install-recommends lua5.1 xmlto luadoc libxcb-randr0-dev libxcb-xtest0-dev \
 libxcb-xinerama0-dev  libxcb-shape0-dev libxcb-keysyms1-dev libxcb-icccm4-dev libx11-xcb-dev lua-lgi-dev \
 libstartup-notification0-dev libxdg-basedir-dev libxcb-image0-dev libxcb-util0-dev libgdk-pixbuf2.0-dev
apt-get source awesome
cd awesome-3.5.1
debuild -us -uc
sudo dpkg -i ../awesome_3.5.1-1_i386.deb
&lt;/pre&gt;
Note that you need to [[Awesome_3.4_to_3.5|update your configuration file]], or awesome will fail to start ([http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=529642 #529642]) with something like
&lt;code&gt;attempt to call field 'add_signal' (a nil value)&lt;/code&gt;. See ~/.xsession-errors if awesome does not start.

If you did not change any config, just use the new version
  cp awesomerc.lua /etc/xdg/awesome/rc.lua

[[Category:Awesome3]]</text>
      <sha1>n74pxxsqe6y38rqplz4t7sdfj0ctvxg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-fedora</title>
    <ns>0</ns>
    <id>518</id>
    <revision>
      <id>5800</id>
      <parentid>5791</parentid>
      <timestamp>2013-02-26T16:18:05Z</timestamp>
      <contributor>
        <username>Rahulsundaram</username>
        <id>2754</id>
      </contributor>
      <text xml:space="preserve" bytes="148">= Installing awesome on Fedora =

Fedora has awesome in the official repository. Use the following command to install it

* sudo yum install awesome</text>
      <sha1>cj2yl2hxajw2bcj7remggy1b0mz4we5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-git</title>
    <ns>0</ns>
    <id>360</id>
    <revision>
      <id>7470</id>
      <parentid>2850</parentid>
      <timestamp>2016-05-09T04:48:09Z</timestamp>
      <contributor>
        <username>Elv13</username>
        <id>375</id>
      </contributor>
      <text xml:space="preserve" bytes="119">== Getting awesome git ==

[http://awesomewm.github.io/apidoc/documentation/01-readme.md.html This page has been moved]</text>
      <sha1>rwtkst0i60soivc54iqw7uibe8xkwsv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-git-Gentoo</title>
    <ns>0</ns>
    <id>258</id>
    <revision>
      <id>2680</id>
      <parentid>2139</parentid>
      <timestamp>2009-05-23T07:19:05Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Add to awesome3 category</comment>
      <text xml:space="preserve" bytes="2702">This page is intended to show Gentoo users how to use awesome 3 from [http://git.naquadah.org/?p=awesome.git git].

''You need to have root access all of this''

I have this script to automatically fetch the latest version of awesome and wicked; it creates symlinks for the man pages and the wicked library. It also fetches the latest version of xcb-util in case you want the latest version.

* Put the script in /usr/local/src, it doesn't matter what you name it (I named it update.sh)
 #! /bin/sh
 
 if [ &quot;$(id -u)&quot; != &quot;0&quot; ]; then
 echo &quot;This script must be run as root&quot; 1&gt;&amp;2
   exit 1
 fi
 
 rm -rvf /usr/local/src/awesome-git
 git clone git://git.naquadah.org/awesome.git /usr/local/src/awesome-git
 
 rm -rvf /usr/local/src/xcb-util-git
 git clone git://anongit.freedesktop.org/git/xcb/util /usr/local/src/xcb-util-git
 
 rm -rvf wicked-git
 rm -rv /usr/local/share/awesome/lib/wicked.lua
 rm -rv /usr/share/man/man7/wicked.7.gz
 git clone git://git.glacicle.com/awesome/wicked.git /usr/local/src/wicked-git
 ln -sv /usr/local/src/wicked-git/wicked.lua /usr/local/share/awesome/lib/wicked.lua
 ln -sv /usr/local/src/wicked-git/wicked.7.gz /usr/share/man/man7/wicked.7.gz

* Make that executable with
 chmod +x update.sh

Now you need to edit your /etc/portage/package.keywords  (if it isn't there, create it) to allow you to get the versions of cmake (version 2.6&gt;), xcb (version 1.1&gt;), xcb-util (version 0.3.0&gt;), xproto (version 7.0.12&gt;), and xcb-proto (version 1.1&gt;).

* Your /etc/portage/package.keywords should look like this; along with anything else you already had in there.
 &gt;=dev-util/cmake-2.6.2 ~x86
 &gt;=x11-libs/libxcb-1.1 ~x86
 &gt;=x11-libs/xcb-util-0.3.0 ~x86
 &gt;=x11-proto/xproto-7.0.12 ~x86
 &gt;=x11-proto/xcb-proto-1.1 ~x86

Replace ~x86 with your arch (~amd64, et cetera).

Now all you have to do is emerge the dependencies for awesome, compile awesome, and enjoy!

To emerge the dependencies, just type this command in at your terminal (as root)

 emerge -uav app-doc/doxygen dev-util/cmake dev-util/luadoc dev-lang/lua x11-libs/cairo x11-libs/libxcb x11-libs/pango x11-libs/xcb-util
 x11-proto/xproto

That should be all of the dependencies, if you get an error during the awesome compile, figure it out (you ''are'' using Gentoo, you should be competent enough to do that ;)).

Now to compile awesome, you need git to fetch the latest source for awesome. Just use the update script and it will do all of the fetching for you.

Once you have the source, go into the awesome-git folder, and compile and install awesome.

* Here's how you compile awesome
 cd /usr/local/src/awesome-git
 make
 make install

Now just add exec awesome to your .xinitrc and start X!

[[Category:Awesome3]]</text>
      <sha1>8t9cr8tc19e3uk3u1uoe8ak7pf7ebfe</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-git-Ubuntu-Intrepid</title>
    <ns>0</ns>
    <id>188</id>
    <revision>
      <id>2365</id>
      <parentid>2276</parentid>
      <timestamp>2009-02-25T15:55:11Z</timestamp>
      <contributor>
        <username>Saimonn</username>
        <id>265</id>
      </contributor>
      <comment>added libxcb-xtest0-dev to list of required packages</comment>
      <text xml:space="preserve" bytes="3602">This is based on the [[Awesome-3-Ubuntu-git]] guide and you can follow up this to both, build the last release and the git HEAD version. Enjoy ;-)

1) Make sure your system is up-to-date, then install the GNU Toolchain, the git VCS and some debian/ubuntu packages.

&lt;pre&gt;
$ sudo aptitude install build-essential autoconf automake libtool gperf xmlto
$ sudo aptitude install dpatch fakeroot git git-core debhelper
&lt;/pre&gt;

2) Next, install the X.org development packages required to build awesome.

&lt;pre&gt;
$ sudo aptitude install libx11-dev libxinerama-dev libxrandr-dev \
        libpango1.0-dev libimlib2-dev libgtk2.0-dev libxcb-shm0-dev \
        libxcb-render0-dev  libxcb-randr0-dev libxcb-shape0-dev \
        libcairo2-dev libxcb-xinerama0-dev liblua5.1-filesystem0 \
        liblua5.1-logging libdirectfb-dev libxt-dev libx11-xcb-dev cmake \
        lua5.1 liblua5.1-0-dev libev3 libev-dev luadoc liblua5.1-doc0 \
        libxcb-aux0 libxcb-keysyms0 libxcb-xtest0-dev
&lt;/pre&gt;

3) Optionally you should get asciidoc (to build documentations and developer reference)
&lt;pre&gt;
$ sudo aptitude install asciidoc
&lt;/pre&gt;

4) Build dependencies

get xcb-util:
&lt;pre&gt;
$ git clone git://anongit.freedesktop.org/git/xcb/util
$ cd util &amp;&amp; ./autogen.sh &amp;&amp; ./configure &amp;&amp; make &amp;&amp; sudo make install
&lt;/pre&gt;

&lt;strong&gt;Note&lt;/strong&gt; as of 19 Jan 2009, awesome-3.1.1 will not build against a HEAD checkout of xcb-utils. See [http://www.mail-archive.com/awesome@naquadah.org/msg00438.html this mailing list thread] for details; as a workaround (as noted in that thread), download [http://xcb.freedesktop.org/dist/xcb-util-0.3.2.tar.bz2 the xcb-util-0.3.2 tarball], expand it, and do the standard &lt;code&gt;./configure &amp;&amp; make &amp;&amp; sudo make install&lt;/code&gt;.

5) Build awesome

&lt;pre&gt;
$ git clone git://git.naquadah.org/awesome.git
$ cd awesome &amp;&amp; make &amp;&amp; sudo make install
&lt;/pre&gt;

6) Create an ~/.xinitrc file and link it to ~/.Xsession

Create ~/.xinitrc with the following contents:

&lt;pre&gt;
#!/usr/bin/env bash
xsetroot -solid black &amp;
exec /usr/local/bin/awesome
&lt;/pre&gt;

Create a link to ~/.xinitrc and link it to ~/.Xsession:

&lt;pre&gt;
ln -s ~/.xinitrc ~/.Xsession
&lt;/pre&gt;

7) Now, when you're in the login screen (aka gdm), select 'Sessions', and switch to 'Xsession' from the list. This will run your .xinitrc script.

== GNOME and awesome ==

Chances are, however, you still want to use some parts of GNOME with awesome. You can do this! I have the following entries in my ~/.xinitrc:
&lt;pre&gt;
gnome-screensaver &amp;
gnome-settings-daemon &amp;
gnome-power-manager &amp;
nm-applet &amp;
&lt;/pre&gt;

Note: when editing your .xinitrc, always make sure 'exec awesome' is last.

== Installation into an alternate location ==

I wanted to be able to install into &lt;code&gt;/opt/awesome-3.1.1&lt;/code&gt;, which required some modifications to the above. (N.b. this worked for me, but may not be the best/right way to do it; YMMV.)

First, when building xcb-util, specify the installation location during the configure, then build and install as normal:

&lt;pre&gt;
./configure --prefix=/opt/awesome-3.1.1 &amp;&amp; make &amp;&amp; make install
&lt;/pre&gt;

Second, when building awesome, tell it where to find the xcb-util libraries and specify the installation location:

&lt;pre&gt;
sed -i.old 's/usr\/local/opt\/awesome-3.1.1/' awesomeConfig.cmake 
PKG_CONFIG_PATH=/opt/awesome-3.1.1/lib/pkgconfig/ cmake -DPREFIX=/opt/awesome-3.1.1
make &amp;&amp; sudo make install
&lt;/pre&gt;

Note that the above 'make install' still requires root-level access because it drops a file into &lt;code&gt;/etc/xdg/&lt;/code&gt;. I haven't yet played around with relocating that file, or simply not installing it.

[[Category:Awesome3]]</text>
      <sha1>86hrcvenrh6yxntkh40kz0d9ekarzm3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-git-Ubuntu-Lucid</title>
    <ns>0</ns>
    <id>778</id>
    <redirect title="Awesome-3.4.11/git-Ubuntu-Lucid" />
    <revision>
      <id>5310</id>
      <timestamp>2012-01-14T13:13:06Z</timestamp>
      <contributor>
        <username>Jirib</username>
        <id>572</id>
      </contributor>
      <comment>moved [[Awesome-3-git-Ubuntu-Lucid]] to [[Awesome-3.4.11/git-Ubuntu-Lucid]]</comment>
      <text xml:space="preserve" bytes="45">#REDIRECT [[Awesome-3.4.11/git-Ubuntu-Lucid]]</text>
      <sha1>n2011003j36wd3xinpcwh4vin5wbkzm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3-git-debian</title>
    <ns>0</ns>
    <id>204</id>
    <revision>
      <id>6029</id>
      <parentid>6023</parentid>
      <timestamp>2013-06-11T19:58:54Z</timestamp>
      <contributor>
        <username>Kardan</username>
        <id>3021</id>
      </contributor>
      <minor/>
      <comment>sudo ldconfig</comment>
      <text xml:space="preserve" bytes="1245">The debian builder script is optimized for building GIT version of Awesome.

To setup a building environment you should:

* clone official repository
  git clone git://git.naquadah.org/awesome.git

* Change to fetched repository
  cd awesome

* Add debian source
  git remote add origin-debian git://git.debian.org/git/users/acid/awesome.git

* Fetch objects from debian
  git fetch origin-debian

* build binaries
  cmake -DCMAKE_PREFIX_PATH=/usr -DSYSCONFDIR=/etc &amp;&amp; make

* install awesome
  sudo make install
  sudo ldconfig -v

* [[Awesome_3.4_to_3.5|update the configuration file]] or use the new version
  sudo cp awesomerc.lua /etc/xdg/awesome/rc.lua


  [user]
          email = your-email@ddr.ess
          name = Your name
  [core]
          repositoryformatversion = 0
          filemode = true
          bare = false
          logallrefupdates = true
  [remote &quot;origin&quot;]
          url = git://git.naquadah.org/awesome.git
          fetch = +refs/heads/*:refs/remotes/origin/*
  [branch &quot;master&quot;]
          remote = origin
          merge = refs/heads/master
  [remote &quot;origin-debian&quot;]
          url = git://git.debian.org/git/users/acid/awesome.git
          fetch = +refs/heads/*:refs/remotes/origin-debian/*

[[Category:Awesome3]]</text>
      <sha1>5eoh7z81j167qhqaqu4outuxp6xoeyh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-3.4.11/git-Ubuntu-Lucid</title>
    <ns>0</ns>
    <id>627</id>
    <revision>
      <id>5345</id>
      <parentid>5316</parentid>
      <timestamp>2012-02-14T07:53:36Z</timestamp>
      <contributor>
        <username>Iammuneeb</username>
        <id>795</id>
      </contributor>
      <comment>added nifty trick to install dependencies of awesome</comment>
      <text xml:space="preserve" bytes="3159">'''This provides no warranty.'''

'''First install the dependecies of awesome'''

&lt;pre&gt;
$ sudo apt-get build-dep awesome
&lt;/pre&gt;


'''Tip to have apps versions well organized'''

Now install packages xstow, and autoconf for managing manually installed software.
(Install git-core if building from git version.)

&lt;pre&gt;
$ apt-get install git-core xstow autoconf
&lt;/pre&gt;

Setup xstow dir structure.

&lt;pre&gt;
$ [ ! -d /usr/local/stow ] &amp;&amp; sudo mkdir -p /usr/local/stow
&lt;/pre&gt;

Make sure installed files have proper permissions:
&lt;pre&gt;
$ umask 022
&lt;/pre&gt;


'''Ubuntu Lucid uses old version of Freedesktop software - *xcb*.'''

You need:

libxcb-1.8, xcb-proto-1.7, xcb-util-0.3.8 and xcb-util-wm-0.3.8

Download *xcb* package from [http://www.freedesktop.org/wiki/Software].

Install libxcb-1.8, xcb-proto-1.7, xcb-util-0.3.8 and xcb-util-wm-0.3.8, use following action (replace $app with proper name of application as written above)
to build and install each app.

&lt;pre&gt;
$ cd /tmp/
$ tar xvzf $app.tar.gz
$ cd $app
$ ./configure --prefix=/usr/local/stow/$app
$ sudo make install clean
$ cd /usr/local/stow
$ sudo xstow -v $app
&lt;/pre&gt;

In the final you should have following apps build in /usr/local/stow.

&lt;pre&gt;
$ ls /usr/local/stow/
libxcb-1.8  xcb-proto-1.7  xcb-util-0.3.8  xcb-util-wm-0.3.8
&lt;/pre&gt;


'''Building awesome-3.4.11 or git version'''

Download awesome-3.4.11.tar.bz2 or clone git repo for awesome (if using git
replace 3.4.11 with yours date).

&lt;pre&gt;
$ cd /tmp
$ tar xvjf awesome-3.4.11.tar.bz2
$ cd awesome-3.4.11
$ cmake -DCMAKE_INSTALL_PREFIX=/usr/local/stow/awesome-3.4.11
$ make
$ sudo make install clean
$ cd /usr/local/stow
$ sudo xstow -v awesome-3.4.11
&lt;/pre&gt;

Now you should see in /usr/local/stow. (If using git there would be date instead
of version.)

&lt;pre&gt;
$ ls
awesome-3.4.11  libxcb-1.8  xcb-proto-1.7  xcb-util-0.3.8  xcb-util-wm-0.3.8
&lt;/pre&gt;

'''Post build/install tips'''

Check you $PATH if it contains /usr/local/bin.

&lt;pre&gt;
$ echo $PATH | grep -q /usr/local/bin ; echo $? # 0 = successfull
0
&lt;/pre&gt;

'''Rebuild cache for libraries'''

&lt;pre&gt;
$ sudo ldconfig -v
$ ldconfig -p | egrep &quot;/usr/local/lib/.*xcb&quot; # if you see your new libs in /usr/local it is OK
&lt;/pre&gt;

'''Config tips'''

I recommend to backup your old rc.lua and move it to somewhere else. Let's start with new version's rc.lua first.

&lt;pre&gt;
$ [ -d $HOME/.config/awesome ] &amp;&amp; mv $HOME/.config/awesome $HOME/.config/awesome.backup
$ mkdir -p $HOME/.config/awesome

$ find /usr/local/ -type f -name 'rc.lua'
/usr/local/stow/awesome-3.4.11/etc/xdg/awesome/rc.lua
$ cp /usr/local/stow/awesome-3.4.11/etc/xdg/awesome/rc.lua $HOME/.config/awesome
&lt;/pre&gt;

During awesome building paths to awesome is hardcored, so replace it to be ready for new version.

&lt;pre&gt;
$ perl -i -pe 's#stow/awesome-[^/]*/##;' $HOME/.config/awesome/rc.lua
$ grep 'beautiful.init' $HOME/.config/awesome/rc.lua # just check if paths are OK
beautiful.init(&quot;/usr/local/share/awesome/themes/default/theme.lua&quot;)
&lt;/pre&gt;

Start now your new fresh awesome, if it works try to merge your old config with example coming from your new version.

And the proof and little propaganda :)

[[File:Screenshot-small.jpg]]</text>
      <sha1>kqpsccfwy8bat3o11adkav3q59dlzfr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client</title>
    <ns>0</ns>
    <id>557</id>
    <revision>
      <id>5602</id>
      <parentid>4750</parentid>
      <timestamp>2012-09-11T14:28:09Z</timestamp>
      <contributor>
        <username>Laurtik</username>
        <id>1079</id>
      </contributor>
      <comment>How to make sure you have access to the objects you expect to.</comment>
      <text xml:space="preserve" bytes="5242">== '''DRAFT''' ==


=== Using ''awesome-client'' for fun and no profit ===

On some occasions it may prove useful to control the window manager remotely. For this purpose one can use ''awesome-client''. Purpose of this can be to control media player windows or other graphical content with remote control or time how screen looks like based on external triggers.

''awesome-client'' sends lua commands to AwesomeWM through dbus.


Short (hopefully growing) list of things that can be done with the client. 
(done with awesome version 3.4.4)

Commands beginning with &quot;''awesome#''&quot; are ran inside awesome client and commands beginning with &quot;''$''&quot; are ran as shell commands.

To get &quot;awesome#&quot; prompt execute 'awesome-client' in your favorite terminal&amp;shell combo.

===== This display current mouse coordinates =====
''awesome#'' c=mouse.coords() &lt;br/&gt;
''awesome#'' return c.x
   double 1871
''awesome#'' return c['x']
   double 1871

===== This will move the mouse pointer to top left corner =====
''awesome#'' mouse.coords({x = 10, y = 10})

===== This will change toggle the float status of the active window =====
''awesome#'' c=awful.client.floating&lt;br/&gt;
''awesome#'' c.toggle()

===== This will alter tile proportions if layout supports it =====
''awesome#'' c=awful.tag&lt;br/&gt;
''awesome#'' c.incmwfact(0.1)

===== Notification displaying =====
Notifications can be used in many ways.

# ''$'' for i in `seq 1 10` ; do echo &quot;naughty.notify({ title = 'Title $i', text = 'text $1', timeout = 1 })&quot; | awesome-client ; sleep 2 ; done

# ''awesome#'' naughty.notify({ title = &quot;Long Title Name to test limits of notification&quot;, text = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum&quot; })

# That did not quite fit into the box so we try&lt;br/&gt;''awesome#'' naughty.notify({ title = &quot;Long Title Name to test limits of notification&quot;, text = &quot;Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum&quot;, height = 400, width = 300 })

Have a look at &quot;naughty.lua&quot; for complete list of arguments available for naughty.notify()

===== Write stuff to .xsession-errors file =====
''awesome#'' io.stderr:write(&quot;Lorem ipsum dolor sit amet&quot;)

===== listing client windows =====

Display a popup with list of all client windows&lt;br/&gt;
''awesome#'' awful.menu.clients({width=400})

Print to .xsession-errors a list of visible windows&lt;br/&gt;
''awesome#'' list=awful.client.visible()&lt;br/&gt;
''awesome#'' for k, c in pairs(list) do io.stderr:write(c.name .. &quot;\n&quot;) end

Print to .xsession-errors a list of all windows.&lt;br/&gt;
''awesome#'' list=client.get()&lt;br/&gt;
''awesome#'' for k, c in pairs(list) do io.stderr:write(c.name .. &quot;\n&quot;) end


Why ''awful.client.visible()'' and ''client.get()'' !?!?
why not ''awful.client.visible()'' and ''awful.client.get()'' OR
''client.visible()'' and ''client.get()'' for more consistency??

Former with awful prefix would sound better :)

===== Setting all xterms to float (not ready) =====
''awesome#'' list=client.get()&lt;br/&gt;
''awesome#'' for k, c in pairs(list) do _IF_ c.instance _EQUALS_ &quot;xterm&quot; _THEN_ c.floating.toggle() end


===== Accessing variables and functions  (aka 'pay attention when using &quot;local&quot;' =====

While mostly it seems that sending commands via awesome-client is just like typing lines on the end of your AwesomeWM config and having it auto-restart,
there is one aspect in which this is not true: While what you write in rc.lua can access any variable or function declared in the outermost scope, code sent via awesome-client can only access global values (ie. anything you declared 'local' in the rc.lua will be inaccessible -- AwesomeWM will tell you &quot;that variable doesn't exist&quot;).

So make sure anything you want to access via awesome-client is not declared local.


===== TODO =====

(NOTREADY)


? how to replace a function.

(Couldn't you just do function myfunc() ... end?)

? how to view function.
To my knowledge this is not possible in Lua. Inspecting/reflecting a list or variable is not possible?

Viewing a function's source is not trivial in stock Lua 5.1; the only way I think you can is to use the debug library
to find the source file/string of the function and then use the io library to open that file.  This doesn't always work,
though.  You could probably patch the Lua sources to include a function's source with the function object without much effort.

More effective way of doing this might be with other language, but if one desires to do things from shell scripts then awesome-client is .... awesome.</text>
      <sha1>mno9nhop9a44y8vo9rfz11uenb4qu92</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client 2.x</title>
    <ns>0</ns>
    <id>248</id>
    <revision>
      <id>2907</id>
      <parentid>2905</parentid>
      <timestamp>2009-06-25T14:57:58Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="1894">{{Languages}}

'''This is the man page of awesome-client version 2.3.4, compatible with all versions 2.3.x. It can also be used for a big part with previous versions 2.0.x and 2.1.x, but you may read their own man pages for some differences they have.'''



&lt;H1&gt;AWESOME-CLIENT&lt;/H1&gt;
Section:  (1)

&lt;H2&gt;NAME&lt;/H2&gt;

awesome-client - awesome window manager command line interface

&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

awesome-client

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

awesome-client is the command line interface to awesome. It communicates with awesome via a socket located in the users's HOME directory.

&lt;H2&gt;USAGE&lt;/H2&gt;

To determine which socket is to be used, it reads the DISPLAY environment variable. awesome-client reads commands from standard input.

When you pipe multiple lines into awesome-client, an empty line will flush already collected lines into awesome with an according immediate execution.

The command format is: screen_number command argument

For example, to change a statusbar textbox text on screen 0, you can do the following:


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
echo 0 widget_tell &amp;lt;statusbar-name&amp;gt; &amp;lt;textbox-name&amp;gt; text Hello, world | awesome-client
&lt;/PRE&gt;

&lt;/DL&gt;

To change an iconbox image on screen 1, you can do the following:


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
echo 0 widget_tell &amp;lt;statusbar-name&amp;gt; &amp;lt;iconbox-name&amp;gt; image /home/user/image.jpg | awesome-client
&lt;/PRE&gt;

&lt;/DL&gt;

To view tag number 3 on screen 1:


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
echo 1 tag_view 3 | awesome-client
&lt;/PRE&gt;

&lt;/DL&gt;

To zoom focused window on screen 0:


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
echo 0 client_zoom | awesome-client
&lt;/PRE&gt;

&lt;/DL&gt;

&lt;H2&gt;SEE ALSO&lt;/H2&gt;

awesome(1) awesomerc(5)

&lt;H2&gt;AUTHORS&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt;

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;

&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
mailto:julien@danjou.info
&lt;/DL&gt;

[[Category:Awesome2]]</text>
      <sha1>0yuinia3loc2pne01yv2f1cs6wbob9p</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client 2.x/fr</title>
    <ns>0</ns>
    <id>240</id>
    <revision>
      <id>2910</id>
      <parentid>2908</parentid>
      <timestamp>2009-06-25T14:58:24Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="2734">{{Languages|Awesome-client 2.x}}

'''Ceci est la page de manuel de awesome-client version 2.3.4, valide pour toutes les versions 2.3.x. Elle est utilisable aussi pour une grande part avec les versions précédentes 2.0.x et 2.1.x, mais, pour les quelques différences qu'il y a, veuillez consulter les pages de manuel de ces versions.  '''


&lt;H1&gt;AWESOME-CLIENT&lt;/H1&gt;
Section:  (1)

&lt;H2&gt;NOM&lt;/H2&gt;

awesome-client - interface en ligne de commande du gestionnaire de fenêtres awesome

&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

awesome-client

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

awesome-client est l'interface en ligne de commande pour awesome. Il communique avec awesome à travers une interface de connexion située dans le répertoire HOME de l'utilisateur.

&lt;H2&gt;UTILISATION&lt;/H2&gt;

Pour déterminer quelle interface de connexion doit être utilisée, awesome-client lit la variable d'environnement DISPLAY. Il lit les commandes à partir de l'entrée standard.

Lorsque vous pipez de multiples lignes dans awesome-client, une ligne vide purge les lignes déjà collectées dans awesome, avec une exécution immédiate.

Le format de la commande est : numéro_d'écran commande argument

Par exemple, pour changer le texte dans la boîte de texte d'une barre d'état dans l'écran 0, vous pouvez faire :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
echo 0 widget_tell &amp;lt;statusbar-name&amp;gt; &amp;lt;textbox-name&amp;gt; text Hello, world | awesome-client
&lt;/PRE&gt;

&lt;/DL&gt;

Pour changer une image d'icône dans l'écran 1, vous pouvez faire :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
echo 0 widget_tell &amp;lt;statusbar-name&amp;gt; &amp;lt;iconbox-name&amp;gt; image /home/user/image.jpg | awesome-client
&lt;/PRE&gt;

&lt;/DL&gt;

Pour afficher l'onglet numéro 3 dans l'écran 1 :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
echo 1 tag_view 3 | awesome-client
&lt;/PRE&gt;

&lt;/DL&gt;

Pour rendre maître la fenêtre focalisée dans l'écran 0 :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
echo 0 client_zoom | awesome-client
&lt;/PRE&gt;

&lt;/DL&gt;


&lt;H2&gt;VOIR AUSSI&lt;/H2&gt;

awesome(1) awesomerc(5)

&lt;H2&gt;AUTEUR&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt;

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;P&gt;

&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
courriel : mailto:julien@danjou.info
&lt;/DL&gt;

&lt;H2&gt;TRADUCTION&lt;/H2&gt;

Ce document est une traduction, réalisée par Jean-Luc Duflot &amp;lt;jl&amp;nbsp;POING&amp;nbsp;duflot&amp;nbsp;CHEZ&amp;nbsp;laposte&amp;nbsp;POING&amp;nbsp;net&amp;gt; le 2&amp;nbsp;novembre&amp;nbsp;2008.


L'équipe de traduction a fait le maximum pour réaliser une adaptation française de qualité.
La version anglaise la plus à jour de ce document est toujours consultable via la commande&amp;nbsp;: LANGUAGE=en man awesome-client. N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute erreur dans cette page de manuel.

[[Category:Awesome2]]</text>
      <sha1>mblmnt6ic2fabi1facv9gvc5z4nlmgb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client 2.x (en)</title>
    <ns>0</ns>
    <id>373</id>
    <redirect title="Awesome-client 2.x" />
    <revision>
      <id>2906</id>
      <timestamp>2009-06-25T14:57:44Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome-client 2.x (en)]] to [[Awesome-client 2.x]]</comment>
      <text xml:space="preserve" bytes="32">#REDIRECT [[Awesome-client 2.x]]</text>
      <sha1>ke7cxmrfr89yvmpwvihpds4wfaea9j3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client 2.x (fr)</title>
    <ns>0</ns>
    <id>374</id>
    <redirect title="Awesome-client 2.x/fr" />
    <revision>
      <id>2909</id>
      <timestamp>2009-06-25T14:58:09Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome-client 2.x (fr)]] to [[Awesome-client 2.x/fr]]</comment>
      <text xml:space="preserve" bytes="35">#REDIRECT [[Awesome-client 2.x/fr]]</text>
      <sha1>7y31djduxum3u3yszu09uqf9v4bbyar</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client 3.x</title>
    <ns>0</ns>
    <id>254</id>
    <revision>
      <id>3779</id>
      <parentid>3775</parentid>
      <timestamp>2009-11-10T12:57:12Z</timestamp>
      <contributor>
        <username>Jihell78</username>
        <id>50</id>
      </contributor>
      <text xml:space="preserve" bytes="1142">{{Languages}}

'''This is the man page of awesome-client version 3.4.1. It can also be used for a large part with previous versions 3.x, because there are not much differences, apart the communication mode with awesome (since 3.3). Nevertheless, you may read their specific man pages if it is necessary.'''


&lt;H2&gt;NAME&lt;/H2&gt;

awesome-client - awesome window manager remote execution
&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

&lt;P&gt;
awesome-client
&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

awesome-client is a remote command line interface to awesome. It communicates with awesome via D-Bus, allowing remote execution of Lua code.
&lt;H2&gt;USAGE&lt;/H2&gt;

awesome-client reads commands from standard input and sends them via D-Bus to awesome. If &lt;I&gt;rlwrap&lt;/I&gt; is installed, it will be used to provide a readline command line interface.

The &lt;I&gt;awful.remote&lt;/I&gt; module has to be loaded if you want this command to work.
&lt;H2&gt;SEE ALSO&lt;/H2&gt;

awesome(1) awesomerc(5)
&lt;H2&gt;AUTHORS&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt;
&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
mailto:julien@danjou.info



[[Category:Awesome3]]</text>
      <sha1>c0u6j84aywc7ks44c45idqi3gptjqxt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client 3.x/fr</title>
    <ns>0</ns>
    <id>245</id>
    <revision>
      <id>3778</id>
      <parentid>3776</parentid>
      <timestamp>2009-11-10T12:52:08Z</timestamp>
      <contributor>
        <username>Jihell78</username>
        <id>50</id>
      </contributor>
      <text xml:space="preserve" bytes="1819">{{Languages|Awesome-client 3.x}}

'''Ceci est la page de manuel de awesome-client version 3.4.1. Elle est utilisable aussi pour une grande part avec les versions précédentes 3.x, parce qu'il y a peu de différences, excepté le mode de communication avec awesome (depuis 3.3). Néanmoins, vous pouvez consulter spécifiquement leurs pages si besoin est. '''


&lt;H2&gt;NOM&lt;/H2&gt;

awesome-client - exécution à distance du gestionnaire de fenêtres awesome
&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

awesome-client
&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

awesome-client est une interface en ligne de commande à distance pour awesome. Il communique avec awesome via D-Bus, permettant d'exécuter du code Lua à distance.
&lt;H2&gt;UTILISATION&lt;/H2&gt;

awesome-client lit les commandes à partir de l'entrée standard et les envoie à awesome via D-Bus. Si &lt;I&gt;rlwrap&lt;/I&gt; est installé, il sera utilisé pour fournir une interface en ligne de commande de readline.

Le module &lt;I&gt;awful.remote&lt;/I&gt; doit être chargé pour que cette commande fonctionne.
&lt;H2&gt;VOIR AUSSI&lt;/H2&gt;

awesome(1) awesomerc(5)
&lt;H2&gt;AUTEUR&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt;

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
courriel : mailto:julien@danjou.info

&lt;H2&gt;TRADUCTION&lt;/H2&gt;

Ce document est une traduction, réalisée par Jean-Luc Duflot &amp;lt;jl&amp;nbsp;POING&amp;nbsp;duflot&amp;nbsp;CHEZ&amp;nbsp;laposte&amp;nbsp;POING&amp;nbsp;net&amp;gt; le 10&amp;nbsp;novembre&amp;nbsp;2009.

L'équipe de traduction a fait le maximum pour réaliser une adaptation française de qualité.
La version anglaise la plus à jour de ce document est toujours consultable via la commande&amp;nbsp;: LANGUAGE=en man awesome-client. N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute erreur dans cette page de manuel.


[[Category:Awesome3]]</text>
      <sha1>tlbe2lib8ixyte6qsntiahf36om5ot9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client 3.x (en)</title>
    <ns>0</ns>
    <id>384</id>
    <redirect title="Awesome-client 3.x" />
    <revision>
      <id>2951</id>
      <timestamp>2009-06-25T15:17:49Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome-client 3.x (en)]] to [[Awesome-client 3.x]]</comment>
      <text xml:space="preserve" bytes="32">#REDIRECT [[Awesome-client 3.x]]</text>
      <sha1>m6ladnli3z0062zs44inl7a7htss3s5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-client 3.x (fr)</title>
    <ns>0</ns>
    <id>385</id>
    <redirect title="Awesome-client 3.x/fr" />
    <revision>
      <id>2954</id>
      <timestamp>2009-06-25T15:18:11Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome-client 3.x (fr)]] to [[Awesome-client 3.x/fr]]</comment>
      <text xml:space="preserve" bytes="35">#REDIRECT [[Awesome-client 3.x/fr]]</text>
      <sha1>kqiqxzqb4jxas1yhwnnz5u0pkudyima</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-menu 2.x</title>
    <ns>0</ns>
    <id>249</id>
    <revision>
      <id>2919</id>
      <parentid>2917</parentid>
      <timestamp>2009-06-25T15:02:12Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="2161">{{Languages}}

'''This is the man page of awesome-client version 2.3.4, compatible with all versions 2.3.x. It can also be used for a big part with previous versions 2.0.x and 2.1.x, but you may read their own man pages for some differences they have.'''



&lt;H1&gt;AWESOME-MENU&lt;/H1&gt;
Section:  (1)

&lt;H2&gt;NAME&lt;/H2&gt;

awesome-menu - awesome menu system

&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

awesome-menu [-c config] [-e command] &amp;lt;title&amp;gt;

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

awesome-menu is a tool which will pop up a menu on your screen, grabbing keyboard and allowing you to search through an initial completion list, or using your files as completion.

&lt;H2&gt;USAGE&lt;/H2&gt;

By default, awesome-menu reads completion from standard input. If nothing is read, the completion list is built from the current working directory files.

To build a menu with all the executable files of /usr/bin:

&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
ls /usr/bin | awesome-menu -e 'exec ' 'Execute'
&lt;/PRE&gt;

&lt;/DL&gt;

To build the same menu and run the programs in a terminal window:


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
ls /usr/bin | awesome-menu -e 'xterm -e exec ' 'Execute in terminal'
&lt;/PRE&gt;

&lt;/DL&gt;

To build an ssh connection prompt:


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
cut -d' ' -f1 ~/.ssh/known_hosts | cut -d, -f1 | awesome-menu -e 'xterm -e ssh ' 'ssh to:'
&lt;/PRE&gt;

&lt;/DL&gt;

If you do not specify the -e option, the result will be sent to standard output. You can do things like that:


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
gzip &amp;quot;$(awesome-menu '&amp;quot;File to gzip')&amp;quot;
&lt;/PRE&gt;

&lt;/DL&gt;

&lt;H2&gt;OPTIONS&lt;/H2&gt;

-c config
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Use an alternate configuration file instead of $HOME/.awesomerc.
&lt;/DL&gt;

-e command
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Command to execute. The result is appended to the end of this command (like xargs).
&lt;/DL&gt;

&amp;lt;title&amp;gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Print this title. This is also used to identify the menu section in the awesomerc file.
&lt;/DL&gt;

&lt;H2&gt;SEE ALSO&lt;/H2&gt;

awesome(1) awesomerc(5)

&lt;H2&gt;AUTHORS&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt;

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;

&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
mailto:julien@danjou.info
&lt;/DL&gt;

[[Category:Awesome2]]</text>
      <sha1>tvuzf4shyhsfsitsj5fjxgrxnwa4zzo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-menu 2.x/fr</title>
    <ns>0</ns>
    <id>241</id>
    <revision>
      <id>2922</id>
      <parentid>2920</parentid>
      <timestamp>2009-06-25T15:02:37Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="3019">{{Languages|Awesome-menu 2.x}}

'''Ceci est la page de manuel de awesome-menu version 2.3.4, valide pour toutes les versions 2.3.x. Elle est utilisable aussi pour une grande part avec les versions précédentes 2.0.x et 2.1.x, mais, pour les quelques différences qu'il y a, veuillez consulter les pages de manuel de ces versions.  '''


&lt;H1&gt;AWESOME-MENU&lt;/H1&gt;
Section:  (1)

&lt;H2&gt;NOM&lt;/H2&gt;

awesome-menu - système de menu de awesome

&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

awesome-menu [-c config] [-e command] &amp;lt;title&amp;gt;

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

awesome-menu est un outil qui fait apparaître un menu sur votre écran ; par la saisie au clavier il vous permet de chercher dans une liste de complètement par défaut, ou dans une liste de complètement contenant vos propres fichiers.

&lt;H2&gt;UTILISATION&lt;/H2&gt;

Par défaut, awesome-menu lit le complètement à partir de l'entrée standard. Si rien n'est lu, la liste de complètement est construite à partir des fichiers du répertoire courant de travail.

Pour construire un menu avec tous les fichiers exécutables de /usr/bin :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
ls /usr/bin | awesome-menu -e 'exec ' 'Execute'
&lt;/PRE&gt;

&lt;/DL&gt;

Pour construire le même menu et lancer les programmes dans une fenêtre de terminal :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
ls /usr/bin | awesome-menu -e 'xterm -e exec ' 'Execute in terminal'
&lt;/PRE&gt;

&lt;/DL&gt;

Pour obtenir une invite de connection ssh :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
cut -d' ' -f1 ~/.ssh/known_hosts | cut -d, -f1 | awesome-menu -e 'xterm -e ssh ' 'ssh to:'
&lt;/PRE&gt;

&lt;/DL&gt;

Si vous ne spécifiez pas l'option -e, le résultat sera envoyé sur la sortie standard. Vous pouvez faire quelquechose comme ça :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
gzip &amp;quot;$(awesome-menu '&amp;quot;File to gzip')&amp;quot;
&lt;/PRE&gt;

&lt;/DL&gt;

&lt;H2&gt;OPTIONS&lt;/H2&gt;

-c config
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Utilise le fichier de configuration &amp;quot;config&amp;quot; à la place de $HOME/.awesomerc.
&lt;/DL&gt;

-e command
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Commande à exécuter. Le résultat est ajouté à la fin de cette commande (comme xargs).
&lt;/DL&gt;

&amp;lt;title&amp;gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche &amp;quot;title&amp;quot;. On l'utilise aussi pour identifier une section de menu dans le fichier awesomerc.
&lt;/DL&gt;

&lt;H2&gt;VOIR AUSSI&lt;/H2&gt;

awesome(1) awesomerc(5)

&lt;H2&gt;AUTEUR&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt;

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;P&gt;

&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
courriel : mailto:julien@danjou.info
&lt;/DL&gt;

&lt;H2&gt;TRADUCTION&lt;/H2&gt;

Ce document est une traduction, réalisée par Jean-Luc Duflot &amp;lt;jl&amp;nbsp;POING&amp;nbsp;duflot&amp;nbsp;CHEZ&amp;nbsp;laposte&amp;nbsp;POING&amp;nbsp;net&amp;gt; le 2&amp;nbsp;novembre&amp;nbsp;2008.

L'équipe de traduction a fait le maximum pour réaliser une adaptation française de qualité.
La version anglaise la plus à jour de ce document est toujours consultable via la commande&amp;nbsp;: LANGUAGE=en man awesome-menu. N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute erreur dans cette page de manuel.

[[Category:Awesome2]]</text>
      <sha1>sidbnytbv02ujti8repk6qqppomegxb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-menu 2.x (en)</title>
    <ns>0</ns>
    <id>376</id>
    <redirect title="Awesome-menu 2.x" />
    <revision>
      <id>2918</id>
      <timestamp>2009-06-25T15:01:58Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome-menu 2.x (en)]] to [[Awesome-menu 2.x]]</comment>
      <text xml:space="preserve" bytes="30">#REDIRECT [[Awesome-menu 2.x]]</text>
      <sha1>pl9n2jdm70d46mz5vxyzthh8svk8tg9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-menu 2.x (fr)</title>
    <ns>0</ns>
    <id>377</id>
    <redirect title="Awesome-menu 2.x/fr" />
    <revision>
      <id>2921</id>
      <timestamp>2009-06-25T15:02:23Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome-menu 2.x (fr)]] to [[Awesome-menu 2.x/fr]]</comment>
      <text xml:space="preserve" bytes="33">#REDIRECT [[Awesome-menu 2.x/fr]]</text>
      <sha1>pq0og06rmskyd5zp0c02750bp9tk1ze</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-menu basics</title>
    <ns>0</ns>
    <id>239</id>
    <revision>
      <id>4346</id>
      <parentid>3735</parentid>
      <timestamp>2010-07-04T06:49:30Z</timestamp>
      <contributor>
        <username>Newacct</username>
        <id>488</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="6651">== awesome-menu basics ==

In awesome 2.3 (now outdated), there's a menu mechanism. There's two sections to the menu, the first is the command being ran, and the rest of the bar is the menu. The first portion can take input from stdin, so any command can be typed there instead of using a menu option.

To add a list of items to the menu,  you can cat a file of contents to it as shown in the following:

~/.awesome/menu contents:
  xterm
  firefox
  pidgin

Then add this to your .awesomerc:
  key { 
    modkey = {&quot;Mod4&quot;} 
    key = &quot;p&quot; 
    command = &quot;spawn&quot; 
    arg = &quot;exec `cat ~/.awesome/menu | awesome-menu 'Run:'`&quot; 
  }

Or, another alternative, which displays everything in /usr/bin as a menu:

  key { 
    modkey = {&quot;Mod4&quot;} 
    key = &quot;p&quot; 
    command = &quot;spawn&quot; 
    arg = &quot;ls /usr/bin | awesome-menu -e 'exec ' 'Run:'&quot; 
  }

Or, you can display everything in $PATH as a menu with dmenu script

  key { 
    modkey = {&quot;Mod4&quot;} 
    key = &quot;p&quot; 
    command = &quot;spawn&quot; 
    arg = &quot;dmenu_path | awesome-menu -e 'exec ' 'Run:'&quot; 
  }
PS If you dont have dmenu installed, there is dmenu_path script
 #!/bin/sh
 CACHE=$HOME/.dmenu_cache
 IFS=:
 uptodate() {
 test ! -f $CACHE &amp;&amp; return 1
 for dir in $PATH
 do
       test $dir -nt $CACHE &amp;&amp; return 1
 done
 return 0
 }
 if ! uptodate
 then
        for dir in $PATH
        do
                for file in &quot;$dir&quot;/*
                do
                        test -x &quot;$file&quot; &amp;&amp; echo &quot;${file##*/}&quot;
                done
        done | sort | uniq &gt; $CACHE.$$
        mv $CACHE.$$ $CACHE
 fi
 cat $CACHE

== Stylizing awesome-menu ==

The awesome-menu stylized using the .awesomerc. When calling awesome-menu, a label can be defined, and awesome-menu uses this to stylize the menu.

  menu Run:  
  {
    styles
    {
        normal { 
          bg = &quot;#0a0a0a&quot; 
          fg = &quot;#a0a0a0&quot; 
          shadow = &quot;#111111&quot; 
          shadow_offset = &quot;1&quot; 
        }
        focus { 
          bg = &quot;#285577&quot; 
          fg =&quot;#ffffff&quot; 
          shadow = &quot;#111111&quot; 
          shadow_offset = &quot;1&quot; 
        }
    } 
    y = &quot;0&quot;
    x = &quot;180&quot;
    height = &quot;14&quot;
  }


== Slightly more advanced awesome-menu ==

Of course, the methods shown above don't look so nice when you want to run 'xterm -bg yellow -fg white', so a simple shell script wrapper can be written:

  #!/bin/bash
  ####
  #
  # awesome-menu-builder - Simple shell script to build menus for 
  # awesome-menu.
  #
  # Concept from http://www.calmar.ws/tmp/dmenu_do
  #
  ####
  
  # build your menu here with whatever simple names you want to use
  MENU=&quot;rxvt
  firefox
  pidgin
  xfe
  vim
  mutt
  logout
  &quot;
  # display the menu and yank the choice made
  CHOICE=$(awesome-menu &lt;&lt;&lt; &quot;${MENU}&quot; &quot;Run: &quot;)
  # parse the choice
  case ${CHOICE%% *} in
      # you only need to put lines here for what you want to run
      # differently than the rest
      rxvt)
          awesome-client &lt;&lt;&lt; &quot;0 spawn rxvt -fg white -bg black&quot;
      ;;
      logout)
          awesome-client &lt;&lt;&lt; &quot;0 quit&quot;
      ;;
      vim|mutt)
          awesome-client &lt;&lt;&lt; &quot;0 spawn rxvt -fg white -bg black -e '${CHOICE}'&quot;
      ;;
      *)
         awesome-client &lt;&lt;&lt; &quot;0 spawn ${CHOICE}&quot;
      ;;
  esac

== An even more advanced awesome-menu ==

Copy this script (name to something like awesome_launch), modify the command sets as you please, then use as follows:

  key 
  {   
      modkey = {&quot;Mod1&quot;}
      key = &quot;F11&quot;
      command = &quot;spawn&quot;
      arg = &quot;exec awesome_launch prog&quot;
  }
  key 
  {   
      modkey = {&quot;Mod1&quot;}
      key = &quot;F12&quot;
      command = &quot;spawn&quot;
      arg = &quot;exec awesome_launch mpc&quot;
  }

  #!/usr/bin/python
  
  import os, sys, shlex, commands
  
  #rxvt = 'urxvt';
  rxvt = 'urxvtc';
  #rxvt = 'rxvt';
  
  # cmd set sort directive
  YES_SORT = True
  NO_SORT = False
  
  # cmd set field index
  SORT = 0
  TEXT = 1
  CMDS = 2
  
  cmdSet = \
  {
    &quot;prog&quot;:
    [
      YES_SORT,
      &quot;Whazup&quot;,
      [
        [ &quot;rxvt&quot;,    rxvt + &quot; -title rxvt -tr -tint black -sh 50 -e bash -li&quot; ],
        [ &quot;scr&quot;,     rxvt + &quot; -title screen +sb -e screen -dR&quot; ],
        [ &quot;remote&quot;,  rxvt + &quot; -title insanum +sb -tr -tint black -sh 50 -e ssh -Y -t foo\@bar.com screen -dR&quot; ],
        [ &quot;mocp&quot;,    rxvt + &quot; -title mocp -e mocp&quot; ],
        [ &quot;fox&quot;,     &quot;firefox&quot; ],
        [ &quot;fox3&quot;,    &quot;firefox3&quot; ],
        [ &quot;opera&quot;,   &quot;opera&quot; ],
        [ &quot;wire&quot;,    &quot;sudo wireshark&quot; ],
        [ &quot;xchm&quot;,    &quot;xchm&quot; ],
        [ &quot;xpdf&quot;,    &quot;xpdf&quot; ],
        [ &quot;acro&quot;,    &quot;acroread&quot; ],
        [ &quot;emel&quot;,    &quot;emelfm2&quot; ],
        [ &quot;rpd&quot;,     &quot;rdesktop -T windows -g 80% -K -0 -u Administrator -p whatever somehost&quot; ],
      ]
    ],
  
    &quot;mpc&quot;:
    [
      NO_SORT,
      &quot;MPC&quot;,
      [
        [ &quot;play&quot;,   &quot;mpc play&quot; ],
        [ &quot;stop&quot;,   &quot;mpc stop&quot; ],
        [ &quot;next&quot;,   &quot;mpc next&quot; ],
        [ &quot;prev&quot;,   &quot;mpc prev&quot; ],
        [ &quot;pause&quot;,  &quot;mpc toggle&quot; ],
        [ &quot;repeat&quot;, &quot;mpc repeat&quot; ],
        [ &quot;random&quot;, &quot;mpc random&quot; ],
        [ &quot;sf&quot;,     &quot;mpc seek +10&quot; ],
        [ &quot;sb&quot;,     &quot;mpc seek -10&quot; ],
        [ &quot;info&quot;,   &quot;mpc | dzen2 -l 5 -p -w 500 -ta l -bg darkblue -fg yellow -x 100 -y 100 -e 'onstart=uncollapse;button1=exit;button2=exit;button3=exit;'&quot; ],
        [ &quot;ncmpc&quot;,  rxvt + &quot; -title mpc -e ncmpc&quot; ],
        [ &quot;sonata&quot;, &quot;sonata&quot; ],
        [ &quot;gmpc&quot;,   &quot;gmpc&quot; ],
      ]
    ],
  
    #&quot;mocp&quot;:
    #[
    #  NO_SORT,
    #  &quot;MOCP&quot;,
    #  [
    #    [ &quot;play&quot;,  &quot;mocp --play&quot; ],
    #    [ &quot;stop&quot;,  &quot;mocp --stop&quot; ],
    #    [ &quot;next&quot;,  &quot;mocp --next&quot; ],
    #    [ &quot;prev&quot;,  &quot;mocp --previous&quot; ],
    #    [ &quot;pause&quot;, &quot;mocp --toggle-pause&quot; ],
    #    [ &quot;info&quot;,  &quot;mocp --info | dzen2 -l 10 -p -w 1000 -ta l -bg darkblue -fg yellow -x 100 -y 100 -e 'onstart=uncollapse;button1=exit;button2=exit;button3=exit;'&quot; ],
    #    [ &quot;exit&quot;,  &quot;mocp --exit&quot; ],
    #    [ &quot;mocp&quot;,  rxvt + &quot; -title mocp -e mocp&quot; ],
    #  ]
    #],
  }
  
  if len(sys.argv) != 2:
      sys.exit(1)
  
  set = sys.argv[1]
  
  if cmdSet[set][SORT] == YES_SORT:
      cmdSet[set][CMDS].sort(key=lambda x: x[0])
  
  cmdNames = ''
  for c in cmdSet[set][CMDS]:
     cmdNames += c[0] + '\n'
  
  pipe = os.popen('echo -n -e &quot;' + cmdNames + '&quot; | awesome-menu &quot;' + cmdSet[set][TEXT] + '&quot;', 'r')
  name = pipe.read().strip().rstrip()
  pipe.close()
  
  for c in cmdSet[set][CMDS]:
      if c[0] == name:
          #os.system(c[1])
          tmp = shlex.split(c[1])
          pid = os.fork()
          if not pid:
              os.execvp(tmp[0], tmp)

== awesome-menu with history ==

This script makes the menu store history in ~/.awesome-history, and can include all the commands from the debian menu system too.

http://git.kitenet.net/?p=joey/home.git;a=blob;f=bin/awesome-prompt

[[Category:Awesome2]]</text>
      <sha1>e9iutf153q5l48dlnyt5z6po1g8mdff</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-message 2.x</title>
    <ns>0</ns>
    <id>250</id>
    <revision>
      <id>2928</id>
      <parentid>2926</parentid>
      <timestamp>2009-06-25T15:04:22Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="1508">{{Languages}}

'''This is the man page of awesome-client version 2.3.4, compatible with all versions 2.3.x. It can also be used for a big part with previous versions 2.0.x and 2.1.x, but you may read their own man pages for some differences they have.'''



&lt;H1&gt;AWESOME-MESSAGE&lt;/H1&gt;
Section:  (1)

&lt;H2&gt;NAME&lt;/H2&gt;

awesome-message - awesome message window

&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

awesome-message [-x xcoord] [-y ycoord] [-d delay] &amp;lt;message&amp;gt; &amp;lt;icon&amp;gt;

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

awesome-message is a tool which will pop up a simple X window with a message and optionally an icon in front of it.

&lt;H2&gt;USAGE&lt;/H2&gt;

To have a popup when you have new mail, you can do something like that:


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
awesome-message &amp;quot;You have new mails!&amp;quot; ~/.awesome/icons/newmail.png
&lt;/PRE&gt;

&lt;/DL&gt;

&lt;H2&gt;OPTIONS&lt;/H2&gt;

-x xcoord
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set x coordinate of the window.
&lt;/DL&gt;

-y ycoord
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set y coordinate of the window.
&lt;/DL&gt;

-d delay
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Close the window after &amp;lt;delay&amp;gt; seconds. Must be an integer greater than 0.
&lt;/DL&gt;

&amp;lt;message&amp;gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Print this message in the window.
&lt;/DL&gt;

&amp;lt;icon&amp;gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Draw this icon file in the window.
&lt;/DL&gt;

&lt;H2&gt;SEE ALSO&lt;/H2&gt;

awesome(1)

&lt;H2&gt;AUTHORS&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt;

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;

&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
mailto:julien@danjou.info
&lt;/DL&gt;

[[Category:Awesome2]]</text>
      <sha1>172i8zy0k7nu4emddr7y2e3dgiykn2c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-message 2.x/fr</title>
    <ns>0</ns>
    <id>242</id>
    <revision>
      <id>2931</id>
      <parentid>2929</parentid>
      <timestamp>2009-06-25T15:04:45Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="2316">{{Languages|Awesome-message 2.x}}

'''Ceci est la page de manuel de awesome-message version 2.3.4, valide pour toutes les versions 2.3.x. Elle est utilisable aussi pour une grande part avec les versions précédentes 2.0.x et 2.1.x, mais, pour les quelques différences qu'il y a, veuillez consulter les pages de manuel de ces versions.  '''


&lt;H1&gt;AWESOME-MESSAGE&lt;/H1&gt;
Section:  (1)

&lt;H2&gt;NOM&lt;/H2&gt;

awesome-message - fenêtre de message de awesome

&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

awesome-message [-x xcoord] [-y ycoord] [-d delay] &amp;lt;message&amp;gt; &amp;lt;icon&amp;gt;

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

awesome-message est un outil qui fait apparaître une fenêtre X avec un message et optionellement une icône en face de lui.

&lt;H2&gt;UTILISATION&lt;/H2&gt;

Pour faire apparaître une fenêtre lorsque vous avez un nouveau courriel, vous pouvez faire quelquechose comme ça :


&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
&lt;PRE&gt;
awesome-message &amp;quot;Vous avez de nouveaux messages!&amp;quot; ~/.awesome/icons/newmail.png
&lt;/PRE&gt;

&lt;/DL&gt;

&lt;H2&gt;OPTIONS&lt;/H2&gt;

-x xcoord
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Définit la coordonnée horizontale de la fenêtre.
&lt;/DL&gt;

-y ycoord
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Définit la coordonnée verticale de la fenêtrew.
&lt;/DL&gt;

-d delay
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Ferme la fenêtre après le délai &amp;lt;delay&amp;gt; en secondes. Ce paramètre doit être un nombre entier supérieur à 0.
&lt;/DL&gt;

&amp;lt;message&amp;gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche ce message dans la fenêtre.
&lt;/DL&gt;

&amp;lt;icon&amp;gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche ce fichier d'icône dans la fenêtre.
&lt;/DL&gt;

&lt;H2&gt;VOIR AUSSI&lt;/H2&gt;

awesome(1)

&lt;H2&gt;AUTEUR&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt;

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;P&gt;

&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
courriel : mailto:julien@danjou.info
&lt;/DL&gt;

&lt;H2&gt;TRADUCTION&lt;/H2&gt;

Ce document est une traduction, réalisée par Jean-Luc Duflot &amp;lt;jl&amp;nbsp;POING&amp;nbsp;duflot&amp;nbsp;CHEZ&amp;nbsp;laposte&amp;nbsp;POING&amp;nbsp;net&amp;gt; le 2&amp;nbsp;novembre&amp;nbsp;2008.

L'équipe de traduction a fait le maximum pour réaliser une adaptation française de qualité.
La version anglaise la plus à jour de ce document est toujours consultable via la commande&amp;nbsp;: LANGUAGE=en man awesome-message. N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute erreur dans cette page de manuel.

[[Category:Awesome2]]</text>
      <sha1>nsxpkzcn1xfmn6rwjqgv73by2nbsz91</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-message 2.x (en)</title>
    <ns>0</ns>
    <id>378</id>
    <redirect title="Awesome-message 2.x" />
    <revision>
      <id>2927</id>
      <timestamp>2009-06-25T15:04:08Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome-message 2.x (en)]] to [[Awesome-message 2.x]]</comment>
      <text xml:space="preserve" bytes="33">#REDIRECT [[Awesome-message 2.x]]</text>
      <sha1>iqq0g3gvjr7qmhheuh9c8c6ikru6p8o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome-message 2.x (fr)</title>
    <ns>0</ns>
    <id>379</id>
    <redirect title="Awesome-message 2.x/fr" />
    <revision>
      <id>2930</id>
      <timestamp>2009-06-25T15:04:30Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome-message 2.x (fr)]] to [[Awesome-message 2.x/fr]]</comment>
      <text xml:space="preserve" bytes="36">#REDIRECT [[Awesome-message 2.x/fr]]</text>
      <sha1>flscf1q8587o25fk837gw5goxqgb52s</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome2's client zoom in Awesome3</title>
    <ns>0</ns>
    <id>141</id>
    <revision>
      <id>1248</id>
      <timestamp>2008-10-15T16:16:50Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="509">Awesome2's client_zoom would replace the current master with the client that had focus and back again.

I ''think'' this is missing in Awesome3, so I implemented it in lua:

&lt;pre&gt;
keybinding({ modkey }, &quot;Return&quot;, 
    function () 
        if  client.focus == awful.client.master() then
            awful.client.focus.history.previous()
        end
        client.focus:swap(awful.client.master()) 
    end):add()
&lt;/pre&gt;

Enjoy.

--[[User:Cciulla|Cciulla]] 12:41, 11 September 2008 (UTC)

[[Category:Awesome3]]</text>
      <sha1>irjrjplimmssel11ze0vytneu0z5ruj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.0 to 3.1</title>
    <ns>0</ns>
    <id>190</id>
    <revision>
      <id>6044</id>
      <parentid>3440</parentid>
      <timestamp>2013-06-12T02:42:47Z</timestamp>
      <contributor>
        <username>Kardan</username>
        <id>3021</id>
      </contributor>
      <minor/>
      <comment>+cat</comment>
      <text xml:space="preserve" bytes="3154">{{Template:Languages|Awesome 3.0 to 3.1}}
The purpose of this page is to list changes that need to be done in order to use a configuration working with Awesome 3.0 in the new Awesome 3.1 release. This should ease the transition for those not wanting to start over with the default config but rather have quick glance at what sections of their old config to change.

'''Feel free to change and move anything you see fit.'''


== Required changes ==

==== statusbar ====
Statusbar objects no longer exist and you have to be replace this old code
 mystatusbar = statusbar({
     position    = &quot;top&quot;,
     fg          = beautiful.fg_normal,
     bg          = beautiful.bg_normal
 })
with the following new one
 mystatusbar = wibox({
     position    = &quot;top&quot;,
     fg          = beautiful.fg_normal,
     bg          = beautiful.bg_normal
 })

Also, the syntax for adding widget changed. Replace
 mystatusbar:widgets({ foo })
with
 mystatusbar.widgets = { foo }

==== taglist ====
In 3.0 the taglist was a capi widget which has now changed since it is now implemented in lua. The new taglist has the following form
 mytaglist = awful.widget.taglist.new(screen, taglabel_function, button_table)
where you can choose one of
* awful.widget.taglist.label.noempty 
* awful.widget.taglist.label.all
The button_table looks as follows
 mybuttons = {
     button({      }, 1, awful.tag.viewonly),
     button({modkey}, 1, awful.client.movetotag),
     button({      }, 3, function (tag) tag.selected = not tag.selected end),
     button({modkey}, 3, awful.client.toggletag)
 }

==== tasklist ====
The tasklist has gotten the same treatment as the taglist. The new way of creating it is therefore:

 mytasklist = awful.widget.tasklist.new(tasklist_function, button_table)

Or in an example using one of the predefined tasklist functions

 mybuttons = {
    button({}, 1, function (c) client.focus = c; c:raise() end),
 }
 mytasklist = awful.widget.tasklist.new(function(c) return awful.widget.tasklist.label.currenttags(c, s) end, config.widgets.tasklists.buttons)



== Optional changes ==

==== hooks ====

In 3.0 the hooks were defined as simple functions and then registered using
 function hook_focus(c)
     ...
 end
 awful.hooks.focus.register(hook_focus)
in 3.1 hooks are created the same way keybindings were done
 awful.hooks.focus.register(function (c)
     ...
 end)

==== squares in taglist ====
If you use own theme file, you may notice, that there are new ''taglist_squares'' options:
 taglist_squares_sel = /usr/share/awesome/themes/default/taglist/squarefw.png
 taglist_squares_unsel = /usr/share/awesome/themes/default/taglist/squarew.png

==== image widget ====
Previously displaying an image was done by creating a text widget and setting the text to display the desired image. This is still possible but there is now a special image widget.
So instead of
 myimage       = widget({ type = &quot;textbox&quot;, align = &quot;right&quot; })
 myimage.text  = &quot;&lt;bg image='/path/to/image.png'/&gt;&quot;
now it is possible to use
 myimage       = widget({ type = &quot;imagebox&quot;, align = &quot;right&quot; })
 myimage.image = image(&quot;/path/to/image.png&quot;)

[[Category:Awesome3]]
[[Category:Config]]</text>
      <sha1>0h2y75dkttvlgweefc1x6yt9x886k6t</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.0 to 3.1/ru</title>
    <ns>0</ns>
    <id>455</id>
    <revision>
      <id>3435</id>
      <parentid>3429</parentid>
      <timestamp>2009-08-14T16:57:36Z</timestamp>
      <contributor>
        <username>Atragor</username>
        <id>120</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="3159">{{DISPLAYTITLE: Переход с Awesome 3.0 на Awesome 3.1}}
{{Template:Languages|Awesome 3.0 to 3.1}}
Цель этой страницы - предоставить список изменений, которые необходимо будет сделать, чтобы файл конфигурации Awesome 3.0 заработал в Awesome 3.1. Это должно облегчить переход для тех пользователей, которые предпочитают модифицировать свой файл конфигурации вместо использования стандартного.


== Обязательные изменения ==

==== statusbar ====
Объекты типа statusbar больше не существуют, поэтому старый код
 mystatusbar = statusbar({
     position    = &quot;top&quot;,
     fg          = beautiful.fg_normal,
     bg          = beautiful.bg_normal
 })
нужно заменить новым
 mystatusbar = wibox({
     position    = &quot;top&quot;,
     fg          = beautiful.fg_normal,
     bg          = beautiful.bg_normal
 })

Также изменился синтаксис для добавления виджета. Замените
 mystatusbar:widgets({ foo })
на
 mystatusbar.widgets = { foo }

==== taglist ====
В версии 3.1 виджет taglist переписан на Lua. Новый виджет создаётся в следующей форме
 mytaglist = awful.widget.taglist.new(screen, taglabel_function, button_table)
можно выбирать один из
* awful.widget.taglist.label.noempty 
* awful.widget.taglist.label.all
Таблица button_table имеет вид
 mybuttons = {
     button({      }, 1, awful.tag.viewonly),
     button({modkey}, 1, awful.client.movetotag),
     button({      }, 3, function (tag) tag.selected = not tag.selected end),
     button({modkey}, 3, awful.client.toggletag)
 }

==== tasklist ====
Виджет tasklist подвергся тем же изменениям, что и taglist. Поэтому новый способ его создания:

 mytasklist = awful.widget.tasklist.new(tasklist_function, button_table)

Или можно использовать одну из предопределённых функций tasklist

 mybuttons = {
    button({}, 1, function (c) client.focus = c; c:raise() end),
 }
 mytasklist = awful.widget.tasklist.new(function(c) 
                                          return awful.widget.tasklist.label.currenttags(c, s) 
                                        end, 
                                        config.widgets.tasklists.buttons)

== Необязательные изменения ==

==== hooks (ловушки) ====

В версии 3.0 ловушки определялись как обычные функции и затем регистрировались с помощью функции
 function hook_focus(c)
     ...
 end
 awful.hooks.focus.register(hook_focus)
В версии 3.1 ловушки создаются так же, как привязки клавиш
 awful.hooks.focus.register(function (c)
     ...</text>
      <sha1>5w36m7wuu2y3o98mcn3waukgn3nt3qn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.3 to 3.4</title>
    <ns>0</ns>
    <id>468</id>
    <revision>
      <id>6042</id>
      <parentid>6040</parentid>
      <timestamp>2013-06-12T02:40:19Z</timestamp>
      <contributor>
        <username>Kardan</username>
        <id>3021</id>
      </contributor>
      <minor/>
      <comment>+cat</comment>
      <text xml:space="preserve" bytes="6928">=== Window management layouts ===
Most noticeable change is that ''floating'' layout is now used on all tags by default. You can change the default for all tags with a simple modification of ''rc.lua''. Tag section is near the top of the default ''rc.lua'' and tags are setup like this:
  -- Each screen has its own tag table.
  tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s)

To have the ''tile'' layout on all tags, you can change that to:
  -- Each screen has its own tag table.
  tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s, awful.layout.suit.tile)

In awesome '''3.4.1''' layout argument can also be a table, and the following example also shows how to name your tags:
  -- Each screen has its own tag table.
  tags[s] = awful.tag({ &quot;one&quot;, &quot;www&quot;, &quot;irc&quot;, 4, 5, 6, 7, 8, 9}, s,
  { layouts[2], layouts[1], layouts[1],          -- Tags: 1, 2, 3
    layouts[5], layouts[6], layouts[2],          --       4, 5 ,6
    layouts[2], layouts[1], layouts[3]           --       7, 8, 9
  })

In awesome '''3.4.3''' layout argument is set to ''layouts[1]'' by default, and the first layout in the layouts table is floating. Changing the default layout is a matter of reordering your layouts table.

If you are wondering why floating is the default layout, know that awesome is trying to go past the &quot;tiling window manager&quot; label. Maybe it's not in the same category as ''openbox'' but it also doesn't fit in the same drawer as ''wmii'' or ''subtle''. It is probably closest to ''fvwm'', at least by philosophy of being a frame-work window manager. If you are not convinced it's best to read what the lead developer has to say about it: [http://julien.danjou.info/blog/2009/taking-the-other-direction Taking the other direction].

=== Widget Layouts ===

One of the bigger changes in awesome from version 3.3 to 3.4 is the introduction of widget layouts. These allow controlling the placement of widgets from Lua, to a much bigger degree than with the &quot;old&quot; .align property on widgets.

==== How do they work? ====

Each widget table has a .layout field. This field points to a function which takes a table containing widgets and the area these widgets should be placed in as its parameters and returns a table containing geometries (i.e. width, height, x and y position) for all widgets. That function is simply called with the widget table as its argument. Sounds simple, right? Well, it is :)

==== How do I use them? ====

First, remove all .align properties from your widgets, they are no longer effective. Then, put widgets which had the same .align into tables and set the tables .layout field to the right layout function (these are described below). Put these tables into the widgets table of your wibox and set its layout field accordingly.

Make sure that your tasklist widget is the last one in the widgets table, because it uses the flex layout by default.

==== Which layouts are available? ====

At the moment, the following widget layouts are available:
; awful.widget.layout.horizontal.leftright:
: places all widgets it contains left to right onto the wibox. Similar to the old .align = &quot;left&quot;

; awful.widget.layout.horizontal.rightleft:
: like the previous, only places the widgets right to left. Similar to .align = &quot;right&quot;, although the order of widgets is inverted, i.e. the widget which appears first in a table with .layout = awful.widget.layout.horizontal.rightleft is placed rightmost

; awful.widget.layout.horizontal.flex:
: similar to the old .align = &quot;flex&quot;, but it needs to be placed ''last'' in the widget table, as it uses all horizontal space it has available at its point of execution.

; awful.widget.layout.vertical.flex:
: similar to the horizontal flex layout, this layout places widgets on top of each other, which for example allows stacking an imagebox and a textbox on top of each other to form an icon with caption.

=== Widgets ===
Progressbar and graph widgets are now implemented in Lua, and C widgets are deprecated (to be removed in the next awesome release). You can create progressbars and graphs by calling ''awful.widget.progressbar'' and ''awful.widget.graph''.

Using the old C API
    mygraphwidget = widget({ type = &quot;graph&quot;, name = &quot;mygraphwidget&quot;, align = &quot;right&quot; })
    mypbarwidget  = widget({ type = &quot;progressbar&quot;, name = &quot;mypbarwidget&quot;, align = &quot;right&quot; })
Using awful.widget
    mygraphwidget = awful.widget.graph()
    mypbarwidget  = awful.widget.progressbar()
When putting the widget in your wibox, make sure to access the actual widget, which is stored in the .widget field:
    mytextclock,
    mygraphwidget.widget,
    mypbarwidget.widget,
Check the respective API docs for the [http://awesome.naquadah.org/doc/api/modules/awful.widget.graph.html graph] and [http://awesome.naquadah.org/doc/api/modules/awful.widget.progressbar.html progressbar] widgets to learn the new settings.

=== Invaders ===
After the ''Awesome User Survey'' was completed it was decided that ''Invaders'' will not be a part of the standard awesome distribution.

=== Timers ===

Awesome 3.4 has a new Lua [http://awesome.naquadah.org/doc/api/modules/timer.html timer] object. This new timer API is the preferred way to schedule periodic events; the old awful.hooks.timer has been deprecated.

Update your old code from
 -- Hook called every 30s
 awful.hooks.timer.register(30, function() mytextbox.text = foo() end)
to
 mytimer = timer({ timeout = 30 })
 mytimer:add_signal(&quot;timeout&quot;, function() mytextbox.text = foo() end)
 mytimer:start()

=== D-Bus ===

The dbus name has changed from ''org.awesome.'' to '''org.naquadah.awesome'''


=== Signals ===

Awesome 3.4 introduces a new way to manage events. It replaces the old hook system and some other functions like widget.mouse_enter

Instead of:
  mytextbox.mouse_leave = function ()
      --CODE
  end

Use:
  mytextbox:add_signal(&quot;mouse::leave&quot;, function ()
      --CODE
  end)

=== Buttons ===
Syntax went through little changes.

Old:
  mytextbox:buttons({
    button({ }, 1, function()
        --CODE
    end
  })



New:
  mytextbox:buttons(awful.util.table.join(
    awful.button({ }, 1, function()
        --CODE
    end)
  ))

=== Client rules ===
Application specific behaviour (previously defined in two tables; ''floatapps'' and ''apptags'') was replaced by the '''awful.rules''' module. All rules are now defined in the ''awful.rules.rules'' table, and syntax is documented [http://awesome.naquadah.org/doc/api/modules/awful.rules.html#rules here].

=== Themes ===
'''Zenburn''' theme is now a part of the standard awesome distribution, in addition to the old themes; ''default'' and ''sky''.

'''*Bug in 3.4.11*''': If your theme.lua was broken upon upgrading to 3.4.11, it could be because ''wallpaper_cmd'' requires a table. The bug is already fixed in awesome-git. Meanwhile you can get your theme working again by using the line:
  theme.wallpaper_cmd = { 42 }

[[Category:Awesome3.4]]
[[Category:Config]]</text>
      <sha1>tpopasnuke813m0zjfexxyhubxqij62</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.4 to 3.5</title>
    <ns>0</ns>
    <id>777</id>
    <revision>
      <id>6167</id>
      <parentid>6043</parentid>
      <timestamp>2013-11-10T23:39:26Z</timestamp>
      <contributor>
        <username>I5513</username>
        <id>3100</id>
      </contributor>
      <comment>/* Signals */</comment>
      <text xml:space="preserve" bytes="8008">This page summarizes changes which Awesome has undergone between 3.4 and 3.5. You should use it as a guideline for updating your widgets and configuration files.

If you want to test your config without restarting (and potentially breaking) your current running instance of awesome, you can use [[Using Xephyr|Xephyr]].

== New Runtime-Only Dependency ==

Awesome 3.5 uses [https://github.com/pavouk/lgi LGI] for accessing some libraries. This package provides ''Lua GObject Introspection'', which is used for accessing the Cairo and Pango libraries.

However, this a not a build dependency, which means that building and installing Awesome may still succeed even if you don't have LGI installed. This makes it easy to miss this dependency.

If you are unsure whether you have LGI and the needed introspection files, you can run the following command:

 $ lua -e 'lgi = require(&quot;lgi&quot;) print(lgi.cairo, lgi.Pango, lgi.PangoCairo)'
 table: 0xe74160    table: 0xf40830    table: 0xf168e0

The above is what this looks like if everything goes well. However, if you don't have lgi, you will see an error message like this:

 $ lua -e 'lgi = require(&quot;lgi&quot;) print(lgi.cairo, lgi.Pango, lgi.PangoCairo)'
 lua: (command line):1: module 'lgi' not found:
 [long error message here]

Please note that you need LGI 0.6.1 or newer, because older versions don't have the necessary Cairo bindings. The above test should detect whether this is a problem.

===Ubuntu 13.04 (raring)===

To perform the above test on Ubuntu, you will need to have the lua interpreter installed:

 $ sudo apt-get install lua5.2

To pull all the required runtime dependencies (''LGI'' and the necessary typelibs for ''pango'' and ''cairo'') using apt, the following command should do the trick (note that the cairo introspection stuff gets pulled as a dependency):

 $ sudo apt-get install lua-lgi gir1.2-pango-1.0

== Lua 5.2 Compatibility ==

In Lua 5.2, the '''module()''' function was deprecated. This has an effect on user configs. You now have to explicitely assign modules to variables when you load them:

 naughty = require(&quot;naughty&quot;)

== Signals ==

You should replace all calls of the '''add_signal''' function with '''connect_signal'''. Similarly, '''remove_signal''' becomes '''disconnect_signal'''.

To do signal and module() replacements and keep backup of awesome config this snippet can be handy:
&lt;pre&gt;
export AWCONF=/etc/xdg/awesome/rc.lua; \
for pattern in 's/add_signal/connect_signal/' 's/remove_signal/disconnect_signal/' \
's/^require\(&quot;(naughty|beautiful|awful)&quot;\)/\1 = \0/'; \
do sed -r &quot;$pattern&quot; &lt; $AWCONF &gt; $AWCONF.new;done
&lt;/pre&gt;
(in case there is a better way or place to put this, please go ahead --[[User:Kardan|Kardan]])&lt;br&gt;
If Kardan recommendation is true, and generalizing last pattern, the code should be:
&lt;pre&gt;
export AWCONF=/etc/xdg/awesome/rc.lua; \
sed -i.bak -r -e 's/add_signal/connect_signal/' \
              -e 's/remove_signal/disconnect_signal/' \
              -e 's/^require\(&quot;([^&quot;]*)&quot;\)/\1 = \0/' $AWCONF
&lt;/pre&gt;

== &quot;widget&quot; Library Changes ==

=== &quot;widget&quot; Library Replacement ===
There is no longer a thing like '''widget''' in the API, so different widgets which were provided by its '''type''' parameter can be found in different places.

One of them is a new module named '''wibox'''. Please note that wibox is no longer a part of the standard API, so you need to ''require(&quot;wibox&quot;)'' to use it.

;textbox
:Migrated to '''wibox.widget.textbox()'''
;imagebox
:Migrated to '''wibox.widget.imagebox()'''
;systray
:Migrated to '''wibox.widget.systray()'''

=== Textbox Text Assignment ===
You should no longer simply assign text to the '''text''' property of the textbox widget. Instead you should use the following functions:

;&lt;nowiki&gt;yourbox:set_markup(text)&lt;/nowiki&gt;
:Set the text content, with support for pango markup.
;&lt;nowiki&gt;yourbox:set_text(text)&lt;/nowiki&gt;
:Set the text content, with no pango markup.

=== Imagebox Image Assignment ===
Similar things apply to the imagebox. However, you can now also give a file name to the imagebox widget directly.

;&lt;nowiki&gt;box:set_image(image)&lt;/nowiki&gt;

== &quot;awful&quot; Library Changes ==

=== awful.taglist ===

The second argument to awful.widget.taglist, the tags labels should now be accessed using a widget taglist filter method.

The old default config did this : 

    mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.label.all, mytaglist.buttons)

Now : 

    mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.filter.all, mytaglist.buttons)


=== awful.tasklist ===
The first argument to ''awful.widget.tasklist'' is now the screen that the tasklist is for.

The old default config did this:

     mytasklist[s] = awful.widget.tasklist(function(c) return awful.widget.tasklist.label.currenttags(c, s) end, mytasklist.buttons)

The new default config instead creates its tasklist like this:

    mytasklist[s] = awful.widget.tasklist(s, awful.widget.tasklist.filter.currenttags, mytasklist.buttons)

=== awful.menu ===
'''awful.menu''' module has undergone a lot of changes. One of them is the modified method of setting the size of the entries. You no longer set it as:

   mymenu = awful.menu({ items = { ..... },
                         width = 300, height = 30 })

but it is rather like:

   mymenu = awful.menu({ items = { ...... },
                         theme = { width = 300, height = 30 } })

=== awful.menu_keys ===
A new key &lt;code&gt;enter&lt;/code&gt; has been added to &lt;code&gt;awful.menu_keys&lt;/code&gt;. So if you redefine the default &lt;code&gt;menu_keys&lt;/code&gt; in your &lt;code&gt;rc.lua&lt;/code&gt;, you will need to update it to include the new entry, like this:

 awful.menu.menu_keys = { up    = { &quot;k&quot;, &quot;Up&quot; },
                          down  = { &quot;j&quot;, &quot;Down&quot; },
                          exec  = { &quot;l&quot;, &quot;Return&quot;, &quot;Right&quot; },
                          -- the new item
                          enter = { &quot;Right&quot; },
                          --
                          back  = { &quot;h&quot;, &quot;Left&quot; },
                          close = { &quot;q&quot;, &quot;Escape&quot; },
                        }

== Writing Your Own Widgets ==

There is a separate guide which explains how to implement your own widgets. It can be found [[Writing own widgets|here]].

== Small Prettifications ==

=== Gradients ===
You may think that widget gradients for, say, progressbars are not supported in 3.5. '''False!'''

Now it is just one kind of ''pattern'', which can be used as a background or foreground colour, or indeed any colour except for window borders. See the [http://awesome.naquadah.org/doc/api/modules/gears.color.html gears.color] module documentation for details.

For example, where previously you had the following:

  cpubar:set_gradient_colors({ &quot;#ff0000&quot;, &quot;#00ff00&quot;, &quot;#0000ff&quot; })

With 3.5 you would do this instead:

  cpubar:set_color({ type = &quot;linear&quot;, from = { 0, 0 }, to = { 0, 20 }, stops = { { 0, &quot;#ff0000&quot; }, { 0.5, &quot;#00ff00&quot; }, { 1, &quot;#0000ff&quot; } }})

For more information about linear (and other) gradients in cairo, you can take a look at [http://kapo-cpp.blogspot.de/2008/01/gradients-in-cairo.html] and [http://zetcode.com/gfx/cairo/gradients/].

=== Widget Borders ===
Indeed, there's no &lt;code&gt;textbox.border_width = 1&lt;/code&gt; or anything similar in 3.5 (as of Dec 10th 2012). [http://bpaste.net/show/IIBSq19KrGHwBbGFAUHN/ Here]'s what [[User:psychon|psychon]] has to say about implementing it yourself; [[Writing own widgets|this page]] describes the functions used there.

== Updating Your rc.lua via 3-Way Merge ==

If your ''rc.lua'' for 3.4 isn't terribly different from the default version, you can use a three-way merging tool like [http://kdiff3.sourceforge.net/ kdiff3] (Qt) or [http://meldmerge.org/ meld] (GTK):

 $ kdiff3 stock_3.4_rc.lua your_3.4_rc.lua stock_3.5_rc.lua -o your_3.5_rc.lua

or

 $ meld stock_3.4_rc.lua your_3.4_rc.lua stock_3.5_rc.lua

It will detect changes made to the config since 3.4.x, both by you and Awesome developers, and help you merge them into a new version.

[[Category:Awesome3.5]]
[[Category:Config]]</text>
      <sha1>g1praar8bqztu9gifb8au5kef5a25rc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.4 to 3.5/ru</title>
    <ns>0</ns>
    <id>1027</id>
    <revision>
      <id>6391</id>
      <parentid>6390</parentid>
      <timestamp>2014-04-30T16:43:20Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Замена библиотеки &quot;widget&quot; */</comment>
      <text xml:space="preserve" bytes="11561">{{Languages|Awesome 3.4 to 3.5}}

Эта страница суммирует изменения между Awesome 3.4 и 3.5. Вы можете использовать данное руководство для обновления своих виджетов и файлов конфигурации.
Если вы хотите проверить ваши файлы конфигурации без перезапуска (и возможных поломок) вашей текущей системы, можно использовать [[Using Xephyr/ru|Xephyr]]

== Новые зависимости Runtime-Only ==

Awesome 3.5 использует  [https://github.com/pavouk/lgi LGI] для доступа к некоторым библиотекам. Этот пакет называется ''Lua GObject Introspection'', он используется для доступа к библиотекам Cairo и Pango.

Однако, сборка awesome не зависит от LGI. Вы можете успешно собрать и установить Awesome, даже если не установлен LGI. Это позволяет пропустить эту зависимость.

Если вы не уверены, что LGI и необходимые файлы у вас есть, вы можете выполнить следующую команду:
&lt;pre&gt;
$ lua -e 'lgi = require(&quot;lgi&quot;) print(lgi.cairo, lgi.Pango, lgi.PangoCairo)'
 table: 0xe74160    table: 0xf40830    table: 0xf168e0
 &lt;/pre&gt;

Написанное выше, означает, что все отлично. Однако, если lgi у вас не стоит, вы увидите сообщение подобное описаному ниже:
&lt;pre&gt;
 $ lua -e 'lgi = require(&quot;lgi&quot;) print(lgi.cairo, lgi.Pango, lgi.PangoCairo)'
  lua: (command line):1: module 'lgi' not found:
  [здесь будет большой список]
&lt;/pre&gt;

Обратите внимание, что вам требуется LGI 0.6.1 или более новый, потому что предыдущие версии не содержат необходимых зависимостей Cairo. Вышеописанный тест, позволяетизбежать этих проблем.

===Ubuntu 13.04 (raring)===

Для выполнения этого теста на Ubuntu, необходимо установить интерпретатор lua:
&lt;pre&gt;
 $ sudo apt-get install lua5.2
&lt;/pre&gt;

Чтобы не было неразрешенных зависимостей (&quot;LGI&quot; и все необходимые библиотеки &quot;pango&quot;  и &quot;cairo&quot;) используйте apt, следующая команда установить все необходимое (обратите внимание, что cairo устаноавливается как зависимость другого пакета):
&lt;pre&gt;
$ sudo apt-get install lua-lgi gir1.2-pango-1.0
&lt;/pre&gt;

== Совместимость Lua 5.2 ==

В Lua 5.2 была удалена функция '''module()'''. Поэтому предется переделывать конфигурационные файлы. Теперь необходимо явно присваивать модули глобальным переменным, при загрузке:

&lt;pre&gt; naughty = require(&quot;naughty&quot;) &lt;/pre&gt;

== Сигналы ==

Вам необходимо заменить все вызовы функции '''add_signal''' на '''connect_signal'''. Также необходимо заменить '''remove_signal''' на '''disconnect_signal'''.

Для замены сигналов и module(), предварительно сделайте резервную копию, можно использовать следующий код:
&lt;pre&gt;
export AWCONF=/etc/xdg/awesome/rc.lua; \
for pattern in 's/add_signal/connect_signal/' 's/remove_signal/disconnect_signal/' \
	's/^require\(&quot;(naughty|beautiful|awful)&quot;\)/\1 = \0/'; \
	do sed -r &quot;$pattern&quot; &lt; $AWCONF &gt; $AWCONF.new;done
&lt;/pre&gt;

(Если вы хотите найти лучший способ для модификации файла, попробуйте способ предложенный --[[User:Kardan|Kardan]])&lt;br&gt;
Если рекомендация от Kardan верна, то код должен выглядеть так:
&lt;pre&gt;
export AWCONF=/etc/xdg/awesome/rc.lua; \
sed -i.bak -r -e 's/add_signal/connect_signal/' \
              -e 's/remove_signal/disconnect_signal/' \
			  -e 's/^require\(&quot;([^&quot;]*)&quot;\)/\1 = \0/' $AWCONF
&lt;/pre&gt;

== Изменение библиотеки &quot;widget&quot; ==

=== Замена библиотеки &quot;widget&quot; ===

Теперь больше нет понятия '''widget''' в API, теперь параметры которые определяют различные виджеты, их '''type''' могут находиться в разных местах.
Один из них новый модуль, называемый '''wibox'''. Пожалуйста запомните, что wibox больше не часть стандарта API, поэтому используйте ''require(&quot;wibox&quot;)''.

;textbox
:Заменено на '''wibox.widget.textbox()'''
;imagebox
:Заменено на '''wibox.widget.imagebox()'''
;systray
:Заменено на '''wibox.widget.systray()'''

=== Textbox Текстовое значение ===
Теперь вы не можете больше просто присвоить текст свойству '''text''' текстового виджета. Вместо этого вы должны использовать следующую функцию:

;&lt;nowiki&gt;yourbox:set_markup(text)&lt;/nowiki&gt;
:Set the text content, with support for pango markup.
;&lt;nowiki&gt;yourbox:set_text(text)&lt;/nowiki&gt;
:Set the text content, with no pango markup.

=== Imagebox Значение изображения ===

То же самое относится и к imagebox. Теперь вы можете, непосредственно назначать файл(имя файла) виджету imagebox.

== Изменения в библиотеке &quot;awful&quot; ==

=== awful.taglist ===

Второй аргумент awful.widget.taglist, описывающий тэги(tags), теперь должен быть установлен используя методы фильтрации taglist.
В старых конфигурациях использовалось:
&lt;pre&gt;
    mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.label.all, mytaglist.buttons)
&lt;/pre&gt;
Теперь так:
&lt;pre&gt;       mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.filter.all, mytaglist.buttons)) &lt;/pre&gt;

=== awful.tasklist ===

Первый аргумент ''awful.widget.tasklist'' теперь является номером экрана на котором будет отображен tasklist.

Было:
&lt;pre&gt;
     mytasklist[s] = awful.widget.tasklist(function(c) return awful.widget.tasklist.label.currenttags(c, s) end, mytasklist.buttons)
&lt;/pre&gt;

Новая версия:
&lt;pre&gt;
    mytasklist[s] = awful.widget.tasklist(s, awful.widget.tasklist.filter.currenttags, mytasklist.buttons)
&lt;/pre&gt;

=== awful.menu ===
'''awful.menu''' один из модулей который претерпел существенные изменения. Одним из изменений является модификация размера меню. Теперь больше не нужно писать так:
&lt;pre&gt;
   mymenu = awful.menu({ items = { ..... },
                         width = 300, height = 30 })
&lt;/pre&gt;

Теперь эта запись выглядит так:
&lt;pre&gt;
   mymenu = awful.menu({ items = { ...... },
                         theme = { width = 300, height = 30 } })
&lt;/pre&gt;

=== awful.menu_keys ===
Добавлено новое ключевое слово '''enter''' в 'awful.menu_keys. Теперь если вы переопределяете значения по умолчанию 'menu_keys' в вашем 'rc.lua', вам необходимо обновить настройки под новые значения, следующим образом:

&lt;pre&gt;
 awful.menu.menu_keys = { up    = { &quot;k&quot;, &quot;Up&quot; },
                          down  = { &quot;j&quot;, &quot;Down&quot; },
						  exec  = { &quot;l&quot;, &quot;Return&quot;, &quot;Right&quot; },
						 -- the new item
						  enter = { &quot;Right&quot; },
						  --
						  back  = { &quot;h&quot;, &quot;Left&quot; },
						  close = { &quot;q&quot;, &quot;Escape&quot; },
						}
&lt;/pre&gt;

== Написание своих виджетов ==

Существует отдельное руководство, в котором Вы можете найти, как создавать свои собственные виджеты. Вы можете найти его [[Writing own widgets|здесь]].

== Small Prettifications ==

=== Градиенты ===

Вам может показаться, что градиентные виджеты, к примеру progressbars все еще не поддерживаются в 3.5, но... '''Теперь они поддерживаются!'''

Теперь есть один вид ''pattern'', который может устанавливать цвет переднего или заднего фона, или вообще любого цвета, за исключением границы окон. Вы можете ознакоиться с детальной информацией по [http://awesome.naquadah.org/doc/api/modules/gears.color.html gears.color]

Например, ранее необходимо было писать:
&lt;pre&gt;
  cpubar:set_gradient_colors({ &quot;#ff0000&quot;, &quot;#00ff00&quot;, &quot;#0000ff&quot; })
&lt;/pre&gt;

Вместо этого начиная с версии  3.5, необходимо писать так:
&lt;pre&gt;
  cpubar:set_color({ type = &quot;linear&quot;, from = { 0, 0 }, to = { 0, 20 }, stops = { { 0, &quot;#ff0000&quot; }, { 0.5, &quot;#00ff00&quot; }, { 1, &quot;#0000ff&quot; } }})
&lt;/pre&gt;

Дополнительные сведения о линейных(linear) и других видах графиентах в cairo, вы можете найти по ссылке [http://kapo-cpp.blogspot.de/2008/01/gradients-in-cairo.html] и [http://zetcode.com/gfx/cairo/gradients/].

=== Границы виджетов ===

Действительно, textbox.border_width = 1 или подобного в 3.5 (по состоянию на 10 декабря 2012) нет. [http://bpaste.net/show/IIBSq19KrGHwBbGFAUHN/ Здесь] пользователь [[User:psychon|psychon]] рассказал о способах реализации данной функции для себя. На [[Writing own widgets|этой странице]] описана функция реализующая эту возможность.

== Обновление Вашего rc.lua 3-х сторонним способом ==

Если ваш ''rc.lua'' от 3.4 не очень отличается от стандартного, вы можете использовать трехсторонний метод слияния  [http://kdiff3.sourceforge.net/ kdiff3] (Qt) или [http://meldmerge.org/ meld] (GTK):
&lt;pre&gt;
 $ kdiff3 stock_3.4_rc.lua your_3.4_rc.lua stock_3.5_rc.lua -o your_3.5_rc.lua

или

$ meld stock_3.4_rc.lua your_3.4_rc.lua stock_3.5_rc.lua
&lt;/pre&gt;

Они обнаружат изменения внесеные в конфигурацию для 3.4, Вами и разработчиком, и помогут объединить их в новую версию.

[[Category:Awesome3.5]]
[[Category:Config]]</text>
      <sha1>tv790oun1yj79qmz3362gfb5fs6uddo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.4 to git master</title>
    <ns>0</ns>
    <id>868</id>
    <redirect title="Awesome 3.4 to 3.5" />
    <revision>
      <id>5650</id>
      <timestamp>2012-11-24T14:35:20Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Awesome 3.4 to git master]] to [[Awesome 3.4 to 3.5]]: Yay, release time!</comment>
      <text xml:space="preserve" bytes="32">#REDIRECT [[Awesome 3.4 to 3.5]]</text>
      <sha1>h9adz9ciot1x90m7hs22bg1pd75ygpz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.x</title>
    <ns>0</ns>
    <id>253</id>
    <revision>
      <id>6058</id>
      <parentid>6057</parentid>
      <timestamp>2013-07-04T19:36:46Z</timestamp>
      <contributor>
        <username>Ghosy</username>
        <id>3031</id>
      </contributor>
      <comment>Undo revision 6057 by [[Special:Contributions/Ghosy|Ghosy]] ([[User talk:Ghosy|talk]])</comment>
      <text xml:space="preserve" bytes="6746">{{Languages}}

'''This is the man page of awesome version 3.4.1. It can also be used for a large part with previous versions 3.x, because there are not much differences ; for example, the commands Mod4 + w (Open main menu) in version 3.3 and Mod4 + n (Minimize client) in 3.4 version have been added. Nevertheless, you may read their specific man pages if it is necessary.'''

&lt;H1&gt;AWESOME&lt;/H1&gt;

&lt;H2&gt;NAME&lt;/H2&gt;

awesome - awesome window manager
&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; [&lt;B&gt;-v&lt;/B&gt; | &lt;B&gt;--version&lt;/B&gt;] [&lt;B&gt;-h&lt;/B&gt; | &lt;B&gt;--help&lt;/B&gt;] [&lt;B&gt;-c&lt;/B&gt; | &lt;B&gt;--config&lt;/B&gt; &lt;I&gt;FILE&lt;/I&gt;] [&lt;B&gt;-k&lt;/B&gt; | &lt;B&gt;--check&lt;/B&gt;]
&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; is a window manager for X. It manages windows in different layouts, like floating or tiled. Any layout can be applied dynamically, optimizing the environment for the application in use and the task currently being performed.
In a tiled layout, windows are managed in a master and stacking area. The master area contains the windows which currently need the most attention, whereas the stacking area contains all other windows. In a floating layout windows can be resized and moved freely. Dialog windows are always managed as floating, regardless of the layout currently applied. The spiral and dwindle layouts are special cases of the tiled layout where the stacking area is arranged in a spiral for the former or as a rectangular fractal for the later.
Windows are grouped by tags in awesome. Each window can be tagged with one or more tags. Selecting certain tags displays all windows with these tags.
&lt;B&gt;awesome&lt;/B&gt; can contain small wiboxes which can display anything you want: all available tags, the current layout, the title of the visible windows, text, etc.
&lt;H2&gt;OPTIONS&lt;/H2&gt;

&lt;B&gt;-v&lt;/B&gt;, &lt;B&gt;--version&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Print version information to standard output, then exit.
&lt;/DL&gt;

&lt;B&gt;-h&lt;/B&gt;, &lt;B&gt;--help&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Print help information, then exit.
&lt;/DL&gt;

&lt;B&gt;-c&lt;/B&gt;, &lt;B&gt;--config&lt;/B&gt; &lt;I&gt;FILE&lt;/I&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Use an alternate configuration file instead of
&lt;I&gt;$XDG_CONFIG_HOME/awesome/rc.lua&lt;/I&gt;.
&lt;/DL&gt;

&lt;B&gt;-k&lt;/B&gt;, &lt;B&gt;--check&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Check configuration file syntax.
&lt;/DL&gt;

&lt;H2&gt;DEFAULT MOUSE BINDINGS&lt;/H2&gt;

&lt;H3&gt;Navigation&lt;/H3&gt;

&lt;B&gt;Button1&lt;/B&gt; on tag name
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
View tag.
&lt;/DL&gt;

&lt;B&gt;Button4&lt;/B&gt;, &lt;B&gt;Button5&lt;/B&gt; on tag name
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Switch to previous or next tag.
&lt;/DL&gt;

&lt;B&gt;Button4&lt;/B&gt;, &lt;B&gt;Button5&lt;/B&gt; on root window
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Switch to previous or next tag.
&lt;/DL&gt;

&lt;B&gt;Button1&lt;/B&gt;, &lt;B&gt;Button3&lt;/B&gt;, &lt;B&gt;Button4&lt;/B&gt;, &lt;B&gt;Button5&lt;/B&gt; on layout symbol
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Switch to previous or next layout.
&lt;/DL&gt;

&lt;H3&gt;Layout modification&lt;/H3&gt;

&lt;B&gt;Mod4 + Button1&lt;/B&gt; on tag name
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Tag current client with this tag only.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Button3&lt;/B&gt; on tag name
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Toggle this tag for client.
&lt;/DL&gt;

&lt;B&gt;Button3&lt;/B&gt; on tag name
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Add this tag to current view.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Button1&lt;/B&gt; on client window
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Move window.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Button3&lt;/B&gt; on client window
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Resize window.
&lt;/DL&gt;

&lt;H2&gt;DEFAULT KEY BINDINGS&lt;/H2&gt;

&lt;H3&gt;Window manager control&lt;/H3&gt;

&lt;B&gt;Mod4 + Control + r&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Restart
&lt;B&gt;awesome&lt;/B&gt;.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + q&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Quit
&lt;B&gt;awesome&lt;/B&gt;.
&lt;/DL&gt;

&lt;B&gt;Mod4 + r&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Run prompt.
&lt;/DL&gt;

&lt;B&gt;Mod4 + x&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Run Lua code prompt.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Return&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Spawn terminal emulator.
&lt;/DL&gt;

&lt;B&gt;Mod4 + w&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Open main menu.
&lt;/DL&gt;

&lt;H3&gt;Clients&lt;/H3&gt;

&lt;B&gt;Mod4 + Shift + r&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Redraw the focused window.
&lt;/DL&gt;

&lt;B&gt;Mod4 + m&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Maximize client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + n&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Minimize client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + f&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set client fullscreen.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + c&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Kill focused client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + t&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Mark a client.
&lt;/DL&gt;

&lt;H3&gt;Navigation&lt;/H3&gt;

&lt;B&gt;Mod4 + j&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focus next client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + k&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focus previous client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + u&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focus first urgent client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Left&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
View previous tag.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Right&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
View next tag.
&lt;/DL&gt;

&lt;B&gt;Mod4 + 1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Switch to tag 1-9.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Control + j&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focus next screen.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Control + k&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focus previous screen.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Escape&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focus previously selected tag set.
&lt;/DL&gt;

&lt;H3&gt;Layout modification&lt;/H3&gt;

&lt;B&gt;Mod4 + Shift + j&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Switch client with next client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + k&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Switch client with previous client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + o&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Send client to next screen.
&lt;/DL&gt;

&lt;B&gt;Mod4 + h&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Decrease master width factor by 5%.
&lt;/DL&gt;

&lt;B&gt;Mod4 + l&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Increase master width factor by 5%.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + h&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Increase number of master windows by 1.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + l&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Decrease number of master windows by 1.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Control + h&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Increase number of columns for non-master windows by 1.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Control + l&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Decrease number of columns for non-master windows by 1.
&lt;/DL&gt;

&lt;B&gt;Mod4 + space&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Switch to next layout.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + space&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Switch to previous layout.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Control + space&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Toggle client floating status.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Control + Return&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Swap focused client with master.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Control + 1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Toggle tag view.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + 1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Tag client with tag.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + Control + 1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Toggle tag on client.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Shift + F1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Tag marked clients with tag.
&lt;/DL&gt;

&lt;H2&gt;CUSTOMIZATION&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; is customized by creating a custom &lt;I&gt;$XDG_CONFIG_HOME/awesome/rc.lua&lt;/I&gt; file.
&lt;H2&gt;SIGNALS&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; can be restarted by sending it a SIGHUP.
&lt;H2&gt;SEE ALSO&lt;/H2&gt;

&lt;B&gt;awesomerc&lt;/B&gt;(5) &lt;B&gt;awesome-client&lt;/B&gt;(1)
&lt;H2&gt;BUGS&lt;/H2&gt;

Of course there's no bug in &lt;B&gt;awesome&lt;/B&gt;. But there may be unexpected behaviors.
&lt;H2&gt;AUTHORS&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt; and others.
&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
mailto:julien@danjou.info




[[Category:Awesome3]]</text>
      <sha1>ss0cw09vfdddkccgp3b7ujyivihnmmw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.x/fr</title>
    <ns>0</ns>
    <id>244</id>
    <revision>
      <id>3802</id>
      <parentid>3784</parentid>
      <timestamp>2009-11-15T19:28:07Z</timestamp>
      <contributor>
        <username>Jihell78</username>
        <id>50</id>
      </contributor>
      <text xml:space="preserve" bytes="9190">{{Languages|Awesome 3.x}}

'''Ceci est la page de manuel de awesome version 3.4.1. Elle est utilisable aussi pour une grande part avec les versions précédentes 3.x, parce qu'il y a peu de différences ; par exemple, les commandes Mod4 + w (Ouvre le menu principal) dans la version 3.3 et Mod4 + n (Minimise la fenêtre) dans la version 3.4.1 ont été ajoutées. Néanmoins, vous pouvez consulter spécifiquement leurs pages  si besoin est.'''


&lt;H1&gt;AWESOME&lt;/H1&gt;

&lt;H2&gt;NOM&lt;/H2&gt;

awesome - gestionnaire de fenêtres awesome
&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; [&lt;B&gt;-v&lt;/B&gt; | &lt;B&gt;--version&lt;/B&gt;] [&lt;B&gt;-h&lt;/B&gt; | &lt;B&gt;--help&lt;/B&gt;] [&lt;B&gt;-c&lt;/B&gt; | &lt;B&gt;--config&lt;/B&gt; &lt;I&gt;FILE&lt;/I&gt;] [&lt;B&gt;-k&lt;/B&gt; | &lt;B&gt;--check&lt;/B&gt;]
&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; est un gestionnaire de fenêtres pour X. Il gère les fenêtres avec diverses mises en page, par exemple flottante ou juxtaposée. Toutes les mises en page peuvent être appliquées dynamiquement, pour optimiser l'environnement pour l'application utilisée et la tâche en cours d'exécution.

Avec la mise en page juxtaposée, les fenêtres sont gérées avec une zone maître et une zone d'empilage. La zone maître contient les fenêtres qui nécessitent le plus d'attention, tandis que la zone d'empilage contient toutes les autres fenêtres. Avec la mise en page flottante, les fenêtres peuvent être redimensionnées et déplacées à la demande. Les fenêtres de dialogue sont toujours gérées d'une manière flottante, quelle que soit la mise en page en cours. Les mises en forme spirale ou décroissante sont des modes spéciaux de mise en forme juxtaposée, où la zone d'empilage est présentée en spirale pour la première, ou comme une fractale rectangulaire pour la seconde.

Dans awesome les fenêtres sont groupées en onglets. Chaque fenêtre peut être affectée à  un ou plusieurs onglets. En sélectionnant plusieurs onglets on peut afficher toutes les fenêtres affectées à ces onglets.
&lt;B&gt;awesome&lt;/B&gt; peut contenir des petites boîtes graphiques qui peuvent afficher tout ce que vous désirez&amp;nbsp;: tous les onglets disponibles, la mise en page courante, le titre des fenêtres visibles, du texte, etc.
&lt;H2&gt;OPTIONS&lt;/H2&gt;


&lt;B&gt;-v&lt;/B&gt;, &lt;B&gt;--version&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche la version de awesome sur la sortie standard.
&lt;/DL&gt;

&lt;B&gt;-h&lt;/B&gt;, &lt;B&gt;--help&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche l'aide.
&lt;/DL&gt;

&lt;B&gt;-c&lt;/B&gt;, &lt;B&gt;--config&lt;/B&gt; &lt;I&gt;FILE&lt;/I&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Définit un autre fichier de configuration à la place de &lt;I&gt;$XDG_CONFIG_HOME/awesome/rc.lua&lt;/I&gt;.
&lt;/DL&gt;

&lt;B&gt;-k&lt;/B&gt;, &lt;B&gt;--check&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Vérifie la syntaxe du fichier de configuration.
&lt;/DL&gt;

&lt;H2&gt;ASSOCIATIONS AVEC LA SOURIS (PAR DÉFAUT)&lt;/H2&gt;

&lt;H3&gt;Navigation&lt;/H3&gt;

&lt;B&gt;Bouton1&lt;/B&gt; sur le nom de l'onglet
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche le contenu de l'onglet.
&lt;/DL&gt;

&lt;B&gt;Bouton4&lt;/B&gt;, &lt;B&gt;Bouton5&lt;/B&gt; sur le nom de l'onglet
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche le contenu de l'onglet précédent ou suivant.
&lt;/DL&gt;

&lt;B&gt;Bouton4&lt;/B&gt;, &lt;B&gt;Bouton5&lt;/B&gt; sur un onglet vide
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche le contenu de l'onglet précédent ou suivant.
&lt;/DL&gt;

&lt;B&gt;Bouton1&lt;/B&gt;, &lt;B&gt;Bouton3&lt;/B&gt;, &lt;B&gt;Bouton4&lt;/B&gt;, &lt;B&gt;Bouton5&lt;/B&gt; sur le symbole de mise en page
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche la mise en page précédente ou suivante.
&lt;/DL&gt;

&lt;H3&gt;Changement dans la mise en page&lt;/H3&gt;

&lt;B&gt;Mod4 + Bouton1&lt;/B&gt; sur le nom de l'onglet
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Déplace la fenêtre courante vers cet onglet.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Bouton3&lt;/B&gt; sur le nom de l'onglet 
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Ajoute ou retire la fenêtre courante à cet onglet.
&lt;/DL&gt;

&lt;B&gt;Bouton3&lt;/B&gt; sur le nom de l'onglet
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Ajoute ou retire le contenu de cet onglet à la vue courante.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Bouton1&lt;/B&gt; sur la fenêtre courante avec déplacement de la souris
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Déplace la fenêtre courante sur l'écran.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Bouton3&lt;/B&gt; sur la fenêtre courante avec déplacement de la souris
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Redimensionne la fenêtre courante sur l'écran.
&lt;/DL&gt;

&lt;H2&gt;ASSOCIATIONS AVEC LES TOUCHES DU CLAVIER (PAR DÉFAUT)&lt;/H2&gt;

&lt;H3&gt;Contrôle du gestionnaire de fenêtres&lt;/H3&gt;

&lt;B&gt;Mod4 + Contrôle + r&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Redémarre le gestionnaire de fenêtres &lt;B&gt;awesome&lt;/B&gt;.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + q&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Quitte le gestionnaire de fenêtres &lt;B&gt;awesome&lt;/B&gt;.
&lt;/DL&gt;

&lt;B&gt;Mod4 + r&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche une invite de ligne de commande dans la barre de statut.
&lt;/DL&gt;

&lt;B&gt;Mod4 + x&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche une invite de code lua dans la barre de statut.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Retour&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Lance un émulateur de terminal. 
&lt;/DL&gt;

&lt;B&gt;Mod4 + w&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Ouvre le menu principal.
&lt;/DL&gt;

&lt;H3&gt;Clients&lt;/H3&gt;

&lt;B&gt;Mod4 + Majuscule + r&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Réaffiche la fenêtre focalisée.
&lt;/DL&gt;

&lt;B&gt;Mod4 + m&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Maximize la fenêtre de l'application.
&lt;/DL&gt;

&lt;B&gt;Mod4 + n&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Minimise la fenêtre de l'application.
&lt;/DL&gt;

&lt;B&gt;Mod4 + f&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche la fenêtre de l'application en plein écran.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + c&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Ferme la fenêtre focalisée.
&lt;/DL&gt;

&lt;B&gt;Mod4 + t&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Marque la fenêtre de l'application.
&lt;/DL&gt;

&lt;H3&gt;Navigation&lt;/H3&gt;

&lt;B&gt;Mod4 + j&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focalise sur la fenêtre suivante.
&lt;/DL&gt;

&lt;B&gt;Mod4 + k&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focalise sur la fenêtre précédente.
&lt;/DL&gt;

&lt;B&gt;Mod4 + u&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focalise sur la première fenêtre urgente.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Flèche Gauche&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche l'onglet précédent.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Flèche Droite&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche l'onglet suivant.
&lt;/DL&gt;

&lt;B&gt;Mod4 + 1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche le contenu de l'onglet 1 à 9.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Contrôle + j&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focalise sur l'écran d'affichage suivant et y déplace la souris.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Contrôle + k&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Focalise sur l'écran d'affichage précédent et y déplace la souris.
&lt;/DL&gt;

&lt;B&gt;Mod4 + échappement&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche l'onglet sélectionné précédemment.
&lt;/DL&gt;

&lt;H3&gt;Changement dans la mise en page&lt;/H3&gt;

&lt;B&gt;Mod4 + Majuscule + j&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Intervertit la fenêtre courante avec la suivante.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + k&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Intervertit la fenêtre courante avec la précédente.
&lt;/DL&gt;

&lt;B&gt;Mod4 + o&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Déplace le client vers l'écran suivant.
&lt;/DL&gt;

&lt;B&gt;Mod4 + h&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Diminue la largeur de la fenêtre-maître de 5%.
&lt;/DL&gt;

&lt;B&gt;Mod4 + l&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Augmente la largeur de la fenêtre-maître de 5%.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + h&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Augmente de 1 le nombre de fenêtres-maître.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + l&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Diminue de 1 le nombre de fenêtres-maître.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Contrôle + h&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Augmente de 1 le nombre de colonnes pour les fenêtres non-maître.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Contrôle + l&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Diminue de 1 le nombre de colonnes pour les fenêtres non-maître.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Espace&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche la mise en page suivante.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + Espace&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche la mise en page précédente.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Contrôle + Espace&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Rend la fenêtre flottante, ou fixe si elle est déjà flottante.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Contrôle + Retour&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Intervertit la fenêtre focalisée avec la fenêtre-maître.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Contrôle + 1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Ajoute ou supprime le contenu de l'onglet 1 à 9 à l'onglet courant.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + 1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Déplace la fenêtre courante dans l'onglet 1 à 9.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + Contrôle + 1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Ajoute ou retire la fenêtre courante à l'onglet 1 à 9.
&lt;/DL&gt;

&lt;B&gt;Mod4 + Majuscule + F1-9&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Déplace les applications marquées vers l'onglet 1 à 9.
&lt;/DL&gt;

&lt;H2&gt;PERSONNALISATION&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; peut être personnalisé en créant un fichier spécifique &lt;I&gt;$XDG_CONFIG_HOME/awesome/rc.lua&lt;/I&gt;.
&lt;H2&gt;SIGNAUX&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; peut être redémarré en lui envoyant un signal SIGHUP.
&lt;H2&gt;VOIR AUSSI&lt;/H2&gt;

&lt;B&gt;awesomerc&lt;/B&gt;(5) &lt;B&gt;awesome-client&lt;/B&gt;(1)
&lt;H2&gt;BOGUES&lt;/H2&gt;

Bien sûr il n'y a aucun bogue dans &lt;B&gt;awesome&lt;/B&gt; ! Il peut seulement y avoir des comportements inattendus....
&lt;H2&gt;AUTEURS&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt; et d'autres personnes.
&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
courriel : mailto:julien@danjou.info

&lt;H2&gt;TRADUCTION&lt;/H2&gt;

Ce document est une traduction, réalisée par Jean-Luc Duflot &amp;lt;jl&amp;nbsp;POING&amp;nbsp;duflot&amp;nbsp;CHEZ&amp;nbsp;laposte&amp;nbsp;POING&amp;nbsp;net&amp;gt; le 9&amp;nbsp;novembre&amp;nbsp;2009.


L'équipe de traduction a fait le maximum pour réaliser une adaptation française de qualité.
La version anglaise la plus à jour de ce document est toujours consultable via la commande&amp;nbsp;: LANGUAGE=en man awesome. N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute erreur dans cette page de manuel.


[[Category:Awesome3]]</text>
      <sha1>im30u58mgehhde5xnrf6n23mxqjlnoh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.x/ru</title>
    <ns>0</ns>
    <id>1108</id>
    <revision>
      <id>6739</id>
      <timestamp>2014-06-09T06:32:42Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{Languages|Man pages}}  '''Это man страница для awesome версии 3.4.1. Она может быть использована для большей части...&quot;</comment>
      <text xml:space="preserve" bytes="9943">{{Languages|Man pages}}

'''Это man страница для awesome версии 3.4.1. Она может быть использована для большей части предыдущих версий 3.x, так как различия несущественны; например, команда Mod4 + w (открывает главное меню) в версии 3.3 и Mod4 + n (свернуть приложение) были добавлены в версии 3.4 . Тем не менее, вы можете прочитать справочное руководство для конкретной версии, если пожелаете.'''

&lt;H1&gt;AWESOME&lt;/H1&gt;



&lt;H2&gt;NAME&lt;/H2&gt;
       awesome - тайловый оконный менеджер

&lt;H2&gt;СИНОПСИС&lt;/H2&gt;
       &lt;B&gt;awesome&lt;/B&gt; [&lt;B&gt;-v&lt;/B&gt; | &lt;B&gt;--version&lt;/B&gt;] [&lt;B&gt;-h&lt;/B&gt; | &lt;B&gt;--help&lt;/B&gt;] [&lt;B&gt;-c&lt;/B&gt; | &lt;B&gt;--config&lt;/B&gt; &lt;I&gt;FILE&lt;/I&gt;] [&lt;B&gt;-k&lt;/B&gt; | &lt;B&gt;--check&lt;/B&gt;]

&lt;H2&gt;ОПИСАНИЕ&lt;/H2&gt;
       &lt;b&gt;awesome&lt;/b&gt; — это оконный менеджер для X. Он управляет окнами, размещая их в соответствии с разными
       схемами (layout), такими как плавающая (floating) или мозаичная (tiled). Любая схема может быть
       применена динамически, оптимально подстраивая рабочую среду под текущую выполняемую задачу и
       приложение.
       В мозаичной схеме окна размещаются в двух зонах: главная и стековая. В главной зоне размещаются
       окна, которые требуют основного внимания, а в стековой — все остальные. В плавающей схеме окна
       можно свободно перемещать и изменять их размер. Диалоговые окна всегда отображаются в плавающем
       режиме, вне зависимости от текущей выбранной схемы. Спиральная и уменьшающая схемы являются
       исключениями: окна в стековой зоне в этих схемах размещаются по спирали для первой, и в виде
       фрактала квадратов для второй.
       Окна в awesome сгруппированы по тегам. Каждое окно может быть помечено одним или несколькими
       тегами. Можно выбрать один или несколько тегов, чтобы увидеть окна с этими тегами.
       В &lt;b&gt;awesome&lt;/b&gt; можно создавать вибоксы (виджет + бокс), в которых можно отображать всё, что вы
       хотите: все имеющиеся теги, текущая выбранная схема, заголовки видимых окон, произвольный текст
       и т. д.

&lt;H2&gt;ОПЦИИ&lt;/H2&gt;
       &lt;b&gt;-v, --version&lt;/b&gt;
           Показать информацию о версии на стандартный вывод и выйти.
       &lt;b&gt;-h, --help&lt;/b&gt;
           Показать справку и выйти.
       &lt;b&gt;-c, --config FILE&lt;/b&gt;
           Использовать альтернативный конфигурационный файл вместо $XDG_CONFIG_HOME/awesome/rc.lua.
       &lt;b&gt;-k, --check&lt;/b&gt;
           Проверить синтаксис конфигурационного файла.

       &lt;b&gt;-a, --no-argb&lt;/b&gt;
           Не использовать ARGB.

&lt;h2&gt;НАСТРОЙКИ МЫШИ ПО-УМОЛЧАНИЮ&lt;/h2&gt;
   &lt;h3&gt;Навигация&lt;/h3&gt;
       &lt;b&gt;Button1&lt;/b&gt; на имени тега
           Выбрать тег для отображения.
       &lt;b&gt;Button4, Button5&lt;/b&gt; на имени тега
           Выбрать предыдущий или следующий тег.
       &lt;b&gt;Button4, Button5&lt;/b&gt; на корневом окне
           Выбрать предыдущий или следующий тег.
       &lt;b&gt;Button1, Button3, Button4, Button5&lt;/b&gt; на значке схемы
           Переключиться на предыдущую или следующую схему.

   &lt;h3&gt;Изменение схемы&lt;/h3&gt;
       &lt;b&gt;Mod4 + Button1&lt;/b&gt; на имени тега
           Пометить текущий клиент только этим тегом.
       &lt;b&gt;Mod4 + Button3&lt;/b&gt; на имени тега
           Пометить текущий клиент этим тегом, либо убрать пометку этим тегом.
       &lt;b&gt;Button3&lt;/b&gt; на имени тега
           Добавить текущий тег для просмотра.
       &lt;b&gt;Mod4 + Button1&lt;/b&gt; на окне клиента
           Переместить окно.
       &lt;b&gt;Mod4 + Button3&lt;/b&gt; на окне клиента
           Изменить размер окна.

&lt;h2&gt;НАСТРОЙКИ КЛАВИАТУРЫ ПО-УМОЛЧАНИЮ&lt;/h2&gt;
   &lt;h3&gt;Управление менеджером окон&lt;/h3&gt;
       &lt;b&gt;Mod4 + Control + r&lt;/b&gt;
           Перезапустить awesome.
       &lt;b&gt;Mod4 + Shift + q&lt;/b&gt;
           Выйти из awesome.
       &lt;b&gt;Mod4 + r&lt;/b&gt;
           Открыть командную строку.
       &lt;b&gt;Mod4 + x&lt;/b&gt;
           Открыть командную строку для выполнения Lua-кода.
       &lt;b&gt;Mod4 + Return&lt;/b&gt;
           Запустить эмулятор терминала.
       &lt;b&gt;Mod4 + w&lt;/b&gt;
           Открыть главное меню.

   &lt;h3&gt;Клиенты&lt;/h3&gt;
       &lt;B&gt;Mod4 + Shift + r&lt;/B&gt;
           Перерисовать активное окно.
       &lt;b&gt;Mod4 + m&lt;/b&gt;
           Развернуть на весь экран.
       &lt;b&gt;Mod4 + n&lt;/b&gt;
           Свернуть.
       &lt;b&gt;Mod4 + Control + n&lt;/b&gt;
           Восстановить.
       &lt;b&gt;Mod4 + f&lt;/b&gt;
           Полноэкранный режим.
       &lt;b&gt;Mod4 + Shift + c&lt;/b&gt;
           Убить выбранный клиент.
       &lt;b&gt;Mod4 + t&lt;/b&gt;
           Прикрепить поверх всех.

   &lt;h3&gt;Навигация&lt;/h3&gt;
       &lt;b&gt;Mod4 + j&lt;/b&gt;
           Следующий клиент.
       &lt;b&gt;Mod4 + k&lt;/b&gt;
           Предыдущий клиент.
       &lt;b&gt;Mod4 + u&lt;/b&gt;
           Первый клиент в режиме повышенного внимания (urgent).
       &lt;b&gt;Mod4 + Left&lt;/b&gt;
           Выбрать предыдущий тег.
       &lt;b&gt;Mod4 + Right&lt;/b&gt;
           Выбрать следующий тег.
       &lt;b&gt;Mod4 + 1-9&lt;/b&gt;
           Переключиться на тег по номеру (от 1 до 9).
       &lt;b&gt;Mod4 + Control + j&lt;/b&gt;
           Следующий экран.
       &lt;b&gt;Mod4 + Control + k&lt;/b&gt;
           Предыдущий экран.
       &lt;b&gt;Mod4 + Escape&lt;/b&gt;
           Выбрать предыдущий выбранный набор тегов.

   &lt;h3&gt;Изменение схемы&lt;/h3&gt;
       &lt;b&gt;Mod4 + Shift + j&lt;/b&gt;
           Поменять текущий и следующий за ним клиенты местами.
       &lt;b&gt;Mod4 + Shift + k&lt;/b&gt;
           Поменять текущий и предыдущий клиенты местами.
       &lt;b&gt;Mod4 + o&lt;/b&gt;
           Отправить клиент на следующий экран.
       &lt;b&gt;Mod4 + h&lt;/b&gt;
           Уменьшить главную зону на 5%.
       &lt;b&gt;Mod4 + l&lt;/b&gt;
           Увеличить главную зона на 5%.
       &lt;b&gt;Mod4 + Shift + h&lt;/b&gt;
           Увеличить число окон в главной зоне на 1.
       &lt;b&gt;Mod4 + Shift + l&lt;/b&gt;
           Уменьшить число окон в главной зоне на 1.
       &lt;b&gt;Mod4 + Control + h&lt;/b&gt;
           Увеличить число колонок для стековой зоны на 1.
       &lt;b&gt;Mod4 + Control + l&lt;/b&gt;
           Уменьшить число колонок для стековой зоны на 1.
       &lt;b&gt;Mod4 + space&lt;/b&gt;
           Выбрать следующую схему.
       &lt;b&gt;Mod4 + Shift + space&lt;/b&gt;
           Выбрать предыдущую схему.
       &lt;b&gt;Mod4 + Control + space&lt;/b&gt;
           Переключить плавающий режим для текущего клиента.
       &lt;b&gt;Mod4 + Control + Return&lt;/b&gt;
           Поменять текущий и главный клиенты местами.
       &lt;b&gt;Mod4 + Control + 1-9&lt;/b&gt;
           Включить/выключить тег по номеру.
       &lt;b&gt;Mod4 + Shift + 1-9&lt;/b&gt;
           Пометить клиента тегом по номеру.
       &lt;b&gt;Mod4 + Shift + Control + 1-9&lt;/b&gt;
           Пометить/снять пометку клиента тегом по номеру.
       &lt;b&gt;Mod4 + Shift + F1-9&lt;/b&gt;
           Пометить все отмеченные клиенты тегом по номеру.

&lt;h2&gt;НАСТРОЙКА&lt;/h2&gt;
       &lt;b&gt;awesome&lt;/b&gt; настраивается файлом $XDG_CONFIG_HOME/awesome/rc.lua (надо создать, если его нет).

&lt;h2&gt;СИГНАЛЫ&lt;/h2&gt;
       &lt;b&gt;awesome&lt;/b&gt; может быть перезапущен сигналом SIGHUP.

&lt;h2&gt;СМОТРИ ТАКЖЕ&lt;/h2&gt;
       awesomerc(5) awesome-client(1)

&lt;h2&gt;БАГИ&lt;/h2&gt;
       Само собой разумеется, что в awesome багов нет. Но могут встречаться ВНЕЗАПНОСТИ.

&lt;h2&gt;АВТОРЫ&lt;/h2&gt;
       Julien Danjou &lt;julien@danjou.info[1]&gt; и другие.

&lt;h2&gt;WWW&lt;/h2&gt;
       http://awesome.naquadah.org

[[Category:Awesome3]]</text>
      <sha1>9mivhu9oehzj2iwoub8gs9hraibfjnm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3.x (fr)</title>
    <ns>0</ns>
    <id>383</id>
    <redirect title="Awesome 3.x/fr" />
    <revision>
      <id>2946</id>
      <timestamp>2009-06-25T15:16:47Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesome 3.x (fr)]] to [[Awesome 3.x/fr]]</comment>
      <text xml:space="preserve" bytes="28">#REDIRECT [[Awesome 3.x/fr]]</text>
      <sha1>5ytueivcffcltuyy7gl62lw7kitv7yl</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration</title>
    <ns>0</ns>
    <id>111</id>
    <revision>
      <id>6531</id>
      <parentid>6196</parentid>
      <timestamp>2014-05-17T15:45:55Z</timestamp>
      <contributor>
        <username>Bcoughlan</username>
        <id>3301</id>
      </contributor>
      <comment>/* Files */ Make it clear that if local rc.lua loads, /etc/xdg/awesome/rc.lua doesn't</comment>
      <text xml:space="preserve" bytes="12663">{{Template:Languages}}

== Background ==

'''awesome 3''' now uses a configuration file based on the [http://www.lua.org Lua] language. Most people coming from the awesome 2 world will cry seeing that the old configuration file in libconfuse format has disappeared, others will hate this because they never understood the [http://modeemi.fi/~tuomov/ion/ ion] configuration file, but neither did I.

Why Lua?
Because it offers more control. It offers conditional behavior: you wanted awesome to do something when something happens, you were not able to. Now, you are. You're able to do almost '''anything''' (in the range of what a window manager can do).

== Files ==
* ~/.config/awesome/rc.lua
* /etc/xdg/awesome/rc.lua

If awesome cannot find ~/.config/awesome/rc.lua, or fails to load it, it falls back to using /etc/xdg/awesome/rc.lua.

== Lua basics ==
[http://www.lua.org/ Lua] is a '''simple''' language. While an intimate understanding of it is not an absolute prerequisite to use awesome, one's ability does directly correlate with the capacity to customize and fully realize awesome's potential.

While awesome 3 was originally conceptualized and developed for power users with some computer science background, many current users only learned Lua for and by using awesome. In fact, many current awesome users are not programmers, developers, or &quot;power user&quot; types - simply people who wanted more from their window manager. 

If you're not familiar at all with computer languages, i.e. if you do not know what ''objects'', ''methods'' and ''arguments'' are, well, this particular document may be a bit beyond you. You can learn some basics and come back to this, or press on and start your learning here. No matter from where you are starting, there is enough help to get even the most novice user up and running with awesome. So, if you're really motivated, you can learn enough basics to configure and control awesome.

The best way to learn Lua is to spend one or two hours reading the [http://www.lua.org/pil/ Programming In Lua] book, which is nice and will give you an overview of what's doable in Lua. Do not hesitate to bookmark important pages talking about flow control, useful statements, etc. That will help: it's awful to look for the ''for'' syntax when trying to type lines of code.

To get a quick and precise glimpse at Lua language please consider reading [[The_briefest_introduction_to_Lua|this]] article. It will provide you with a basic knowledge enough to start configuring your Awesome.

== awesome object types ==
For people coming from outer space who did not use awesome, here are the basic objects awesome will give you and you will have to manipulate soon.

;&lt;span id=&quot;screen&quot;&gt;Screen&lt;/span&gt;
: There is no real screen object in awesome, but we will talk about screens later. A screen is a physical monitor plugged into your computer. They are represented by their index, starting at 1.
;&lt;span id=&quot;client&quot;&gt;Client&lt;/span&gt;
: A client is a window. I guess I'm clear.
;&lt;span id=&quot;tag&quot;&gt;Tag&lt;/span&gt;
: A tag is something like a workspace/desktop but the concept is less rigid.
: Each client has at least one tag assigned to it. Each screen has at least one tag.
: At any time, on a screen, you can view any tag number. Watching no tag will hide every client. Watching one or more tags will show you all clients which have these tags.
;&lt;span id=&quot;widget&quot;&gt;Widget&lt;/span&gt;
: Widgets are objects which draw things on the screen. There are several types of widget. For example there's a text box widget which prints text on the screen. There's also a icon box widget which draws icons on the screen.
;&lt;span id=&quot;titlebar&quot;&gt;Titlebar&lt;/span&gt;
: A titlebar is a bar which is around a client and attached to it. You can put widgets in it.
;&lt;span id=&quot;statusbar&quot;&gt;Statusbar&lt;/span&gt;
: A statusbar is a bar which is fixed at the edge of a screen. You can put widgets in it.

== Building our interface ==
To build our interface, we need to use awesome functions and methods: '''everything''' is documented in the [http://awesome.naquadah.org/doc/api/ Lua API documentation] and in the awesomerc(5) manpage. Read them. They are your development reference. I repeat: read it, everything is documented in this manpage and in luadoc.

Which manpage?… awesomerc(5). Good. You're following.

=== Tag creation ===
If you start awesome without any Lua operation, you will have 0 tags, which is fatal. awesome wants at least one tag.

So first, we need to create a tag. How do we do that? We look for tag() and its documentation, the tag creator function in the manpage. It says that the parameter of the function must be a table with at least a name attribute. Let's do that.

 mytagone = tag({ name = &quot;one&quot; })

Now you declared an object ''mytagone'' to be a tag object, and its name is ''one''.

 mytagtwo = tag({name = &quot;two&quot;})

Now, we have a second tag object &quot;mytagtwo&quot;: its name is ''two'', and by default it arranges clients with the floating algorithm, which, like its name suggests, lets the clients float.

Creating objects is nice, but well, for now it's useless. Remember: each screen has at least one tag. So we need to add these created tags to our first screen. The ''screen'' attribute of the tag object does that for us, we only need to give it the screen number value.

 mytagone.screen = 1

We just added that tag to the screen #1. If we have a second screen (multi-head: Zaphod, Xinerama or XRandR are identical for awesome), we can add our second tag to this screen:

 mytagtwo.screen = 2

And if we have 3 screens, we need to... Well, I guess you got it.

If you want to know how many screens you have, you can use the ''screen.count()'' function.

You can manipulate tag viewing with the ''selected'' attribute. If you want to view your tag ''one'':

 mytagone.selected = true

If you want to hide it, you can obviously set the value to ''false''.

You can manipulate all the tag settings with its attributes. See the documentation.

=== Client manipulation ===
Sometimes, you will get client objects. This is very useful in hook functions, which we will discuss later.

A client is an object which has methods too, like tags and others. We decide that the ''c'' variable is our client object.
For example, if we want to set a client floating we can use the ''floating'' attribute like this:

 c.floating = true

Some methods return values that can be used later for analysis. If we want to know if a client is floating, we can get the ''floating'' attribute:

 is_client_floating = c.floating

The variable ''is_client_floating'' now contains a boolean value: ''true'' if the client is floating or ''false'' if the client is not.

We can combine these 2 functions to create a toggle function: this function will set the client floating state to true if it's not, or to false if it is.

 function client_floating_toggle(c)
     if c then
         c.floating = not c.floating
     end
 end

We can also use that to toggle a tag on our client:

 function client_tag_with_tag_one(c)
     if c then
         local t = c:tags()
         table.insert(t, one)
         c:tags(t)
     end
 end

=== Widget creation ===
Widgets are small objects that can be placed either on a titlebar or on a statusbar. Like tags, if you do not add them somewhere, they're totally useless. To create a widget you use the ''widget()'' function:

 mytextbox = widget({ type = &quot;textbox&quot; })

''mytextbox'' now contains a widget object. You can use different attributes with different widget types, the following sets the text displayed by the textbox.

 mytextbox.text = &quot;Hello, world!

=== Statusbar creation ===
Statusbars are widget containers (wiboxes) that you can put on the top, bottom, left or right screen edges.

First, create a wibox:

 mystatusbar = wibox({ position = &quot;top&quot; })

''mystatusbar'' is now a variable which contains a wibox object. Since we set ''position'' to ''top'', it will be placed on top of our screen. Obviously, we did not add it to the screen, so it's useless for now. Let's do it:

 mystatusbar.screen = 1

Our statusbar is now visible on top of the screen. Well, it does nothing, so it's not very useful. Let's add some widgets!

 -- Create a textbox
 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })
 -- Set text of the textbox
 mytextbox.text = &quot;Hello, world!&quot;
 -- Create a statusbar
 mystatusbar = awful.wibox({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })
 -- Add widgets to the statusbar
 mystatusbar.widgets = { mytextbox }
 -- Add the statusbar on screen #1
 mystatusbar.screen = 1

And voilà. We now have a brand new statusbar on top of the screen which prints ''Hello, world!''. Using this method, you can set up a statusbar with lots of widgets before starting awesome, in your configuration file.

=== Titlebar creation ===
Like I said before, titlebars are like statusbar except that they are around a window. To create a titlebar, you know the drill:

 mytitlebar = titlebar({ position = &quot;top&quot; })

Then, you probably want to put widgets in it. It works like statusbars:

 mytitlebartitle = widget({ type = &quot;textbox&quot;, name = &quot;mytitlebartitle&quot; })
 mytitlebar:widgets({ mytitlebartitle })

A titlebar must be added to a ''client object''. We can get the currently focused client: it is stored in ''client.focus'' variable. Let's do that:

 -- Get the focused client
 c = client.focus
 -- Set a titlebar on it
 c.titlebar = mytitlebar

Now, the focused client has a nice titlebar on top of it! But it has nothing in it. No, wait! Remember, in the titlebar we already added a ''textbox widget''. We can now print the client name in it:

 mytitlebartitle.text = c.name

The ''name'' attribute is a string with the client's title, and we set it as the text of the widget. Now the titlebar prints the client's title.

Remember: a titlebar is one object, and a client is another object. So you need to create a titlebar for each client you want a titlebar around.

=== Using hooks/signals ===
hooks have been replaced by [[Signals]] in 3.4+


With what we have seen above, you can build a nice interface. However, imagine you want to update the title printed in the titlebar of a client: you can't. Wait! Here's the solution: hooks.

With hooks, you can define functions that are called when an event happens. Let's try with an example.

When a new client pops up on the screen, awesome runs the function hooked by the ''manage'' hook. This function is called with the new client as its argument. Here's an example:

 function hook_manage(c)
     if c.name:find(&quot;mplayer&quot;) then
         c.floating = true
     end
 end

First, we defined a ''hook_manage'' function, with an argument named ''c'', which will be the client. Then, we try to find the string ''&quot;mplayer&quot;'' in the name of the client, and if so, we set it floating.

  awful.hooks.manage.register(hook_manage)

This defines that the function to be called on each new client arrival is ''hook_manage''.

There's a lot of hooks you can use and define: focus, unfocus, manage, unmanage, mouseover, arrange, titleupdate, urgent, timer, … Refer to the manpage for more information.

=== Executing commands and scripts ===

You can execute commands and scripts from the lua based configuration. Here is an example function that takes command as parameter and returns its output. This is useful for example for putting stuff from command outputs to textboxes.

&lt;pre&gt;
-- Execute command and return its output. You probably won't only execute commands with one
-- line of output
function execute_command(command)
   local fh = io.popen(command)
   local str = &quot;&quot;
   for i in fh:lines() do
      str = str .. i
   end
   io.close(fh)
   return str
end
&lt;/pre&gt;

Here is an example of putting /proc/loadavg to mytextbox:
&lt;pre&gt;
 mytextbox.text = &quot; &quot; .. execute_command(&quot;cat /proc/loadavg&quot;) .. &quot; &quot;
&lt;/pre&gt;

== awesome Lua libraries ==

;[[Awful]]
: The default library to interact with awesome, like mouse actions or keybinds.
;[[Beautiful]]
: The library to theme the look of awesome.
;[[Eminent]]
: A Lua library that will enable you to use dynamic tagging. Dynamic tagging in this instance means that the amount of tags you have is not pre-defined, you can give specific tags names, but simply going to the next tag when you're on the last tag will provide you with a brand new one, allowing you to adapt to various usage situations without changing your configuration file to give you more or less tags.
;[[Shifty]]
: An up-to-date dynamic tagging library + client matching
;[[Naughty]]
: A notification library.
;[[Wicked]]
: A Lua library for awesome to provide more widgets (e.g. MPD Widgets, CPU usage, memory usage, etc.).

[[Category: Awesome3]]
[[Category:Config]]</text>
      <sha1>rus8jzmv8w3nebkozlx85bwsx4gpzsy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration/es</title>
    <ns>0</ns>
    <id>178</id>
    <revision>
      <id>4301</id>
      <parentid>2794</parentid>
      <timestamp>2010-06-11T18:36:02Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>/* Setting up key chains */ Removing this because it's outdated</comment>
      <text xml:space="preserve" bytes="12908">{{Languages|Awesome 3 configuration}}

= Fondo =

'''awesome 3''' ahora usa un archivo de configuración basado en el lenguaje [http://www.lua.org Lua]. La mayoría de las personas que vienen del mundo de awesome 2 llorarán viendo que el viejo archivo de configuración en el formato libconfuse ha desaparecido, otros odiarán esto porque nunca entendieron el archivo de configuración de [http://modeemi.fi/~tuomov/ion/ ion], pero yo tampoco lo entendí.

¿Por qué Lua?
Porque ofrece más control. Si ofrece comportamiento condicional:  querías que awesome hiciera algo cuando algo sucediera, no podías hacerlo. Ahora, puedes. Puedes hacer casi '''cualquier''' cosa (en el rango de lo que un manejador de ventanas puede hacer).

= Archivos =
* ~/.config/awesome/rc.lua
* /etc/xdg/awesome/rc.lua

= Base de Lua =
Estamos hablando acerca de Lua, entonces lo primero, aprende Lua. ¿No quieres? No uses awesome 3 y para de leer ahora. (Alternativamente toma un archivo de configuración del código fuente, o de alguien, y solo modifícalo adecuadamente, lo cual debería funcionar incluso sin ningún conocimiento del lenguaje Lua).

Para las personas que siguen leyendo, ¡excelente! Lua es un lenguaje '''simple'''. Por otro lado, si no estás familiarizado del todo con los lenguajes de las computadoras, por ejemplo, si no sabes qué son ''objetos'', ''métodos'' y ''argumentos'', bueno, estás muy perdido para este documento, ¡aprende algunas cosas básicas y regresa!

No estoy siendo elitista: awesome 3 está diseñado para usuarios poderosos con un mínimo de conocimientos de ciencias de la computación, sin embargo, si estás realmente motivado, puedes aprender lo básico y lo suficiente para configurar y controlar awesome.

La mejor manera de aprender Lua es usar una o dos horas leyendo el libro [http://www.lua.org/pil/ Programming In Lua], el cual es bastante bueno y te dará una descripción general de lo que es posible hacer en Lua. No dudes en agregar a tu bookmark páginas importantes que hablen acerca de control de flujo, declaraciones útiles, entre otros. Eso te ayudará: es horrible buscar por la sintaxis ''for'' cuando estás tratando de escribir líneas de código.

= Tipos de objetos en awesome =
Para la gente que viene de otro espacio que no usó awesome antes, aquí están los objetos básicos de awesome que se te darán y que tendrás que manipular pronto.

== Screen ==
No hay un objeto real llamado screen en awesome, pero hablaremos de las screens luego. Un screen es un monitor físico conectado a tu computadora. Ellos estan representados por sus índices, comenzando en 1.

== Client ==
Un Client es una ventana. Creo ser claro.

== Tag ==
Un tag es algo como un espacio de trabajo/escritorio pero con un concepto menos rígido
Cada client tiene al menos un tag asignado a él. Cada Screen tiene al menos un tag.
A cualquier tiempo, en un screen, puedes ver cualquier número del tag. El no observar ningún tag ocultará todos los clients los cuales tienen dichos tags.

== Widget ==
Los Widgets son objetos que dibujan cosas en el screen. Hay varios tipos de widgets. Por ejemplo, hay un widget caja de texto el cual imprime texto en el screen. También hay un widget caja de icono, el cual dibuja un icono en el screen.

== Titlebar ==
Un titlebar es una barra que está alrededor del client y adjunta a este. Puedes poner widgets en ella.

== Statusbar ==
Un statusbar (barra de estado) es una barra que está fijada al borde de un screen. Puedes colocar widgets en el.

= Construyendo nuestra interfaz =
Para construir nuestra interfaz, necesitamos usar los métodos y funciones de awesome: '''todo''' esta documentado en [http://awesome.naquadah.org/apidoc/ Lua API documentation] y en el manual awesomerc(5). Léelos. Son tu referencia para desarrollar. Repito: Léelo, todo está documentado en ese manual y en luadoc.

¿Cuál manual?… awesomerc(5). Bien. Nos estás siguiendo.

== Creación de un Tag  ==
Si comienzas sin ninguna operación de Lua, tendrás un número de tags igual a cero, Lo cual es fatal. awesome requiere al menos un tag.

Entonces lo primero, necesitamos crear un tag. ¿Cómo hacemos eso? Buscamos por  tag() y su documentación, la función del creador de tags en el manual dice que el parámetro de la función debe ser una tabla con al menos un atributo nombre. Hagámoslo: 

 mytagone = tag({ name = &quot;one&quot; })

''mytag'' es ahora un objeto tag, y su nombre es ''one''. Si queremos configurar un layout por defecto, tenemos que agregarlo como un par llave/valor dentro de la tabla, como se explica en la documentación.

 mytagtwo = tag({name = &quot;two&quot;, layout = &quot;floating&quot; })

Ahora, tenemos un segundo tag: su nombre es ''two'', y por defecto ordena los clientes con algoritmos flotantes, los cuales, como su nombre sugiere, dejan flotar los clientes.

Crear objetos es divertido, pero bueno, por ahora son inútiles. Recuerda: cada screen tiene al menos un tag. Entonces necesitamos agregar esos tags creados a nuestro primer screen. El atributo ''screen'' de el objeto tag hace eso por nosotros, solo necesitamos darle el valor del número del screen.

 mytagone.screen = 1

Acabamos de agregar ese tag al screen #1. Si tenemos un segundo screen (multi-head: Zaphod, Xinerama o XRandR son indenticos para awesome), podemos agregar nuestro segundo tag a dicho screen:

 mytagtwo.screen = 2

Y si tenemos 3 screens, Necesitamos... Bueno, Creo que entiendes.

Si quieres saber cuántas screens tienes, puedes usar la función''screen.count()''.

Puedes manipular la forma las vistas de un tag con el atributo''selected''. Si quieres ver tu tag ''one'':

 mytagone.selected = true

Si quieres ocultarlo, puedes obviamente configurar el valor a ''false''.

Puedes manipular todas las configuraciones de los tag con sus atributos. Lee la documentación.

== Manipulación de Clientes ==
Algunas veces, crearás objetos client. Esto es bastante útil en funciones de tipo hook, las cuales discutiremos luego.

Un cliente, es un objeto el cual también tiene métodos, como tags entre otros. Nosotros decidimos que la variable ''c'' es nuestro objeto client.

Por ejemplo, si queremos configurar un cliente flotante (client floating) podemos usar el atributo ''floating'' como este:

 c.floating = true

Algunos métodos devuelven valores que pueden ser usados luego para analizar. Si queremos saber si un cliente es flotante (floating), podemos obtener el atributo ''floating'':

 is_client_floating = c.floating

La variable ''is_client_floating'' ahora contiene un valor booleano: ''true'' si el cliente es flotante o ''false'' si el cliente no es flotante.

Podemos combinar esas 2 funciones para crear una función alterna: esta función configurará el estado cliente flotante (client floating) a verdadero (true) si no es, o falso (false) si lo es.

 function client_floating_toggle(c)
     if c then
         c.floating = not c.floating
     end
 end

También podemos usar eso para alternar un tag en nuestro cliente:

 function client_tag_with_tag_one(c)
     if c then
         local t = c:tags()
         table.insert(t, one)
         c:tags(t)
     end
 end

== Creación de Widget ==
Los Widgets son pequeños objetaos que pueden ser colocados ya sea en el titlebar como en el status bar. Como tags, si tu no los agregas en algún lugar, son totalmente inútiles. Para crear un widget usas la función ''widget()'':

 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })

''mytextbox'' ahora contiene un objeto widget. Puedes usar diferentes atributos con diferentes tipos de widgets, seguidos de los grupos de textos mostrados por el textbox.

 mytextbox.text = &quot;Hello, world!

== Creación de la barra de estado (Statusbar)  ==
Las barras de estado (Statusbars) son contenedores widgets que puedes colocar en el tope, en la parte inferior o en los bordes derecho o izquierdo del screen.

Primero, crea la barra de estado:

 mystatusbar = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })

''mystatusbar'' es ahora una variable que contiene un objeto statusbar. Desde que configuramos la posición (''position'') en el tope (''top''), será mostrada en el tope de nuestra pantalla (screen). Obviamente, no lo agregamos al screen, por tanto es inútil por ahora. Hagámoslo:

 mystatusbar.screen = 1

Nuestra barra de estado es ahora visible en el tope de nuestra pantalla. Bien, la barra de estado no tiene nada, pero es muy útil. ¡Vamos a agregarle widgets! 

 -- Create a textbox
 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })
 -- Set text of the textbox
 mytextbox.text = &quot;Hello, world!&quot;
 -- Create a statusbar
 mystatusbar = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })
 -- Add widgets to the statusbar
 mystatusbar:widgets({ mytextbox })
 -- Add the statusbar on screen #1
 mystatusbar.screen = 1

Y voilà. Ahora tenemos una nueva barra de estado en el tope de la pantalla que imprime en pantalla ''Hello, world!''. Usando este método, puedes configurar una barra de estado con muchos widgets antes de comenzar a ejecutar awesome, en tu archivo de configuración.

== Titlebar creation ==
Like I said before, titlebars are like statusbar except that they are around a window. To create a titlebar, you know the drill:

 mytitlebar = titlebar({ position = &quot;top&quot; })

Then, you probably want to put widgets in it. It works like statusbars:

 mytitlebartitle = widget({ type = &quot;textbox&quot;, name = &quot;mytitlebartitle&quot; })
 mytitlebar:widgets({ mytitlebartitle })

A titlebar must be added to a ''client object''. We can get the currently focused client: it is stored in ''client.focus'' variable. Let's do that:

 -- Get the focused client
 c = client.focus
 -- Set a titlebar on it
 c.titlebar = mytitlebar

Now, the focused client has a nice titlebar on top of it! But it has nothing in it. No, wait! Remember, in the titlebar we already added a ''textbox widget''. We can now print the client name in it:

 mytitlebartitle.text = c.name

The ''name'' attribute is a string with the client's title, and we set it as the text of the widget. Now the titlebar prints the client's title.

Remember: a titlebar is one object, and a client is another object. So you need to create a titlebar for each client you want a titlebar around.

== Using hooks ==
With what we seen before, you can build a nice interface. However, imagine you want to update the title printed in the titlebar of a client: you can't. Wait! Here's the solution: hooks.

With hooks, you can define functions that are called when an event happens. Let's try with an example.

When a new client pops up on the screen, awesome runs the function hooked by the ''manage'' hook. This function is called with the new client as its argument. Here's an example:

 function hook_manage(c)
     if c.name:find(&quot;mplayer&quot;) then
         c.floating = true
     end
 end

First, we defined a ''hook_manage'' function, with an argument named ''c'', which will be the client. Then, we try to find the string ''&quot;mplayer&quot;'' in the name of the client, and if so, we set it floating.

  awful.hooks.manage.register(hook_manage)

Then, with that call, we define that the function is to be calledd on each new client arrival is ''hook_manage''.

There's a lot of hooks you can use and define: focus, unfocus, manage, unmanage, mouseover, arrange, titleupdate, urgent, timer, … Refer to the manpage for more information.

== Executing commands and scripts ==

You can execute commands and scripts from the lua based configuration. Here is an example function that takes command as parameter and returns its output. This is usefull for example for putting stuff from command outputs to textboxes.

&lt;pre&gt;
-- Execute command and return its output. You probably won't only execute commands with one
-- line of output
function execute_command(command)
   local fh = io.popen(command)
   local str = &quot;&quot;
   for i in fh:lines() do
      str = str .. i
   end
   io.close(fh)
   return str
end
&lt;/pre&gt;

Here is an example of putting /proc/loadavg to mytextbox:
&lt;pre&gt;
 mytextbox.text = &quot; &quot; .. execute_command(&quot;cat /proc/loadavg&quot;) .. &quot; &quot;
&lt;/pre&gt;

= awesome Lua libraries =

== awful ==
[[awful]] is the default library to interact with awesome, like mouse actions or keybinds.

== beautiful ==
[[Beautiful]] is as library to theme the look of awesome.

== eminent ==
[[Eminent]] is a Lua library that will enable you to use dynamic tagging. Dynamic tagging in this instance means that the amount of tags you have is not pre-defined, you can give specific tags names, but simply going to the next tag when you're on the last tag will provide you with a brand new one, allowing you to adapt to various usage situations without changing your configuration file to give you more or less tags.

== wicked ==
[[Wicked]] is a Lua library for awesome to provide more widgets, like MPD Widgets, CPU usage, memory usage, etc.


[[Category: Awesome3]]</text>
      <sha1>mk4e4wr4m43d6uwa7ee3c1uholi3pl6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration/fr</title>
    <ns>0</ns>
    <id>369</id>
    <revision>
      <id>4705</id>
      <parentid>4302</parentid>
      <timestamp>2011-01-21T12:39:24Z</timestamp>
      <contributor>
        <username>Biganon</username>
        <id>576</id>
      </contributor>
      <comment>/* Manipulation des clients */</comment>
      <text xml:space="preserve" bytes="15113">{{DISPLAYTITLE:Configuration d’awesome 3}}
{{Languages|Awesome 3 configuration}}

== Contexte ==

Introduction de [[User:Jd|Julien Danjou]] :

« '''''awesome 3''' utilise maintenant un fichier de configuration fondé sur le langage [http://www.lua.org Lua]. La plupart des gens venant du monde d’awesome 2 risquent de râler car l’[[Awesomerc/fr|ancien fichier de configuration]] au format libconfuse a disparu, d’autres détesteront ça parce qu’ils n’ont jamais compris le fichier de configuration d’[http://modeemi.fi/~tuomov/ion/ ion], mais je l’ai fait quand même.''

''Pourquoi Lua ?''

''Parce qu’il offre plus de contrôle. Il offre un comportement conditionnel : avant, si on voulait qu’awesome fasse quelque chose quand il se passe quelque chose, on ne pouvait pas. Maintenant, on peut. On peut faire quasiment ''tout'' dans la liste des choses qu’un gestionnaire de fenêtres peut faire.'' »

== Fichiers ==
* ~/.config/awesome/rc.lua
* /etc/xdg/awesome/rc.lua

== Bases en Lua ==
On parle de Lua, alors on va d’abord apprendre le Lua. Si vous ne voulez pas, n’utilisez pas awesome 3 et arrêtez de lire maintenant. Ou alors, récupérez le fichier de configuration de l’archive '''.tar''' ou de quelqu’un, et bidouillez un peu ; ça devrait marcher même sans connaissance du langage Lua.

Pour ceux qui lisent encore, c’est super ! Lua est un langage ''simple''. D’un autre côté, si vous n’êtes pas habitué du tout aux langages informatiques, ''i. e.'' si vous ne savez pas ce que sont des « objets », des « méthodes » et des « arguments », eh bien, vous serez perdus en lisant ce document, alors allez apprendre les bases et revenez !

C’est un peu élitiste : awesome 3 est conçu pour les utilisateurs avancés avec un minimum de connaissances informatiques, mais si vous êtes vraiment motivé, ce n’est pas pour autant que vous ne pourrez pas apprendre les bases pour configurer et contrôler awesome.

La meilleure façon d’apprendre le Lua est de passer une heure ou deux à lire le livre ''[http://www.lua.org/pil/ Programming In Lua]'', qui est bien fait et qui vous donnera un aperçu de ce qu’il est possible de faire en Lua. N’hésitez pas à faire des marque-pages sur les notions importantes de ''flow control'', d’''useful statements'', etc. Ça vous aidera : c’est toujours horrible de chercher la syntaxe d’une boucle « for » quand on essaie encore de taper des lignes de code.

== Types d’objets awesome ==
Pour les gens qui viennent du fin fond de l’espace intersidéral et qui n’utilisaient pas awesome, voici les objets de bases qu’awesome vous propose et que vous allez devoir manipuler très bientôt :

;Écran
: Il n’y a pas de vrai objet « écran » dans awesome, mais on parlera des écrans plus tard. Un écran est un moniteur physique branché à votre ordinateur. Ils sont représentés par leurs numéros, commençant à 1.
;Client
: Un client est une fenêtre. Ça doit être suffisamment clair.
;Onglet
: Un onglet est en gros comme un bureau ou un bureau virtuel, mais le concept est moins rigide.
: Chaque client a au moins un onglet qui lui est assigné. Chaque écran a au moins un onglet.
: À tout moment, sur un écran, vous pouvez voir n’importe quel onglet numéro untel. Ne regarder aucun onglet revient à cacher tous les clients. Regarder un ou plusieurs onglets revient à voir tous les clients qui ont ces onglets.
;Widget
: Les widgets sont des objets qui affichent des trucs sur l’écran. Il y a de nombreux types de widgets. Par exemple, il y a un widget « boîte de texte » qui affiche du texte à l’écran. Il y a aussi un widget « boîte à icone » qui affiche une icône à l’écran.
;Barre de titre
: Une barre de titre est une barre qui se trouve autour d’un client et qui lui est attaché. Vous pouvez mettre des widgets dessus.
;Barre de statut
: Une barre de statut est une barre qui est fixée au bord d’un écran. Vous pouvez mettre des widgets dessus.

== Construisons notre interface ==
Pour construire notre interface, on doit utiliser les fonctions et méthodes d’awesome : ''tout'' est documenté dans la [http://awesome.naquadah.org/doc/api/ documentation de l’interface de programmation (API) de Lua] et dans la page de manuel '''awesomerc(5)'''. Lisez-les. Elles sont vos références de développement. À nouveau : lisez-les, tout est documenté dans cette page de manuel et la doc de Lua.

C’est quelle page de manuel, déjà ? … '''awesomerc(5)'''. Bien. Vous suivez.

''Voir aussi : [[Man pages/fr|Pages de manuel]]''

=== Création d’onglets ===
Si vous lancez awesome sans aucune opération Lua, vous n’aurez aucun onglet, ce qui est critique. awesome veut au moins un onglet.

Donc d’abord, on doit créer un onglet. Comment on fait ça ? On cherche « ''tag()'' » et sa documentation dans la page de manuel : c’est la fonction de création d’onglets. Ça dit que le paramètre de la fonction doit être un tableau avec au moins un attribut de nom. Faisons ça :

 mytagone = tag({ name = &quot;one&quot; })

Là, on a déclaré un objet, « ''mytagone'' », qui est un objet « onglet », et son nom est « ''one'' ». Si on veut lui donner la disposition par défaut, on la rajoute sous la forme d’une paire de valeurs ou clés dans le tableau, comme expliqué dans la documentation.

 mytagtwo = tag({name = &quot;two&quot;, layout = &quot;floating&quot; })

Maintenant, on a un deuxième objet onglet, « ''mytagtwo'' » : son nom est « ''two'' », et par défaut il arrange les clients avec l’algorithme flottant, qui, comme son nom l’indique, laisse les clients flotter.

Créer des objets, c’est sympa, mais bon, pour le moment ça sert à rien. Souvenez-vous : chaque écran a au moins un onglet. Donc on doit ajouter les onglets qu’on vient de créer à notre premier écran. L’attribut ''screen'' de l’objet onglet fait ça pour nous : on a juste à lui donner le numéro de l’écran.

 mytagone.screen = 1

On vient d’ajouter cet onglet à l’écran nº1. Si on a un deuxième écran (multi-écran : Zaphod, Xinerama ou XRandR sont identiques pour awesome), on peut ajouter notre deuxième onglet à cet écran :

 mytagtwo.screen = 2

Et si on a trois écrans, on doit… Eh bien, vous avez sans doute déjà trouvé.

Si vous voulez savoir combien d’écrans vous avez, vous pouvez utiliser la fonction ''screen.count()''.

Vous pouvez manipuler l’affichage d’un onglet avec l’attribut ''selected''. Si vous voulez voir votre onglet « ''one'' » :

 mytagone.selected = true

Si vous voulez le cacher, vous pouvez évidemment affecter la valeur à ''false''.

Vous pouvez manipuler tous les paramètres de l’onglet avec ses attributs. Regardez dans la documentation.

=== Manipulation des clients ===
Parfois, vous aurez des objets « client ». C’est très utile dans les fonctions ''hook'', dont on parlera plus tard.

Un client est un objet qui a des méthodes lui aussi, comme les onglets et les autres. Décidons que la variable ''c'' est notre objet client.

Par exemple, si on veut qu’un client soit flottant, on peut utiliser l’attribut ''floating'' de cette façon :

 c.floating = true

Certaines méthodes retournent des valeurs qui peuvent être utilisées plus tard pour analyse. Si l'on veut savoir si un client est flottant, on peut récupérer l’attribut ''floating'' :

 is_client_floating = c.floating

La variable ''is_client_floating'' contient maintenant un booléen : ''true'' si le client flotte ou ''false'' sinon.

On peut combiner ces deux fonctions pour créer une fonction de bascule : cette fonction mettra l’état flottant du client à ''true'' s’il ne l’est pas, et à ''false'' si l’est.

 function client_floating_toggle(c)
     if c then
         c.floating = not c.floating
     end
 end

On peut aussi utiliser ça pour basculer un onglet à notre client :

 function client_tag_with_tag_one(c)
     if c then
         local t = c:tags()
         table.insert(t, one)
         c:tags(t)
     end
 end

=== Création de widgets ===
Les widgets sont de petits objets qui peuvent être placés soit sur une barre de titre, soit sur une barre de statut. Comme pour les onglets, si vous ne les ajoutez nulle part, ils servent complètement à rien. Pour créer un widget, on utilise la fonction ''widget()'' :

 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })

''mytextbox'' contient maintenant un objet « widget ». Vous pouvez utiliser différents attributs avec différents types de widgets ; ce qui suit paramètre le texte affiché par la boîte textuelle.

 mytextbox.text = &quot;Hello, world!&quot;

=== Création de barre de statut ===
Les barres de statut sons des conteneurs à widgets que vous pouvez mettre sur les bords haut, bas, gauche ou droite de l’écran.

D’abord, on crée une barre de statut :

 mystatusbar = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })

''mystatusbar'' est maintenant une variable qui contient un objet « barre de statut ». Comme on a mis la valeur de ''position'' à ''top'', la barre sera placée en haut de l’écran. Évidemment, on ne l’a pas ajoutée à l’écran, donc elle ne sert à rien pour le moment. Réglons ça :

 mystatusbar.screen = 1

Notre barre de statut est maintenant visible en haut de l’écran. Mais bon, elle ne fait rien, donc elle n’est pas très utile… Ajoutons des widgets !

 -- Crée une boîte textuelle
 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })
 -- Paramètre le texte de la boîte textuelle
 mytextbox.text = &quot;Hello, world!&quot;
 -- Crée une barre de statut
 mystatusbar = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })
 -- Ajoute des widgets à la barre de statut
 mystatusbar:widgets({ mytextbox })
 -- Ajoute la barre de statut à l’écran nº1
 mystatusbar.screen = 1

Et ''that’s all, folks!''. On a maintenant une barre de statut toute neuve en haut de l’écran, qui affiche « ''Hello, world!'' ». De cette façon, vous pouvez mettre en place une barre de statut avec de nombreux widgets avant de lancer awesome, dans votre fichier de configuration.

=== Création de barre de titre ===
Comme dit plus tôt, les barres de titre sont comme des barres de statut, sauf qu’elles sont autour d’une fenêtre. Pour créer une barre de titre, c’est toujours la même rengaine :

 mytitlebar = titlebar({ position = &quot;top&quot; })

Ensuite, vous voulez sans doute mettre des widgets dessus. Ça marche comme pour les barres de statut :

 mytitlebartitle = widget({ type = &quot;textbox&quot;, name = &quot;mytitlebartitle&quot; })
 mytitlebar:widgets({ mytitlebartitle })

Une barre de titre doit être ajoutée à un objet « client ». On peut obtenir le client qui est actuellement au premier plan : c’est stocké dans la variable ''client.focus''. C’est parti :

 -- On récupère le client au premier plan
 c = client.focus
 -- On met une barre de titre dessus
 c.titlebar = mytitlebar

Maintenant, le client au premier plan a une barre de titre sympa au-dessus de lui ! Mais il n’y a rien dessus. Ah si, attendez ! Vous vous souvenez, on a déjà ajouté un widget « boîte textuelle » dans la barre de titre. On peut donc maintenant afficher le nom du client dedans :

 mytitlebartitle.text = c.name

L’attribut ''name'' est une chaîne de caractères contenant le titre du client, et on l’a mis dans le texte du widget. Maintenant, la barre de titre affiche le titre du client.

Souvenez-vous : une barre de titre est un objet, et un client est un autre objet. Donc on doit créer une barre de titre pour chaque client pour lequel vous voulez une barre de titre autour.

=== Utiliser des ''hooks'' ===
Avec ce qu’on vient de voir, vous pouvez construire une interface sympa. Mais imaginez maintenant que vous voulez mettre à jour le titre qui s’affiche dans la barre de titre d’un client : vous ne pouvez pas. Attendez ! Voilà la solution : les ''hooks''.

Avec les ''hooks'', vous pouvez définir des fonctions qui sont appelées quand un évènement se produit. Essayons sur un exemple simple.

Quand un nouveau client arrive sur l’écran, awesome lance la fonction liée au ''hook'' « ''manage'' ». Cette fonction est appelée avec le nouveau client comme argument. Voici un exemple :

 function hook_manage(c)
     if c.name:find(&quot;mplayer&quot;) then
         c.floating = true
     end
 end

D’abord, on définit une fonction ''hook_manage'', avec un argument qui s’appelle ''c'', qui sera le client. Ensuite, on essaie de trouver la chaîne « mplayer » dans le nom du client, et si c’est le cas, on le rend flottant.

  awful.hooks.manage.register(hook_manage)

Ensuite, avec cet appel, on définit que la fonction qui doit être appelée à l’arrivée de chaque client est ''hook_manage''.

Il y a de nombreux ''hooks'' que vous pouvez utiliser et définir : focus, unfocus, manage, unmanage, mouseover, arrange, titleupdate, urgent, timer, etc. Reportez-vous à la page de manuel pour plus d’information.

=== Exécuter des commandes et des scripts ===
Vous pouvez exécuter des commandes et des scripts depuis la configuration de base de Lua. voici un exemple de fonction qui prend une commande en paramètre et renvoie sa sortie. C’est très utile par exemple pour mettre des sorties de commandes dans des boîtes textuelles.

 -- Exécute « command » et renvoie sa sortie. On ne va sans doute pas
 -- exécuter seulement des commandes avec une seule ligne de sortie.
 function execute_command(command)
    local fh = io.popen(command)
    local str = &quot;&quot;
    for i in fh:lines() do
       str = str .. i
    end
    io.close(fh)
    return str
 end

Voici un exemple où l’on met '''/proc/loadavg''' dans ''mytextbox'' :
 mytextbox.text = &quot; &quot; .. execute_command(&quot;cat /proc/loadavg&quot;) .. &quot; &quot;

== Bibliothèques Lua d’awesome ==

;[[Awful]]
: La bibliothèque par défaut pour interagir avec awesome, comme les actions avec la souris ou les touches du clavier.
;[[Beautiful/fr|Beautiful]]
: Bibliothèque pour changer le thème d’apparence d’awesome.
;[[Eminent]]
: Bibliothèque Lua qui vous permet de faire des onglets dynamiques. Les onglets dynamiques, dans ce contexte, signifie que le nombre d’onglets que vous avez n’est pas prédéfini ; vous pouvez donnez des noms d’onglets spécifiques, mais encore mieux par exemple : simplement aller sur l’onglet suivant quand vous êtes sur le dernier onglet vous fournit un onglet tout neuf, ce qui vous permet de vous adapter à de nombreuses situations sans changer votre fichier de configuration pour ajouter ou enlever un onglet. ''Cette bibliothèque est obsolète : Shifty ci-dessous est plus flexible est plus à jour''
;[[Shifty/fr|Shifty]]
: Bibliothèque à jour de gestion d’onglets dynamiques et de clients.
;[[Naughty/fr|Naughty]]
: Bibliothèque de notification.
;[[Wicked/fr|Wicked]]
: Bibliothèque Lua pour awesome, fournissant plus de widgets ; par exemple des widgets MPD, l’utilisation du processeur, de la mémoire, etc.

[[Category: Awesome3]]</text>
      <sha1>fbowj2jbhpij69vev2404dzmoc1ea0l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration/it</title>
    <ns>0</ns>
    <id>155</id>
    <revision>
      <id>4143</id>
      <parentid>2757</parentid>
      <timestamp>2010-03-15T22:25:48Z</timestamp>
      <contributor>
        <username>Fero</username>
        <id>436</id>
      </contributor>
      <minor/>
      <comment>api link</comment>
      <text xml:space="preserve" bytes="14189">{{Template:Languages|Awesome_3_configuration}}

= Ambiente =

'''awesome 3''' utilizza un file di configurazione basato sul linguaggio [http://www.lua.org Lua]. Molte persone che utilizzavano awesome 2 piangeranno quando vedranno che il vecchio file in libconfuse è sparito, altri odieranno awesome 3 perchè non riescono a capire il file di configurazione [http://modeemi.fi/~tuomov/ion/ ion].

Perchè Lua?
Perchè offre più controllo. Permette di controllare più aspetti: stavate cercando di far fare ad awesome qualcosa in un determinato evento, e non eravate in grado di farlo. Ora siete in grado di fare '''qualsiasi cosa''' (nel campo di quello che può fare un window manager).

= File =
* ~/.config/awesome/rc.lua
* /etc/xdg/awesome/rc.lua

= Basi di Lua =
Abbiamo parlato di Lua; quindi prima di tutto imparate Lua. Non volete? Allora fate a meno di usare awesome 3 e smettete di leggere. (Oppure procuratevi il file di configurazione dall'archivio dei sorgenti o da qualcuno, e dategli una ritoccata, perchè non potete fare altro senza la conoscenza del lua).

Per le persone che stanno ancora leggendo, Lua è un linguaggio '''semplice'''. In altre parole, se non avete familiarità coi linguaggi di programmazione, i.e. se non conoscete ''oggetti'', ''metodi'' e ''parametri'', beh, vi troverete un poco spaesati leggendo questa pagina; andate a imparare un po' di basi della programmazione e tornate!

Non sto chiedendo geni dell'informatica: awesome 3 è ideato per le persone che hanno un minimo di ''background'' informatico. Comunque qualsiasi persona, se abbastanza motivata, può imparare le basi che servono a configurare e controllare awesome.

Il miglior modo per imparare Lua è quello di dedicare un paio d'ore alla lettura di [http://www.lua.org/pil/ Programming In Lua], che da un'anteprima di quello che è possibile realizzare in Lua. Non esitare ad aggiungere ai Preferiti una pagina così importante: parla di controllo del flusso, espressioni, ecc. Questo dovrebbe aiutare : è una pessima idea cercare a proposito della sintassi &quot;for&quot; quando stai scrivendo linee di codice.

= Tipi di oggetti in awesome =
Per le persone che non hanno mai usato awesome, qui sono spiegati gli oggetti messi a disposizione, che è necessario manipolare.

== Screen ==
Non c'è un vero e proprio schermo in awesome, ma parleremo dopo degli oggetti di questo tipo. Uno ''screen'' è un monitor fisico collegato al vostro computer. Sono rappresentati da un indice che parte da 1.

== Client ==
Un ''client'' è una finestra. Credo di essere stato chiaro.

== Tag ==
Un ''tag'' è qualcosa come un workspace/desktop, anche se il concetto è meno rigido.
Ogni client ha almeno un tag assegnato. Ogni screen ha almeno un tag.
In qualsiasi momento, su uno screen, poteve vedere un qualsiasi numero di tag. Facendo a meno di osservare almeno un tag, nasconderai tutti i client. Osservando uno o più tag contemporaneamente, saranno visibili tutti i client che ogni tag possiede.

== Widget ==
I ''widget'' sono oggetti che visualizzano qualcosa su uno screen. Ci sono molti tipi di widget. Per esempio c'è il tipo textbox che stampa un testo su uno screen. Ci sono anche i widget iconbox che visualizzano un'icona su uno screen.

== Titlebar ==
Una ''titlebar'' è una barra che è intorno ad un client e attaccata ad esso. Potete inserire dei widget in essa.

== Statusbar ==
Una ''statusbar'' è una barra fissata al bordo di uno screen. Anche qui, potete inserire dei widget all'interno.

= Costruiamo l'interfaccia =
Per costruire la nostra interfaccia, dobbiamo usare le funzioni e i metodi messi a disposizione da awesome: '''qualsiasi cosa''' è riportata nella [http://awesome.naquadah.org/doc/api/ Documentazione delle API Lua] e nel manuale di awesomerc(5). Leggeteli. Rappresentano la documentazione alla quale dovete riferirvi. Vi ripeto: leggeteli; qualsiasi cosa è documentata in quella pagina di manuale o nella luadoc.

Quale pagina di manuale? ... awesomerc(5). Ottimo. Mi stavate seguendo.

== Creare i tag ==
Se avviate awesome senza esegure alcuna operazione con lua, vi ritroverete con 0 tag; questo è fatale. Awesome ha bisogno di almeno un tag.

Per prima cosa, dobbiamo creare un tag. Come possiamo farlo? Vediamo i tag() nella documentazione, e la funzione per creare tag nella pagina del manuale. Dice che il parametro della funzione dev'essere una tabella con almeno un nome come parametro. Facciamolo.

 mytagone = tag({ name = &quot;one&quot; })

''mytag'' è un nuovo oggetto di tipo tag, il suo nome è ''one''. Se vogliamo impostargli un layout di default, dobbiamo aggiungere una chiava/valore all'interno della tabella, come spiegato nella documentazione.

 mytagtwo = tag({name = &quot;two&quot;, layout = &quot;floating&quot; })

Ora, noi abbiamo un secondo tag: il suo nome è ''two'', e di default lui gestisce i client con lo schema floating, che come suggerisce il nome, rende i client liberi.

Creare oggetti è divertente, ma per il momento privo di utilità. Ricorda ogni screen deve avere almeno un tag. Quindi dobbiamo aggiungere questi tag che abbiamo creato al nostro primo screen. L'attributo ''screen'' di un tag lo fa per noi, dobbiamo solo assegnare il numero dello screen che desideriamo.

 mytagone.screen = 1

Ora abbiamo aggiunto il tag allo screen #1. Se abbiamo un secondo screen (multi-head: Zaphod, Xinerama o XRandR sono identici per awesome), dobbiamo aggiungere un secondo tag a questo screen:

 mytagtwo.screen = 2

E se avessimo 3 screen, dobbiamo... beh, spero abbiate capito il concetto.

Se volete conoscere quanti screen avete, potete usare la funzione ''screen.count()''.

Potete gestire la visualizzazione del tag con l'attributo ''selected''. Se volete vedere il tag ''one'':

 mytagone.selected = true

Se volete nasconderlo, ovviamente dovete settare il valore su ''false''.

Potete gestire tutte le impostazioni del tag con i suoi attributi. Guardate la documentazione,

== Gestire i client ==
Qualche volta, vorrete prendere gli oggetti di tipo client. Sono veramente utili nelle funzioni hook, delle quali ne parleremo dopo.

Un client è un oggetto con dei metodi, come i tag e altro. Decidiamo che la variabile ''c'' è il nostro oggetto client.
Per esempio, se vogliamo rendere un client libero dobbiamo usare l'attributo ''floating'' in questo modo:

 c.floating = true

Alcuni metodi ritornano valori che possono essere usati dopo per delle analisi. Se vogliamo sapere se un client è libero possiamo prendere l'attributo ''floating'':

 is_client_floating = c.floating

La variabile ''is_client_floating'' ora contiene un valore booleano: ''true'' se il client è libero o ''false'' se non lo è.

Possiamo combinare queste 2 funzioni per creare una funzione: questa funzione imposterà lo stato libero del client su true se non lo è già, oppure su falso se lo è.

 function client_floating_toggle(c)
     if c then
         c.floating = not c.floating
     end
 end

Possiamo anche usare questa funzione per spostare un client su un determinato tag:

 function client_tag_with_tag_one(c)
     if c then
         local t = c:tags()
         table.insert(t, one)
         c:tags(t)
     end
 end

== Creare i widget ==
I widget sono piccoli oggetti che possono essere disposti nelle titlebar o nelle statusbar. Come i tag, se non li aggiungete da qualche parte, sono completamente inutili. Per creare un widget usate la funzione ''widget()'':

 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })

Ora ''mytextbox'' contiene un oggetto di tipo textbox. Potete usare diversi attributi con diversi tipi di widget, il prossimo inserisce un testo in una textbox.

 mytextbox.text = &quot;Hello, world!

== Creare statusbar ==
Le statusbar sono contenitori di widget che possono essere disposti in alto, in basso, a sinistra o a destra di uno screen.

Primo, create la statusbar:

 mystatusbar = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })

''mystatusbar'' è una variabile che contiene un oggetto statusbar. Abbiamo dato a ''position'' il valore ''top'', che posizionerà la barra in alto allo screen. Ovviamente, non l'abbiamo aggiunta allo screen, per ora è un oggetto inutile. Quindi facciamo:

 mystatusbar.screen = 1

La nostra statusbar sarà ora visibile in alto allo screen. Bene, non fa niente ma è davvero utile. Aggiungiamo qualche widget!

 -- Crea una textbox
 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })
 -- Imposta un testo nella textbox
 mytextbox.text = &quot;Hello, world!&quot;
 -- Crea una statusbar
 mystatusbar = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })
 -- Aggiunge le widgets alla statusbar
 mystatusbar:widgets({ mytextbox })
 -- Aggiunge la statusbar allo screen #1
 mystatusbar.screen = 1

E voilà. Ora abbiamo una statusbar nuova di zecca in alto allo schermo che visualizza ''Hello, world!''. Usando questo metodo, potete settare un bel po' di widget sulla statusbar prima di avviare awesome, nel vostro file di configurazione.

== Creare titlebar ==
Come detto prima, le titlebar sono come le statusbar ma le titlebar si trovano intorno ad una finestra. Per creare una titlebar, sapete cosa fare:

 mytitlebar = titlebar({ position = &quot;top&quot; })

Quindi, probabilmente vorreste inserire dei widget all'interno. Funziona come nelle statusbar:

 mytitlebartitle = widget({ type = &quot;textbox&quot;, name = &quot;mytitlebartitle&quot; })
 mytitlebar:widgets({ mytitlebartitle })

Una titlebar dev'essere aggiunta a un ''oggetto client''. Possiamo ottenere la finestra in primo piano: è contenuta nella variabile ''client.focus''. Facciamo questo:

 -- Prendi la finestra in primo piano
 c = client.focus
 -- Imposta una titlebar per quella finestra
 c.titlebar = mytitlebar

Ora, la finestra in primo piano ha una carina titlebar in alto! Ma non c'è nulla all'interno. No, aspetto! Ricorda, nelle titlebar noi possiamo sempre aggiungere una ''widget di tipo textbox''. Possiamo ora stampare il nome del client su di essa:

 mytitlebartitle.text = c.name

L'attributo ''name'' è una stringa che contiene il nome del client, e noi inseriamo il testo in una widget. Ora la titlebar visualizza il titolo del client.

Ricorda: una titlebar è un oggetto, e un client è un altro oggetto. Vuol dire che dovrai creare una titlebar per ogni client a cui vuoi assegnarla.

== Usare gli hooks ==
Con quello che abbiamo visto prima, potete costruire una bella interfaccia. Comunque, immagine di voler aggiornare il titolo visualizzato nella titlebar di un client: non potete. Aspetta! Qui c'è la soluzione: gli hooks.

Con gli hooks, potete definire funzioni che sono richiamate al seguito di un evento. Provate con un esempio.

Quando un nuovo client appare nello screen, awesome esegue la funzione collegata ''gestita'' dall'hook. Questa funzione è chiamata passando il nuovo client come argomento. Questo è un esempio:

 function hook_manage(c)
     if c.name:find(&quot;mplayer&quot;) then
         c.floating = true
     end
 end

In primo luogo, abbiamo definito una funzione ''hook_manage'', con un argomento chiamato ''c'', che sarà il cliente. Quindi, cerchiamo di trovare la stringa ''&quot;mplayer&quot;'' nel nome del client, e se c'è, impostiamo lo stato libero al client.

  awful.hooks.manage.register(hook_manage)

Poi, con quella chiamta, definiamo che la funzione chiamata per ogni nuovo client che arriva è ''hook_manage''.

Ci sono molti hooks che potete usare e definire: focus, unfocus, manage, unmanage, mouseover, arrange, titleupdate, urgent, timer, … Consultate il manuale per altre informazioni.

== Creare le combinazioni di tasti ==
A volte può essere utile mappare alcune azioni ad una serie di tasti, che sono spesso più facili da premere rispetto Mod-shift-ctrl-x. Nell'esempio seguente è possibile digitare Ctrl-f e DOPO premere &quot;a&quot; invece di premere tutti i tasti nello stesso momento.

  -- Crea una lista di scorciatoie da tastiera che possono essere aggiunte quando viene premuto Ctrl-f
  keybind_ctrl_f = {} 
   
  function keychain_ctrl_f_add() 
      for k, v in pairs(keybind_ctrl_f) do 
          v:add() 
      end 
  end 
  
  function keychain_ctrl_f_remove() 
      for k, v in pairs(keybind_ctrl_f) do 
          v:remove() 
      end 
  end 
  
  table.insert(keybind_ctrl_f, keybinding({}, &quot;a&quot;, function () 
      mytextbox.text = &quot;You pressed a!&quot;
      keychain_ctrl_f_remove() 
  end)) 
  
  table.insert(keybind_ctrl_f, keybinding({ &quot;Mod4&quot; }, &quot;b&quot;, function () 
      mytextbox.text = &quot;You pressed Mod4 + b!&quot;
      keychain_ctrl_f_remove() 
  end)) 
  
  table.insert(keybind_ctrl_f, keybinding({}, &quot;Escape&quot;, keychain_ctrl_f_remove)) 
  
  keybinding({ &quot;Control&quot; }, &quot;f&quot;, keychain_ctrl_f_add):add()

== Eseguire comandi e script ==

Potete eseguire comandi e script inseriti nella configurazione base di lua. Qui un esempio di funzione che prende come parametro un comando e ritorna un risultato. Questa è utile per esempio per visualizzare qualcosa nelle textbox.

&lt;pre&gt;
-- Esegui il comando e ritorna il suo risultato. Probabilmente non volete eseguire
-- comandi che hanno una sola linea come output
function execute_command(command)
   local fh = io.popen(command)
   local str = &quot;&quot;
   for i in fh:lines() do
      str = str .. i
   end
   io.close(fh)
   return str
end
&lt;/pre&gt;

Qui un esempio che inserisce /proc/loadavg in mytextbox:
&lt;pre&gt;
 mytextbox.text = &quot; &quot; .. execute_command(&quot;cat /proc/loadavg&quot;) .. &quot; &quot;
&lt;/pre&gt;

= Librerie Lua di awesome =

== awful ==
[[awful]] è la libreria predefinita per interagire con awesome, come le azioni del mouse o le scorciatoie da tastiera.

== beautiful ==
[[Beautiful]] è la libreria per gestire il tema di awesome.

== eminent ==
[[Eminent]] è una libreria Lua che permette di gestire i tag dinamicamente. Con gestire i tag dinamicamente intendo dire che il numero di tag che avrete non è predefinito, potete assegnare specifici nomi ai tag, ma semplicemente andando nel prossimo tag o nell'ultimo potrete aggiungere un tag, permettendovi di adattarvi alla situazione senza cambiare la vostra configurazione per avere più o meno tag.

== wicked ==
[[Wicked]] è una libreria Lua per awesome che fornisce molti widget, come il widget per MPD, utilizzo della CPU, memoria, ecc.

[[Category:Awesome3]]</text>
      <sha1>r30gvehri2gukh2eyk6qqj81wjreshr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration/ru</title>
    <ns>0</ns>
    <id>251</id>
    <revision>
      <id>6532</id>
      <parentid>6494</parentid>
      <timestamp>2014-05-17T17:01:50Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Файлы */ добавлено различие в файлах rc.lua</comment>
      <text xml:space="preserve" bytes="24082">{{Template:Languages|Awesome_3_configuration}}

= Описание =

'''awesome 3''' теперь использует конфигурационный файл основанный на языке [http://www.lua.org Lua]. Большинство переходящих с awesome 2 будут разочарованы увидев, что старый формат кофигурационного файла в libconfuse исчез, некоторые будут сожалеть по этому поводу, так как они никогда не могли понять формат конфигов [http://modeemi.fi/~tuomov/ion/ ion'a].

Почему Lua?
Потому что этот язык дает больше управляемости. Если предположить подобную ситуацию: вам нужно сделать что-то при некотором условии, ранее такого бы не получилось. Но теперь вы можете сделать это. Вы можете сделать практически '''все''' (конечно в пределах возможностей WM'а).

= Файлы =
* ~/.config/awesome/rc.lua
* /etc/xdg/awesome/rc.lua

По умолчанию если система находит файл в ~/.config/awesome/rc.lua, то используется он. Но если в нем присутсвуют ошибки, либо его нет, то загружается дефолтная конфигурация из /etc/xdg/awesome/rc.lua (никогда не трогайте это файл, чтобы коректно загрузиться в случае сбоев или ошибок в основном файле).

= Основы Lua =
[http://www.lua.org Lua] - очень простой язык. Хотя глубокое понимание этого языка не является обязательным условием для использования Awesome, знание Lua напрямую влияет на возможность кастомизации и полной реализации потенциала Awesome.

awesome 3 разработан для опытных пользователей, которые имеют хотя бы минимальные представления о компьютерных технологиях. В любом случае, если у вас есть желание, то выучить основы настройки и управления awesome не составит труда.

Лучший способ выучить Lua - это тратить по паре часов в день на чтение книги [http://www.lua.org/pil/ Programming In Lua], которая даст представление о возможностях языка. В ходе чтения создавайте закладки важных страниц описывающих управление плавающими окнами, содержащих полезную информацию и проч. Это поможет, глупо было бы подглядывать синтаксис цикла ''for'' в ходе написания кода, не так ли?

= Типы объектов awesome =
Для тех людей, что ранее не использовали awesome, в этом разделе представлены базовые объекты, которыми вы сможете управлять.

== Screen ==
На самом деле screen — это не объект, но мы подробно рассмотрим этот момент позднее. А пока вам необходимо знать, что screen это реальный монитор (устройство), подключенное к вашему компьютеру. Если вы имеете несколько мониторов, то они будут представлены своими индексами, начиная с единицы.

== Client ==
Клиент - это окно приложения. 

== Tag ==
Тэги - это что-то подобное рабочим столам, но это понятие менее жесткое. Каждый клиент имеет по крайней мере один тэг, ему соответсвующий. Каждый экран также содержит как минимум один тэг. В любой момент на экране вы можете просматривать любое количество тэгов. Отображение без тэгов скроет все клиенты. Просмотр одного и более тэгов отобразит на экране все приложения с этими тэгами.

== Widget ==
Виджеты - это объекты выводящие информацию на экран. Существует несколько типов виджетов, которые отображают определенный тип информации: текстовые виджеты, виджеты отображающие иконки.

== Titlebar ==
Заголовок окна - это полоса вокруг приложения и присоединенная к нему. На него можно добавлять виджеты.

== Statusbar ==
Строка состояния - это полоса которая закреплена на границе экрана. На ней так же можно размещать виджеты.

= Создание собственного интерфейса =
Для создания интерфейса, необходимо использовать функции и методы awesome: '''все''' описано в [http://awesome.naquadah.org/doc/api/ Lua API documentation] и в man-странице awesomerc(5). Прочтите их, они ваше руководство по разработке.

== Создание тэгов ==
Если вы запустите awesome без какого либо кода Lua, у вас будет 0 тэгов, что фатально. awesome необходим хотя бы один тэг.

Итак во-первых, нам нужно создать тэг. Как это сделать? Мы ищем описание tag(), функции для создания тегов в man-странице. Там говорится что параметром функции должна являться таблица, которая содержит хотя бы имя атрибута. Сделаем это.

 mytagone = tag({ name = &quot;one&quot; })

Только что вы создали объект ''mytagone'' с типом tag и атрибутом name со значением ''one''. Если мы захотим установить метод компоновки окон (layout) по умолчанию для этого объекта, мы можем сделать это, добавив пару ключ/значение  в таблицу, как описано в документации.

 mytagtwo = tag({name = &quot;two&quot;, layout = &quot;floating&quot; })

Теперь у нас есть второй объект типа tag — &quot;mytagtwo&quot; c атрибутом name со значением ''two'' и по умолчанию приложения (clients) будут располагаться на нем согласно &quot;плавающему&quot; алгоритму (подобным образом окна располагаются в большинстве WM, например в kwin, metacity etc), который, как видно из его названия, позволяет их перемещать.(? lets the clients float.)

Теперь мы имеем общее представление о создании объектов, но смотря правде в глаза, в данный момент это не приносит нам особой пользы, так как кроме этого мы пока ничего не умеем. Пока запомните: каждый &quot;объект&quot; screen (физический монитор) должен иметь по крайней мере один тэг. Что же, теперь мы хотим добавить только что созданные тэги на наш первый (и возможно единственный) монитор. Атрибут &quot;screen&quot; tag-объекта сделает это за нас, все что нам нужно — это присвоить цифровое значение (индекс, соответствующий монитору) атрибуту screen.

 mytagone.screen = 1

Только что мы добавили тэг на screen (монитор) #1. Если у нас есть второй монитор (multi-head: Zaphod, Xinerama или XRandR — для awesome не имеет значения), мы можем добавить наш второй тэг для этого монитора:

 mytagtwo.screen = 2

Соответственно если у нас 3 монитора нам нужно... Впрочем, я думаю это понятно. :)

Если вы хотите узнать сколько у вас мониторов, вы можете использовать функцию ''screen.count()''.

Вы можете управлять отображением тэгов, используя атрибут ''selected''. Например, если вы хотите увидеть ваш тэг 'one' (по сути все окна, &quot;привязанные&quot; к этому тэгу):

 mytagone.selected = true

Если вы хотите скрыть его, вы, очевидно, должны установить установить значение ''false'' для атрибута ''selected''.

Вы можете управлять всеми настройками тэгов, используя их атрибуты. Подробнее смотрите в документации.

== Управление приложением (client) ==
Иногда вам придется работать с объектами приложений (clients). Чаще всего это используется в hook-функциях, которые мы рассмотрим позднее.

Приложение (client) это такой же объект, который тоже имеет методы, подобно, например, тэгам. Для следующих примеров условимся, что наш объект приложения будет хранится в переменной ''c''.
Например, если мы хотим установить floating компоновку для приложения мы можем использовать ''floating'' атрибут таким образом:

 c.floating = true

Некоторые методы возвращают значения, которые могут быть использованы позднее для анализа. Так, если мы хотим узнать, является ли компоновка приложения (client) ''floating'', мы можем получить значение ''floating'' атрибута:

 is_client_floating = c.floating

Переменная ''is_client_floating'' теперь содержит булево (boolean) значение: ''true'' в случае¸ если компоновка приложения floating, или ''false'' в обратном случае.

Используя полученные знания, мы можем написать функцию-''переключатель'', которая будет устанавливать атрибут floating приложения (client) в ''true'', если режим компоновки ''не'' floating , и в ''false'' в обратном случае (когда режим компоновки floating).

 function client_floating_toggle(c)
     if c then
         c.floating = not c.floating
     end
 end

Так же мы можем использовать подобную функцию для изменения (''переключения'') тэгов нашего приложения (client):

 function client_tag_with_tag_one(c)
     if c then
         local t = c:tags()
         table.insert(t, one)
         c:tags(t)
     end
 end

== Создание виджетов (widget) ==
Виджеты — это небольшие объекты, которые могут быть расположены (добавлены) в заголовок окна (приложения) или в строку состояния. Подобно тэгам, если вы не добавите их куда-нибудь, они будут полностью бесполезны, вы попросту не сможете их использовать. Для того, чтобы создать виджет вы должны использовать функцию ''widget()'':

 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })

''mytextbox'' теперь содержит объект виджета. Вы можете использовать различные атрибуты для различных типов виджетов. Например, следующая команда устанавливает текст, который будет отображен в только что созданном виджете (тип ''textbox'').

 mytextbox.text = &quot;Hello, world!

== Создаем строку состояния (statusbar) ==
Строка состояния (statusbar) — это контейнер для виджетов, который вы можете расположить у верхней, нижней, левой или правой границы экрана.

Для начала создадим строку состояния:

 mystatusbar = wibox({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })

Теперь ''mystatysbar'' это переменная, содержащая объект строки состояния. Если мы установим значение ''top'' для атрибута ''position'' строка состояния будет помещена рядом с верхней границей экрана. Очевидно, что пока мы не &quot;привяжем&quot; строку состояния к нашему монитору, мы не сможем ее видеть и пользоваться ей. Сделаем это:

 mystatusbar.screen = 1

Наша строка состояния теперь видна рядом с верхней границей экрана. Пока ее никак нельзя использовать, но поверьте — ее функционал очень широк. Давайте добавим на нее виджеты!

 -- Создаем textbox
 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })
 -- Устанавливаем текст для textbox
 mytextbox.text = &quot;Hello, world!&quot;
 -- Создаем строку состояния (statusbar)
 mystatusbar = awful.wibox({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })
 --Добавляем виджеты на строку состояния
 mystatusbar:widgets({ mytextbox })
 -- &quot;Привязываем&quot; строку состояния к первому монитору
 mystatusbar.screen = 1

Вуаля. Теперь у нас есть строка состояния, расположенная у верхней границы экрана, на которой напечатано ''Hello, world!''. Используя этот метод, вы можете настроить параметры строки состояния и разместить на ней виджеты перед тем как запустить awesome, в вашем конфигурационном файле.

== Создание заголовка окна (titlebar) ==
Как уже было сказано заголовки окна (titlebars) похожи на строку состояния (statusbar), за тем исключением, что они находятся вокруг окна, а не у границ экрана. Для создания заголовка окна вы должны сделать следующее:

 mytitlebar = titlebar({ position = &quot;top&quot; })

Потом, возможно, вы захотите поместить на заголовок окна (titlebar) какие-нибудь виджеты. Используем тот же принцип, что и для строки состояния:

 mytitlebartitle = widget({ type = &quot;textbox&quot;, name = &quot;mytitlebartitle&quot; })
 mytitlebar:widgets({ mytitlebartitle })

Заголовок окна должен быть добавлен (привязан к объекту приложения) в объект приложения (''client object''). Мы можем определить, какое приложение в данный момент находится в фокусе (активное приложение), используя переменную (атрибут) ''client.focus''. Давайте попробуем:

 -- Определяем активное приложение (client)
 c = client.focus
 -- Устанавливаем для него заголовок окна (titlebar)
 c.titlebar = mytitlebar

Теперь у активного окна (focused client) есть милый заголовок (titlebar) сверху. Но пока в заголовоке пусто. Нет, подождите! Мы же добавили в заголовок окна ''textbox widget''. Теперь с его помощью мы можем напечатать в заголовке название запущенного приложения (client):

 mytitlebartitle.text = c.name

Атрибут ''name'' это строка, содержащая название приложения (client), и мы устанавливаем ее как текст, который будет отображаться внутри виджета. Теперь в заголовке мы можем видеть название запущенного приложения.

Помните: заголовок окна это один объект, а приложение это другой объект. Следовательно вам нужно создать заголовки окна для каждого приложения (client), рядом с которым вы хотите видеть заголовок (titlebar).

== Использование ловушек (hooks) ==
С тем, что мы рассмотрели ранее, вы можете создать неплохой интерфейс. Однако, представьте, что вам нужно обновить текст в заголовке (titlebar) приложения (client): вы не можете этого сделать. Стойте! Вот решение: ловушки (hooks).

С помощью ловушек (hooks) вы можете определять функции, которые вызываются когда случается какое-либо событие. Давайте разберём это на примере.

Когда новое приложение (client) появляется на экране, awesome запускает функцию, связанную с ловушкой (hook) ''manage''. Эта функция вызывается с новым приложением (client) в качестве аргумента. Вот пример:

 function hook_manage(c)
     if c.name:find(&quot;mplayer&quot;) then
         c.floating = true
     end
 end

Прежде всего мы определили функцию ''hook_manage'' с аргументом ''c'', который и будет приложением (client). После этого мы пытаемся найти строку ''&quot;mplayer&quot;'' в имени приложения, и если находим, устанавливаем для приложения компоновку floating.

  awful.hooks.manage.register(hook_manage)

Далее мы определяем, что функцией, которая вызывается при появлении каждого нового приложения, будет ''hook_manage''.

Есть много ловушек (hooks), которые вы можете использовать и определять: focus, unfocus, manage, unmanage, mouseover, arrange, titleupdate, urgent, timer, … За более подробной информацией загляните на страницу справочника. (Refer to the manpage for more information.)

== Запуск команд и скриптов ==

Вы можете запускать команды и скрипты на lua. Вот пример функции, в качестве параметра принимает команду, а возвращает ее вывод. Это может быть полезно при помещении вывода команды в тестовые поля (textboxes)

&lt;pre&gt;
-- Запускаем команду и возвращаем ее вывод. Вы можете запускать команды со множеством выходящих строк
function execute_command(command)
   local fh = io.popen(command)
   local str = &quot;&quot;
   for i in fh:lines() do
      str = str .. i
   end
   io.close(fh)
   return str
end
&lt;/pre&gt;

Это пример помещения содержимого /proc/loadavg в mytextbox:
&lt;pre&gt;
 mytextbox.text = &quot; &quot; .. execute_command(&quot;cat /proc/loadavg&quot;) .. &quot; &quot;
&lt;/pre&gt;

При подключенной библиотеке awful, то же самое можно сделать намного проще, для этого всего лишь в нчале файла rc.lua добавляем

 require(&quot;awful&quot;)

А затем в нужном месте вызываем функцию 'awful.util.pread', которая и возвратит вывод скрипта в наш виджет:

 mytextbox.text = awful('наша скриптовая команда')

= Lua-библиотеки awesome =

== awful ==
[[awful]] -- основная библиотека для взаимодействия с awesome (действия мыши, клавиатурные сочетания).

== beautiful ==
[[Beautiful]] -- библиотека для работы с темами для awesome.

== eminent ==
[[Eminent]] -- библиотека, которая позволяет динамически работать с тэгами. Это означает, что все тэги не являются жестко заданными. Вы можете изменять имена тэгов. Также, переключаясь на следующий тег, когда уже находитесь на последнем, вы получите совершенно новый тег. Это позволяет работать с тегами, не меняя конфигурационный файл.

== Shifty ==
[[Shifty]] -- новейшая динамическая библиотека тегов + согласование работы клиентских приложений

== naughty ==
[[Naughty/ru|Naughty]] -- библиотека для сообщений.

== wicked ==
[[Wicked]] -- библиотека, которая предоставляет дополнительные виджеты для awesome, такие как виджеты MPD, загрузка CPU, использование памяти и пр.


[[Category: Awesome3]]</text>
      <sha1>4mifcr5jhz6035zi9zmrn30vtiso02b</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration/zh-hans</title>
    <ns>0</ns>
    <id>269</id>
    <revision>
      <id>4827</id>
      <parentid>4304</parentid>
      <timestamp>2011-04-20T20:48:11Z</timestamp>
      <contributor>
        <username>Pegnitz</username>
        <id>629</id>
      </contributor>
      <text xml:space="preserve" bytes="13094">{{Template:Languages|Awesome_3_configuration}}

= 背景 =

'''awesome 3''' 现在开始使用一个基于 [http://www.lua.org Lua] 语言的配置文件。很多从 awesome 2 迁移过来的用户都将痛苦的发现，使用 libconfuse 格式的旧配置文件已经消失了，还有些人或许会不舒服，因为他们不理解 [http://modeemi.fi/~tuomov/ion/ ion] 配置文件。但是我不会。

为什么选择 Lua 语言？
因为它丰富的可操控性。例如: 你希望 awesome 在某件事发生时作某事，在以前这是无法实现的。但是现在可以了。你几乎可以做 '''任何事''' (仅限于一个窗口管理器能做的事)。

= 配置文件 =
* ~/.config/awesome/rc.lua
* /etc/xdg/awesome/rc.lua

= Lua 语言基础 =
我们正在讨论 Lua 语言，所以首先，学习 Lua 语言。你不想？那么请不要使用 awesome 3 并且立即停止浏览。(还有一个解决办法就是，从源代码或者其他人哪里获得一份配置文件，然后进行微调，用不到任何 Lua 语言的知识)。

对坚持浏览的用户说一声，很好！Lua 语言是一种 '''简单''' 的语言。但另一方面，如果你对计算机语言一点也不熟悉，比如说，你不知道 ''对象''，''方法'' 还有 ''参数'' 是什么意思，那么，你是很难理解这份文档的，请先学习一些基础知识后再来。

我是精英主义者: awesome 3 被设计给拥有最低限度计算机科学知识的进阶用户。但是如果你非常有积极性，你可以学会足够的基础知识配置和操控 awesome。

学习 Lua 语言最好的方法是花一两个小时阅读 [http://www.lua.org/pil/ Programming In Lua] 这本书，通过这本书你将对 Lua 的用法有一个大概的认知。Do not hesitate to bookmark important pages talking about flow control, useful statements, etc. That will help: it's awful to look for the for syntax when trying to type lines of code.

= awesome 对象类型 =
对于那些未曾使用过awesome的来自外太空的人来说，以下是一些awesome提供的，你即将对其控制的基本对象。
== Screen 屏幕 ==
在 awesome 里并没有屏幕(Screen)这个对象，但我们稍后会讨论它。一个屏幕代表了一个和你电脑相连接的物理显示器。它们由索引标识，起始索引是1。

== Client 客户 ==
一个客户(Client)代表一个窗口。我想我已经说清楚了。

== Tag 标签 ==
一个标签(Tag)就好像一个工作区或者一个虚拟桌面，但是更加灵活。
每一个客户(Client)都可以被分配(至少)一个标签。每一个屏幕(Screen)都可以被分配(至少)一个标签。
任何时候，在一个屏幕，你可以查看任何标签。查看空标签的话将隐藏所有客户。查看一个或多个标签的话将把分配了这些标签的客户都显示给你。

== Widget 零件 ==
零件就是可以在屏幕上绘制出来的对象。现有几种类型的零件。例如在屏幕上绘制文本的文本零件，在屏幕上绘制图标的图标零件。

== Titlebar 标题栏 ==
标题栏就是附属在客户周围的栏。你可以把零件放置在其中。

== Statusbar 状态栏 ==
状态栏就是固定在屏幕边缘的栏。你可以把零件放置在其中。

= 建造我们的界面 =
为了建造我们的界面，我们需要用到 awesome 的函数和方法: '''所有这些''' 都已经整理成文档 [http://awesome.naquadah.org/apidoc/ Lua API 文档] 和 awesomerc(5) 系统帮助手册。阅读它们，它们是你开发的参考资料。我重复: 阅读它们，所有函数和方法都被整理到系统帮助手册和 lua 文档。

系统帮助手册在哪里？…… awesomerc(5)。很好，你找到了。

== 标签的创建 ==
如果你在启动 awesome 时没有设置任何 Lua 动作，你将拥有 0 个标签，这是错误的。awesome 需要至少一个标签。

所以首先，我们需要创建一个标签。我们该怎么做呢？我们在文档和系统帮助手册中找到创建标签的函数 tag()。它显示这个函数的参数必须是一个 table，而且这个 table 至少有一个 name 属性。让我们这么做。

 mytagone = tag({ name = &quot;one&quot; })

现在你将一个对象 ''mytagone'' 定义成了一个标签对象，而且这个标签对象的名称是 ''one''。如果我们想设置它默认的布局，我们可以把这种 key/value 对加入 table，就像文档中说明的那样。

 mytagtwo = tag({name = &quot;two&quot;, layout = &quot;floating&quot; })

现在，我们有了第二个标签对象 ''mytagtwo''：它的名称是 ''two''，而且默认把所有客户按照 floating 布局排列。

创建对象很有用，但是目前而言，它还没起作用。请记住：每个屏幕都至少要分配一个标签。所以我们需要把这些创建好了的标签添加到我们的首个屏幕。这个 ''screen'' 参数为我们作了这件事，我们只要把屏幕的索引赋值给它就可以了。

 mytagone.screen = 1

我们刚刚把那个标签对象添加到屏幕#1。如果我们拥有第二台显示器，我们可以把我们的第二个标签对象添加进去。

 mytagtwo.screen = 2

而且如果我们有第三台显示器，我们就可以……好了，我想你已经明白了。

如果你想知道你拥有多少个屏幕，你可以调用这个函数 ''screen.count()''。

你通过 ''selected'' 参数可以操控标签的显示与否。如果你想查看你的标签 ''one''：

 mytagone.selected = true

如果你想隐藏它，你可以赋值 ''false''。

你通过这个参数可以操控所有的标签显示与否。请查阅文档。

== 客户的操控 ==
有时候，你可能会获得客户对象。它在 hook 函数中是非常有用的，我们将会稍后讨论 hook 函数。

一个客户就是一个像标签和其它东西一样拥有方法的对象。我们决定用 ''c'' 这个变量命名我们的客户对象。
例如，如果我们想把一个对象的显示方式设置为浮动方式，我们可以使用 ''floating'' 参数，就像这样：

 c.floating = true

某些方法具有的返回值可以用来进行后期处理。如果我们已经知道一个客户是浮动显示的，我们可以获得这个 ''floating'' 参数的值：

 is_client_floating = c.floating

现在这个变量 ''is_client_floating'' 包含了一个布尔值：''true'' 表示这个客户是浮动显示的，或者 ''false'' 表示它不是浮动显示的。

我们可以接合这两个函数来创建一个开关函数：这个函数将控制客户的浮动显示与否。

 function client_floating_toggle(c)
     if c then
         c.floating = not c.floating
     end
 end

我们还可以用它来控制在我们客户上的标签：

 function client_tag_with_tag_one(c)
     if c then
         local t = c:tags()
         table.insert(t, one)
         c:tags(t)
     end
 end

== 零件的创建 ==
零件是一些很小的对象，它们可以放置在标题栏或者状态栏上。和标签对象一样，如果你不把它们添加到某个地方，它们是不起作用的。创建一个零件需要用到一个函数 ''widget()''：

 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })

''mytextbox'' 现在包含了一个零件对象。对于不同的零件类型，你可以访问不同的参数，下面的设置是在 textbox 上显示文字。

 mytextbox.text = &quot;Hello, world!

== 状态栏的创建 ==
状态栏是零件的容器。状态栏可以放置在屏幕的上、下、左、右边缘。

首先，创建一个状态栏：

 mystatusbar = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })

''mystatusbar'' 现在是一个包含了状态栏对象的变量。由于我们设置了 ''position'' 为 ''top''，它将会显示在我们屏幕的上方。但是我们还没有把它添加到屏幕上，所以现在它还没起作用。让我们开始吧：

 mystatusbar.screen = 1

我们的状态栏现在已经显示在我们屏幕的上方了。很好，它什么也不做，但实际上它非常有用。让我们添加一些零件上去！

 -- Create a textbox 创建一个文本零件
 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })
 -- Set text of the textbox 设置文本零件显示的文字
 mytextbox.text = &quot;你好, 世界!&quot;
 -- Create a statusbar 创建一个状态栏
 mystatusbar = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; })
 -- Add widgets to the statusbar 把零件添加到状态栏
 mystatusbar:widgets({ mytextbox })
 -- Add the statusbar on screen #1 把状态栏添加到屏幕#1
 mystatusbar.screen = 1

我们现在已经有一个在屏幕上方显示 ''你好，世界!'' 的状态栏了。通过这些方法，你可以在你的 awesome 配置文件中设置一个拥有一些零件的个性状态栏了。

== 标题栏的创建 ==
正如我之前所说，标题栏和状态栏很相似，只不过它附属在一个窗口的边缘。创建一个标题栏，你知道的：

 mytitlebar = titlebar({ position = &quot;top&quot; })

然后，你可能想放置零件上去。这和状态栏的处理很像：

 mytitlebartitle = widget({ type = &quot;textbox&quot;, name = &quot;mytitlebartitle&quot; })
 mytitlebar:widgets({ mytitlebartitle })

一个标题栏必须添加一个 ''客户对象''。我们可以得到当前焦点的客户：它的信息保存在 ''client.focus'' 变量中。让我们

 -- Get the focused client 获得当前焦点对象
 c = client.focus
 -- Set a titlebar on it 给它设置一个标题栏
 c.titlebar = mytitlebar

现在，焦点客户的上方已经有了一个不错的标题栏了！但是标题栏上什么也没有。不是吧，等等！请看，在标题栏中我们已经添加了一个 ''textbox'' 零件。现在我们可以用它把客户名称显示出来：

 mytitlebartitle.text = c.name

这个 ''name'' 属性是一个描述了客户标题名称的字符串，我们可以把它作为文本内容赋值给零件。现在的标题栏已经显示出客户的标题了。

请记住：一个标题栏是一个对象，一个客户也是一个对象。所以你需要为每一个你希望拥有标题栏的客户分别创建一个标题栏。

== 钩子的使用 ==
正如之前我们所见，你可以创建一个美丽的界面。但是，设想一下你希望更新一个客户上标题栏中显示的标题：你做不到。等等！有办法：钩子函数。

通过钩子，你可以定义一个函数，这个函数将在一个事件发生时被调用执行。让我们通过一个示例尝试一下。

当一个客户在屏幕上弹出来的时候，awesome 运行一个 ''manage'' 钩子函数。通过传递客户这个参数来调用此函数。这里有个例子：

 function hook_manage(c)
     if c.name:find(&quot;mplayer&quot;) then
         c.floating = true
     end
 end

首先，我们定义了一个 ''hook_manage'' 函数，有一个参数名为 ''c''，这个参数代表一个客户。然后，我们试图找到一个名为 ''&quot;mplayer&quot;'' 的客户，如果我们找到了，我们就把它的显示方式设置为浮动方式。

  awful.hooks.manage.register(hook_manage)

再然后，通过上面这行调用，我们定义了当有新的客户出现时，执行一个名为 ''hook_manage'' 的函数。

这里提供了众多的钩子供你使用和定义：focus, unfocus, manage, unmanage, mouseover, arrange, titleupdate, urgent, timer, 等等。参考系统帮助手册了解更多详细信息。

== 执行命令或脚本 ==
你可以在 lua 配置文件中执行命令和脚本。这里有个示例函数，它实现的功能是：运行参数所指定的命令并返回该命令的返回值。对于把命令的返回值放到 textboxes 零件上这类功能来说，这个函数还是很有用的。

&lt;pre&gt;
-- Execute command and return its output. You probably won't only execute commands with one
-- line of output
function execute_command(command)
   local fh = io.popen(command)
   local str = &quot;&quot;
   for i in fh:lines() do
      str = str .. i
   end
   io.close(fh)
   return str
end
&lt;/pre&gt;

这里有个例子说明了如何将 /proc/loadavg 信息放置在 mytextbox 零件上：
&lt;pre&gt;
 mytextbox.text = &quot; &quot; .. execute_command(&quot;cat /proc/loadavg&quot;) .. &quot; &quot;
&lt;/pre&gt;

= awesome Lua 库 =

== awful ==
[[awful]] 是和 awesome 交互的默认库，其中包括了像鼠标动作或者键盘事件等。

== beautiful ==
[[Beautiful]] 是关于 awesome 外观/主题的库。

== eminent ==
[[Eminent]] 是一个 Lua 库，它能让你使用动态标签(dynamic tagging)。动态标签在这里的含义是指你所拥有的标签总数并没有在固定死，你可以先设定一个特殊的标签名称，当你在最后一个标签上时，然后切换到下一个标签，这时它将提供给你一个新的标签。这将允许你在不改变你的配置文件的前提下适应多种用法，给你更多或更少的标签。

== naughty ==
[[Naughty]] 是关于通知的库。

== wicked ==
[[Wicked]] 是用于提供更多 awesome 零件所需的库。例如 MPD Widgets，CPU usage，memory usage，等等。


[[Category: Awesome3]]</text>
      <sha1>7aete7yiooragyeum5kxxi9eli93lb1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration (Español)</title>
    <ns>0</ns>
    <id>347</id>
    <redirect title="Awesome 3 configuration/es" />
    <revision>
      <id>2793</id>
      <timestamp>2009-05-23T11:29:10Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Awesome 3 configuration (Español)]] to [[Awesome 3 configuration/es]]:&amp;#32;Make this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="40">#REDIRECT [[Awesome 3 configuration/es]]</text>
      <sha1>nhbq4l6nj3kdpq1pk58dvqllc8331p1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration (Italiano)</title>
    <ns>0</ns>
    <id>341</id>
    <redirect title="Awesome 3 configuration/it" />
    <revision>
      <id>2751</id>
      <timestamp>2009-05-23T10:02:52Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Awesome 3 configuration (Italiano)]] to [[Awesome 3 configuration/it]]:&amp;#32;Makes this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="40">#REDIRECT [[Awesome 3 configuration/it]]</text>
      <sha1>7ztow9jf9qe6l5i7nsd55diu3jmnewg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration (Russian)</title>
    <ns>0</ns>
    <id>342</id>
    <redirect title="Awesome 3 configuration/ru" />
    <revision>
      <id>2753</id>
      <timestamp>2009-05-23T10:03:11Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Awesome 3 configuration (Russian)]] to [[Awesome 3 configuration/ru]]:&amp;#32;Make this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="40">#REDIRECT [[Awesome 3 configuration/ru]]</text>
      <sha1>evzzn9p2l0zmjemkdaizaqek9ak2cpk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 configuration (Simplified Chinese)</title>
    <ns>0</ns>
    <id>343</id>
    <redirect title="Awesome 3 configuration/zh-hans" />
    <revision>
      <id>2755</id>
      <timestamp>2009-05-23T10:03:37Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Awesome 3 configuration (Simplified Chinese)]] to [[Awesome 3 configuration/zh-hans]]:&amp;#32;Make this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="45">#REDIRECT [[Awesome 3 configuration/zh-hans]]</text>
      <sha1>tkf490pawstacf5k0mkibaplgq4hjul</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 properties</title>
    <ns>0</ns>
    <id>145</id>
    <revision>
      <id>3450</id>
      <parentid>3447</parentid>
      <timestamp>2009-08-14T20:08:24Z</timestamp>
      <contributor>
        <username>Atragor</username>
        <id>120</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="594">== Properties ==

Here is the list of properties of various classes. This is sadly not covered by luadoc, which covers only functions.

=== client ===
{| class=&quot;wikitable&quot;, border=&quot;1&quot;
! Property   !! Description         !! Comments
|-
| c.name     || Window name (title) || Changing will not call titleupdate hook
|-
| c.class    || Window class        ||                                         
|-
| c.instance || Window instance     ||                                         
|-
| c.screen   || Screen number       ||                                         
|-

|}


[[Category: Awesome3]]</text>
      <sha1>91jtrfyhs46lne2icrsxkmck07h85hf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome 3 properties/ru</title>
    <ns>0</ns>
    <id>458</id>
    <revision>
      <id>3449</id>
      <parentid>3448</parentid>
      <timestamp>2009-08-14T20:08:06Z</timestamp>
      <contributor>
        <username>Atragor</username>
        <id>120</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="942">{{DISPLAYTITLE: Свойства объектов Awesome 3}}

== Свойства ==

Вот список свойств различных классов. Они, к сожалению, не описаны в документации luadoc, которая охватывает только функции.

=== Клиент ===
{| class=&quot;wikitable&quot;, border=&quot;1&quot;
! Свойство   !! Описание             !! Комментарии
|-
| c.name     || Имя (заголовок) окна || Изменение этого свойства не приведёт к срабатыванию ловушки titleupdate
|-
| c.class    || Класс окна           ||                                         
|-
| c.instance || Экземпляр окна       ||                                         
|-
| c.screen   || Номер экрана         ||                                         
|-

|}


[[Category: Awesome3]]</text>
      <sha1>9onitvpdtus2ihqydd2fhwgtnileqqe</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesome and Xfce4</title>
    <ns>0</ns>
    <id>970</id>
    <revision>
      <id>6242</id>
      <parentid>6241</parentid>
      <timestamp>2014-01-26T09:02:37Z</timestamp>
      <contributor>
        <username>Vitaly m</username>
        <id>3159</id>
      </contributor>
      <comment>/* Option 1. Disabling Xfce panels */</comment>
      <text xml:space="preserve" bytes="3599">[[Image:vitaly_m_desktop.png|300px|right|thumb|Awesome 3.4.13 and Xfce 4.8.3 on Debian 7 Wheezy ]]
== Replacing xfwm4 by awesome wm ==
Open Xfce Settings Manager ('''LC_ALL=C''' opens it without any localization):
&lt;pre&gt;
LC_ALL=C xfce4-settings-manager 
&lt;/pre&gt;
Navigate to '''Session and Startup''' then open '''Session''' tab.

Here you see the list of apps your Xfce4 session consists of. You should have '''xfwm4''' in that list. Now you need to switch '''Restart Style''' of xfwm4 to '''Never'''. 

Then go to '''Application Autostart''' tab and add '''awesome''' to your autostart.

Now fire this command:
&lt;pre&gt;
killall xfwm4
&lt;/pre&gt;

Next time you log in your xfce4 session you gonna get '''awesome''' startead as well.

For now you can use '''Alt+F2''' and enter '''awesome''' to run this awesome window manager.

== Wallpaper setting problems ==
For some reason in Debian 7 Wheezy I had problem using xfce4 to set wallpapers. So I ended up disabling '''xfdesktop''' service and making '''awesome''' in charge of wallpaper setting. This is not any different to disabling xfwm4 like we did in 1st part of this article:

Open Xfce Settings Manager ('''LC_ALL=C''' opens it without any localization):
&lt;pre&gt;
LC_ALL=C xfce4-settings-manager 
&lt;/pre&gt;
Navigate to '''Session and Startup''' then open '''Session''' tab.

Here you see the list of apps your Xfce4 session consists of. You should have '''xfdesktop''' in that list. Now you need to switch '''Restart Style''' of '''xfdesktop''' to '''Never'''. 

Now fire this command:
&lt;pre&gt;
killall xfdesktop
&lt;/pre&gt;

== Panels ==
You can choose to disable all Xfce4 panels (you can even disable '''xfce4-panel''' service altogether) and use only '''awesome''' panels. The other choice can be combining both of 2 worlds.

=== Option 1. Disabling Xfce panels ===
This is not any different to disabling xfwm4 like we did in 1st part of this article:

Open Xfce Settings Manager ('''LC_ALL=C''' opens it without any localization):
&lt;pre&gt;
LC_ALL=C xfce4-settings-manager 
&lt;/pre&gt;
Navigate to '''Session and Startup''' then open '''Session''' tab.

Here you see the list of apps your Xfce4 session consists of. You should have '''xfce4-panel''' in that list. Now you need to switch '''Restart Style''' of '''xfce4-panel''' to '''Never'''. 

Now fire this command:
&lt;pre&gt;
killall xfce4-panel
&lt;/pre&gt;

=== Option 2. Making foreign panels work well with awesome  ===
The problems you can encounter when you use some other panels when running awesome are:
* Your panel can be closed or minimized by '''awesome''' hotkey press if you click on panel (see fix for it below).
* Your panel will steal your application focus if you click on panel and there is no fix for it yet. But you can get used to it -- just remember to switch to your task back after using mouse on panel.

There are the fixes you may want to apply.

Make your kill hotkey look like this to prevent killing the panel:
&lt;pre&gt;
   awful.key({ modkey, &quot;Shift&quot;   }, &quot;c&quot;,      function (c)
                                                 if not c.name == &quot;xfce4-panel&quot; then
                                                    c:kill()
                                                 end
&lt;/pre&gt;

Make your minimize hotkey look like this to prevent panel minimizing:
&lt;pre&gt;
   awful.key({ modkey,           }, &quot;n&quot;,      function (c)
                       	                         if not c.name == &quot;xfce4-panel&quot; then
                                                    c.minimized	= not c.minimized
                                                 end
                                              end),
&lt;/pre&gt;</text>
      <sha1>p6yb0whr1me4az1yfhr1p304xish33r</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesomerc</title>
    <ns>0</ns>
    <id>5</id>
    <revision>
      <id>3385</id>
      <parentid>3269</parentid>
      <timestamp>2009-07-27T02:04:34Z</timestamp>
      <contributor>
        <username>Bostonvaulter</username>
        <id>306</id>
      </contributor>
      <comment>added note to specify that this is for version 2</comment>
      <text xml:space="preserve" bytes="8356">{{Languages}}

Here is a sample .awesomerc file for Awesome version 2 with comments.

----

 # Configuration file for awesome
 #
 # First physical screen
 screen 0
 {
     general
     {
         # Windows border size in pixel
         border = 1
         # Pixels number before collapsing window border and screen border
         snap = 8
         # Respect windows minimal geometry
         resize_hints = true
         # Opacity for unfocused windows (with xcompmgr)
         opacity_unfocused = 100
         # Should focus switching move pointer
         focus_move_pointer = false
         # Allow floating windows to be below others
         allow_lower_floats = false
         # Status bar font (Xft)
         font = &quot;Inconsolata-8&quot;
     }#end general
     
     colors
     {
         # Normal border color
         normal_border = &quot;#111111&quot;
         # Normal background color (statusbar)
         normal_bg = &quot;#111111&quot;
         # Normal foreground color (statusbar)
         normal_fg = &quot;#eeeeee&quot;
         # Focused border color
         focus_border = &quot;#6666ff&quot;
         # Focused background color (statusbar)
         focus_bg = &quot;#6666ff&quot;
         # Focused foreground color (statusbar)
         focus_fg = &quot;#ffffff&quot;
     }#end colors
     
     #top, left, bottom, right
     statusbar{position = &quot;top&quot;}
     
     #These are what is actually displayed on the status bar.
     #Here for example, &quot;1:terminal&quot; is displayed instead of the default &quot;one&quot;
     tags { 
         tag 1:terminal {layout = &quot;tile&quot; mwfact = .5}
         tag 2:web {layout = &quot;floating&quot;} 
         tag 3:vim {layout = &quot;tile&quot;}
         tag 4:files {layout = &quot;tile&quot;}
         tag five {layout = &quot;tile&quot;}
         tag six {layout = &quot;tile&quot;}
     }#end tags
     
     layouts {
         layout tile {symbol = &quot;[]=&quot;}
         layout tileleft {symbol = &quot;=[]&quot;}
         layout max {symbol = &quot;[ ]&quot;}
         layout floating {symbol = &quot;&gt;&lt;&gt;&quot;}
     }#end layouts
 }#end screen 0
 
 #This section defines in which tag a program will open, as well as whether it is tile, max, or float.
 rules {
     rule {name = &quot;Gimp&quot; tags = &quot;nine&quot; float = true}
     rule {name = &quot;MPlayer&quot; float = true}
     rule {name = &quot;Acroread&quot; float = true}
     rule {name = &quot;pinentry&quot; float = true}
     rule {name = &quot;urxvt&quot; float = true tags = &quot;1:terminal&quot;}
     rule {name = &quot;Swiftfox&quot; float = true tags = &quot;2:web&quot;}
     rule {name = &quot;wifi-radar&quot; float = true tags = &quot;2:web&quot;}
     rule {name = &quot;gvim&quot; float = true tags = &quot;3:vim&quot;}
     rule {name = &quot;emelfm&quot; float = true tags = &quot;4:files&quot;}
     rule {name = &quot;mc&quot; float = true tags = &quot;4:files&quot;}
 
 }#end rules
 ## Note that &quot;Mod1&quot; is normally the &quot;Alt&quot; key, and that &quot;Mod4&quot; is the &quot;super&quot; or &quot;Windows&quot; key
 # Mouse buttons bindings
 mouse {
     # For click on tag
     tag {button = &quot;1&quot; command = &quot;tag_view&quot;}
     tag {button = &quot;1&quot; modkey = {&quot;Mod4&quot;} command = &quot;client_tag&quot;}
     tag {button = &quot;3&quot; command = &quot;tag_toggleview&quot;}
     tag {button = &quot;3&quot; modkey = {&quot;Mod4&quot;} command = &quot;client_toggletag&quot;}
     tag {button = &quot;4&quot; command = &quot;tag_viewnext&quot;}
     tag {button = &quot;5&quot; command = &quot;tag_viewprev&quot;}
     
     # For click on layout symbol
     layout {button = &quot;1&quot; command = &quot;tag_setlayout&quot; arg = &quot;+1&quot;}
     layout {button = &quot;4&quot; command = &quot;tag_setlayout&quot; arg = &quot;+1&quot;}
     layout {button = &quot;3&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot;}
     layout {button = &quot;5&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot;}
     
     # For click on root window
     root {button = &quot;3&quot; command = &quot;spawn&quot; arg = &quot;exec urxvt&quot;}
     root {button = &quot;4&quot; command = &quot;tag_viewnext&quot;}
     root {button = &quot;5&quot; command = &quot;tag_viewprev&quot;}
 
     # For click on client windows
     client {modkey = {&quot;Mod4&quot;} button = &quot;1&quot; command = &quot;client_movemouse&quot;}
     client {modkey = {&quot;Mod4&quot;} button = &quot;2&quot; command = &quot;client_zoom&quot;}
     client {modkey = {&quot;Mod4&quot;} button = &quot;3&quot; command = &quot;client_resizemouse&quot;}
 }#end mouse
 
 # Keys bindings
 keys {
  
     #These are where you can define shortcuts to launch programs.
     #You can see that I have added &quot;sudo&quot; to some, this method will work with other commands as well.
     key {modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;Return&quot; command = &quot;spawn&quot; arg = &quot;exec urxvt&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;r&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo wifi-radar&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;n&quot;                 command = &quot;spawn&quot; arg = &quot;exec swiftfox&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;v&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo gvim&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;f&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo emelfm&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;Return&quot;            command = &quot;spawn&quot; arg = &quot;exec gmrun&quot;}  
     ###############################################################################
  
     #Bindings for managing individual windows within each tag.
     key { modkey = {&quot;Mod4&quot;} key = &quot;j&quot;                command = &quot;client_focusnext&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;k&quot;                command = &quot;client_focusprev&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;j&quot;     command = &quot;client_swapnext&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;k&quot;     command = &quot;client_swapprev&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;c&quot;                command = &quot;client_kill&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;m&quot;                command = &quot;client_togglemax&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Shift&quot;} key = &quot;m&quot;       command = &quot;client_toggleverticalmax&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;m&quot;     command = &quot;client_togglehorizontalmax&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;f&quot;                command = &quot;client_togglefloating&quot; }
  
     #Bindings to switch between tags
     key { modkey = {&quot;Mod4&quot;} key = &quot;Right&quot;            command = &quot;tag_viewnext&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;Left&quot;             command = &quot;tag_viewprev&quot; }
     key { modkey = {&quot;Mod4&quot;} key = 1                  command = &quot;tag_view&quot; arg = 1 }
     key { modkey = {&quot;Mod4&quot;} key = 2                  command = &quot;tag_view&quot; arg = 2 }
     key { modkey = {&quot;Mod4&quot;} key = 3                  command = &quot;tag_view&quot; arg = 3 }
     key { modkey = {&quot;Mod4&quot;} key = 4                  command = &quot;tag_view&quot; arg = 4 }
     key { modkey = {&quot;Mod4&quot;} key = 5                  command = &quot;tag_view&quot; arg = 5 }
     key { modkey = {&quot;Mod4&quot;} key = 6                  command = &quot;tag_view&quot; arg = 6 }
 
     #View multiple tags in current one
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 1       command = &quot;tag_toggleview&quot; arg = 1}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 2       command = &quot;tag_toggleview&quot; arg = 2}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 3       command = &quot;tag_toggleview&quot; arg = 3}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 4       command = &quot;tag_toggleview&quot; arg = 4}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 5       command = &quot;tag_toggleview&quot; arg = 5}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 6       command = &quot;tag_toggleview&quot; arg = 6}
 
 ##################################################################################################################
  ###These are addition bindings that I don't use.
  ###Perhaps someone else could fill them in?
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;h&quot;          command = &quot;tag_setnmaster&quot; arg = &quot;+1&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;l&quot;          command = &quot;tag_setnmaster&quot; arg = &quot;-1&quot; }
  #awesome
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;r&quot;          command = &quot;exec&quot; arg = &quot;/usr/local/bin/awesome&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;q&quot;          command = &quot;quit&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;b&quot;          command = &quot;statusbar_toggle&quot; }
  
  #additionally view tag &lt;nr&gt;: Mod1 + Shift + Number
  #inc/dec number of columns
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;h&quot;            command = &quot;tag_setncol&quot; arg = &quot;-1&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;l&quot;            command = &quot;tag_setncol&quot; arg = &quot;+1&quot; }
  #number of master clients
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;j&quot;         command = &quot;screen_focusnext&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;k&quot;         command = &quot;screen_focusprev&quot; }
  #key { modkey = {&quot;Mod1&quot;,} key = &quot;t&quot;                   command = &quot;client_settrans&quot; arg = &quot;+0.10&quot; }
  #key { modkey = {&quot;Mod1&quot;} key = &quot;t&quot;                    command = &quot;client_settrans&quot; arg = &quot;-0.10&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;Return&quot;      command = &quot;client_zoom&quot; arg=&quot;-0.10&quot; }
  } #end keys


[[Category:awesome2]]</text>
      <sha1>stoskib5dua3te5s41ra9zgab14ks6c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesomerc/fr</title>
    <ns>0</ns>
    <id>441</id>
    <revision>
      <id>3339</id>
      <parentid>3290</parentid>
      <timestamp>2009-07-15T18:37:59Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use DISPLAYTITLE instead of Template:Title</comment>
      <text xml:space="preserve" bytes="9095">{{DISPLAYTITLE:Fichier de configuration d’awesome 2}}
{{Languages|Awesomerc}}

Voici un fichier '''.awesomerc''' avec commentaires. C’était le fichier de configuration par défaut pour la version 2 d’awesome. Depuis la version 3, le [[Awesome 3 configuration/fr|fichier de configuration]] par défaut est codé en Lua et son nom est '''rc.lua'''.


 # Fichier de configuration d’awesome 2
 #
 # Premier écran physique
 screen 0
 {
     general
     {
         # Taille des bordures de fenêtres, en pixels
         border = 1
         # Nombre de pixels avant de coller la bordure d’une fenêtre avec la bordure de l’écran
         snap = 8
         # Respecter la géométrie minimale des fenêtres ?
         resize_hints = true
         # Transparence des fenêtres qui ne sont pas au premier plan (avec xcompmgr)
         opacity_unfocused = 100
         # La mise au premier plan doit-elle suivre la souris ?
         focus_move_pointer = false
         # Les fenêtres flottantes doivent-elles être sous les autres ?
         allow_lower_floats = false
         # Fonte de la barre de statut (Xft)
         font = &quot;Inconsolata-8&quot;
     }#end general
     
     colors
     {
         # Couleur de bordure standard
         normal_border = &quot;#111111&quot;
         # Couleur de fond standard (barre de statut)
         normal_bg = &quot;#111111&quot;
         # Couleur d’avant-plan standard (barre de statut)
         normal_fg = &quot;#eeeeee&quot;
         # Couleur de bordure d’une fenêtre au premier plan
         focus_border = &quot;#6666ff&quot;
         # Couleur de fond au premier plan (barre de statut)
         focus_bg = &quot;#6666ff&quot;
         # Couleur d’avant plan au premier plan (barre de statut
         focus_fg = &quot;#ffffff&quot;
     }#end colors
     
     #top, left, bottom, right
     statusbar{position = &quot;top&quot;}
     
     #Ce qui suit est ce qui est réellement affiché sur la barre de statut.
     #Ici par exemple, « 1:console » est affiché au lieu du « one » par défaut
     tags { 
         tag 1:console {layout = &quot;tile&quot; mwfact = .5}
         tag 2:net {layout = &quot;floating&quot;} 
         tag 3:vim {layout = &quot;tile&quot;}
         tag 4:fichiers {layout = &quot;tile&quot;}
         tag five {layout = &quot;tile&quot;}
         tag six {layout = &quot;tile&quot;}
     }#end tags
     
     layouts {
         layout tile {symbol = &quot;[]=&quot;}
         layout tileleft {symbol = &quot;=[]&quot;}
         layout max {symbol = &quot;[ ]&quot;}
         layout floating {symbol = &quot;&gt;&lt;&gt;&quot;}
     }#end layouts
 }#end screen 0
 
 #Cette section définit dans quel onglet un programme s’ouvre et s’il est en mosaïque, maximisé ou flottant.
 rules {
     rule {name = &quot;Gimp&quot; tags = &quot;six&quot; float = true}
     rule {name = &quot;MPlayer&quot; float = true}
     rule {name = &quot;Acroread&quot; float = true}
     rule {name = &quot;pinentry&quot; float = true}
     rule {name = &quot;urxvt&quot; float = true tags = &quot;1:console&quot;}
     rule {name = &quot;Swiftfox&quot; float = true tags = &quot;2:net&quot;}
     rule {name = &quot;wifi-radar&quot; float = true tags = &quot;2:net&quot;}
     rule {name = &quot;gvim&quot; float = true tags = &quot;3:vim&quot;}
     rule {name = &quot;emelfm&quot; float = true tags = &quot;4:fichiers&quot;}
     rule {name = &quot;mc&quot; float = true tags = &quot;4:fichiers&quot;}
 
 }#end rules
 ## Remarque : « Mod1 » est en général la touche [Alt] et « Mod4 » est [Super] ou [Windows]
 # Actions avec les boutons de la souris
 mouse {
     # En cliquant sur un onglet
     tag {button = &quot;1&quot; command = &quot;tag_view&quot;}
     tag {button = &quot;1&quot; modkey = {&quot;Mod4&quot;} command = &quot;client_tag&quot;}
     tag {button = &quot;3&quot; command = &quot;tag_toggleview&quot;}
     tag {button = &quot;3&quot; modkey = {&quot;Mod4&quot;} command = &quot;client_toggletag&quot;}
     tag {button = &quot;4&quot; command = &quot;tag_viewnext&quot;}
     tag {button = &quot;5&quot; command = &quot;tag_viewprev&quot;}
     
     # En cliquant sur le symbole de disposition
     layout {button = &quot;1&quot; command = &quot;tag_setlayout&quot; arg = &quot;+1&quot;}
     layout {button = &quot;4&quot; command = &quot;tag_setlayout&quot; arg = &quot;+1&quot;}
     layout {button = &quot;3&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot;}
     layout {button = &quot;5&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot;}
     
     # En cliquant sur la fenêtre root
     root {button = &quot;3&quot; command = &quot;spawn&quot; arg = &quot;exec urxvt&quot;}
     root {button = &quot;4&quot; command = &quot;tag_viewnext&quot;}
     root {button = &quot;5&quot; command = &quot;tag_viewprev&quot;}
 
     # En cliquant sur les clients
     client {modkey = {&quot;Mod4&quot;} button = &quot;1&quot; command = &quot;client_movemouse&quot;}
     client {modkey = {&quot;Mod4&quot;} button = &quot;2&quot; command = &quot;client_zoom&quot;}
     client {modkey = {&quot;Mod4&quot;} button = &quot;3&quot; command = &quot;client_resizemouse&quot;}
 }#end mouse
 
 # Raccourcis claviers
 keys {
  
     #C’est là que vous définissez vos raccourcis clavier pour lancer des programmes.
     #Vous pouvez voir que j’ai ajouté « sudo » à certains ; cette méthode marchera aussi pour d’autres commandes.
     key {modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;Return&quot; command = &quot;spawn&quot; arg = &quot;exec urxvt&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;r&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo wifi-radar&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;n&quot;                 command = &quot;spawn&quot; arg = &quot;exec swiftfox&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;v&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo gvim&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;f&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo emelfm&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;Return&quot;            command = &quot;spawn&quot; arg = &quot;exec gmrun&quot;}  
     ###############################################################################
  
     #Raccourcis pour générer les fenêtres individuelles dans chaque onglet.
     key { modkey = {&quot;Mod4&quot;} key = &quot;j&quot;                command = &quot;client_focusnext&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;k&quot;                command = &quot;client_focusprev&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;j&quot;     command = &quot;client_swapnext&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;k&quot;     command = &quot;client_swapprev&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;c&quot;                command = &quot;client_kill&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;m&quot;                command = &quot;client_togglemax&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Shift&quot;} key = &quot;m&quot;       command = &quot;client_toggleverticalmax&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;m&quot;     command = &quot;client_togglehorizontalmax&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;f&quot;                command = &quot;client_togglefloating&quot; }
  
     #Raccourcis pour se déplacer entre les onglets
     key { modkey = {&quot;Mod4&quot;} key = &quot;Right&quot;            command = &quot;tag_viewnext&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;Left&quot;             command = &quot;tag_viewprev&quot; }
     key { modkey = {&quot;Mod4&quot;} key = 1                  command = &quot;tag_view&quot; arg = 1 }
     key { modkey = {&quot;Mod4&quot;} key = 2                  command = &quot;tag_view&quot; arg = 2 }
     key { modkey = {&quot;Mod4&quot;} key = 3                  command = &quot;tag_view&quot; arg = 3 }
     key { modkey = {&quot;Mod4&quot;} key = 4                  command = &quot;tag_view&quot; arg = 4 }
     key { modkey = {&quot;Mod4&quot;} key = 5                  command = &quot;tag_view&quot; arg = 5 }
     key { modkey = {&quot;Mod4&quot;} key = 6                  command = &quot;tag_view&quot; arg = 6 }
 
     #Voir plusieurs onglets dans l’onglet actuel
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 1       command = &quot;tag_toggleview&quot; arg = 1}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 2       command = &quot;tag_toggleview&quot; arg = 2}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 3       command = &quot;tag_toggleview&quot; arg = 3}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 4       command = &quot;tag_toggleview&quot; arg = 4}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 5       command = &quot;tag_toggleview&quot; arg = 5}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 6       command = &quot;tag_toggleview&quot; arg = 6}
 
 ##################################################################################################################
  ###Voici des raccourcis supplémentaires que je n’utilise pas.
  ###Peut-être que quelqu’un d’autre veut les utiliser ?
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;h&quot;       command = &quot;tag_setnmaster&quot; arg = &quot;+1&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;l&quot;       command = &quot;tag_setnmaster&quot; arg = &quot;-1&quot; }
  #awesome
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;r&quot;       command = &quot;exec&quot; arg = &quot;/usr/local/bin/awesome&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;q&quot;       command = &quot;quit&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;b&quot;       command = &quot;statusbar_toggle&quot; }
  
  #voir l’onglet supplémentaire « num » : Mod1 + Maj + Numéro
  #augmenter ou réduire le nombre de colonnes
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;h&quot;         command = &quot;tag_setncol&quot; arg = &quot;-1&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;l&quot;         command = &quot;tag_setncol&quot; arg = &quot;+1&quot; }
  #nombre de clients maîtres
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;j&quot;       command = &quot;screen_focusnext&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;k&quot;       command = &quot;screen_focusprev&quot; }
  #key { modkey = {&quot;Mod1&quot;,} key = &quot;t&quot;                 command = &quot;client_settrans&quot; arg = &quot;+0.10&quot; }
  #key { modkey = {&quot;Mod1&quot;} key = &quot;t&quot;                  command = &quot;client_settrans&quot; arg = &quot;-0.10&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;Return&quot;    command = &quot;client_zoom&quot; arg=&quot;-0.10&quot; }
  } #end keys


[[Category:awesome2]]</text>
      <sha1>s0pyrbtga3iko7zm793vy85q5ljp9g2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesomerc/it</title>
    <ns>0</ns>
    <id>119</id>
    <revision>
      <id>3270</id>
      <parentid>3267</parentid>
      <timestamp>2009-07-09T09:17:35Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="8338">{{Languages|Awesomerc}}

Questo è un semplice .awesomerc commentato.

----

 # File di configurazione per awesome
 #
 # Primo schermo fisico
 screen 0
 {
     general
     {
         # Bordi finestre in pixel
         border = 1
         # Pixels number before collapsing window border and screen border
         snap = 8
         # Respect windows minimal geometry
         resize_hints = true
         # Opacity for unfocused windows (with xcompmgr)
         opacity_unfocused = 100
         # Should focus switching move pointer
         focus_move_pointer = false
         # Allow floating windows to be below others
         allow_lower_floats = false
         # Status bar font (Xft)
         font = &quot;Inconsolata-8&quot;
     }#end general
     
     colors
     {
         # Normal border color
         normal_border = &quot;#111111&quot;
         # Normal background color (statusbar)
         normal_bg = &quot;#111111&quot;
         # Normal foreground color (statusbar)
         normal_fg = &quot;#eeeeee&quot;
         # Focused border color
         focus_border = &quot;#6666ff&quot;
         # Focused background color (statusbar)
         focus_bg = &quot;#6666ff&quot;
         # Focused foreground color (statusbar)
         focus_fg = &quot;#ffffff&quot;
     }#end colors
     
     #top, left, bottom, right
     statusbar{position = &quot;top&quot;}
     
     #These are what is actually displayed on the status bar.
     #Here for example, &quot;1:terminal&quot; is displayed instead of the default &quot;one&quot;
     tags { 
         tag 1:terminal {layout = &quot;tile&quot; mwfact = .5}
         tag 2:web {layout = &quot;floating&quot;} 
         tag 3:vim {layout = &quot;tile&quot;}
         tag 4:files {layout = &quot;tile&quot;}
         tag five {layout = &quot;tile&quot;}
         tag six {layout = &quot;tile&quot;}
     }#end tags
     
     layouts {
         layout tile {symbol = &quot;[]=&quot;}
         layout tileleft {symbol = &quot;=[]&quot;}
         layout max {symbol = &quot;[ ]&quot;}
         layout floating {symbol = &quot;&gt;&lt;&gt;&quot;}
     }#end layouts
 }#end screen 0
 
 #This section defines in which tag a program will open, as well as whether it is tile, max, or float.
 rules {
     rule {name = &quot;Gimp&quot; tags = &quot;nine&quot; float = true}
     rule {name = &quot;MPlayer&quot; float = true}
     rule {name = &quot;Acroread&quot; float = true}
     rule {name = &quot;pinentry&quot; float = true}
     rule {name = &quot;urxvt&quot; float = true tags = &quot;1:terminal&quot;}
     rule {name = &quot;Swiftfox&quot; float = true tags = &quot;2:web&quot;}
     rule {name = &quot;wifi-radar&quot; float = true tags = &quot;2:web&quot;}
     rule {name = &quot;gvim&quot; float = true tags = &quot;3:vim&quot;}
     rule {name = &quot;emelfm&quot; float = true tags = &quot;4:files&quot;}
     rule {name = &quot;mc&quot; float = true tags = &quot;4:files&quot;}
 
 }#end rules
 ## Note that &quot;Mod1&quot; is normally the &quot;Alt&quot; key, and that &quot;Mod4&quot; is the &quot;super&quot; or &quot;Windows&quot; key
 # Mouse buttons bindings
 mouse {
     # For click on tag
     tag {button = &quot;1&quot; command = &quot;tag_view&quot;}
     tag {button = &quot;1&quot; modkey = {&quot;Mod4&quot;} command = &quot;client_tag&quot;}
     tag {button = &quot;3&quot; command = &quot;tag_toggleview&quot;}
     tag {button = &quot;3&quot; modkey = {&quot;Mod4&quot;} command = &quot;client_toggletag&quot;}
     tag {button = &quot;4&quot; command = &quot;tag_viewnext&quot;}
     tag {button = &quot;5&quot; command = &quot;tag_viewprev&quot;}
     
     # For click on layout symbol
     layout {button = &quot;1&quot; command = &quot;tag_setlayout&quot; arg = &quot;+1&quot;}
     layout {button = &quot;4&quot; command = &quot;tag_setlayout&quot; arg = &quot;+1&quot;}
     layout {button = &quot;3&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot;}
     layout {button = &quot;5&quot; command = &quot;tag_setlayout&quot; arg = &quot;-1&quot;}
     
     # For click on root window
     root {button = &quot;3&quot; command = &quot;spawn&quot; arg = &quot;exec urxvt&quot;}
     root {button = &quot;4&quot; command = &quot;tag_viewnext&quot;}
     root {button = &quot;5&quot; command = &quot;tag_viewprev&quot;}
 
     # For click on client windows
     client {modkey = {&quot;Mod4&quot;} button = &quot;1&quot; command = &quot;client_movemouse&quot;}
     client {modkey = {&quot;Mod4&quot;} button = &quot;2&quot; command = &quot;client_zoom&quot;}
     client {modkey = {&quot;Mod4&quot;} button = &quot;3&quot; command = &quot;client_resizemouse&quot;}
 }#end mouse
 
 # Keys bindings
 keys {
  
     #These are where you can define shortcuts to launch programs.
     #You can see that I have added &quot;sudo&quot; to some, this method will work with other commands as well.
     key {modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;Return&quot; command = &quot;spawn&quot; arg = &quot;exec urxvt&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;r&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo wifi-radar&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;n&quot;                 command = &quot;spawn&quot; arg = &quot;exec swiftfox&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;v&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo gvim&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;f&quot;                 command = &quot;spawn&quot; arg = &quot;exec sudo emelfm&quot;}
     key {modkey = {&quot;Mod4&quot;} key = &quot;Return&quot;            command = &quot;spawn&quot; arg = &quot;exec gmrun&quot;}  
     ###############################################################################
  
     #Bindings for managing individual windows within each tag.
     key { modkey = {&quot;Mod4&quot;} key = &quot;j&quot;                command = &quot;client_focusnext&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;k&quot;                command = &quot;client_focusprev&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;j&quot;     command = &quot;client_swapnext&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;k&quot;     command = &quot;client_swapprev&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;c&quot;                command = &quot;client_kill&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;m&quot;                command = &quot;client_togglemax&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Shift&quot;} key = &quot;m&quot;       command = &quot;client_toggleverticalmax&quot; }
     key { modkey = {&quot;Mod4&quot;, &quot;Control&quot;} key = &quot;m&quot;     command = &quot;client_togglehorizontalmax&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;f&quot;                command = &quot;client_togglefloating&quot; }
  
     #Bindings to switch between tags
     key { modkey = {&quot;Mod4&quot;} key = &quot;Right&quot;            command = &quot;tag_viewnext&quot; }
     key { modkey = {&quot;Mod4&quot;} key = &quot;Left&quot;             command = &quot;tag_viewprev&quot; }
     key { modkey = {&quot;Mod4&quot;} key = 1                  command = &quot;tag_view&quot; arg = 1 }
     key { modkey = {&quot;Mod4&quot;} key = 2                  command = &quot;tag_view&quot; arg = 2 }
     key { modkey = {&quot;Mod4&quot;} key = 3                  command = &quot;tag_view&quot; arg = 3 }
     key { modkey = {&quot;Mod4&quot;} key = 4                  command = &quot;tag_view&quot; arg = 4 }
     key { modkey = {&quot;Mod4&quot;} key = 5                  command = &quot;tag_view&quot; arg = 5 }
     key { modkey = {&quot;Mod4&quot;} key = 6                  command = &quot;tag_view&quot; arg = 6 }
 
     #View multiple tags in current one
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 1       command = &quot;tag_toggleview&quot; arg = 1}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 2       command = &quot;tag_toggleview&quot; arg = 2}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 3       command = &quot;tag_toggleview&quot; arg = 3}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 4       command = &quot;tag_toggleview&quot; arg = 4}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 5       command = &quot;tag_toggleview&quot; arg = 5}
     key {modkey = {&quot;Shift&quot;, &quot;Control&quot;} key = 6       command = &quot;tag_toggleview&quot; arg = 6}
 
 ##################################################################################################################
  ###These are addition bindings that I don't use.
  ###Perhaps someone else could fill them in?
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;h&quot;          command = &quot;tag_setnmaster&quot; arg = &quot;+1&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;l&quot;          command = &quot;tag_setnmaster&quot; arg = &quot;-1&quot; }
  #awesome
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;r&quot;          command = &quot;exec&quot; arg = &quot;/usr/local/bin/awesome&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;q&quot;          command = &quot;quit&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;b&quot;          command = &quot;statusbar_toggle&quot; }
  
  #additionally view tag &lt;nr&gt;: Mod1 + Shift + Number
  #inc/dec number of columns
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;h&quot;            command = &quot;tag_setncol&quot; arg = &quot;-1&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;l&quot;            command = &quot;tag_setncol&quot; arg = &quot;+1&quot; }
  #number of master clients
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;j&quot;         command = &quot;screen_focusnext&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Control&quot;} key = &quot;k&quot;         command = &quot;screen_focusprev&quot; }
  #key { modkey = {&quot;Mod1&quot;,} key = &quot;t&quot;                   command = &quot;client_settrans&quot; arg = &quot;+0.10&quot; }
  #key { modkey = {&quot;Mod1&quot;} key = &quot;t&quot;                    command = &quot;client_settrans&quot; arg = &quot;-0.10&quot; }
  #key { modkey = {&quot;Mod1&quot;, &quot;Shift&quot;} key = &quot;Return&quot;      command = &quot;client_zoom&quot; arg=&quot;-0.10&quot; }
  } #end keys

[[Category:awesome2]]</text>
      <sha1>5wggsl212p8yypifxu7av8e7hiy1zln</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesomerc (Italiano)</title>
    <ns>0</ns>
    <id>439</id>
    <redirect title="Awesomerc/it" />
    <revision>
      <id>3268</id>
      <timestamp>2009-07-09T09:17:00Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesomerc (Italiano)]] to [[Awesomerc/it]]</comment>
      <text xml:space="preserve" bytes="26">#REDIRECT [[Awesomerc/it]]</text>
      <sha1>q10twygz1pkklb7olbkat2hbvryiehl</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesomerc 3.x</title>
    <ns>0</ns>
    <id>255</id>
    <revision>
      <id>3800</id>
      <parentid>3799</parentid>
      <timestamp>2009-11-15T18:56:01Z</timestamp>
      <contributor>
        <username>Jihell78</username>
        <id>50</id>
      </contributor>
      <text xml:space="preserve" bytes="2173">{{Languages}}

'''This is the man page of awesomerc version 3.4.1. It can also be used for a large part with previous versions 3.x, because the only difference is about the Pango and awesome marups in text string (since 3.2). Nevertheless, you may read their specific man pages if it is necessary.'''


&lt;H2&gt;NAME&lt;/H2&gt;

awesomerc - Configuration file for the awesome window manager
&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; looks for a configuration file in this order:
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;

$XDG_CONFIG_HOME/awesome/rc.lua
&lt;/DL&gt;

&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;

$HOME/.config/awesome/rc.lua
&lt;/DL&gt;

&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;

XDG_CONFIG_DIRS/awesome/rc.lua
&lt;/DL&gt;

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

The &lt;B&gt;rc.lua&lt;/B&gt; file contains configuration information for &lt;B&gt;awesome&lt;/B&gt;. It can be used to configure the behavior and look of awesome in a variety of ways. It can be assimilated as a Lua program/script run at startup by &lt;B&gt;awesome&lt;/B&gt;. Therefore, it should use the awesome Lua API described in the API section. This file is read at startup.
&lt;H2&gt;AWESOME LUA API&lt;/H2&gt;

Documentation for the Lua API can be found in the luadoc directory.
&lt;H2&gt;COLORS FORMAT&lt;/H2&gt;

The color format in &lt;B&gt;awesome&lt;/B&gt; is either a standard X color name (blue, darkblue, lightred, etc) or a hexadecimal formatted color (#rrggbb or #rrggbbaa). By using the hexadecimal format, you can also specify an alpha channel: that means that #00ff00 will draw pure green, but #00ff00aa will set the alpha channel to 'aa' and will blend the green with the color under it.
&lt;H2&gt;TEXT FORMAT&lt;/H2&gt;

You can use Pango markup in a text string. This allows formating the text rendered inside widgets. Pango markup documentation can be found in the Pango documentation at &lt;B&gt;http://library.gnome.org/devel/pango/stable/PangoMarkupFormat.html&lt;/B&gt;.

A Pango markup example: &amp;lt;span weight=&amp;quot;bold&amp;quot; foreground=&amp;quot;#336699&amp;quot;&amp;gt;...&amp;lt;/span&amp;gt;.
&lt;H2&gt;SEE ALSO&lt;/H2&gt;

awesome(1) awesome-client(1)
&lt;H2&gt;AUTHORS&lt;/H2&gt;

Written by Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt
&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
mailto:julien@danjou.info




[[Category:Awesome3]]</text>
      <sha1>9zf85ggknzql2w2lxbd0s07e5q50nso</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesomerc 3.x/fr</title>
    <ns>0</ns>
    <id>246</id>
    <revision>
      <id>3801</id>
      <parentid>2963</parentid>
      <timestamp>2009-11-15T19:18:07Z</timestamp>
      <contributor>
        <username>Jihell78</username>
        <id>50</id>
      </contributor>
      <text xml:space="preserve" bytes="3007">{{Languages|Awesomerc 3.x}}

'''Ceci est la page de manuel de awesomerc version 3.4.1. Elle est utilisable aussi pour une grande part avec les versions 3.x précédentes, car la seule différence porte sur les marquages Pango et awesome (depuis 3.2). Néanmoins, vous pouvez consulter leurs pages de manuel si besoin est.  '''

&lt;H2&gt;NOM&lt;/H2&gt;

awesomerc - Fichier de configuration pour le gestionnaire de fenêtres awesome
&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

&lt;B&gt;awesome&lt;/B&gt; recherche son fichier de configuration dans l'ordre suivant&amp;nbsp;:
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;

$XDG_CONFIG_HOME/awesome/rc.lua
&lt;/DL&gt;

&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;

$HOME/.config/awesome/rc.lua
&lt;/DL&gt;

&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;

XDG_CONFIG_DIRS/awesome/rc.lua
&lt;/DL&gt;

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

Le fichier &lt;B&gt;rc.lua&lt;/B&gt; contient les informations de configuration pour &lt;B&gt;awesome&lt;/B&gt;. Il peut être utilisé pour configurer le comportement et l'aspect de awesome sur beaucoup de points. Il peut être assimilé à un programme (ou un script) Lua exécuté au démarrage de awesome. Cependant, il devrait utiliser l'API Lua  de awesome, décrite dans la  section API. Ce fichier est lu au démarrage.
&lt;H2&gt;API LUA DE AWESOME  &lt;/H2&gt;

On peut trouver la documentation de l'API Lua dans le répertoire luadoc.
&lt;H2&gt;FORMAT DES COULEURS&lt;/H2&gt;

Le format des couleurs dans &lt;B&gt;awesome&lt;/B&gt; est soit en noms de couleurs au standard X (blue, darkblue, lightred, etc.), soit en format hexadécimal de couleurs (#rrggbb ou #rrggbbaa). Si vous utilisez le format hexadécimal, vous pouvez aussi spécifier un canal alpha&amp;nbsp;: cela signifie que #00ff00 représentant du vert pur, #00ff00aa mettra le canal alpha à la valeur «&amp;nbsp;aa&amp;nbsp;» et mélangera le vert pur à la couleur en arrière-plan.
&lt;H2&gt;FORMAT DE TEXTE &lt;/H2&gt;

Vous pouvez utiliser les marquages Pango dans une chaîne de caractères. Cela permet de formater le texte rendu dans des éléments graphiques. On peut trouver la documentation du marquage Pango dans la documentation Pango sur le site  &lt;B&gt;http://library.gnome.org/devel/pango/stable/PangoMarkupFormat.html&lt;/B&gt;.

Un exemple de marquage Pango&amp;nbsp;: 
&amp;lt;span weight=&amp;quot;bold&amp;quot; foreground=&amp;quot;#336699&amp;quot;&amp;gt;...&amp;lt;/span&amp;gt;.
&lt;H2&gt;VOIR AUSSI&lt;/H2&gt;

awesome(1) awesome-client(1)
&lt;H2&gt;AUTEUR&lt;/H2&gt;

écrit par Julien Danjou &amp;lt;julien@danjou.info[1]
&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;
&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
courriel : mailto:julien@danjou.info


&lt;H2&gt;TRADUCTION&lt;/H2&gt;

Ce document est une traduction, réalisée par Jean-Luc Duflot &amp;lt;jl&amp;nbsp;POING&amp;nbsp;duflot&amp;nbsp;CHEZ&amp;nbsp;laposte&amp;nbsp;POING&amp;nbsp;net&amp;gt; le 11&amp;nbsp;novembre&amp;nbsp;2009.

L'équipe de traduction a fait le maximum pour réaliser une adaptation française de qualité.
La version anglaise la plus à jour de ce document est toujours consultable via la commande&amp;nbsp;: LANGUAGE=en man awesomerc. N'hésitez pas à signaler à l'auteur ou au traducteur, selon le cas, toute erreur dans cette page de manuel.


[[Category:awesome3]]</text>
      <sha1>rfj4fs7m0qztl41oeaiwjk40fgwgfuu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesomerc 3.x (en)</title>
    <ns>0</ns>
    <id>386</id>
    <redirect title="Awesomerc 3.x" />
    <revision>
      <id>2959</id>
      <timestamp>2009-06-25T15:19:11Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesomerc 3.x (en)]] to [[Awesomerc 3.x]]</comment>
      <text xml:space="preserve" bytes="27">#REDIRECT [[Awesomerc 3.x]]</text>
      <sha1>n0xgbkobvsms5usyyajwmwtp8kqokf8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesomerc 3.x (fr)</title>
    <ns>0</ns>
    <id>387</id>
    <redirect title="Awesomerc 3.x/fr" />
    <revision>
      <id>2962</id>
      <timestamp>2009-06-25T15:19:31Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awesomerc 3.x (fr)]] to [[Awesomerc 3.x/fr]]</comment>
      <text xml:space="preserve" bytes="30">#REDIRECT [[Awesomerc 3.x/fr]]</text>
      <sha1>ezpooane4v7hyiu2v4jd9vubkzjvmwp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesompd</title>
    <ns>0</ns>
    <id>606</id>
    <revision>
      <id>6824</id>
      <parentid>6245</parentid>
      <timestamp>2014-06-25T06:56:55Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <text xml:space="preserve" bytes="8226">{{DISPLAYTITLE:Awesompd}}
{{Languages}}
{{VersionSpecific
| goodversions = 3.5
| otherversions = [[Awesompd/3.4|3.4.x]]
}}
=== Description ===

[[Image:awesompd_example_1.png|right|thumb|Widget on the wibox and naughty notification]]

[[Image:awesompd_example_2.png|right|thumb|Current playlist shown in widget menu]]

Awesompd is not just an ordinary MPD widget. Its aim is to provide awesome users a robust, functional and extendable MPD client in the form of widget.

Here are main features of awesompd:

* Provides an ability to control playback, switch songs, playlists, change volume and other options.

* Displays information through a scrolling widget and naughty notifications.

* Supports multiple servers and able to switch them on the fly.

* Supports UTF encodings.

* Acts as a player for Jamendo music (more on this below)

* Shows album cover arts in notifications (for both local tracks and Jamendo streams).

=== Jamendo ===

[[Image:awesompd_example_3.png|right|thumb|Let's search for tracks by their artist (Jamendo -&gt; Search by-&gt; Artist)]]

[[Image:awesompd_example_4.png|right|thumb|Enter the name of an artist in the popup box]]

[[Image:awesompd_example_5.png|right|thumb|Bingo! Awesompd actually found some tracks of this artist]]

[[Image:awesompd_example_6.png|right|thumb|Now we can listen to them with our own MPD server]]

[http://www.jamendo.com Jamendo] is a website where artists host their music under the [http://en.wikipedia.org/wiki/Creative_Commons Creative Commons] licenses. This means that all music is free to download and distribute and it is free of any kind of DRM protection. Another nice feature of Jamendo is that you can listen to music directly from their website, without downloading tracks first.
Awesompd acts as a mediator between Jamendo and MPD server. Here are the functions that it can do so far:

* Search for music on Jamendo and add streams to your MPD.

* Fetch correct track names and display them (instead of the faceless stream links).

* Search tracks by their artist, album or tag.

* Add the current &quot;Top 100&quot; to your playlist. Top 100 can be determined by tracks' daily, weekly or total ratings.

* Switch between two stream formats: MP3 and Ogg Vorbis.

* Fetch and display album covers for Jamendo tracks.

* Open the Jamendo page in the browser for the currently playing artist or album.

==== Order ====

Root Jamendo menu contains a submenu called '''Order'''. The selected item in it defines how the found tracks in the result query would be sorted. For example, if you search by the ''tag'' &quot;rock&quot; and selected order is '''daily rating''' then 100 today's most popular rock songs would be added to your playlist. Or if you search for an ''artist'' &quot;lukhash&quot; with current order being '''random''', then all the tracks of this artist would arrive in random order.

=== How to start ===

* First you need to download the widget itself. You can clone the latest copy from https://github.com/alexander-yakushev/awesompd .

Also you can download the archive directly: https://github.com/alexander-yakushev/awesompd/archive/master.zip .

* Create a new folder called &quot;awesompd&quot; in your ~/.config/awesome/ folder. Copy the downloaded files (awesompd.lua, jamendo.lua, utf8.lua, icons/ folder) into it (so they become '''~/.config/awesome/awesompd/awesompd.lua''' etc.).

* Install '''mpc'''

On Debian\Ubuntu you can do it in this way:

   $ sudo aptitude install mpc

For other distributions see the manual.

* To use Jamendo functions you will also need '''curl''' and '''wget'''. Most probably you already have them installed. Just to be sure check it with the following commands:

   $ curl --version
   $ wget --version

* Open your rc.lua file and add these lines:

   local awesompd = require(&quot;awesompd/awesompd&quot;)
   musicwidget = awesompd:create() -- Create awesompd widget
   musicwidget.font = &quot;Liberation Mono&quot; -- Set widget font 
   musicwidget.scrolling = true -- If true, the text in the widget will be scrolled
   musicwidget.output_size = 30 -- Set the size of widget in symbols
   musicwidget.update_interval = 10 -- Set the update interval in seconds
   -- Set the folder where icons are located (change username to your login name)
   musicwidget.path_to_icons = &quot;/home/username/.config/awesome/awesompd/icons&quot; 
   -- Set the default music format for Jamendo streams. You can change
   -- this option on the fly in awesompd itself.
   -- possible formats: awesompd.FORMAT_MP3, awesompd.FORMAT_OGG
   musicwidget.jamendo_format = awesompd.FORMAT_MP3
   -- If true, song notifications for Jamendo tracks and local tracks will also contain
   -- album cover image.
   musicwidget.show_album_cover = true
   -- Specify how big in pixels should an album cover be. Maximum value
   -- is 100.
   musicwidget.album_cover_size = 50
   -- This option is necessary if you want the album covers to be shown
   -- for your local tracks.
   musicwidget.mpd_config = &quot;/home/username/.mpdconf&quot;
   -- Specify the browser you use so awesompd can open links from
   -- Jamendo in it.
   musicwidget.browser = &quot;firefox&quot;
   -- Specify decorators on the left and the right side of the
   -- widget. Or just leave empty strings if you decorate the widget
   -- from outside.
   musicwidget.ldecorator = &quot; &quot;
   musicwidget.rdecorator = &quot; &quot;
   -- Set all the servers to work with (here can be any servers you use)
   musicwidget.servers = {
      { server = &quot;localhost&quot;,
           port = 6600 },
      { server = &quot;192.168.0.72&quot;,
           port = 6600 } }
   -- Set the buttons of the widget
   musicwidget:register_buttons({ { &quot;&quot;, awesompd.MOUSE_LEFT, musicwidget:command_playpause() },
       			         { &quot;Control&quot;, awesompd.MOUSE_SCROLL_UP, musicwidget:command_prev_track() },
  			         { &quot;Control&quot;, awesompd.MOUSE_SCROLL_DOWN, musicwidget:command_next_track() },
  			         { &quot;&quot;, awesompd.MOUSE_SCROLL_UP, musicwidget:command_volume_up() },
  			         { &quot;&quot;, awesompd.MOUSE_SCROLL_DOWN, musicwidget:command_volume_down() },
  			         { &quot;&quot;, awesompd.MOUSE_RIGHT, musicwidget:command_show_menu() },
                                  { &quot;&quot;, &quot;XF86AudioLowerVolume&quot;, musicwidget:command_volume_down() },
                                  { &quot;&quot;, &quot;XF86AudioRaiseVolume&quot;, musicwidget:command_volume_up() },
                                  { modkey, &quot;Pause&quot;, musicwidget:command_playpause() } })
   musicwidget:run() -- After all configuration is done, run the widget

And finally add the widget to wibox. You should add it as:

    musicwidget.widget

For instance, if you want it to the right of the screen add it here :
    -- Widgets that are aligned to the right
    local right_layout = wibox.layout.fixed.horizontal()
    if s == 1 then right_layout:add(wibox.widget.systray()) end
    right_layout:add(musicwidget.widget)  -- ADD THIS LINE HERE

Also in order to enable global keybindings insert this line before root.keys call:

    &lt;nowiki&gt;musicwidget:append_global_keys()&lt;/nowiki&gt;
    root.keys(globalkeys)

''Note: If you use some other table for keeping your global keybindings, then pass it to the append_global_keys function, and pass the result of it to root.keys:''

    root.keys(musicwidget:append_global_keys(my_key_table))

Awesompd comes with '''rcsample.lua''' file which is basically a default rc.lua with awesompd widget in it. You should try it if you have troubles running awesompd with your own config.

=== Default controls ===

* Left mouse button click (or Mod-Pause/Break) - Play/pause current song

* Right mouse button click - Show/hide menu

* Mouse scroll up/down (or XF86VolumeLower/RaiseVolume) - Increase/decrease volume

* CTRL + mouse scroll up/down - Next/previous song

If you know a little lua, you can change controls, add new functions and bindings and so on. Managing controls is already done in a way that is very easy and understandable (see the function '''register_buttons''').

=== Customization ===

==== Don't notify when disconnected / mpd down ====

Add these lines to '''rc.lua''' where your MPD widget is configured:

    awesompd.DISCONNECTED=&quot;&quot;
    musicwidget.notify_connect = function() end
    musicwidget.notify_disconnect = function() end

[[Category:Widgets]]

[[Category:Awesome3.5]]</text>
      <sha1>eo6hsuyoztjmia7p4oe2v1d2syd719f</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesompd/3.4</title>
    <ns>0</ns>
    <id>908</id>
    <revision>
      <id>6246</id>
      <parentid>6163</parentid>
      <timestamp>2014-02-11T12:45:45Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <minor/>
      <comment>change function in the example</comment>
      <text xml:space="preserve" bytes="7786">{{DISPLAYTITLE:Awesompd}}
{{Languages|Awesompd}}
{{VersionSpecific
| goodversions = 3.4.x
| otherversions = [[Awesompd|3.5]]
}}
=== Description ===

[[Image:awesompd_example_1.png|right|thumb|Widget on the wibox and naughty notification]]

[[Image:awesompd_example_2.png|right|thumb|Current playlist shown in widget menu]]

Awesompd is not just an ordinary MPD widget. Its aim is to provide awesome users a robust, functional and extendable MPD client in the form of widget.

Here are main features of awesompd:

* Provides an ability to control playback, switch songs, playlists, change volume and other options.

* Displays information through a scrolling widget and naughty notifications.

* Supports multiple servers and able to switch them on the fly.

* Supports UTF encodings.

* Acts as a player for Jamendo music (more on this below)

* Shows album cover arts in notifications (for both local tracks and Jamendo streams).

=== Jamendo ===

[[Image:awesompd_example_3.png|right|thumb|Let's search for tracks by their artist (Jamendo -&gt; Search by-&gt; Artist)]]

[[Image:awesompd_example_4.png|right|thumb|Enter the name of an artist in the popup box]]

[[Image:awesompd_example_5.png|right|thumb|Bingo! Awesompd actually found some tracks of this artist]]

[[Image:awesompd_example_6.png|right|thumb|Now we can listen to them with our own MPD server]]

[http://www.jamendo.com Jamendo] is a website where artists host their music under the [http://en.wikipedia.org/wiki/Creative_Commons Creative Commons] licenses. This means that all music is free to download and distribute and it is free of any kind of DRM protection. Another nice feature of Jamendo is that you can listen to music directly from their website, without downloading tracks first.
Awesompd acts as a mediator between Jamendo and MPD server. Here are the functions that it can do so far:

* Search for music on Jamendo and add streams to your MPD.

* Fetch correct track names and display them (instead of the faceless stream links).

* Search tracks by their artist, album or tag.

* Add the current &quot;Top 100&quot; to your playlist. Top 100 can be determined by tracks' daily, weekly or total ratings.

* Switch between two stream formats: MP3 and Ogg Vorbis.

* Fetch and display album covers for Jamendo tracks.

* Open the Jamendo page in the browser for the currently playing artist or album.

==== Order ====

Root Jamendo menu contains a submenu called '''Order'''. The selected item in it defines how the found tracks in the result query would be sorted. For example, if you search by the ''tag'' &quot;rock&quot; and selected order is '''daily rating''' then 100 today's most popular rock songs would be added to your playlist. Or if you search for an ''artist'' &quot;lukhash&quot; with current order being '''random''', then all the tracks of this artist would arrive in random order.

=== How to start ===

* First you need to download the widget itself. You can clone the latest copy from https://github.com/alexander-yakushev/awesompd/tree/awesome-3.4 .

Also you can download the archive directly: https://github.com/alexander-yakushev/awesompd/archive/awesome-3.4.zip

* Create a new folder called &quot;awesompd&quot; in your ~/.config/awesome/ folder. Copy the downloaded files (awesompd.lua, jamendo.lua, utf8.lua, icons/ folder) into it (so they become '''~/.config/awesome/awesompd/awesompd.lua''' etc.).

* Install '''mpc'''

On Debian\Ubuntu you can do it in this way:

   $ sudo aptitude install mpc

For other distributions see the manual.

* To use Jamendo functions you will also need '''curl''' and '''wget'''. Most probably you already have them installed. Just to be sure check it with the following commands:

   $ curl --version
   $ wget --version

* Open your rc.lua file and add these lines:

   local awesompd = require(&quot;awesompd/awesompd&quot;)
   musicwidget = awesompd:create() -- Create awesompd widget
   musicwidget.font = &quot;Liberation Mono&quot; -- Set widget font
 --musicwidget.font_color = &quot;#000000&quot; --Set font color
 --musicwidget.background = '#FFFFFF&quot; --Set background color
   musicwidget.scrolling = true -- If true, the text in the widget will be scrolled
   musicwidget.output_size = 30 -- Set the size of widget in symbols
   musicwidget.update_interval = 10 -- Set the update interval in seconds
   -- Set the folder where icons are located (change username to your login name)
   musicwidget.path_to_icons = &quot;/home/username/.config/awesome/awesompd/icons&quot; 
   -- Set the default music format for Jamendo streams. You can change
   -- this option on the fly in awesompd itself.
   -- possible formats: awesompd.FORMAT_MP3, awesompd.FORMAT_OGG
   musicwidget.jamendo_format = awesompd.FORMAT_MP3
   -- If true, song notifications for Jamendo tracks and local tracks will also contain
   -- album cover image.
   musicwidget.show_album_cover = true
   -- Specify how big in pixels should an album cover be. Maximum value
   -- is 100.
   musicwidget.album_cover_size = 50
   -- This option is necessary if you want the album covers to be shown
   -- for your local tracks.
   musicwidget.mpd_config = &quot;/home/username/.mpdconf&quot;
   -- Specify the browser you use so awesompd can open links from
   -- Jamendo in it.
   musicwidget.browser = &quot;firefox&quot;
   -- Specify decorators on the left and the right side of the
   -- widget. Or just leave empty strings if you decorate the widget
   -- from outside.
   musicwidget.ldecorator = &quot; &quot;
   musicwidget.rdecorator = &quot; &quot;
   -- Set all the servers to work with (here can be any servers you use)
   musicwidget.servers = {
      { server = &quot;localhost&quot;,
           port = 6600 },
      { server = &quot;192.168.0.72&quot;,
           port = 6600 } }
   -- Set the buttons of the widget
   musicwidget:register_buttons({ { &quot;&quot;, awesompd.MOUSE_LEFT, musicwidget:command_playpause() },
       			         { &quot;Control&quot;, awesompd.MOUSE_SCROLL_UP, musicwidget:command_prev_track() },
  			         { &quot;Control&quot;, awesompd.MOUSE_SCROLL_DOWN, musicwidget:command_next_track() },
  			         { &quot;&quot;, awesompd.MOUSE_SCROLL_UP, musicwidget:command_volume_up() },
  			         { &quot;&quot;, awesompd.MOUSE_SCROLL_DOWN, musicwidget:command_volume_down() },
  			         { &quot;&quot;, awesompd.MOUSE_RIGHT, musicwidget:command_show_menu() },
                                  { &quot;&quot;, &quot;XF86AudioLowerVolume&quot;, musicwidget:command_volume_down() },
                                  { &quot;&quot;, &quot;XF86AudioRaiseVolume&quot;, musicwidget:command_volume_up() },
                                  { modkey, &quot;Pause&quot;, musicwidget:command_playpause() } })
   musicwidget:run() -- After all configuration is done, run the widget

And finally add the widget to wibox. You should add it as:

    musicwidget.widget

Also in order to enable global keybindings insert this line before root.keys call:

    &lt;nowiki&gt;musicwidget:append_global_keys()&lt;/nowiki&gt;
    root.keys(globalkeys)

''Note: If you use some other table for keeping your global keybindings, then pass it to the append_global_keys function, and pass the result of it to root.keys:''

    root.keys(musicwidget:append_global_keys(my_key_table))

Awesompd comes with '''rcsample.lua''' file which is basically a default rc.lua with awesompd widget in it. You should try it if you have troubles running awesompd with your own config.

=== Default controls ===

* Left mouse button click (or Mod-Pause/Break) - Play/pause current song

* Right mouse button click - Show/hide menu

* Mouse scroll up/down (or XF86VolumeLower/RaiseVolume) - Increase/decrease volume

* CTRL + mouse scroll up/down - Next/previous song

If you know a little lua, you can change controls, add new functions and bindings and so on. Managing controls is already done in a way that is very easy and understandable (see the function '''register_buttons''').

[[Category:Widgets]]

[[Category:awesome3]]</text>
      <sha1>llgpkuzy39sitxu6o62xiw0t4t2za8c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesompd/3.4/ru</title>
    <ns>0</ns>
    <id>957</id>
    <revision>
      <id>6087</id>
      <parentid>6086</parentid>
      <timestamp>2013-08-20T00:28:09Z</timestamp>
      <contributor>
        <username>Altai</username>
        <id>3054</id>
      </contributor>
      <comment>Many little fixes.</comment>
      <text xml:space="preserve" bytes="11386">{{DISPLAYTITLE:Awesompd}}
{{Languages|Awesompd}}
{{VersionSpecific
| goodversions = 3.4.x
| otherversions = [[Awesompd/ru|3.5]]
}}

=== Описание ===

[[Image:awesompd_example_1.png|right|thumb|Awesompd в контейнере для виджетов и оповещение naughty]]

[[Image:awesompd_example_2.png|right|thumb|Текущий плейлист отображается в меню виджета]]

Awesompd - это не просто обычный MPD-виджет. Его цель - обеспечить пользователей awesome качественным, функциональным и дополняемым MPD-клиентом в форме виджета.

Основные возможности awesompd:

* Возможность управлять воспроизведением, изменять текущую композицию, плейлисты, регулировать громкость и другие опции.

* Показывает информацию с помощью уведомлений naughty.

* Поддерживает несколько серверов и возможность переключения между ними на лету.

* Поддерживает UTF-кодировку.

* Работает как плеер для сервиса Jamendo music (больше об этом ниже).

* Показывает обложки альбомов в уведомлениях(и для локальных треков и для Jamendo-стримов).

=== Jamendo ===

[[Image:awesompd_example_3.png|right|thumb|Давайте найдем треки по их исполнителю (Jamendo -&gt; Search by-&gt; Artist)]]

[[Image:awesompd_example_4.png|right|thumb|Вводим название исполнителя в всплывающее окно]]

[[Image:awesompd_example_5.png|right|thumb|Бинго! Awesompd нашел несколько треков этого исполнителя]]

[[Image:awesompd_example_6.png|right|thumb|Теперь мы можем слушать их через собственный MPD-сервер]]

[http://www.jamendo.com Jamendo] - это веб-сервис, где исполнители выкладывают собственную музыку под лицензией [http://ru.wikipedia.org/wiki/Creative_Commons Creative Commons]. Это означает, что вся музыка свободна для скачивания и распространения, она свободна от любого вида DRM-защиты. Другая приятная особенность Jamendo состоит в том, что вы можете слушать песни прямо с сайта Jamendo, без предварительной загрузки трека. Awesompd действует как проводник между Jamendo и MPD-сервером. Вот возможности Awesompd для использования Jamendo:

* Поиск музыки на Jamendo и добавление стримов в ваш MPD.

* Получение правильных названий треков и их отображение (в отличии от безликих ссылок на стримы).

* Поиск треков по исполнителю, альбому или тегу.

* Добавление текущего &quot;Топ 100&quot; в ваш плейлист. Топ 100 может быть определен по рейтингу треков за день, неделю или за все время.

* Переключение между двумя форматами стрима: MP3 и Ogg Vorbis.

* Получение и отображение обложек альбомов для треков с Jamendo.

* Открытие страницы Jamendo в браузере для воспроизводимого исполнителя или альбома.

==== Order ====

Главное меню Jamendo содержит в себе подменю с названием  '''Order'''. Выбранный пункт в нем определяет, как будут сортироваться результаты в поиске. Например, если вы ищете по ''тегу'' &quot;rock&quot; и выбрали в подменю order пункт '''daily rating''', тогда 100 сегодняшних самых популярных треков рок-исполнителей будут добавлены в плейлист. Или если вы ищете ''исполнителя'' &quot;lukhash&quot;, когда текущий order выставлен как '''random''', тогда все треки этого исполнителя будут расположены в плейлисте в случайном порядке.

=== Установка ===

* Для начала вам необходимо скачать сам виджет. Вы можете скачать последнюю версию на: https://github.com/alexander-yakushev/awesompd . 

Также вы можете скачать архив по прямой ссылке: https://github.com/alexander-yakushev/awesompd/archive/master.zip 

* Создайте новую папку с названием &quot;awesompd&quot; в вашей папке '''~/.config/awesome/'''. Скопируйте загруженные файлы из архива(awesompd.lua, jamendo.lua, utf8.lua, папка icons/) туда так, чтобы путь к ним был в формате '''~/.config/awesome/awesompd/awesompd.lua'''.

* Установите '''mpc''':

Для Debian/Ubuntu вы можете сделать это так:

   $ sudo aptitude install mpc

Для других дистрибутивов смотрите руководство по пакетному менеджеру.

* Для использования функций Jamendo также необходимы '''curl''' и '''wget'''. Наиболее вероятно, что они уже установлены в вашей системе. Для уверенности можно сделать проверку с помощью следующих команд:

   $ curl --version
   $ wget --version

* Откройте свой файл rc.lua в любимом текстовом редакторе и добавьте такие строчки:

  local awesompd = require(&quot;awesompd/awesompd&quot;)
  musicwidget = awesompd:create() -- Create awesompd widget
  musicwidget.font = &quot;Liberation Mono&quot; -- Set widget font
--musicwidget.font_color = &quot;#000000&quot; --Set font color
--musicwidget.background = '#FFFFFF&quot; --Set background color
  musicwidget.scrolling = true -- If true, the text in the widget will be scrolled
  musicwidget.output_size = 30 -- Set the size of widget in symbols
  musicwidget.update_interval = 10 -- Set the update interval in seconds
  -- Set the folder where icons are located (change username to your login name)
  musicwidget.path_to_icons = &quot;/home/username/.config/awesome/awesompd/icons&quot; 
  -- Set the default music format for Jamendo streams. You can change
  -- this option on the fly in awesompd itself.
  -- possible formats: awesompd.FORMAT_MP3, awesompd.FORMAT_OGG
  musicwidget.jamendo_format = awesompd.FORMAT_MP3
  -- If true, song notifications for Jamendo tracks and local tracks will also contain
  -- album cover image.
  musicwidget.show_album_cover = true
  -- Specify how big in pixels should an album cover be. Maximum value
  -- is 100.
  musicwidget.album_cover_size = 50
  -- This option is necessary if you want the album covers to be shown
  -- for your local tracks.
  musicwidget.mpd_config = &quot;/home/username/.mpdconf&quot;
  -- Specify the browser you use so awesompd can open links from
  -- Jamendo in it.
  musicwidget.browser = &quot;firefox&quot;
  -- Specify decorators on the left and the right side of the
  -- widget. Or just leave empty strings if you decorate the widget
  -- from outside.
  musicwidget.ldecorator = &quot; &quot;
  musicwidget.rdecorator = &quot; &quot;
  -- Set all the servers to work with (here can be any servers you use)
  musicwidget.servers = {
     { server = &quot;localhost&quot;,
          port = 6600 },
     { server = &quot;192.168.0.72&quot;,
          port = 6600 } }
  -- Set the buttons of the widget
  musicwidget:register_buttons({ { &quot;&quot;, awesompd.MOUSE_LEFT, musicwidget:command_toggle() },
      			         { &quot;Control&quot;, awesompd.MOUSE_SCROLL_UP, musicwidget:command_prev_track() },
 			         { &quot;Control&quot;, awesompd.MOUSE_SCROLL_DOWN, musicwidget:command_next_track() },
 			         { &quot;&quot;, awesompd.MOUSE_SCROLL_UP, musicwidget:command_volume_up() },
 			         { &quot;&quot;, awesompd.MOUSE_SCROLL_DOWN, musicwidget:command_volume_down() },
 			         { &quot;&quot;, awesompd.MOUSE_RIGHT, musicwidget:command_show_menu() },
                                 { &quot;&quot;, &quot;XF86AudioLowerVolume&quot;, musicwidget:command_volume_down() },
                                 { &quot;&quot;, &quot;XF86AudioRaiseVolume&quot;, musicwidget:command_volume_up() },
                                 { modkey, &quot;Pause&quot;, musicwidget:command_playpause() } })
  musicwidget:run() -- After all configuration is done, run the widget


И, наконец, добавьте виджет в контейнер для виджетов. Вам следует добавить такую строчку в код контейнера для виджета(Wibox):

    musicwidget.widget

Также для включения глобальных хоткеев добавьте эти строчки перед root.keys:

    &lt;nowiki&gt;musicwidget:append_global_keys()&lt;/nowiki&gt;
    root.keys(globalkeys)

''Примечание: Если вы используете другую таблицу для глобальных хоткеев, тогда пропустите предыдущий пункт и используйте вот такую строчку:''

    root.keys(musicwidget:append_global_keys(my_key_table))

Awesompd поставляется с файлом '''rcsample.lua''', который содержит стандартный rc.lua с встроенным awesompd виджетом. Вы можете попробовать его, в случае, если у вас возникнут проблемы с запуском awesompd с вашим собственным конфигурационном файлом.

=== Стандартное управление ===

* Щелчок левой кнопкой мыши(или Mod+Pause|Break на клавиатуре) - Воспроизведение/пауза текущей песни

* Щелчок правой кнопкой мыши - Показать/скрыть меню

* Скроллинг мышью вверх/вниз (или XF86VolumeLower/RaiseVolume) - Увеличение/уменьшение громкости

* CTRL + скроллинг мышью - Следующая/предыдущая песня

Если вы немного знаете Lua, то можете сменить управление, добавить новые функции и комбинации клавиш и даже больше. Настройка управление сделана по принципу наиболее простого и понятного (смотрите функцию '''register_buttons''').

[[Category:Awesome3]]

[[Category:Widgets]]</text>
      <sha1>8ys6vtbtgizg8jc0dok5u260nwg7ecu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesompd/ru</title>
    <ns>0</ns>
    <id>956</id>
    <revision>
      <id>6826</id>
      <parentid>6825</parentid>
      <timestamp>2014-06-25T07:10:02Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="11712">{{DISPLAYTITLE:Awesompd}}
{{Languages|Awesompd}}
{{VersionSpecific
| goodversions = 3.5
| otherversions = [[Awesompd/3.4/ru|3.4.x]]
}}

=== Описание ===

[[Image:awesompd_example_1.png|right|thumb|Awesompd в контейнере для виджетов и оповещение naughty]]

[[Image:awesompd_example_2.png|right|thumb|Текущий плейлист отображается в меню виджета]]

Awesompd - это не просто обычный MPD-виджет. Его цель - обеспечить пользователей awesome качественным, функциональным и дополняемым MPD-клиентом в форме виджета.

Основные возможности awesompd:

* Возможность управлять воспроизведением, изменять текущую композицию, плейлисты, регулировать громкость и другие опции.

* Показывает информацию с помощью уведомлений naughty.

* Поддерживает несколько серверов и возможность переключения между ними на лету.

* Поддерживает UTF-кодировку.

* Работает как плеер для сервиса Jamendo music (больше об этом ниже).

* Показывает обложки альбомов в уведомлениях (и для локальных треков и для Jamendo-стримов).

=== Jamendo ===

[[Image:awesompd_example_3.png|right|thumb|Давайте найдем треки по их исполнителю (Jamendo -&gt; Search by-&gt; Artist)]]

[[Image:awesompd_example_4.png|right|thumb|Вводим название исполнителя в всплывающее окно]]

[[Image:awesompd_example_5.png|right|thumb|Бинго! Awesompd нашел несколько треков этого исполнителя]]

[[Image:awesompd_example_6.png|right|thumb|Теперь мы можем слушать их через собственный MPD-сервер]]

[http://www.jamendo.com Jamendo] - это веб-сервис, где исполнители выкладывают собственную музыку под лицензией [http://ru.wikipedia.org/wiki/Creative_Commons Creative Commons]. Это означает, что вся музыка свободна для скачивания и распространения, она свободна от любого вида DRM-защиты. Другая приятная особенность Jamendo состоит в том, что вы можете слушать песни прямо с сайта Jamendo, без предварительной загрузки трека. Awesompd действует как проводник между Jamendo и MPD-сервером. Вот возможности Awesompd для использования Jamendo:

* Поиск музыки на Jamendo и добавление стримов в ваш MPD.

* Получение правильных названий треков и их отображение (в отличии от безликих ссылок на стримы).

* Поиск треков по исполнителю, альбому или тегу.

* Добавление текущего &quot;Топ 100&quot; в ваш плейлист. Топ 100 может быть определен по рейтингу треков за день, неделю или за все время.

* Переключение между двумя форматами стрима: MP3 и Ogg Vorbis.

* Получение и отображение обложек альбомов для треков с Jamendo.

* Открытие страницы Jamendo в браузере для воспроизводимого исполнителя или альбома.

==== Order ====

Главное меню Jamendo содержит в себе подменю с названием  '''Order'''. Выбранный пункт в нем определяет, как будут сортироваться результаты в поиске. Например, если вы ищете по ''тегу'' &quot;rock&quot; и выбрали в подменю order пункт '''daily rating''', тогда 100 сегодняшних самых популярных треков рок-исполнителей будут добавлены в плейлист. Или если вы ищете ''исполнителя'' &quot;lukhash&quot;, когда текущий order выставлен как '''random''', тогда все треки этого исполнителя будут расположены в плейлисте в случайном порядке.

=== Установка ===

* Для начала вам необходимо скачать сам виджет. Вы можете скачать последнюю версию на: https://github.com/alexander-yakushev/awesompd/tree/for-awesome-git .

Также вы можете скачать архив по прямой ссылке: https://github.com/alexander-yakushev/awesompd/archive/for-awesome-git.zip

* Создайте новую папку с названием &quot;awesompd&quot; в вашей папке '''~/.config/awesome/'''. Скопируйте загруженные файлы из архива(awesompd.lua, jamendo.lua, utf8.lua, папка icons/) туда так, чтобы путь к ним был в формате '''~/.config/awesome/awesompd/awesompd.lua'''.

* Установите '''mpc''':

Для Debian/Ubuntu вы можете сделать это так:

   $ sudo aptitude install mpc

Для других дистрибутивов смотрите руководство по пакетному менеджеру.

* Для использования функций Jamendo также необходимы '''curl''' и '''wget'''. Наиболее вероятно, что они уже установлены в вашей системе. Для уверенности можно сделать проверку с помощью следующих команд:

   $ curl --version
   $ wget --version

* Откройте свой файл rc.lua в любимом текстовом редакторе и добавьте такие строчки:

   local awesompd = require(&quot;awesompd/awesompd&quot;)
   musicwidget = awesompd:create() -- Create awesompd widget
   musicwidget.font = &quot;Liberation Mono&quot; -- Set widget font 
   musicwidget.scrolling = true -- If true, the text in the widget will be scrolled
   musicwidget.output_size = 30 -- Set the size of widget in symbols
   musicwidget.update_interval = 10 -- Set the update interval in seconds
   -- Set the folder where icons are located (change username to your login name)
   musicwidget.path_to_icons = &quot;/home/username/.config/awesome/awesompd/icons&quot; 
   -- Set the default music format for Jamendo streams. You can change
   -- this option on the fly in awesompd itself.
   -- possible formats: awesompd.FORMAT_MP3, awesompd.FORMAT_OGG
   musicwidget.jamendo_format = awesompd.FORMAT_MP3
   -- If true, song notifications for Jamendo tracks and local tracks will also contain
   -- album cover image.
   musicwidget.show_album_cover = true
   -- Specify how big in pixels should an album cover be. Maximum value
   -- is 100.
   musicwidget.album_cover_size = 50
   -- This option is necessary if you want the album covers to be shown
   -- for your local tracks.
   musicwidget.mpd_config = &quot;/home/username/.mpdconf&quot;
   -- Specify the browser you use so awesompd can open links from
   -- Jamendo in it.
   musicwidget.browser = &quot;firefox&quot;
   -- Specify decorators on the left and the right side of the
   -- widget. Or just leave empty strings if you decorate the widget
   -- from outside.
   musicwidget.ldecorator = &quot; &quot;
   musicwidget.rdecorator = &quot; &quot;
   -- Set all the servers to work with (here can be any servers you use)
   musicwidget.servers = {
      { server = &quot;localhost&quot;,
           port = 6600 },
      { server = &quot;192.168.0.72&quot;,
           port = 6600 } }
   -- Set the buttons of the widget
   musicwidget:register_buttons({ { &quot;&quot;, awesompd.MOUSE_LEFT, musicwidget:command_toggle() },
       			         { &quot;Control&quot;, awesompd.MOUSE_SCROLL_UP, musicwidget:command_prev_track() },
  			         { &quot;Control&quot;, awesompd.MOUSE_SCROLL_DOWN, musicwidget:command_next_track() },
  			         { &quot;&quot;, awesompd.MOUSE_SCROLL_UP, musicwidget:command_volume_up() },
  			         { &quot;&quot;, awesompd.MOUSE_SCROLL_DOWN, musicwidget:command_volume_down() },
  			         { &quot;&quot;, awesompd.MOUSE_RIGHT, musicwidget:command_show_menu() },
                                  { &quot;&quot;, &quot;XF86AudioLowerVolume&quot;, musicwidget:command_volume_down() },
                                  { &quot;&quot;, &quot;XF86AudioRaiseVolume&quot;, musicwidget:command_volume_up() },
                                  { modkey, &quot;Pause&quot;, musicwidget:command_playpause() } })
   musicwidget:run() -- After all configuration is done, run the widget


И, наконец, добавьте виджет в контейнер для виджетов. Вам следует добавить такую строчку в код контейнера для виджета(Wibox):

    musicwidget.widget

Также для включения глобальных хоткеев добавьте эти строчки перед root.keys:

    &lt;nowiki&gt;musicwidget:append_global_keys()&lt;/nowiki&gt;
    root.keys(globalkeys)

''Примечание: Если вы используете другую таблицу для глобальных хоткеев, тогда пропустите предыдущий пункт и используйте вот такую строчку:''

    root.keys(musicwidget:append_global_keys(my_key_table))

Awesompd поставляется с файлом '''rcsample.lua''', который содержит стандартный rc.lua с встроенным awesompd виджетом. Вы можете попробовать его, в случае, если у вас возникнут проблемы с запуском awesompd с вашим собственным конфигурационном файлом.

=== Стандартное управление ===

* Щелчок левой кнопкой мыши(или Mod+Pause|Break на клавиатуре) - Воспроизведение/пауза текущей песни

* Щелчок правой кнопкой мыши - Показать/скрыть меню

* Скроллинг мышью вверх/вниз (или XF86VolumeLower/RaiseVolume) - Увеличение/уменьшение громкости

* CTRL + скроллинг мышью - Следующая/предыдущая песня

Если вы немного знаете Lua, то можете сменить управление, добавить новые функции и комбинации клавиш и даже больше. Настройка управление сделана по принципу наиболее простого и понятного (смотрите функцию '''register_buttons''').

=== Кастомизация ===

==== Не оповещать когда mpd отключен ====

Добавьте следующие строки в rc.lua туда, где вы настраиваете ваш MPD-виджет:

   awesompd.DISCONNECTED=&quot;&quot;
   musicwidget.notify_connect = function() end
   musicwidget.notify_disconnect = function() end


[[Category:Awesome3]]

[[Category:Widgets]]</text>
      <sha1>dcyu7ylvp17j8qo8zf7f0dfh8vjox9n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awesompd widget</title>
    <ns>0</ns>
    <id>907</id>
    <redirect title="Awesompd" />
    <revision>
      <id>5812</id>
      <timestamp>2013-03-12T13:05:19Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <comment>moved [[Awesompd widget]] to [[Awesompd]] over redirect</comment>
      <text xml:space="preserve" bytes="22">#REDIRECT [[Awesompd]]</text>
      <sha1>pxsdkzjd9d1aj4x0jxzvjprn9yv5jm1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awful.menu</title>
    <ns>0</ns>
    <id>179</id>
    <revision>
      <id>6666</id>
      <parentid>4524</parentid>
      <timestamp>2014-05-26T07:18:54Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag, delete dead link</comment>
      <text xml:space="preserve" bytes="4605">{{Languages}}

''awful.menu'' is an awful module to allow creation of popup menus with an arborescence of sub-menus.

This module is designed for awesome 3

== Setting up awful.menu ==

The module is automatically loaded at startup, as long as you have the following line on top of your config file:
&lt;pre&gt;require(&quot;awful&quot;)&lt;/pre&gt;

Basically you feed your menu with a table containing another table for each item of your menu. The first element of the item table is the label, then the triggered action which can be a string or a menu table, setting a menu table as an item will result as a sub-menu. The third element is an optional path to an icon.

There is an example in the default ''awesomerc.lua'':

&lt;pre&gt;
myawesomemenu = {
   { &quot;manual&quot;, terminal .. &quot; -e man awesome&quot; },
   { &quot;edit config&quot;, terminal .. &quot; -e nano ~/.config/awesome/rc.lua&quot; },
   { &quot;restart&quot;, awesome.restart },
   { &quot;quit&quot;, awesome.quit }
}

mymainmenu = awful.menu.new({ items = { { &quot;awesome&quot;, myawesomemenu, beautiful.awesome_icon },
                                        { &quot;open terminal&quot;, terminal }
                                      }
                            })
&lt;/pre&gt;

Since awesome 3.4.x labels support access keys configuration: you have to prepend an &amp; to the desired key
eg.

&lt;pre&gt;
{ &quot;&amp;firefox&quot;, &quot;firefox&quot;, awful.util.getdir(&quot;config&quot;) .. &quot;/firefox.png&quot; },
&lt;/pre&gt;

Will allow you to press Mod4 + W (default key binding) to bring the menu up and then &quot;f&quot; to launch firefox.




We first create a table ''myawesomemenu'', we will use it as a sub-menu, then we create a ''mymainmenu'' with two items of which one is our ''myawesomemenu'' table, this is how we get sub-menus working.

Now we want to display our menu, we have two ways.

Using a launcher widget:

&lt;pre&gt;
mylauncher = awful.widget.launcher({ image = image(beautiful.awesome_icon),
                                     menu = mymainmenu
                                   })
&lt;/pre&gt;

Using a binding:

&lt;pre&gt;
awesome.buttons({
    button({ }, 3, function () mymainmenu:toggle() end),
    button({ }, 4, awful.tag.viewnext),
    button({ }, 5, awful.tag.viewprev)
})
&lt;/pre&gt;

Note that the first argument of the '''awful.menu.new()''' function is a table allowing the following elements:
* auto_expand: a boolean controlling the auto expand behaviour which is true by default;
* [fg|bg]_[normal|focus], border_[color|width], submenu_icon, height, width: custom theme overriding [[beautiful]], all these elements are optional;
* items: the items table as seen above;

== Menus behaviour ==

* A left click triggers the action associated with the item or toggle the menu opened/closed state if ''menu_toggle'' parameter is set to true.
* A right click destroys the menu and all its childs, meaning that if you want to destroy a sub-menu that opened another sub-menu it will destroy the two sub-menus but not the parent.

== Tips ==

* You can use pango format to display labels, meaning that you can bold, underline or decorate your label the way you want.
* The triggered action associated to an item can be ''nil'', meaning that if you click that item nothing will happen, the menu will not be destroyed, this can be used to create separators, categories or whatever.
* You can theme your menus using [[Beautiful]].
* For Debian users, you can put following scripts under ~/.menu-methods then run update-menus to generate Debian menus
&lt;pre&gt;
#!/usr/bin/install-menu
# this file has to be executable
# put under ~/.menu-methods
# will run by update-menus
# default generate ~/.config/awesome/menu.lua
# you need to require(&quot;menu&quot;) to use menu.debian_menu

compat=&quot;menu-1&quot;

!include menu.h

compat=&quot;menu-2&quot;
outputencoding= &quot;UTF-8&quot;;

function q($s) = &quot;\&quot;&quot; esc($s,&quot;\\\&quot;&quot;) &quot;\&quot;&quot;;
function s($s) = replacewith(replacewith($s,&quot;/&quot;,&quot;_&quot;), &quot; &quot;, &quot;_&quot;);
function findicon($filename)= 
       ifelsefile($filename, q($filename),
        iffile(&quot;/usr/share/pixmaps/&quot; $filename,
                   q(&quot;/usr/share/pixmaps/&quot; $filename)));
function x11menu()= &quot;\t{&quot;q(title())&quot;,&quot;q($command) ifnempty($icon, &quot;,&quot;findicon($icon))&quot;},\n&quot;;
function textmenu()= &quot;\t{&quot;q(title())&quot;, \&quot;x-terminal-emulator -e \&quot;..&quot;q($command) ifnempty($icon, &quot;,&quot;findicon($icon))&quot;},\n&quot;;

supported;
    x11= x11menu();
    text= textmenu();
endsupported;

startmenu=      s($section)&quot; = {\n&quot;;
endmenu=        &quot;}\n&quot;;
submenutitle=   &quot;\t{&quot;q(title())&quot;,&quot;s($section)&quot;},\n&quot;;
genmenu=        &quot;menu.lua&quot;;
rootsection=    &quot;debian_menu&quot;;
userprefix=     &quot;/.config/awesome/&quot;;
preoutput=      &quot;-- automatically generated file. Do not edit (see /usr/share/doc/menu/html)\n\nmodule(\&quot;menu\&quot;)\n\n&quot;;
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>49fczvth7u34z7zuycahofq0nrbx2zm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awful.menu/ru</title>
    <ns>0</ns>
    <id>1089</id>
    <revision>
      <id>6668</id>
      <timestamp>2014-05-26T09:54:48Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода awful.menu (translating page)</comment>
      <text xml:space="preserve" bytes="6827">{{Languages|Awful.menu}}

''awful.menu'' является частью модуля awful которая обеспечивает создание меню с возможностью создания под-меню

Данный модуль был разработан для  awesome 3

== Установка awful.menu ==

Модуль автоматически загружается при старте, в случае если у вас есть в верхней части вашего файла конфигурации rc.lua следующий код:
&lt;pre&gt;require(&quot;awful&quot;)&lt;/pre&gt;

В общем, вы создаете ваше меню в виде таблицы содержащей другую таблицу для каждого элемента вашего меню. Первым элементом таблицы является метка, затем триггер, который может быть командой или другой таблицей меню, уставновка таблицы меню как item позволяет создать под-меню. Третий элемент является необязательным и указывает путь до иконки. 

Далее приведен пример стандрартного меню из ''awesome rc.lua'':

&lt;pre&gt;
myawesomemenu = {
   { &quot;manual&quot;, terminal .. &quot; -e man awesome&quot; },
   { &quot;edit config&quot;, terminal .. &quot; -e nano ~/.config/awesome/rc.lua&quot; },
   { &quot;restart&quot;, awesome.restart },
   { &quot;quit&quot;, awesome.quit }
}

mymainmenu = awful.menu.new({ items = { { &quot;awesome&quot;, myawesomemenu, beautiful.awesome_icon },
                                        { &quot;open terminal&quot;, terminal }
                                      }
                            })
&lt;/pre&gt;

Поскольку начиная с awesome 3.4.x ярлыки поддерживают конфигурацию ключей доступа: вы можете предварять символом '&amp;' желаемую клавишу


&lt;pre&gt;
{ &quot;&amp;firefox&quot;, &quot;firefox&quot;, awful.util.getdir(&quot;config&quot;) .. &quot;/firefox.png&quot; },
&lt;/pre&gt;

Это позволит вам нажав Mod4 + W (сочетание клавиш по умолчанию) для отображения меню, а замем нажав клавишу &quot;f&quot; запустить firefox.


Сначала мы создаем таблицу ''myawesomemenu'', которую будем использовать как подменю, затем создаем ''mymainmenu'' содержащую два пункта, один из которых наша таблица ''myawesomemenu'', которая будет работать как подменю.

Теперь если мы ходить показать наше меню, у нас есть два способа.

Исользование виджета запуска(launcher widget):

&lt;pre&gt;
mylauncher = awful.widget.launcher({ image = image(beautiful.awesome_icon),
                                     menu = mymainmenu
                                   })
&lt;/pre&gt;

Использование клавиатурного сочетания:

&lt;pre&gt;
awesome.buttons({
    button({ }, 3, function () mymainmenu:toggle() end),
    button({ }, 4, awful.tag.viewnext),
    button({ }, 5, awful.tag.viewprev)
})
&lt;/pre&gt;

Обратите внимание, что первый аргумент функции '''awful.menu.new()''' это таблица которая может принимать следующие значения:
* auto_expand: a boolean controlling the auto expand behaviour which is true by default;
* [fg|bg]_[normal|focus], border_[color|width], submenu_icon, height, width: пользовательская тема является основной [[beautiful/ru|beautiful]], все эти элементы являются необязательными;
* items: собственно таблица элементов, которая описана выше;

== Поведение меню ==

* Нажатие левой кнопки запускает действие связанное с элементом или состояние меню открыть/закрыть, если параметр ''menu_toggle'' установлен как true.
* Нажатие правой клавиши закрывает меню и все его подменю, это значит, что если вы закрываете подменю которое открывает другое подменю, вы закроете два подменю, но не родительское меню.

== Tips ==

* Вы можете использовать формат Pango для отображения ярлыков, это значит что вы можете сделать жирный, подчеркнутый или украшенный как вы хотите ярлык.
* The triggered action associated to an item can be ''nil'', meaning that if you click that item nothing will happen, the menu will not be destroyed, this can be used to create separators, categories or whatever.
* Вы можете украсить ваше меню используя темы [[Beautiful/ru|Beautiful]].
* Для пользователей Debian, вы можете поместить следующий скрипт в файл ~/.menu-methods, затем запустите update-menus для создания меню Debian
&lt;pre&gt;
#!/usr/bin/install-menu
# дайте файлу права на исполнение
# разместите после ~/.menu-methods
# запустите update-menus
# по умолчанию будет создан ~/.config/awesome/menu.lua
# вам необходимо добавать require(&quot;menu&quot;) для использования menu.debian_menu

compat=&quot;menu-1&quot;

!include menu.h

compat=&quot;menu-2&quot;
outputencoding= &quot;UTF-8&quot;;

function q($s) = &quot;\&quot;&quot; esc($s,&quot;\\\&quot;&quot;) &quot;\&quot;&quot;;
function s($s) = replacewith(replacewith($s,&quot;/&quot;,&quot;_&quot;), &quot; &quot;, &quot;_&quot;);
function findicon($filename)= 
       ifelsefile($filename, q($filename),
        iffile(&quot;/usr/share/pixmaps/&quot; $filename,
                   q(&quot;/usr/share/pixmaps/&quot; $filename)));
function x11menu()= &quot;\t{&quot;q(title())&quot;,&quot;q($command) ifnempty($icon, &quot;,&quot;findicon($icon))&quot;},\n&quot;;
function textmenu()= &quot;\t{&quot;q(title())&quot;, \&quot;x-terminal-emulator -e \&quot;..&quot;q($command) ifnempty($icon, &quot;,&quot;findicon($icon))&quot;},\n&quot;;

supported;
    x11= x11menu();
    text= textmenu();
endsupported;

startmenu=      s($section)&quot; = {\n&quot;;
endmenu=        &quot;}\n&quot;;
submenutitle=   &quot;\t{&quot;q(title())&quot;,&quot;s($section)&quot;},\n&quot;;
genmenu=        &quot;menu.lua&quot;;
rootsection=    &quot;debian_menu&quot;;
userprefix=     &quot;/.config/awesome/&quot;;
preoutput=      &quot;-- automatically generated file. Do not edit (see /usr/share/doc/menu/html)\n\nmodule(\&quot;menu\&quot;)\n\n&quot;;
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>81vmq3nvl78e8vzu34tusave7a38cbk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awsetbg 3.1</title>
    <ns>0</ns>
    <id>274</id>
    <revision>
      <id>3520</id>
      <parentid>2968</parentid>
      <timestamp>2009-08-27T17:55:56Z</timestamp>
      <contributor>
        <username>R7</username>
        <id>349</id>
      </contributor>
      <minor/>
      <comment>grammar</comment>
      <text xml:space="preserve" bytes="2525">{{Languages}}

&lt;H1&gt;AWSETBG&lt;/H1&gt;
Section:  (1)

&lt;H2&gt;NAME&lt;/H2&gt;

awsetbg - awesome wrapper tool to set background

&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

&lt;B&gt;awsetbg&lt;/B&gt; [-fctaFCTA wallpaper] [-uU wallpapersetter] [-m #] [-bB fbsetrootoptions ...] [-rR path] [-l]

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

&lt;B&gt;awsetbg&lt;/B&gt; is a wrapper that tries to find a suitable background setting application and then tries to set the wallpaper using that application. You do not have to configure &lt;B&gt;awsetbg&lt;/B&gt;, since it just uses the first application it finds.

Furthermore, it remembers the last wallpaper set, so you do not have to edit anything to change the wallpaper.

&lt;H2&gt;OPTIONS&lt;/H2&gt;

&lt;B&gt;-f&lt;/B&gt; file
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set fullscreen wallpaper.
&lt;/DL&gt;

&lt;B&gt;-c&lt;/B&gt; file
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set centered wallpaper.
&lt;/DL&gt;

&lt;B&gt;-t&lt;/B&gt; file
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set centered wallpaper.
&lt;/DL&gt;

&lt;B&gt;-a&lt;/B&gt; file
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set maximized wallpaper, preserving aspect. If the application chosen do not support this option, fullscreen is used as fallback.
&lt;/DL&gt;

&lt;B&gt;-u&lt;/B&gt; wallpapersetter
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Use the specified wallpaper setter tool.
&lt;/DL&gt;

&lt;B&gt;-r&lt;/B&gt; directory
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set a random wallpaper from this directory.
&lt;/DL&gt;

&lt;B&gt;-F, -C, -T, -A, -U, -R&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Same as the lowercaser option, but without remembering.
&lt;/DL&gt;

&lt;B&gt;-l&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Set the previous wallpaper. If the random feature was the last used, it will set another random wallpaper from this same directory.
&lt;/DL&gt;

&lt;B&gt;-i&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Display useful information about the best application to set the wallpaper found.
&lt;/DL&gt;

&lt;B&gt;-p&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Display useful tips.
&lt;/DL&gt;

&lt;B&gt;-h&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Display help message.
&lt;/DL&gt;

&lt;H2&gt;FILES&lt;/H2&gt;

$XDG_CACHE_HOME/awesome/lastwallpaper or $HOME/.cache/awesome/lastwallpaper files contains the last wallpaper set to use with the -l option.

&lt;H2&gt;ENVIRONMENT VARIABLES&lt;/H2&gt;

&lt;B&gt;wpsetters&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Wallpaper setters to use.
&lt;/DL&gt;

&lt;B&gt;DISPLAY&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Display you want to set the wallpaper on.
&lt;/DL&gt;

&lt;H2&gt;SEE ALSO&lt;/H2&gt;

awesome(1)

&lt;H2&gt;AUTHORS&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt; and others. awsetbg is derived from fbsetbg which was written by Han Boetes &amp;lt;han@fluxbox.org[2]&amp;gt;.

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;

&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
mailto:julien@danjou.info
&lt;/DL&gt;

&lt;DT&gt; 2. han@fluxbox.org
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
mailto:han@fluxbox.org
&lt;/DL&gt;

[[Category:Awesome3]]</text>
      <sha1>5yy4xovouf20l2gbjl35xythcraeexe</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awsetbg 3.1/fr</title>
    <ns>0</ns>
    <id>275</id>
    <revision>
      <id>2971</id>
      <parentid>2969</parentid>
      <timestamp>2009-06-25T15:20:59Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="3463">{{Languages|Awsetbg 3.1}}

&lt;H1&gt;AWSETBG&lt;/H1&gt;
Section:  (1)

&lt;H2&gt;NOM&lt;/H2&gt;

awsetbg - outil d'awesome pour définir l'arrière-plan

&lt;H2&gt;SYNOPSIS&lt;/H2&gt;

&lt;B&gt;awsetbg&lt;/B&gt; [-fctaFCTA wallpaper] [-uU wallpapersetter] [-m #] [-bB fbsetrootoptions ...] [-rR path] [-l]

&lt;H2&gt;DESCRIPTION&lt;/H2&gt;

&lt;B&gt;awsetbg&lt;/B&gt; est un outil qui essaie de trouver une application adéquate de paramétrage d'arrière-plan, puis essaie de mettre en place le papier peint utilisant cette application. Vous n'avez pas à  configurer &lt;B&gt;awsetbg&lt;/B&gt;, puisqu'il utilise seulement la première application qu'il trouve.

De plus, il mémorise le dernier papier peint mis en place, donc vous n'avez pas à  éditer quoi que ce soit pour en changer.

&lt;H2&gt;OPTIONS&lt;/H2&gt;

&lt;B&gt;-f&lt;/B&gt; fichier
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Met en place le papier peint en plein écran.
&lt;/DL&gt;

&lt;B&gt;-c&lt;/B&gt; fichier
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Centre le papier peint.
&lt;/DL&gt;

&lt;B&gt;-t&lt;/B&gt; fichier
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Met en place le papier peint en mosaïque.
&lt;/DL&gt;

&lt;B&gt;-a&lt;/B&gt; fichier
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Maximise le papier peint, tout en préservant son aspect. Si l'application choisie ne supporte pas cette option, le plein écran est utilisé comme solution de rechange.
&lt;/DL&gt;

&lt;B&gt;-u&lt;/B&gt; wallpapersetter
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Utilise l'outil de mise en place de papier peint spécifié.
&lt;/DL&gt;

&lt;B&gt;-r&lt;/B&gt; répertoire
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Met en place un papier peint choisi aléatoirement dans ce répertoire.
&lt;/DL&gt;

&lt;B&gt;-F, -C, -T, -A, -U, -R&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Identique à l'option en minuscule, mais sans mémorisation.
&lt;/DL&gt;

&lt;B&gt;-l&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Met en place le papier peint précédent. Si l'option -r a été utilisée précédemment, un autre papier peint du même répertoire sera choisi aléatoirement.
&lt;/DL&gt;

&lt;B&gt;-i&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche des informations utiles sur la meilleure application pour mettre en place le papier peint voulu.
&lt;/DL&gt;

&lt;B&gt;-p&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche des infobulles utiles.
&lt;/DL&gt;

&lt;B&gt;-h&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Affiche un message d'aide.
&lt;/DL&gt;

&lt;H2&gt;FICHIERS&lt;/H2&gt;

Le fichier $XDG_CACHE_HOME/awesome/lastwallpaper ou $HOME/.cache/awesome/lastwallpaper contient le dernier papier peint mis en place, à  utiliser avec l'option -l.

&lt;H2&gt;VARIABLES D'ENVIRONNEMENT&lt;/H2&gt;

&lt;B&gt;wpsetters&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Outils de mise en place de papier peint à  utiliser.
&lt;/DL&gt;

&lt;B&gt;DISPLAY&lt;/B&gt;
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
Écran choisi pour mettre en place le papier peint.
&lt;/DL&gt;

&lt;H2&gt;VOIR AUSSI&lt;/H2&gt;

awesome(1)

&lt;H2&gt;AUTEURS&lt;/H2&gt;

Julien Danjou &amp;lt;julien@danjou.info[1]&amp;gt; et d'autres personnes. awsetbg est issu de fbsetbg qui a été écrit par Han Boetes &amp;lt;han@fluxbox.org[2]&amp;gt;.

&lt;H2&gt;WWW&lt;/H2&gt;

&lt;I&gt;http://awesome.naquadah.org&lt;/I&gt;

&lt;H2&gt;NOTES&lt;/H2&gt;

&lt;DL COMPACT&gt;
&lt;DT&gt; 1. julien@danjou.info
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
courriel : mailto:julien@danjou.info
&lt;/DL&gt;

&lt;DT&gt; 2.han@fluxbox.org
&lt;DL COMPACT&gt;&lt;DT&gt;&lt;DD&gt;
courriel : mailto:han@fluxbox.org
&lt;/DL&gt;

&lt;H2&gt;TRADUCTION&lt;/H2&gt;

Ce document est une traduction, réalisée par Jean-Luc Duflot &amp;lt;jl&amp;nbsp;POING&amp;nbsp;duflot&amp;nbsp;CHEZ&amp;nbsp;laposte&amp;nbsp;POING&amp;nbsp;net&amp;gt; le 25&amp;nbsp;janvier&amp;nbsp;2009.

L'équipe de traduction a fait le maximum pour réaliser une adaptation française de qualité.
La version anglaise la plus à  jour de ce document est toujours consultable via la commande&amp;nbsp;: LANGUAGE=en man awsetbg. N'hésitez pas à  signaler à  l'auteur ou au traducteur, selon le cas, toute erreur dans cette page de manuel.

[[Category:Awesome3]]</text>
      <sha1>fqgkzwr4kvazfhdn8tvkbuzwj36j906</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awsetbg 3.1 (en)</title>
    <ns>0</ns>
    <id>388</id>
    <redirect title="Awsetbg 3.1" />
    <revision>
      <id>2967</id>
      <timestamp>2009-06-25T15:20:24Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awsetbg 3.1 (en)]] to [[Awsetbg 3.1]]</comment>
      <text xml:space="preserve" bytes="25">#REDIRECT [[Awsetbg 3.1]]</text>
      <sha1>ezmx1opdgmhds9bdw80ce3eng27ur4z</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Awsetbg 3.1 (fr)</title>
    <ns>0</ns>
    <id>389</id>
    <redirect title="Awsetbg 3.1/fr" />
    <revision>
      <id>2970</id>
      <timestamp>2009-06-25T15:20:47Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Awsetbg 3.1 (fr)]] to [[Awsetbg 3.1/fr]]</comment>
      <text xml:space="preserve" bytes="28">#REDIRECT [[Awsetbg 3.1/fr]]</text>
      <sha1>n0afbmhxyylo9usaf8ewlo9uj2bk12x</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Banshee Widgets</title>
    <ns>0</ns>
    <id>776</id>
    <revision>
      <id>5743</id>
      <parentid>5300</parentid>
      <timestamp>2013-01-07T12:40:19Z</timestamp>
      <contributor>
        <username>Zhuravlik</username>
        <id>372</id>
      </contributor>
      <text xml:space="preserve" bytes="4677">== banshee.py ==

[https://github.com/nickbp/misc-utils/blob/master/banshee.py banshee.py] is a script which uses DBus to talk to Banshee. The script is capable of displaying Banshee's current track and controlling its playback.

The status format defaults to ''artist - trackname'', but can easily be customized and extended through commandline arguments. See the python code for details.

=== DBus Conduit Method ===

This involves running banshee.py in the background, where it will act as a conduit between Banshee's DBus and Awesome's DBus. However, no polling is involved, so cycles won't be wasted when Banshee is inactive. Additionally, this method will ''immediately'' update a widget, rather than at the next refresh.

Run banshee.py separately with arguments like this:

 $ banshee.py listen_dbus &quot;musicwidget.text=\&quot;%(artist)s - %(name)s\&quot;&quot; &quot;musicwidget.text=\&quot;%s\&quot;&quot;

Then put something like this in your rc.lua:

 -- Status widget (matches name specified in banshee.py args)
 musicwidget = widget({type = &quot;textbox&quot; })
 
 function banshee(cmd)
   return awful.util.pread(&quot;python &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/banshee.py &quot; .. cmd)
 end
 -- Initialize widget to banshee's current state
 musicwidget.text = banshee(&quot;status&quot;)
 
 -- Keyboard shortcuts
 globalkeys = awful.util.table.join(
   ...
   awful.key({ }, &quot;XF86AudioPlay&quot;, function () banshee(&quot;play&quot;) end),
   awful.key({ }, &quot;XF86AudioNext&quot;, function () banshee(&quot;next&quot;) end),
   awful.key({ }, &quot;XF86AudioPrev&quot;, function () banshee(&quot;prev&quot;) end),
   awful.key({ }, &quot;XF86AudioStop&quot;, function () banshee(&quot;stop&quot;) end),
   ...
 )

banshee.py will sleep until notified of a state change by Banshee, at which point it'll retrieve the current track information and send the command ''musicwidget.text=&quot;artist - trackname&quot;'' to Awesome. Awesome will then update the music widget for us.

=== Polling Method ===

Put something like this in your rc.lua to have a widget which refreshes periodically. You'll be wasting cycles on the refreshes and there will be a delay between Banshee and the widget, but you won't need to run banshee.py in the background.

 -- Status widget
 musicwidget = widget({type = &quot;textbox&quot; })
 function banshee(cmd)
   -- Run the command and update the widget with the new state
   musicwidget.text = awful.util.pread(&quot;python &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/banshee.py &quot; .. cmd)
 end
 -- Initialize widget to banshee's current state
 banshee(&quot;status&quot;)
 -- 3.4:
 bansheetimer = timer({ timeout = 5 })
 bansheetimer:add_signal(&quot;timeout&quot;, function() banshee(&quot;status&quot;) end)
 bansheetimer:start()
 -- 3.3:
 -- awful.hooks.timer.register(5, function() banshee(&quot;status&quot;) end)
 
 -- Keyboard shortcuts (same as in DBus example)
 globalkeys = awful.util.table.join(
   ...
   awful.key({ }, &quot;XF86AudioPlay&quot;, function () banshee(&quot;play&quot;) end),
   awful.key({ }, &quot;XF86AudioNext&quot;, function () banshee(&quot;next&quot;) end),
   awful.key({ }, &quot;XF86AudioPrev&quot;, function () banshee(&quot;prev&quot;) end),
   awful.key({ }, &quot;XF86AudioStop&quot;, function () banshee(&quot;stop&quot;) end),
   ...
 )

This version will automatically run the script every 5 seconds, and will also update the status whenever one of the keyboard shortcuts is executed.

== Using DBus Directly ==

Due to the fact that awesome has built-in dbus support, timer-based polling may be unnecessary if you do not like the idea.

However the dbus module in awesome often doesn't work (according to Elv13 in IRC), so don't be surprised if the following proves fruitless.

=== Awesome 3.4 ===

Use capi.dbus.add_signal? This didn't work for me:

 local capi = { dbus = dbus }
 capi.dbus.add_match(&quot;session&quot;, &quot;interface='org.bansheeproject.Banshee.PlayerEngine',member='EventChanged'&quot;)
 capi.dbus.add_signal(&quot;org.bansheeproject.PlayerEngine&quot;, function() print(&quot;:)\n&quot;) end)

=== Awesome 3.5 and greater ===

Just use capi.dbus.connect_signal and listen for &quot;startofstream&quot; and &quot;endofstream&quot; EventChanged signals on org.bansheeproject.PlayerEngine.

=== With Bashets (awesome 3.5 and greater only) ===

You can also use [[Bashets]] to register for a dbus signal with a callback. But note that Bashets uses the same &quot;capi.dbus&quot; module as the above, so if the above didn't work, this probably won't either:

 bashets.register(&quot;org.bansheeproject.Banshee.PlayerEngine&quot;, {dbus = true, busname = &quot;session&quot;, callback = function(data)
     --data is array of variables, here you need sixth variable; to know why sixth, plz read documentation ;)
     if data[6] == &quot;startofstream&quot; then
         datew:set_markup(awful.util.pread(&quot;python &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/banshee.py &quot; .. cmd))
     end
 end})

This would cause the script to only be called on track change.</text>
      <sha1>co3vvb09xh05urnibg2s1nzenmg8z39</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bashets</title>
    <ns>0</ns>
    <id>491</id>
    <revision>
      <id>6444</id>
      <parentid>5722</parentid>
      <timestamp>2014-05-04T08:00:07Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>Adding tags Languages, for translate other languages</comment>
      <text xml:space="preserve" bytes="4785">{{Languages|Bashets}}

== Intro ==

Bashets is a user widget library (but really not only for widget-related things) powered by shell scripts (but more data sources to come).

Bashets is glue code which empowers you to fetch data somewhere, and put it somewhere. It is a distinct approach from [[Obvious]] or [[Vicious]], which try to implement and package predefined widgets themselves.

Supported sources are:
* Launch shell script for timed execution.
* Launch shell script to provide data itself.
* Listen to DBus signals and fetch data from them.
* Fetch data from a user-provided function.

Supported destinations are:
* A widget's content. The widget could be a textbox, imagebox, progressbar, or graph.
* A callback function. You are able to catch data updates in your own way.

Note: Bashets is compatible with awesome 3.5 and greater.

== Why you should use it ==

Unix-like systems have over 9000 terminal tools for data acquisition and processing. So, the simplest way to get data from somewhere is the shellscript.

If you choose a widget system, you really choose a mean of representing the processed data. For example, your CPU usage could be represented as: graph, progressbar, pie-diagram or plain text.

So, what should you do? Yes, you should ''write a shellscript to process data, and have a widget to represent the value''.

And '''bashets is a small piece of glue code to simplify the task and abstract you from working with raw timers, awesome-client or dbus apis of awesome WM'''.

You should only write one bashets.register() call in your rc.lua per widget - and your counters and graphs should be alive.

== What can be done with it ==

[[File:Bashets_example.png|thumb|A real-world example]]

In the example to the right, you can see my current desktop with the following widgets:

* Keyboard layout (textbox)
* Battery charge (imagebox)
* Music player widget with coverart display and progressbar (textbox + imagebox + progressbar combination).

Irony: Yes, Wicked widgets are the grandfather of all current awesome widget libraries and there should be a symphony in its honour.

Of course, I am able to held all routinous tasks myself: to create the timers for scheduled mpc/acpi calls, to create a shellscript to feed keyboard widget with data.

But instead, it costs me not more than 5 lines of lua code with the help of bashets.

Here's [http://screenoteka.ru/files/screenshots/2010-11-05-132406_1280x800_scrot.png my old desktop], where I had 7 progressbars showing info from different sources. Without Bashets this could've been a nightmare or a birth of several separate widget modules, but with Bashets it took 7 lines of lua code.

== How to use it ==

# Get [http://gitorious.org/bashets/bashets/blobs/raw/master/bashets.lua bashets.lua] and copy it to /usr/share/awesome/lib
# Add require(&quot;bashets&quot;) to the top of your rc.lua
# Create a widget:
#* Textbox:&lt;br/&gt;''xkbw = wibox.widget.textbox()''
#* Imagebox:&lt;br/&gt;''batw = wibox.widget.imagebox()''
#* Progress Bar:&lt;br/&gt;''coverpg = awful.widget.progressbar()''
#* Graph:&lt;br/&gt;''cpugraph = awful.widget.graph()''
# Register a data source to update the widget
#* A timed-execution shell script:&lt;br/&gt;''bashets.register(&quot;batpic.sh&quot;, {widget = batw, separator = &quot; &quot;, update_time=1})''
#* External shell script:&lt;br/&gt;''bashets.register(&quot;xkb.sh&quot;, {widget = xkbw, update_time = 1, external = true, format = ' &lt;span face=&quot;Verdana&quot; weight=&quot;bold&quot; rise=&quot;45&quot;&gt;$1&lt;/span&gt;'})''
#* DBus signal:&lt;br/&gt;''bashets.register(&quot;org.freedesktop.Hal.Manager&quot;, {dbus = true, busname = &quot;system&quot;, widget = datew, format=&quot;$3&quot;})''
# Edit format string and separator such as you need (by default, &quot;$1&quot; and space symbol are used).
# '''After''' all widget registrations, add the line: ''bashets.start()''
# Add the line ''bashets.stop()'' adjacent to ''awesome.quit()'' if you use external shell scripts. Otherwise your terminal will be flooded with DBus errors.
# Enjoy!

A note about &quot;timed-execution&quot; vs &quot;external&quot; shell scripts:
* Timed-execution scripts are launched every update_time period
* External shell scripts launch with awesome and work in the background, they provide widgets with data through awesome-client
From the user's viewpoint, there should be no difference between the two. They should print several lines to stdout, nothing more.

'''To learn more, [https://gitorious.org/bashets/pages/Brief_Introduction read the docs]'''.

PS: The [[Bashets_original_info|previous version of this page]] covers more of the design and ideology behind Bashets.

== Get Bashets ==

Bashets is hosted at [https://gitorious.org/bashets Gitorious], alongside [https://gitorious.org/bashets/pages/Brief_Introduction thorough documentation]. There's also an [https://aur.archlinux.org/packages.php?ID=30612 Arch Linux package] in AUR.</text>
      <sha1>spx805u5eqj41gvuh0ufzrb3v2znc0a</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bashets/ru</title>
    <ns>0</ns>
    <id>1030</id>
    <revision>
      <id>6417</id>
      <parentid>6416</parentid>
      <timestamp>2014-05-02T12:30:38Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Как использовать библиотеку */</comment>
      <text xml:space="preserve" bytes="8349">{{Languages|Bashets}}

== Введение ==

Bashets это пользовательская библиотека виджетов (but really not only for widget-related things) работающая со криптами оболочки (в дальнейшем возможности увеличатся).

Bashets это объединяющий код, который позволяет вам где то получить данные, а затем передать их куда либо (например в другой виджет). Это отдельный подход для [[Obvious]] или [[Vicious]], который пытаются упаковать и объеденять все их виджеты.

Поддерживаются источники:
* Запуск скрипта по времени (timed-execution).
* Запуск скрипта для получения данных (external).
* Прослушивание сигналов DBus и получение данных из него.
* Получение данных из предопределенных пользователем функций.

Поддерживаются перенаправления в:
* Различные виджеты. Виджеты могуть быть textbox, imagebox, progressbar, или graph.
* Возвращающие значения функции. Вы можете принять возвращаемые значения в ваших собственных функциях.

&lt;b&gt;Примечание: Bashets работает с awesome 3.5 и новее.&lt;/b&gt;

== Почему вы должны использовать эту библиотеку ==

Unix-подобные системы насчитывают более 9000 консольных утилит для сбора и обработки данных. Поэтому простейший способ получения этих данных где либо - это использование shell скриптов.

Когда вы выбираете какую либо систему виджетов, на самом деле вы выбираете способ обработки и представления данных. Например, данные по использованию процессора могут быть представлены в виде: графика, прогрессбара, диаграмы или простого текста.

Итак, что вам для этого нужно? Вам нужно ''написать shell-скрипт для получения данных, и иметь виджет который будет их отображать''.

'''Bashets это объединяющий код, облегчающий взаимодействие и абстагирующий вашу работу с сырыми timers, awesome-client или DBUS APIs в awesome'''.

Вам необходимо только единожды добавить вызов 'bashets.register()' в rc.lua для виджета - и ваши счетчики и графики заработают.

== Что можно сделать с его помощью ==

[[File:Bashets_example.png|thumb|Реальный пример]]

В примере справа, вы можете увидеть мой рабочий стол во следующими виджетами:

* Раскладка клавиатуры (textbox)
* Заряд аккумулятора (imagebox)
* Виджет плеера с обложкой и прогресбаром (textbox + imagebox + progressbar combination).


Ирония заключается в том, что виджеты и библиотеки Wicked являются основоположниками для всех существующих виджетов и библиотек awesome и это нужно отметить, хотя на сегодняшний день эта библиотека и считается устаревшей.

Конечно, вы можете сделать все рутинные задачи самостоятельно: создать таймер для вызова mpc/acpi , или написать shell-скрипт для передачи данных клавиатурному виджету.
Но вместо этого, вам нужно написать около 5 строк кода на lua, и bashets облегчит вашу работу.

Здесь мой старый [http://screenoteka.ru/files/screenshots/2010-11-05-132406_1280x800_scrot.png рабочий стол], где у меня стоит 7 progressbar получающих данные из разных источников. Без использования Bashets это было кошмаром, необходимо было использовать различные модули для виджетов, в то время как сейчас при использовании Bashets достаточно добавить всего 7 строк кода на lua.

== Как использовать библиотеку ==

# Скачайте [http://gitorious.org/bashets/bashets/blobs/raw/master/bashets.lua bashets.lua] и скопируйте ее в /usr/share/awesome/lib
# Добавьте ''require(&quot;bashets&quot;)'' в начало файла rc.lua
# Создайте виджет:
#* Textbox:&lt;br/&gt;''xkbw = wibox.widget.textbox()''
#* Imagebox:&lt;br/&gt;''batw = wibox.widget.imagebox()''
#* Progress Bar:&lt;br/&gt;''coverpg = awful.widget.progressbar()''
#* Graph:&lt;br/&gt;''cpugraph = awful.widget.graph()''
# Зарегистрируйте источник данных для обновления виджета
#* Периодически запускаемый(timed-execution) shell-скрипт:&lt;br/&gt;''bashets.register(&quot;batpic.sh&quot;, {widget = batw, separator = &quot; &quot;, update_time=1})''
#* Сторонний (extetnal) shell-скрипт:&lt;br/&gt;''bashets.register(&quot;xkb.sh&quot;, {widget = xkbw, update_time = 1, external = true, format = ' &lt;span face=&quot;Verdana&quot; weight=&quot;bold&quot; rise=&quot;45&quot;&gt;$1&lt;/span&gt;'})''
#* Сигналы DBus:&lt;br/&gt;''bashets.register(&quot;org.freedesktop.Hal.Manager&quot;, {dbus = true, busname = &quot;system&quot;, widget = datew, format=&quot;$3&quot;})''
# Отредактируйте форматирование строки и разделите ее так как вам нужно (по умолчанию испльзуются &quot;$1&quot; и символ пробела).
# '''После''' того как все виджеты зарегистрированны , добавьте строку: ''bashets.start()''
# Добавьте строку ''bashets.stop()'' непосредственно перед ''awesome.quit()'' если вы используете внешние(extarnal) скрипты. В противном случае, ваш терминал получит огромное колличество ошибок DBus.
# Наслаждайтесь!

Помните различие между &quot;timed-execution&quot; и &quot;external&quot; скрипты:
* Timed-execution скрипт запускается каждый раз через значение установленное в update_time
* External скрипты запускаются с awesome и работают в фоне, они передают данные виджетам через awesome-client
С пользовательской точки зрения, никакой разницы в использовании между ними нет. Они печатают разные строки в stdout, и это единственное различие.

'''Чтобы узнать больше [https://gitorious.org/bashets/pages/Brief_Introduction прочтите документацию]'''.

PS: [[Bashets_original_info|Предыдущая версия этой сраницы]] описывает больше средств разработки и идеологии Bashets.

== Как получить Bashets ==

Bashets располагается на [https://gitorious.org/bashets Gitorious], там же [https://gitorious.org/bashets/pages/Brief_Introduction полная докуметация]. Еще вы можете найти на [https://aur.archlinux.org/packages.php?ID=30612 Arch Linux package] в AUR.</text>
      <sha1>0hhn0mau6nm4m2wnpwl1fz0upotmujr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bashets original info</title>
    <ns>0</ns>
    <id>775</id>
    <revision>
      <id>5229</id>
      <timestamp>2012-01-08T10:58:28Z</timestamp>
      <contributor>
        <username>Zhuravlik</username>
        <id>372</id>
      </contributor>
      <comment>Created page with &quot;Bashets is a distinct approach to Awesome widgets. This library allows you to use your existing shellscripts as a content providers for widgets. Starting from version 0.4 bashets...&quot;</comment>
      <text xml:space="preserve" bytes="4079">Bashets is a distinct approach to Awesome widgets. This library allows you to use your existing shellscripts as a content providers for widgets.
Starting from version 0.4 bashets is not necessarily used as a widget updater. With the help of callbacks, you are able to use bashets for tracking changes in script output.

== Why Bashets ==

We have a great bunch of shellscripts on the Web or written by ourselves for system monitoring purposes. Many of them are written for tools such as Conky to be content providers. So,

* Why it's not the same for Awesome widgets? 
* Why do we need to write more or less complicated Lua scripts to provide system data for widgets?

Yes, it's reasonable in the case of interactive widgets with complex behaviour. But for simple widgets 'tis not true.

* That's why in Bashets you only need to provide a script filename and formatting options. 

It's much more powerful than to rely on developer's aims and to wait until needed widget is implemented as a part of Vicious, Obvious, etc.

From version 0.3.2 non-text widgets are also supported. That means that you are able to draw CPU/memory/anything-else usage graphs, have live progressbar (for example of disk usage) or even organize a slideshow utilizing simple shellscript that outputs random image paths from some directory.

From version 0.4 user-defined callbacks are supported. That means that you are able to notify yourself about low battery, or to display some info on song change in mpd, or run your mail agent if you have new email, and it is implemented in a few lines of Bash/Perl/Python/etc. script and one trivial Lua callback.

From version 0.5 there is a limited support of external widget updates through dbus.

From version 0.6 there is an initial support for dbus signals as a data source.

== How to use Bashets ==

Bashets homepage is now:

* http://gitorious.org/bashets

For the first time you will need to read a [http://gitorious.org/bashets/pages/Brief_Introduction  brief introduction] to see implemented functions.

Also you could be interested in existing configuration file using Bashets. It's here:
* [http://gitorious.org/bashets/awesome-config/trees/master/  http://gitorious.org/bashets/awesome-config/trees/master/].

For a screenshot you can see this one:
* [http://awesome.naquadah.org/w/images/Zhuravlik_screen.png  http://awesome.naquadah.org/w/images/Zhuravlik_screen.png]

Bottom widgets are all implemented with the help of Bashets. If you need example shellscripts, they are here:
* [http://gitorious.org/bashets/bashets/trees/master/userscripts  http://gitorious.org/bashets/bashets/trees/master/userscripts]

== Postscriptum ==

As frequently said, tsar's one if for tsar and God's one is for God. Shellscript is a great tool for system information retrieval. Awesome's config is a great tool for managing Awesome. That's why Bashets passes all retrieval tasks for Bash/Perl/Python/etc., and widget appearance task - for Awesome.

Choose a simple way to concatenate the power of shell with the window manager you use.

== Hint ==

If you are worried by a number of HDD hits when you use bashets, you are able to move the library and temporary files to /dev/shm filesystem.
See 
[http://gitorious.org/bashets/pages/Brief_Introduction#bashets+and+/dev/shm http://gitorious.org/bashets/pages/Brief_Introduction#bashets+and+/dev/shm] 
for details.

== Another way ==

If you are not satisfied with shellscripts running repeatedly on scheduled intervals, you can try the approach to run a bunch of sleeping shellscripts that wake up to provide data at given time intervals. 

Starting from version 0.5, bashets has a limited support for this feature by so-called external mode. Simply set external=true in your registration options, and ''copy runner.sh script to your scripts directory''.

This approach was originally implemented in [pipelets http://www.mail-archive.com/awesome@naquadah.org/msg02578.html] library written by ''ierton''.

You can grab pipelets.lua, pipeman and example shellscripts here:
http://git.ierton.ru/?p=awesomerc.git;a=tree</text>
      <sha1>6cfwf1phzhevlvmo4gixfsfuv08xfge</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Battery Widget for Linux (Pure Lua)</title>
    <ns>0</ns>
    <id>306</id>
    <revision>
      <id>4723</id>
      <parentid>4490</parentid>
      <timestamp>2011-01-31T04:11:44Z</timestamp>
      <contributor>
        <username>Pavankp</username>
        <id>584</id>
      </contributor>
      <minor/>
      <comment>Replaced 'fraxcpu' with  'fraxbat', removed extra ')' . Tested with Awesome 3.4.5</comment>
      <text xml:space="preserve" bytes="4331">by [[User:Frax|Fredrik Ax]] &lt;mailto:frax@axnet.nu&gt;
{|cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; style=&quot;margin: 0em&quot; width=&quot;100%&quot;
|- style=&quot;background: #aea&quot;
| This widget is written entirely in LUA for awesome 3.2.
It depends on Linux ACPI_BATTERY, ACPI_SYSFS_POWER and SYSFS (&quot;/sys/class/power_supply/BAT[0-N]/*&quot;).
|}

It provides a textbox widget that shows your current battery status (or &quot;No Bat&quot; if not available) in percent and an estimation of how long until fully (dis)charged

When clicked, it simply updates it self.

The widget must be defined before it is added to the wibox where it is going to be used. So using the mywibox as defined in the default rc.lua the code should be inserted before the loop (for s = 1, screen.count() do) containing the statement starting with:
 mywibox[s].widgets = {

This is the code to be inserted:
 -- Create fraxbat widget
 fraxbat = widget({ type = &quot;textbox&quot;, name = &quot;fraxbat&quot;, align = &quot;right&quot; })
 fraxbat.text = 'fraxbat';
 
 -- Globals used by fraxbat
 fraxbat_st= nil
 fraxbat_ts= nil
 fraxbat_ch= nil
 fraxbat_now = nil
 fraxbat_est= nil
 
 -- Function for updating fraxbat
 function hook_fraxbat (tbw, bat)
    -- Battery Present?
    local fh= io.open(&quot;/sys/class/power_supply/&quot;..bat..&quot;/present&quot;, &quot;r&quot;)
    if fh == nil then
       tbw.text=&quot;No Bat&quot;
       return(nil)
    end
    local stat= fh:read()
    fh:close()
    if tonumber(stat) &lt; 1 then
       tbw.text=&quot;Bat Not Present&quot;
       return(nil)
    end
 
    -- Status (Charging, Full or Discharging)
    fh= io.open(&quot;/sys/class/power_supply/&quot;..bat..&quot;/status&quot;, &quot;r&quot;)
    if fh == nil then
       tbw.text=&quot;N/S&quot;
       return(nil)
    end
    stat= fh:read()
    fh:close()
    if stat == 'Full' then
       tbw.text=&quot;100%&quot;
       return(nil)
    end
    stat= string.upper(string.sub(stat, 1, 1))
    if stat == 'D' then tag= 'i' else tag= 'b' end
 
    -- Remaining + Estimated (Dis)Charging Time
    local charge= ''
    fh= io.open(&quot;/sys/class/power_supply/&quot;..bat..&quot;/charge_full_design&quot;, &quot;r&quot;)
    if fh ~= nil then
       local full= fh:read()
       fh:close()
       full= tonumber(full)
       if full ~= nil then
         fh= io.open(&quot;/sys/class/power_supply/&quot;..bat..&quot;/charge_now&quot;, &quot;r&quot;)
         if fh ~= nil then
            local now= fh:read()
            local est= ''
            fh:close()
            if fraxbat_st == stat then
               delta= os.difftime(os.time(),fraxbat_ts)
               est= math.abs(fraxbat_ch - now)
               if delta &gt; 30 and est &gt; 0 then
                  est= delta/est
                  if now == fraxbat_now then
                     est= fraxbat_est
                  else
                     fraxbat_est= est
                     fraxbat_now= now
                  end
                  if stat == 'D' then
                     est= now*est
                  else
                     est= (full-now)*est
                  end
                  local h= math.floor(est/3600)
                  est= est - h*3600
                  est= string.format(',%02d:%02d',h,math.floor(est/60))
               else
                  est= ''
               end
            else
               fraxbat_st= stat
               fraxbat_ts= os.time()
               fraxbat_ch= now
               fraxbat_now= nil
               fraxbat_est= nil
            end
            charge=':&lt;'..tag..'&gt;'..tostring(math.ceil((100*now)/full))..'%&lt;/'..tag..'&gt;'..est
         end
       end
    end
    tbw.text= stat..charge
 end

Optional mouse button bindings for fraxbat (replace 'BAT0' with whatever you use)
 fraxbat.buttons(fraxbat,{ button({ }, 1, function () hook_fraxbat(fraxbat,'BAT0') end),
                          button({ }, 2, function () hook_fraxbat(fraxbat,'BAT0') end),
                          button({ }, 3, function () hook_fraxbat(fraxbat,'BAT0') end) })

Don't forget to make the widget visible, e.g. by adding it to the mywibox as defined by the default rc.lua, look for the line starting with
 mywibox[s].widgets = {
and insert &quot;fraxbat,&quot; into the list of widgets.

Finally you need to register a timer that keeps the widget updated.

To update it every 10:th second add the following at the end of your rc.lua (replace 'BAT0' with whatever tou use): 

 awful.hooks.timer.register(10, function () hook_fraxbat(fraxbat,'BAT0') end)

[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>jv1cdezfeob81agyzrsr2q337pkdg2j</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Battery Widget using powersave</title>
    <ns>0</ns>
    <id>172</id>
    <revision>
      <id>1254</id>
      <timestamp>2008-10-16T14:32:37Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1558">I've written a simple Lua function for printing the battery state - [ 44%/77m▾ ] - to a widget.
It uses the (quite common) &quot;powersave&quot; command - which is called directly from Lua via popen(). You do not have to run some other script at session startup, and you do not have to compile additional C bindings. Just install [http://sourceforge.net/projects/powersave/ powersave] and add the following lines to your rc.lua:

&lt;pre&gt;
-- the widget
mybattmon = widget({ type = &quot;textbox&quot;, name = &quot;mybattmon&quot;, align = &quot;right&quot; })
&lt;/pre&gt;


&lt;pre&gt;
-- returns a string with battery info
function battery_status ()
    local battery = 0
    local time = 0
    local state = 0  -- discharging = -1, charging = 1, nothing = 0
    local icon = &quot;&quot;
    local fd = io.popen(&quot;powersave -b&quot;, &quot;r&quot;)
    if not fd then
        do return &quot;no info&quot; end

    end
    local text = fd:read(&quot;*a&quot;)
    io.close(fd)
    if string.match(text, &quot;discharging&quot;) then
        state = -1
        icon =  &quot;▾&quot;
    else
        state = 1
        icon = &quot;▴&quot;
    end

    battery = string.match(text, &quot;Remaining percent: (%d+)&quot;)
    time = string.match(text, &quot;Remaining minutes: (%d+)&quot;)
    -- above string does not always match
    if not time then
        time = string.match(text, &quot;(%d+) minutes until fully charged&quot;)
    end

    return battery .. &quot;%/&quot; .. time .. &quot;m&quot; .. &quot;&lt;b&gt;&quot; .. icon ..&quot;&lt;/b&gt;&quot;
end
&lt;/pre&gt;


&lt;pre&gt;
-- Hook called every second
function hook_timer ()
    --mytextbox.text = &quot; &quot; .. os.date() .. &quot; &quot;
    mybattmon.text = &quot; &quot; .. battery_status() .. &quot; &quot;
end
&lt;/pre&gt;

[[Category:awesome3]]</text>
      <sha1>amieydqszj9g59sw4l2xnmw1uq6xnqu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bavardage's volume wibox</title>
    <ns>0</ns>
    <id>197</id>
    <revision>
      <id>2696</id>
      <parentid>1517</parentid>
      <timestamp>2009-05-23T07:34:10Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Awesome3 again</comment>
      <text xml:space="preserve" bytes="561">==Download the Images==
... or roll your own.

[http://omploader.org/vd3B0 You can get images here]

put the images somewhere (... really?... yes)

==Download Volumous module==
Put this somewhere where awesome looks for files - perhaps in ~/.config/awesome/

Name the file volumous.lua

[http://omploader.org/vd3B1 volumous.lua]

===Adding the Widget===
Add the following to your rc.lua
  require(&quot;volumous&quot;)
  -- image path, x co-ord, y co-ord
  --ensure the path has a trailing slash
  volumous.init(&quot;/path/to/images/&quot;, 30, 30)


Magic!

[[Category:Awesome3]]</text>
      <sha1>9uvohmb78uu3iwwvc4pow4zw5y3yc1m</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Beautiful</title>
    <ns>0</ns>
    <id>129</id>
    <revision>
      <id>5751</id>
      <parentid>4032</parentid>
      <timestamp>2013-01-10T15:44:45Z</timestamp>
      <contributor>
        <username>Masterkorp</username>
        <id>871</id>
      </contributor>
      <comment>/* Setting up Beautiful */ Document new module loading.</comment>
      <text xml:space="preserve" bytes="5515">{{Languages}}

Beautiful is a lua library that allows you to theme awesome using an external file, it becomes very easy to dynamically change your whole awesome colours and wallpaper without changing your ''rc.lua''.

It has been written for people who enjoy changing their colours/wallpaper from time to time without editing their ''rc.lua'', store old colours values, write new ones etc.

Beautiful is designed for awesome 3 only.

== Setting up Beautiful ==
First, you must use:
&lt;pre&gt;beautiful = require('beautiful')&lt;/pre&gt;
to include the library in your configuration file.

Then, you will have to initialize Beautiful with a theme file using:
&lt;pre&gt;beautiful.init(&quot;path_to_theme_file&quot;)&lt;/pre&gt;
A default theme file is provided and is located at ''/usr/local/share/awesome/themes/default/theme.lua'' or ''/usr/share/awesome/themes/default/theme.lua'', depending on your distro.

The theme file is essentially another Lua file which returns a table with key-value pairs (such as 'bg_normal' = '#222222').

[[Awful]] can handle Beautiful avoiding you to pass plenty arguments to awful's functions in your configuration file.

Now you are ready to go. Basically, you can now replace each colour variable definition by (for instance):
&lt;pre&gt;bg_focus = beautiful.bg_focus&lt;/pre&gt;
You can access all keys in the currently registered theme as &lt;pre&gt;beautiful.&amp;lt;key&amp;gt;&lt;/pre&gt;

To start making your own theme, run:
&lt;pre&gt;
cp -r /usr/local/share/awesome/themes ~/.config/awesome/
&lt;/pre&gt;
or
&lt;pre&gt;
cp -r /usr/share/awesome/themes ~/.config/awesome/
&lt;/pre&gt;
Don't forget to change the theme file path in your ''rc.lua'':
&lt;pre&gt;
beautiful.init(awful.util.getdir(&quot;config&quot;) .. &quot;/themes/default/theme.lua&quot;)
&lt;/pre&gt;

== Usage ==
=== Custom variables ===
You should never change default variable names (''font'', ''bg_normal'' and stuff) as those names are used by [[awful]], this would break your configuration file. But you can add as many new variables as you wish.

For instance, if you wish to theme your widgets you can use:
&lt;pre&gt;
fg_off_widget = #ffffff
fg_widget = #000000
fg_end_widget = #ff0000
&lt;/pre&gt;

And in your ''rc.lua'':
&lt;pre&gt;
my_widget:bar_properties_set(&quot;data_name&quot;, {
   border_color = beautiful.border_normal,
   fg_off = beautiful.fg_off_widget,
   fg = beautiful.fg_widget,
   fg_end = beautiful.fg_end_widget
})
&lt;/pre&gt;
In this example we mixed both default theme variables ('''beautiful.border_normal''') and custom variables ('''beautiful.*_widget'''). You can imagine to set your own specific icons and stuff. But be aware that if you start using custom variables in your ''rc.lua'', every theme files you have should define those variables too, otherwise it will break your configuration file.

=== Setting up your wallpaper ===
Beautiful can handle your wallpaper, thus you don't need to set it up in your ''.xinitrc'' or ''.xsession'' files. This allows you to have a specific wallpaper for each theme. If you take a look at the default theme file you'll see a ''wallpaper_cmd'' key, the given command is executed when '''beautiful.init(&quot;path_to_theme_file&quot;)''' is run. You can put here you own command or remove/comment the key if you don't want Beautiful to interfere with your wallpaper business.

For instance, if you use '''fbsetbg''' to set your wallpaper, you can write:
&lt;pre&gt;
wallpaper_cmd = fbsetbg -f .config/awesome/themes/awesome-wallpaper.png
&lt;/pre&gt;

If you have multiple screens and you want a different wallpaper on each one, you can use:
&lt;pre&gt;
wallpaper_cmd = { &quot;fbsetbg -f .config/awesome/themes/awesome-wallpaper1.png&quot;,
                  &quot;fbsetbg -f .config/awesome/themes/awesome-wallpaper2.png&quot; }
&lt;/pre&gt;

=== Tips ===
==== Usage of symlinks ====
It has been said that Beautiful avoids you to edit your ''rc.lua'' file when you want to change your awesome theme, actually that is not true as you must change the path to your theme file in the '''beautiful.init()''' function. But you can make a symbolic link of your current theme and use it to initialize Beautiful, thus you'll only have to point that link to another file and restart awesome (''ctrl+mod4+r'' by default) to change theme.

Now you can write a function to feed a [[awful.menu]] popup to instantly change your theme, we assume that your theme path is set like:
&lt;pre&gt;
beautiful.init(awful.util.getdir(&quot;config&quot;) .. &quot;/current_theme/theme.lua&quot;)
&lt;/pre&gt;

Now write:
&lt;pre&gt;
mythememenu = {}

function theme_load(theme)
   local cfg_path = awful.util.getdir(&quot;config&quot;)

   -- Create a symlink from the given theme to /home/user/.config/awesome/current_theme
   awful.util.spawn(&quot;ln -sfn &quot; .. cfg_path .. &quot;/themes/&quot; .. theme .. &quot; &quot; .. cfg_path .. &quot;/current_theme&quot;)
   awesome.restart()
end

function theme_menu()
   -- List your theme files and feed the menu table
   local cmd = &quot;ls -1 &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/themes/&quot;
   local f = io.popen(cmd)

   for l in f:lines() do
	  local item = { l, function () theme_load(l) end }
	  table.insert(mythememenu, item)
   end

   f:close()
end

-- Generate your table at startup or restart
theme_menu()

-- Modify your awesome menu to add your theme sub-menu
myawesomemenu = {
   { &quot;manual&quot;, terminal .. &quot; -e man awesome&quot; },
   { &quot;edit config&quot;, editor_cmd .. &quot; &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/rc.lua&quot; },
   { &quot;themes&quot;, mythememenu },
   { &quot;restart&quot;, awesome.restart },
   { &quot;quit&quot;, awesome.quit }
}
&lt;/pre&gt;

==== Share your themes ====
Do not hesitate to [[Beautiful themes|share your own themes]] with the awesome awesome's community!

[[Category:Themes]][[Category:awesome3]]</text>
      <sha1>0acz6krdrhs04pypwpwf3ysxoef5uiw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Beautiful/fr</title>
    <ns>0</ns>
    <id>395</id>
    <revision>
      <id>3355</id>
      <parentid>3204</parentid>
      <timestamp>2009-07-15T19:03:34Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>DISPLAYTITLE instead of Templaet:Title</comment>
      <text xml:space="preserve" bytes="8526">{{DISPLAYTITLE:Beautiful}}
{{Languages|Beautiful}}

Beautiful est une bibliothèque Lua qui vous permet de changer l’apparence d’awesome avec un fichier externe. Il est très simple de changer dynamiquement vos couleurs d’awesome tout entier et le papier peint du bureau, sans changer le contenu du fichier '''rc.lua'''.

Cette bibliothèque a été écrite pour des personnes qui aiment changer souvent leurs couleurs ou leur papier peint de bureau sans modifier leurs '''rc.lua''', stocker leurs anciennes valeurs, réécrire les nouvelles, etc.

Beautiful est conçue pour awesome 3 uniquement.

__TOC__

== Obtenir beautiful ==
Actuellement, beautiful est fournie avec awesome 3 ; vous n’avez pas besoin de la récupérer ailleurs. Si vous utilisez la version git d’awesome 3, vous devrez toutefois mettre à jour votre fichier de configuration. Gardez à l’esprit que le fichier '''rc.lua''' fourni dans le dépôt git est compatible avec beautiful et n’hésitez pas à vous y reporter pour paramétrer ou mettre à jour votre propre fichier '''rc.lua'''.

== Paramétrer beautiful ==
Tout d’abord, vous devez utiliser :
 require('beautiful')
pour inclure la bibliothèque dans votre fichier de configuration.

Ensuite, vous devrez initialiser beautiful avec un fichier de thème, en utilisant  :
 beautiful.init(&quot;chemin_vers_fichier_de_thème&quot;)
Un fichier de thème par défaut est fourni ; on le trouve dans '''/usr/local/share/awesome/themes/default''' ou '''/usr/share/awesome/themes/default''', suivant votre distribution.

La commande d’initialisation interprète le fichier de thème et remplit la table de hachage (''theme[&quot;clé&quot;] = valeur'').

[[Awful]] peut gérer beautiful, ce qui vous éviter de passer de nombreux arguments aux fonctions d’awful dans votre fichier de configuration, mais vous devez d’abord l’enregistrer :
 awful.beautiful.register(beautiful)

Vous êtes maintenant prêt. En gros, vous n’avez plus qu’à remplacer chaque définition de variable de couleur par (par exemple) :
 bg_focus = beautiful.bg_focus
La fonction ''beautiful.clé'' renvoie la valeur ''value'' correspondant à la ''clé'' de votre fichier de thème.

== Fichier de thème par défaut ==
Voici le fichier de thème par défaut fourni avec awesome 3 :
&lt;pre&gt;
--------------------------------
-- Thème par défaut d’awesome --
--------------------------------

font          = sans 8

bg_normal     = #222222
bg_focus      = #535d6c
bg_urgent     = #ff0000

fg_normal     = #aaaaaa
fg_focus      = #ffffff
fg_urgent     = #ffffff

border_width  = 1
border_normal = #000000
border_focus  = #535d6c
border_marked = #91231c

# Il y a d’autres ensembles de variables
# qui sont prioritaires sur celles par défaut
# quand on les utilise. Ce sont :
# [taglist|tasklist]_[bg|fg]_[focus|urgent]
# titlebar_[bg|fg]_[normal|focus]
# Exemple :
#taglist_bg_focus = #ff0000

# Ensembles de variables pour le thème du menu
# menu_[bg|fg]_[normal|focus]
# menu_[border_color|border_width]
# menu_submenu_icon = /usr/local/share/awesome/icons/submenu.png
menu_height   = 15
menu_width    = 100

# Affiche les carrés de la liste d’onglets
taglist_squares = true

# Vous pouvez ajouter autant de variables
# que vous voulez et y accéder en utilisant
# beautiful.variable dans votre rc.lua
#bg_widget    = #cc0000

# Affiche le bouton de fermeture dans la barre de titre
titlebar_close_button = true

# Définit l’image à charger
@ (if titlebar_close_button_[normal|focus] these values are ignored)
#titlebar_close_button_img_normal = /usr/local/share/awesome/icons/titlebar/closea.png
#titlebar_close_button_img_focus = /usr/local/share/awesome/icons/titlebar/closera.png
# Ou créez vos propres boutons de fermeture
#titlebar_close_button_normal = &lt;span&gt;...&lt;/span&gt;
#titlebar_close_button_focus = &lt;span&gt;...&lt;/span&gt;

# Vous pouvez utiliser votre propre commande
#pour mettre en place votre papier peint de bureau
wallpaper_cmd = awsetbg /usr/local/share/awesome/themes/default-background.png
&lt;/pre&gt;

Pour commencer à faire votre propre thème, lancez :
 cp -r /usr/local/share/awesome/themes ~/.config/awesome/
ou
 cp -r /usr/share/awesome/themes ~/.config/awesome/
et n’oubliez pas de changer le chemin vers le fichier de thème dans votre rc.lua :
 beautiful.init(os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/themes/default&quot;)

== Utilisation ==
=== Variables personnalisées ===
Vous ne devriez jamais changer les noms de variables par défaut, tels que ''font'' ou ''bg_normal'', puisque ces noms sons utilisés par [[awful]] et cela pourrait casser votre fichier de configuration. Toutefois, vous pouvez créer autant de variables que vous voulez.

Par exemple, si vous souhaitez changer l’apparence de vos widgets, vous pouvez utiliser :
 fg_off_widget = #ffffff
 fg_widget = #000000
 fg_end_widget = #ff0000

et dans votre '''rc.lua''' :
 my_widget:bar_properties_set(&quot;data_name&quot;, {
    border_color = beautiful.border_normal,
    fg_off = beautiful.fg_off_widget,
    fg = beautiful.fg_widget,
    fg_end = beautiful.fg_end_widget
 })

Dans cet exemple, nous avons mélangé des noms de variable de thème par défaut (''beautiful.border_normal'') et des noms de variables personnalisés (''beautiful.*_widget''). Vous pouvez imaginer créer vos propres icônes et autres. Mais soyez conscient du fait que si vous commencez à utiliser des variables personnalisées dans votre '''rc.lua''', vous devrez les définir aussi dans chaque fichier de thème, sinon cela cassera votre fichier de configuration.

=== Paramétrer votre papier peint de bureau ===
Beautiful peut gérer votre papier peint, pour que vous n’ayez pas à le mettre en place dans vos fichiers '''.xinitrc''' ou '''.xsession''' par exemple. Cela vous permet d’avoir un papier peint propre à chaque thème. Si vous regardez le fichier de thème par défaut, vous verrez une clé ''wallpaper_cmd'' ; la commande donnée est exécutée quand ''beautiful.init(&quot;chemin_vers_fichier_de_thème&quot;)''' est lancé. Vous pouvez mettre à cet endroit votre propre commande, voire enlever ou commenter la clé si vous ne voulez pas que beautiful interfère avec votre moyen de gérer le papier peint.

Par exemple, si vous utilisez ''fbsetbg'' pour votre papier peint, vous pouvez écrire :
 wallpaper_cmd = fbsetbg -f .config/awesome/themes/awesome-wallpaper.png

== Astuces ==
=== Utilisation de liens symboliques ===
Comme dit plus haut, beautiful vous éviter d’avoir à éditer votre fichier '''rc.lua''' quand vous voulez changer votre thème awesome, ce qui n’est pas tout à fait vrai puisque vous devez changer le chemin vers votre fichier de thème dans la fonction ''beautiful.init()''. Mais vous pouvez créer un lien symbolique vers votre thème actuel et l’utiliser pour initialiser beautiful ; de cette manière, vous n’aurez plus qu’à faire pointer ce lien vers un autre fichier et relancer awesome (Super+Ctrl+R par défaut) pour changer de thème.

Mais vous pouvez même écrire une fonction pour remplir un memu popup [[awful.menu]] vous permettant de changer de thème. Supposons que votre chemin de thème est :
 home_dir = os.getenv(&quot;HOME&quot;)
 beautiful.init(awful.util.getdir(&quot;config&quot;) .. &quot;/theme_actuel/theme&quot;)

Dans ce cas, écrivez :
&lt;pre&gt;
mythememenu = {}

function theme_load(theme)
   local cfg_path = awful.util.getdir(&quot;config&quot;)

   -- Crée un lien symbolique depuis le thème donné vers /home/utilisateur/.config/awesome/theme_actuel
   awful.util.spawn(&quot;ln -sf &quot; .. cfg_path .. &quot;/themes/&quot; .. theme .. &quot; &quot; .. cfg_path .. &quot;/theme_actuel&quot;)
   awesome.restart()
end

function theme_menu()
   -- Liste vos fichiers de thème et remplit le tableau du menu
   local cmd = &quot;ls -1 &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/themes/&quot;
   local f = io.popen(cmd)

   for l in f:lines() do
	  local item = { l, function () theme_load(l) end }
	  table.insert(mythememenu, item)
   end

   f:close()
end

-- Génère votre tableau au (re)démarrage
theme_menu()

-- Modifie votre menu awesome pour ajouter votre sous-menu de thème
myawesomemenu = {
   { &quot;Manuel&quot;, terminal .. &quot; -e man awesome&quot; },
   { &quot;Configuration (rc.lua)&quot;, editor_cmd .. &quot; &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/rc.lua&quot; },
   { &quot;Thèmes&quot;, mythememenu },
   { &quot;Recharger la config&quot;, awesome.restart },
   { &quot;Quitter&quot;, awesome.quit }
}
&lt;/pre&gt;

=== Partagez vos thèmes ===
N’hésitez pas à [[Beautiful themes/fr|partager vos propres thèmes]] avec la communauté ''grandiose'' d’awesome !

[[Category:Themes]]
[[Category:awesome3]]</text>
      <sha1>bg2g0o0wa5xvu0uey13grudrz9d4puw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Beautiful/ru</title>
    <ns>0</ns>
    <id>1033</id>
    <revision>
      <id>6426</id>
      <timestamp>2014-05-02T17:06:27Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{DISPLAYTITLE:Темы Beautiful}} {{Languages|Beautiful}}  Beautiful это библиотека lua, которая позволяет вам настраивать тем...&quot;</comment>
      <text xml:space="preserve" bytes="8672">{{DISPLAYTITLE:Темы Beautiful}}
{{Languages|Beautiful}}

Beautiful это библиотека lua, которая позволяет вам настраивать темы в awesome используя внешние файлы. Она очень облегчает диначеское изменение цветов или обой в awesome, без изменения ''rc.lua''.

Она была написана людьми, которым нравится кастомизировать их систему время от времени. Данная возможность доступна без редактирования основного файла настроек ''rc.lua'', позволяя сохранить старые настройки, или добавляя новые.

Beautiful доступна только для 3 версии awesome.

== Установка Beautiful ==
Во первых, нужно добавить:
&lt;pre&gt;beautiful = require('beautiful')&lt;/pre&gt;
для подключения библиотеки в вашем файле конфигурации.

Затем, нужно изициализировать использование библиотеки Beautiful с нужной темой:
&lt;pre&gt;beautiful.init(&quot;path_to_theme_file&quot;)&lt;/pre&gt;
Тема по умолчанию расположена в ''/usr/local/share/awesome/themes/default/theme.lua'' или ''/usr/share/awesome/themes/default/theme.lua'', в зависимости от вашего дистрибутива.

Файл темы существенно отличается от других файлов Lua которые используют таблицу соотвествия пар ключ-значение (такие как 'bg_normal' = '#222222').

Awful может работать с Beautiful позволяя вам избежать добавления лишнего кода и аргументов в функции awful.

Итак, приступим. В принципе, вы можете заменить все определения цветовых переменных по следующему примеру:
&lt;pre&gt;bg_focus = beautiful.bg_focus&lt;/pre&gt;
Вы можете получить доступ ко всем ключам в паре (keys=value) зарегистрированных в теме как &lt;pre&gt;beautiful.&amp;lt;key&amp;gt;&lt;/pre&gt;

Для того, чтобы создать свою собственную тему, наберите в терминале:
&lt;pre&gt;
cp -r /usr/local/share/awesome/themes ~/.config/awesome/
&lt;/pre&gt;
или
&lt;pre&gt;
cp -r /usr/share/awesome/themes ~/.config/awesome/
&lt;/pre&gt;
Не забудьте изменить путь к файлу темы в вашем ''rc.lua'':
&lt;pre&gt;
beautiful.init(awful.util.getdir(&quot;config&quot;) .. &quot;/themes/default/theme.lua&quot;)
&lt;/pre&gt;

== Использование ==
=== Custom variables ===
Вы никогда не должны изменять названия переменных по умолчанию (''font'', ''bg_normal'' и прочее) так как они испльзуются в awful, и это приведет к ошибкам в вашем файле конфигурации. Но вы можете добавить любые другие переменные по вашему желанию.

Например, если вы хотите, вы можете добавить тему для вашего виджета:
&lt;pre&gt;
fg_off_widget = #ffffff
fg_widget = #000000
fg_end_widget = #ff0000
&lt;/pre&gt;

Далее в файле ''rc.lua'':
&lt;pre&gt;
my_widget:bar_properties_set(&quot;data_name&quot;, {
   border_color = beautiful.border_normal,
   fg_off = beautiful.fg_off_widget,
   fg = beautiful.fg_widget,
   fg_end = beautiful.fg_end_widget
})
&lt;/pre&gt;
В этом примере мы смешали и переменную темы по умолчанию ('''beautiful.border_normal''') и заданную нами переменную ('''beautiful.*_widget'''). Также вы можете назначать свои собственные иконки и прочее.  Но помните, что если вы начали использовать определенную вами переменную в вашем файле ''rc.lua'', вам необходимо определить эту переменную в каждом файле ВСЕХ тем, иначе при выборе другой темы будет множество ошибок. 

=== Установка обой ===
Beautiful может устанавливать обои, поэтому вам нет необходимости изменять ''.xinitrc'' или ''.xsession''. Это позволяет устанавливать обои для каждой темы отдельно. Если вы посмотрите файл темы по умолчанию(default), вы увидите ключ ''wallpaper_cmd'', этот ключ установит обои при выполнении команды '''beautiful.init(&quot;path_to_theme_file&quot;)'''. Вы можете удалить/закоментировать этот ключ, если не хотите, чтобы Beautiful производил обработку этой команды.

Например, если вы используете '''fbsetbg''' для установки обой, вы можете записать следующее:
&lt;pre&gt;
wallpaper_cmd = fbsetbg -f .config/awesome/themes/awesome-wallpaper.png
&lt;/pre&gt;

Если у вас несколько мониторов(screen), и вы хотите иметь различные обои на них, используйте следующий код:
&lt;pre&gt;
wallpaper_cmd = { &quot;fbsetbg -f .config/awesome/themes/awesome-wallpaper1.png&quot;,
                  &quot;fbsetbg -f .config/awesome/themes/awesome-wallpaper2.png&quot; }
&lt;/pre&gt;

=== Дополнение ===
==== Использование symlinks ====
Ранее было сказано, что использование Beautiful позволяет избежать редактирования файла''rc.lua'' когда вы хотите изменить оформление, на самом деле это не совсем верно, так как при изменении темы, вам необходимо изменить путь к ней в функции '''beautiful.init()'''. Но, вы можете использовать символическую ссылку на вашу текущую тему, и использовать ее для инициализации Beautiful, таким образом, вам понадобится только изменить ссылку на другую тему, а затем презапустить awesome (''ctrl+mod4+r'' по умолчанию) для изменения темы.

Теперь вы можете написать функцию и добавить ее в меню [[awful.menu]] для мгновенного изменения вашей темы, мы предполагаем, что путь к теме у вас такой же:
&lt;pre&gt;
beautiful.init(awful.util.getdir(&quot;config&quot;) .. &quot;/current_theme/theme.lua&quot;)
&lt;/pre&gt;

Затем пишем:
&lt;pre&gt;
mythememenu = {}

function theme_load(theme)
   local cfg_path = awful.util.getdir(&quot;config&quot;)

   -- Создание символической ссылки на выбраную тему в /home/user/.config/awesome/current_theme
   awful.util.spawn(&quot;ln -sfn &quot; .. cfg_path .. &quot;/themes/&quot; .. theme .. &quot; &quot; .. cfg_path .. &quot;/current_theme&quot;)
   awesome.restart()
end

function theme_menu()
   -- Прочитать все файлы тем и добавить их в таблицу меню
   local cmd = &quot;ls -1 &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/themes/&quot;
   local f = io.popen(cmd)

   for l in f:lines() do
	  local item = { l, function () theme_load(l) end }
	  table.insert(mythememenu, item)
   end

   f:close()
end

-- Создаем таблицу меню при запуске или перезапуске
theme_menu()

-- Модификация меню awesome для добавления подменю с темами
myawesomemenu = {
   { &quot;manual&quot;, terminal .. &quot; -e man awesome&quot; },
   { &quot;edit config&quot;, editor_cmd .. &quot; &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/rc.lua&quot; },
   { &quot;themes&quot;, mythememenu },
   { &quot;restart&quot;, awesome.restart },
   { &quot;quit&quot;, awesome.quit }
}
&lt;/pre&gt;

==== Делитесь своими темами ====
Не стесняйтесь [[Beautiful themes|делитесь вашими темами]] с сообществом awesome!

[[Category:Themes]][[Category:awesome3]]</text>
      <sha1>hqd1t0zsvb7ybgjrrfucwk85njd2ur8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Beautiful themes</title>
    <ns>0</ns>
    <id>131</id>
    <revision>
      <id>7466</id>
      <parentid>7339</parentid>
      <timestamp>2016-04-11T17:55:44Z</timestamp>
      <contributor>
        <username>Gyrfalco</username>
        <id>3740</id>
      </contributor>
      <comment>update pro themes link</comment>
      <text xml:space="preserve" bytes="1818">{{Languages}}

{|
|- align=&quot;center&quot; valign=&quot;top&quot;
| [[Image:Screenshot-anrxc.png|thumb|none|[[Zenburn Theme]]]]
| [[Image:Screenshot-WWII.png|thumb|none|[[WWII Theme]]]]
| [[Image:Screenshot-DWM.png|thumb|none|[http://github.com/farhaven/awesome-configs/tree/master/themes/dwm/ DWM Theme]]]
| [[Image:Screenshot-Worm.png|thumb|none|[[Worm Theme]]]]
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:Zhuravlik_screen.png|thumb|none|[[Zhuravlik theme]]]]
| [[Image:subtle_hacker.png|thumb|none|[[subtle hacker theme]] -- classic emacs-like]]
| [[Image:Coolblue.png|thumb|none|[[cool blue theme]] -- mod of default w/ blue/grey colors]]
| [[Image:Pro.jpg|thumb|none|[http://github.com/stobenski/pro Pro themes]]]
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:Anon1.png|thumb|none|[[Anon theme]]]]
| [[Image:Awesome-aurantium.jpg|thumb|none|[[aurantium theme]]]]
| [[Image:Xeno.png|thumb|none|[[xeno theme]] -- black/blue theme like irssi default]]
| [[Image:Arch.png|thumb|none|[[arch theme]] -- mod of default white/black/blue colors]]
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:goblin-theme.png|thumb|none|[[goblin theme]] -- default with some green]]
| [[Image:IoGA_scr_1.png|thumb|none|[[IoGA theme]]]]
| [[Image:Clearlooks.png|thumb|none|[[Clearlooks theme]]]]
| [[Image:gigamo_current_ss.png|thumb|none|[[Gigamos Theme]]]]
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:Screenshot-nac-theme.png|thumb|none|[[Nice and Clean Theme]]]]
| [[Image:Glossy.png|thumb|none|[[Glossy theme]]]]
| [[Image:Darklooks.png|thumb|none|[[Darklooks theme]]]]
| [[Image:Darkblue_theme.png|thumb|none|[[Darkblue Theme]]]]
| &amp;nbsp;
|}

=== Themepack ===
*pre 3.5:
 https://github.com/mikar/awesome34-themes
*3.5:
 https://github.com/mikar/awesome-themes
 or
 https://github.com/Morley93/awesome-themes-3.5

[[Category:Themes]][[Category:awesome3]]</text>
      <sha1>gaga0t467mzf5efflgjrpol9kge1ugf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Beautiful themes/fr</title>
    <ns>0</ns>
    <id>397</id>
    <revision>
      <id>3807</id>
      <parentid>3539</parentid>
      <timestamp>2009-11-17T23:49:26Z</timestamp>
      <contributor>
        <username>Kaiju</username>
        <id>275</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="3857">{{DISPLAYTITLE:Thèmes Beautiful}}
{{Languages|Beautiful themes}}

Voici quelques thèmes, dont certains sont gérés avec la bilbiothèque beautiful. Regardez également les [[User Configuration Files/fr|fichiers de configuration d’utilisateurs]] où vous trouverez d’autres thèmes inclus dans des configurations.

== Thèmes à récupérer ==
=== Quelques thèmes avec aperçus ===
{|
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:goblin-theme.png|thumb|none|[[goblin theme|« goblin »]] : par défaut avec un peu de vert]]
| [[Image:subtle_hacker.png|thumb|none|[[subtle hacker theme|« hacker classique »]] : ressemblant au classique emacs]]
| [[Image:Coolblue.png|thumb|none|[[cool blue theme|« bleu frais »]] : mod du défaut avec couleurs bleu et gris]]
| [[Image:Clearlooks.png|thumb|none|[[Clearlooks theme|« clearlooks »]] : reprenant le thème GTK du même nom]]
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:Redd.png|thumb|none|« redd »⁽¹⁾ : thème rouge et marron avec images]]
| [[Image:Arch.png|thumb|none|[[arch theme|« arch »]] : mod du défaut, couleurs blanc, noir et bleu]]
| [[Image:Xeno.png|thumb|none|[[xeno theme|« xeno »]] : thème noir et bleu comme le défaut irssi]]
| [[Image:gigamo_current_ss.png|thumb|none|[[Gigamos Theme|thème de Gigamo]] avec widgets et amazing]]
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:Screenshot-anrxc.png|thumb|none|[[Zenburn Theme|« Zenburn »]]]]
| &amp;nbsp;
| &amp;nbsp;
| &amp;nbsp;
|}
⁽¹⁾ à télécharger sur [http://uploaded.to/?id=xgqbwj Uploaded.to] ou [http://rapidshare.com/files/166741313/redd-1.0.tar.html RapidShare]


=== Autres thèmes ===
*[[elegant cold blue - mod of cool blue theme|« bleu froid élégant »]] : mod du thème « bleu frais »
*[[Anon theme|« Anon »]]
*[[aurantium theme|« Aurantium »]]
*[[IoGA theme|thème de IoGA]]
* Thème de STxza : [http://balancest.deviantart.com/gallery/ captures d’écran] et [http://github.com/stxza/arch-linux-configs/tree/master/.config%2Fawesome fichiers de configuration] 

=== Anciens thèmes, pour awesome 2.3 ===
{|
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:Awesome_2.3_default.png|thumb|none|[[Default 2.3 Theme/fr|Thème par défaut d’awesome 2.3]]]]
| [[Image:Mortini_green_screenshot.png|thumb|none|[[Mortini Simple Laptop Theme|« portable simple »]] : un thème simple avec deux widgets]]
| [[Image:twoism_theme_busy.png|thumb|none|Twoism « occupé » : [[Twoism theme|thème simple]] avec widgets]]
| [[Image:twoism_theme_clean.png|thumb|none|Twoism « propre » : [[Twoism theme|thème simple]] avec widgets]]
|}

== Captures d’écran diverses ==
[[Image:Awesome-n810.jpg|thumb|right|250px|''awesome tourne aussi sur les téléphones portables ! Ici, sur un Nokia N-810'']]
Garoth a mis en ligne une dizaine de captures d’écrans de plusieurs utilisateurs d’awesome à [http://garoth.com/awesome/showcase cette adresse]

Quelques captures d’écran prises par purehate pendant qu’il construisait son thème :
*[http://i236.photobucket.com/albums/ff141/purehate138/5_mon_awesome_FTW.png les quatre écrans]
*[http://img161.imageshack.us/img161/5333/awesome5tu8.png écran seul]
*[http://i236.photobucket.com/albums/ff141/purehate138/awesome2.png écran nº2 seul]
*[http://i236.photobucket.com/albums/ff141/purehate138/awesome4.png écran nº3 seul]
*[http://i236.photobucket.com/albums/ff141/purehate138/4monitors.jpg station de travail]

[http://chm.duquesne.free.fr/divers/images/screenshot.jpg Capture] de Christophe-Marie.

=== Participez ! ===
Vous pouvez vous aussi nous faire parvenir vos captures d’écran. Pour cela, rien de plus simple avec ImageMagick :
  import screenshot.png
Vous pouvez également redimensionner votre capture d’écran :
 convert screenshot.png -resize 640x -quality 93 screenshot_small.jpg


[[Category:Themes]]
[[Category:awesome3]]</text>
      <sha1>jrzll5k4h69tjbgvpeocmxx4whja0ao</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Beautiful themes/ru</title>
    <ns>0</ns>
    <id>480</id>
    <revision>
      <id>3808</id>
      <parentid>3557</parentid>
      <timestamp>2009-11-17T23:49:49Z</timestamp>
      <contributor>
        <username>Kaiju</username>
        <id>275</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="1278">{{DISPLAYTITLE:Темы Beautiful}}
{{Languages|Beautiful themes}}

{|
|- align=&quot;center&quot; valign=&quot;top&quot;
| [[Image:Screenshot-anrxc.png|thumb|none|[[Zenburn Theme|Zenburn]]]]
| [[Image:Arch.png|thumb|none|[[arch theme|arch]] -- модификация стандартных бело-чёрно-синих цветов]]
| [[Image:Xeno.png|thumb|none|[[xeno theme | xeno]] -- чёрно-синяя тема, аналогичная используемой в irssi]]
| [[Image:Clearlooks.png|thumb|none|[[Clearlooks theme|Clearlooks]]]]
|- align=&quot;center&quot; valign=&quot;bottom&quot;
| [[Image:goblin-theme.png|thumb|none|[[goblin theme|goblin]] -- стандартная тема с добавлением зелёного цвета]]
| [[Image:subtle_hacker.png|thumb|none|[[subtle hacker theme|subtle hacker]] -- классическая тема в стиле emacs]]
| [[Image:Coolblue.png|thumb|none|[[cool blue theme|cool blue]] -- модификация стандартных бело-сине-серых цветов]]
| [[Image:Redd.png|thumb|none|redd - [http://uploaded.to/?id=xgqbwj Uploaded.to]]]
| &amp;nbsp;
|}

* Другие темы
**[[Gigamos Theme|Gigamos]]
**[[Anon theme|Anon]]
**[[IoGA theme|IoGA]]
**[[aurantium theme|aurantium]]

[[Category:Themes]][[Category:awesome3]]</text>
      <sha1>82iq1h5dzxx3hoyiqm4ddwgvd0cgqit</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Better Font Rendering</title>
    <ns>0</ns>
    <id>669</id>
    <revision>
      <id>6599</id>
      <parentid>5661</parentid>
      <timestamp>2014-05-22T14:28:11Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2312">{{Languages}}

You might be able to get a smoother font rendering with one of the .fonts.conf below. Actually it depends on the kind of monitor used, so one of them might work better over the other, or none of them might work at all.

  &lt;?xml version=&quot;1.0&quot;?&gt;
  &lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;
  &lt;fontconfig&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;autohint&quot; &gt;
              &lt;bool&gt;true&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;rgba&quot; &gt;
              &lt;const&gt;none&lt;/const&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;hinting&quot; &gt;
              &lt;bool&gt;false&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;hintstyle&quot; &gt;
              &lt;const&gt;hintnone&lt;/const&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;antialias&quot; &gt;
              &lt;bool&gt;true&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
  &lt;/fontconfig&gt;


  &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;
  &lt;fontconfig&gt;
      &lt;match target=&quot;font&quot;&gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;rgba&quot;&gt;
              &lt;const&gt;none&lt;/const&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot;&gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;hinting&quot;&gt;
              &lt;bool&gt;true&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot;&gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;hintstyle&quot;&gt;
              &lt;const&gt;hintmedium&lt;/const&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot;&gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;antialias&quot;&gt;
              &lt;bool&gt;true&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
  &lt;/fontconfig&gt;


If fonts.conf doesn't work for GTK applications, try to add Xft sections to ~/.Xresources

  ! Render setting for cairo -&gt; pango -&gt; gtk
  Xft.dpi:        96
  Xft.antialias:  true
  Xft.hinting:    true
  Xft.rgba:       rgb
  Xft.hintstyle:  hintslight

Finally don't forget to call xrdb -load ~/.Xresources to load new configurations.

Following two probably are good resources to read more about font configuration:
# http://www.freedesktop.org/software/fontconfig/fontconfig-user.html
# https://wiki.archlinux.org/index.php/Font_Configuration
# https://wiki.archlinux.org/index.php/X_resources</text>
      <sha1>0cigxvp5o800zsdqzzomqycysvu1vrd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Better Font Rendering/ru</title>
    <ns>0</ns>
    <id>1071</id>
    <revision>
      <id>6601</id>
      <timestamp>2014-05-22T14:47:10Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Better Font Rendering (translating page)</comment>
      <text xml:space="preserve" bytes="2810">{{Languages|Better Font Rendering}}
{{DISPLAYTITLE:Улучшенный рендеринг шрифтов}}

Вы можете получить более сглаженый шрифт используя fong.conf приведенный ниже. На самом деле все зависит от типа используемого монитора, поэтому один из них может работать лучше другого, или все они будут работать одинаково.

  &lt;?xml version=&quot;1.0&quot;?&gt;
  &lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;
  &lt;fontconfig&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;autohint&quot; &gt;
              &lt;bool&gt;true&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;rgba&quot; &gt;
              &lt;const&gt;none&lt;/const&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;hinting&quot; &gt;
              &lt;bool&gt;false&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;hintstyle&quot; &gt;
              &lt;const&gt;hintnone&lt;/const&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot; &gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;antialias&quot; &gt;
              &lt;bool&gt;true&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
  &lt;/fontconfig&gt;


  &lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;
  &lt;fontconfig&gt;
      &lt;match target=&quot;font&quot;&gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;rgba&quot;&gt;
              &lt;const&gt;none&lt;/const&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot;&gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;hinting&quot;&gt;
              &lt;bool&gt;true&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot;&gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;hintstyle&quot;&gt;
              &lt;const&gt;hintmedium&lt;/const&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
      &lt;match target=&quot;font&quot;&gt;
          &lt;edit mode=&quot;assign&quot; name=&quot;antialias&quot;&gt;
              &lt;bool&gt;true&lt;/bool&gt;
          &lt;/edit&gt;
      &lt;/match&gt;
  &lt;/fontconfig&gt;


Если fonts.conf не работает на приложениях GTK, попробуйте добавить секцию Xft в ~/.Xresources

  ! Render setting for cairo -&gt; pango -&gt; gtk
  Xft.dpi:        96
  Xft.antialias:  true
  Xft.hinting:    true
  Xft.rgba:       rgb
  Xft.hintstyle:  hintslight

В завершении не забудьте вызвать xrdb -load ~/.Xresources для загрузки новой конфигураци.

Далее приведены 2 неплохих ресурса для получения дополнительной информации по настройке шрифтов:
# http://www.freedesktop.org/software/fontconfig/fontconfig-user.html
# https://wiki.archlinux.org/index.php/Font_Configuration
# https://wiki.archlinux.org/index.php/X_resources</text>
      <sha1>64zsnhnrssc3dloc5tm5cv37vzkr8jo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Binary Clock widget</title>
    <ns>0</ns>
    <id>887</id>
    <redirect title="Binary clock widget" />
    <revision>
      <id>5748</id>
      <timestamp>2013-01-08T06:22:30Z</timestamp>
      <contributor>
        <username>Joker</username>
        <id>2530</id>
      </contributor>
      <comment>moved [[Binary Clock widget]] to [[Binary clock widget]]</comment>
      <text xml:space="preserve" bytes="33">#REDIRECT [[Binary clock widget]]</text>
      <sha1>7xzueysm3l9y10drgmj19joeeaejry1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Binary clock widget</title>
    <ns>0</ns>
    <id>728</id>
    <revision>
      <id>5747</id>
      <parentid>5746</parentid>
      <timestamp>2013-01-08T06:22:30Z</timestamp>
      <contributor>
        <username>Joker</username>
        <id>2530</id>
      </contributor>
      <minor/>
      <comment>moved [[Binary Clock widget]] to [[Binary clock widget]]</comment>
      <text xml:space="preserve" bytes="7258">This is small widget providing a [http://en.wikipedia.org/wiki/Binary_clock#Binary-coded_decimal_clocks Binary-coded decimal clocks] in your panel.

[[File:binclock.png]]

'''This is the code:'''

  binaryclock = {}
  binaryclock.widget = widget({type = &quot;imagebox&quot;})
  binaryclock.w = 51 --width 
  binaryclock.h = 24 --height (better to be a multiple of 6) 
  --dont forget that awesome resizes our image with clocks to fit wibox's height
  binaryclock.show_sec = true --must we show seconds? 
  binaryclock.color_active = beautiful.bg_focus --active dot color
  binaryclock.color_bg = beautiful.bg_normal --background color
  binaryclock.color_inactive = beautiful.fg_focus --inactive dot color
  binaryclock.dotsize = math.floor(binaryclock.h / 6) --dot size
  binaryclock.step = math.floor(binaryclock.dotsize / 2) --whitespace between dots
  binaryclock.widget.image = image.argb32(binaryclock.w, binaryclock.h, nil) --create image
  if (binaryclock.show_sec) then binaryclock.timeout = 1 else binaryclock.timeout = 20 end --we don't need to update often
  binaryclock.DEC_BIN = function(IN) --thanx to Lostgallifreyan (http://lua-users.org/lists/lua-l/2004-09/msg00054.html)
      local B,K,OUT,I,D=2,&quot;01&quot;,&quot;&quot;,0
      while IN&gt;0 do
          I=I+1
          IN,D=math.floor(IN/B),math.mod(IN,B)+1
          OUT=string.sub(K,D,D)..OUT
      end
      return OUT
  end
  binaryclock.paintdot = function(val,shift,limit) --paint number as dots with shift from left side
        local binval = binaryclock.DEC_BIN(val)
        local l = string.len(binval)
        local height = 0 --height adjustment, if you need to lift dots up
        if (l &lt; limit) then
               for i=1,limit - l do binval = &quot;0&quot; .. binval end
        end
        for i=0,limit-1 do
               if (string.sub(binval,limit-i,limit-i) == &quot;1&quot;) then
                     binaryclock.widget.image:draw_rectangle(shift,  binaryclock.h - binaryclock.dotsize - height, binaryclock.dotsize, binaryclock.dotsize, true, binaryclock.color_active)
               else
                     binaryclock.widget.image:draw_rectangle(shift,  binaryclock.h - binaryclock.dotsize - height, binaryclock.dotsize,binaryclock.dotsize, true, binaryclock.color_inactive)
               end
               height = height + binaryclock.dotsize + binaryclock.step
         end
  end
  binaryclock.drawclock = function () --get time and send digits to paintdot()
        binaryclock.widget.image:draw_rectangle(0, 0, binaryclock.w, binaryclock.h, true, binaryclock.color_bg) --fill background
        local t = os.date(&quot;*t&quot;)
        local hour = t.hour
        if (string.len(hour) == 1) then
               hour = &quot;0&quot; .. t.hour
        end
        local min = t.min
        if (string.len(min) == 1) then
               min = &quot;0&quot; .. t.min
        end
        local sec = t.sec
        if (string.len(sec) == 1) then
               sec = &quot;0&quot; .. t.sec
        end
        local col_count = 6
        if (not binaryclock.show_sec) then col_count = 4 end
        local step = math.floor((binaryclock.w - col_count * binaryclock.dotsize) / 8) --calc horizontal whitespace between cols
        binaryclock.paintdot(0 + string.sub(hour, 1, 1), step, 2)
        binaryclock.paintdot(0 + string.sub(hour, 2, 2), binaryclock.dotsize + 2 * step, 4)
        binaryclock.paintdot(0 + string.sub(min, 1, 1),binaryclock.dotsize * 2 + 4 * step, 3)
        binaryclock.paintdot(0 + string.sub(min, 2, 2),binaryclock.dotsize * 3 + 5 * step, 4)
        if (binaryclock.show_sec) then
               binaryclock.paintdot(0 + string.sub(sec, 1, 1), binaryclock.dotsize * 4 + 7 * step, 3)
               binaryclock.paintdot(0 + string.sub(sec, 2, 2), binaryclock.dotsize * 5 + 8 * step, 4)
        end
        binaryclock.widget.image = binaryclock.widget.image
    end


'''Register timer''' 

  binarytimer = timer { timeout = binaryclock.timeout } --register timer
    binarytimer:add_signal(&quot;timeout&quot;, function()
        binaryclock.drawclock()
    end)
    binarytimer:start()--start timer

And finally '''add widget''' to your panel


    mywibox[s].widgets = {
            --widgets
            binaryclock.widget,
            --widgets again
            layout = awful.widget.layout.horizontal.rightleft
        }


I recommend you to modify your panel's height like that:

  mywibox[s] = awful.wibox({ position = &quot;top&quot;, screen = s, height = &quot;22&quot; })

--[[User:Lazywolf|Lazywolf]] 13:26, 13 September 2011 (CEST)lazywolf


== For awesome 3.5 ==

  ------------------------------------------------------
  -- Binary clock
  
  local binClock = wibox.widget.base.make_widget()
  binClock.radius = 1.5
  binClock.shift = 1.8
  binClock.farShift = 2
  binClock.border = 1
  binClock.lineWidth = 1
  binClock.colorActive = beautiful.bg_focus 
  
  binClock.fit = function(binClock, width, height)
  	local size = math.min(width, height)
  	return 6 * 2 * binClock.radius + 5 * binClock.shift + 2 * binClock.farShift + 2 * binClock.border + 2 * binClock.border, size
  end
  
  binClock.draw = function(binClock, wibox, cr, width, height)
  	local curTime = os.date(&quot;*t&quot;)
  
  	local column = {}
  	table.insert(column, string.format(&quot;%04d&quot;, binClock:dec_bin(string.sub(string.format(&quot;%02d&quot;, curTime.hour), 1, 1))))
  	table.insert(column, string.format(&quot;%04d&quot;, binClock:dec_bin(string.sub(string.format(&quot;%02d&quot;, curTime.hour), 2, 2))))
  	table.insert(column, string.format(&quot;%04d&quot;, binClock:dec_bin(string.sub(string.format(&quot;%02d&quot;, curTime.min), 1, 1))))
  	table.insert(column, string.format(&quot;%04d&quot;, binClock:dec_bin(string.sub(string.format(&quot;%02d&quot;, curTime.min), 2, 2))))
  	table.insert(column, string.format(&quot;%04d&quot;, binClock:dec_bin(string.sub(string.format(&quot;%02d&quot;, curTime.sec), 1, 1))))
  	table.insert(column, string.format(&quot;%04d&quot;, binClock:dec_bin(string.sub(string.format(&quot;%02d&quot;, curTime.sec), 2, 2))))
  
  	local bigColumn = 0
  	for i = 0, 5 do
  		if math.floor(i / 2) &gt; bigColumn then
  			bigColumn = bigColumn + 1
  		end
  		for j = 0, 3 do
  			if string.sub(column[i + 1], j + 1, j + 1) == &quot;0&quot; then 
  				active = false 
  			else 
  				active = true 
  			end 
  			binClock:draw_point(cr, bigColumn, i, j, active)
  		end
  	end
  end
  
  binClock.dec_bin = function(binClock, inNum)
  	inNum = tonumber(inNum)
  	local base, enum, outNum, rem = 2, &quot;01&quot;, &quot;&quot;, 0
  	while inNum &gt; (base - 1) do
  		inNum, rem = math.floor(inNum / base), math.fmod(inNum, base)
  		outNum = string.sub(enum, rem + 1, rem + 1) .. outNum
  	end
  	outNum = inNum .. outNum
  	return outNum
  end
  
  binClock.draw_point = function(binClock, cr, bigColumn, column, row, active)
  	cr:arc(binClock.border + column * (2 * binClock.radius + binClock.shift) + bigColumn * binClock.farShift + binClock.radius,
  		 binClock.border + row * (2 * binClock.radius + binClock.shift) + binClock.radius, 2, 0, 2 * math.pi)
  	if active then
  		cr:set_source_rgba(0, 0.5, 0, 1)
  	else
  		cr:set_source_rgba(0.5, 0.5, 0.5, 1)
  	end
  	cr:fill()
  end
  
  binClocktimer = timer { timeout = 1 }
  binClocktimer:connect_signal(&quot;timeout&quot;, function() binClock:emit_signal(&quot;widget::updated&quot;) end)
  binClocktimer:start()
  
  --
  ------------------------------------------------------

--[[User:Joker|Joker]] 07:16, 8 January 2013 (CET)</text>
      <sha1>sg3afsoimpn03boyjhaulw2b2e5hokx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bioe007 moc widget (scrolling text)</title>
    <ns>0</ns>
    <id>199</id>
    <revision>
      <id>2702</id>
      <parentid>2294</parentid>
      <timestamp>2009-05-23T07:38:12Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>And another awesome3 candidate</comment>
      <text xml:space="preserve" bytes="9497">With all the great widgets on my statusbar, I'm running out of room. And its aggravating that I can not see all of the artist plus track title for whats currently playing in moc. 

So I decided to write a widget that would 'scroll' text to show the entire thing.

'''Note''' throughout this page files are linked to my github account, where you can always find the latest version.

This new (2/17/09) version makes use of mocp's ability to execute a script when the song changes, here is the script i use in [http://github.com/bioe007/bioe007configs/blob/master/.bin/mochg ~/.bin/mochg]:

  
  #!/bin/bash
  # a helper script to update my awesome mocp widget
  #
  # this script accepts key value pairs and passes them to the mocp module via awesome-client
  echo time &gt;&gt; ~/mocdbg
  if [ &quot;$#&quot; -lt &quot;2&quot; ] ; then
    echo 'mocp.update(&quot;state&quot;,&quot;STOP&quot;)' | awesome-client
  else
    while [ &quot;$#&quot; -ge &quot;2&quot; ] ; do
      echo 'mocp.update(&quot;'$1'&quot;,&quot;'$2'&quot;)' | awesome-client
      shift; shift
    done
  fi
  

This is the actual mocp module code, I put it in [http://github.com/bioe007/bioe007configs/blob/master/.config/awesome/mocp.lua ~/.config/awesome/mocp.lua]:  

  
  local io = io
  local string = string
  local awful = require(&quot;awful&quot;)
  local beautiful = require(&quot;beautiful&quot;)
  local naughty = require(&quot;naughty&quot;)
  local markup = require(&quot;markup&quot;)
  
  module(&quot;mocp&quot;)
  
  -- public settings
  settings = {}
  settings.iScroller = 1
  settings.MAXCH = 15
  settings.interval = 0.75
  
  local mocbox = nil
  local trackinfo = {}
  trackinfo.artist = &quot;&quot;
  trackinfo.songtitle = &quot;&quot;
  trackinfo.album = &quot;&quot;
  trackinfo.state = &quot;&quot;
  
  ---{{{ local state()
  -- updates trackinfo.state [ PLAY|PAUSE|STOP|OFF ]
  -- and makes widget text/size changes as needed
  local function state()
  
    local fd = {}
    local state =&quot;&quot; 
  
    fd = io.popen('pgrep -fx mocp')
  
    if fd:read() ~= nil then 
        fd:close()
  
        fd = io.popen('mocp -i')
        trackinfo.state = string.gsub(fd:read(),&quot;State:%s*&quot;,&quot;&quot;)
        fd:close()
  
        if trackinfo.state == &quot;STOP&quot; then
            return false
        else
            settings.widget.width = 112
            return true
        end
    else
        trackinfo.state = &quot;OFF&quot;
        settings.widget.text = &quot;&quot; 
        settings.widget.width = 0
    end
    fd:close()
  end
  ---}}}
  
  ---{{{ local setTitle
  -- call to force update of trackinfo variables
  local function setTitle()
  
    local fd = {}
  
    if state() then
        fd = io.popen('mocp -i')
  
        -- read to end of mocp -i
        tmp = fd:read()
        while tmp ~= nil do
            key = string.match(tmp,&quot;^%w+&quot;)
            if trackinfo[key:lower()] ~= nil then
                trackinfo[key:lower()]=awful.util.escape(string.gsub(string.gsub(tmp,key..&quot;:%s*&quot;,&quot;&quot;),&quot;%b()&quot;,&quot;&quot;))
            end
            tmp = fd:read()
        end
    end
  
  end
  ---}}}
  
  ---{{{ local title(delim)
  local function title(delim)
  
    local eol = delim or &quot; &quot;
    local np = {}
  
    if trackinfo.artist == &quot;&quot; and state() then setTitle() end
    np.song =string.gsub( string.gsub(trackinfo.songtitle,&quot;^%d*&quot;,&quot;&quot;),&quot;%(.*&quot;,&quot;&quot;) .. eol
  
    -- return for widget text
    return trackinfo.artist..&quot; : &quot;..np.song
  
  end
  ---}}}
  
  ---{{{ local function notdestroy()
  local function notdestroy()
    if mocbox ~= nil then
        naughty.destroy(mocbox)
        mocbox = nil
    end
  end
  ---}}}
  
  ---{{{ local getTime() gets ct and tt of track for popup
  --@return string containig formatted times
  local function getTime()
    local fd = {}
    local ttable = {}
    fd = io.popen('mocp -i')
    local tmp = fd:read()
  
    while tmp ~= nil do
        key = string.match(tmp,&quot;^%w+&quot;)
        if key == &quot;TotalTime&quot; then
            tstring = &quot; [ &quot;..markup.fg(beautiful.fg_normal,awful.util.escape(string.gsub(string.gsub(tmp,key..&quot;:%s*&quot;,&quot;&quot;),&quot;%b()&quot;,&quot;&quot;)))..&quot; ]&quot;
        elseif key == &quot;CurrentTime&quot; then
            tstring = markup.fg(beautiful.fg_focus,&quot;Time:   &quot;)..
                      markup.fg(beautiful.fg_normal,awful.util.escape(string.gsub(string.gsub(tmp,key..&quot;:%s*&quot;,&quot;&quot;),&quot;%b()&quot;,&quot;&quot;)))..tstring
        end
        tmp = fd:read()
    end
  
    fd:close()
  
    return tstring
  end
  ---}}}
  
  ---{{{ popup
  -- displays a naughty notificaiton of the current track
  function popup()
    
    setTitle()
    notdestroy()
  
    local np = {}
    np.state = nil
    np.strng = &quot;&quot;
    if not state() then
        return
    else
        np.strng = &quot;Artist: &quot;..markup.fg(beautiful.fg_normal,trackinfo.artist)..&quot;\n&quot;..
                   &quot;Song:   &quot;..markup.fg(beautiful.fg_normal,trackinfo.songtitle)..&quot;\n&quot;..
                   &quot;Album:  &quot;..markup.fg(beautiful.fg_normal,trackinfo.album)..&quot;\n&quot;
        np.strng = np.strng..markup.fg(beautiful.fg_normal,getTime())
    end
    np.strng = markup.fg( beautiful.fg_focus, markup.font(&quot;monospace&quot;, np.strng..&quot;  &quot;))  
    mocbox = naughty.notify({ 
        title = markup.font(&quot;monospace&quot;,&quot;Now Playing:&quot;),
        text = np.strng, hover_timeout = ( settings.hovertime or 3 ), timeout = 0,
        -- icon = &quot;/usr/share/icons/gnome/24x24/actions/edia-playback-start.png&quot;, icon_size = 24,
          run = function() play(); popup() end
      })
  end
  ---}}}
  
  ---{{{ mocplay() 
  -- easier way to check|run mocp
  function play() 
    if trackinfo.state == &quot;STOP&quot; then
     awful.util.spawn('mocp --play') 
    elseif trackinfo.state == &quot;PLAY&quot; then
      awful.util.spawn('mocp --next')
    else 
      awful.util.spawn('mocp --toggle-pause')
  end
  end
  ---}}}
  
  function setwidget(w)
    settings.widget = w
    awful.hooks.timer.register (settings.interval,scroller)
    state()
  end
  
  ---{{{ function update ( k, v)
  -- called by any kind of external script to trigger widget text update
  function update ( k, v )
    if #k == 0 or #v == 0 then return end
    if trackinfo[k] ~= nil then
        trackinfo[k] = v
    end
    state()
  end
  ---}}}
  
  -- mocp widget, scrolls text
  function scroller(tb)
    local np = {}
  
    -- if mocp is not running, then simply return here
    if trackinfo.state == &quot;OFF&quot; then
        settings.iScroller = 1
        state()
        return
    else
        -- this sets the symbolic prefix based on where moc is playing or stopped or paused
        if trackinfo.state == &quot;PAUSE&quot; then
            prefix = &quot;|| &quot;
            settings.interval = 2
        elseif trackinfo.state == &quot;STOP&quot; then
            settings.iScroller = 1
            settings.widget.width = 20
            settings.widget.text = &quot;[]&quot;
            return
        else
            prefix = &quot;&gt;&gt; &quot;
            settings.interval = 0.75
        end
  
        -- extract a substring, putting it after the 
        np.strng = title()
        np.rtn = string.sub(np.strng,settings.iScroller,settings.MAXCH+settings.iScroller-1) 
  
        -- if our index and settings.MAXCH count are bigger than the string, wrap around to the beginning and
        -- add enough to make it look circular
        if settings.MAXCH+settings.iScroller &gt; (np.strng):len() then
            np.rtn = np.rtn .. string.sub(np.strng,1,(settings.MAXCH+settings.iScroller-1)-np.strng:len())
        end
  
        np.rtn = awful.util.escape(np.rtn)
        settings.widget.text = markup.fg(beautiful.fg_normal,prefix) .. markup.fg(beautiful.fg_sb_hi,np.rtn) 
  
        if settings.iScroller &lt;= np.strng:len() then
            settings.iScroller = settings.iScroller +1
        else
            settings.iScroller = 1
        end
    end
  end
  -- }}}
  

Now in [http://github.com/bioe007/bioe007configs/blob/master/.config/awesome/rc.lua ~/.config/awesome/rc.lua], require(&quot;mocp&quot;) near the top, like any other 'included' script. Then setup mocpwidget similar to this:

  
  mocpwidget = widget({ type = 'textbox', name = 'mocpwidget', align = 'right'})
  mocp.setwidget(mocpwidget)
  mocpwidget:buttons({
    button({ }, 1, function () mocp.play(); mocp.popup() end ),
    button({ }, 2, function () awful.util.spawn('mocp --toggle-pause') end),
    button({ }, 4, function () awful.util.spawn('mocp --toggle-pause') end),
    button({ }, 3, function () awful.util.spawn('mocp --previous'); mocp.popup() end),
    button({ }, 5, function () awful.util.spawn('mocp --previous'); mocp.popup() end)
  })
  mocpwidget.mouse_enter = function() mocp.popup() end
  awful.hooks.timer.register (mocp.settings.interval,mocp.scroller)
  
Also make sure to update your [http://github.com/bioe007/bioe007configs/blob/master/.moc/config ~/.moc/config] OnSongChange and OnStop value to point to the script that will call mocp.lua.

  
  OnSongChange = &quot;/home/perry/.bin/mochg artist %a songtitle %t album %r&quot;
  OnStop = &quot;/home/perry/.bin/mochg&quot;
  

Add to your statusbar wibox the mocpwidget and you should be good.

I tried to liberally comment the above but if its confused you might find me in #awesome (but for that matter there are many helpful people in #awesome anyway). 

'''Thanks:'''

I'd like to thank farhaven for helping me debug this and get the width proper.

'''Notes:''' 
2/17/08: Rewrote this widget to rely on OnSongChange of mocp's config, dramatically reduces resource use.

I use a markup module that can be found on my github so I don't need any ugly formatting inline with my code, you can either remove all the 'markup' references or grab my markup module from github. (also most current version of this widget is on [http://github.com/bioe007/bioe007configs/tree/master github])

[[Category:Awesome3]]</text>
      <sha1>fkddif99cv43h5seypgbjlyalhch0ns</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bitcoin Price Widget</title>
    <ns>0</ns>
    <id>905</id>
    <revision>
      <id>7385</id>
      <parentid>7383</parentid>
      <timestamp>2015-11-05T21:21:27Z</timestamp>
      <contributor>
        <username>Cwsmith</username>
        <id>4307</id>
      </contributor>
      <comment>/* blockchain.info Linegraph and Textbox */</comment>
      <text xml:space="preserve" bytes="5221">== MtGox Textbox ==

This widget places the current MtGox bitcoin price in USD as a widget in your taskbar.  It refreshes every 5 minutes.  Hope you enjoy.

You'll need to put [[http://chiselapp.com/user/dhkolf/repository/dkjson/home]] somewhere where bitcoin_widget can find it.

  -- Builds an mtgox backed ticker for the bitcoin price
  json = require (&quot;dkjson&quot;)
  vicious = require(&quot;vicious&quot;)
  
  local price = &quot;n/a&quot;
  
  -- call the Bitcoin API, expecting JSON in return
  local function get_json()
     bitcoin_url = &quot;https://mtgox.com/api/1/BTCUSD/ticker&quot;
     -- get the visitors and actions for today
     command = 'curl -m 5 -s &quot;'..bitcoin_url..'&quot;'
     f = io.popen(command)
     if (not f) then return 0 end
     -- store the returned json as a string
     return f:read(&quot;*all&quot;)
  end
  
  -- parse the JSON from Bitcoin
  local function parse_json(j)
     local obj, pos, err = json.decode (j, 1, nil)
     if err then
        return &quot;Err&quot;
     else
        return obj[&quot;return&quot;] -- obj[&quot;return&quot;][&quot;sell&quot;][&quot;display_short&quot;]
     end
  end
  
  -- the widget updater worker
  function worker(format, warg)
     dat = parse_json(get_json())
     if type(dat) == type(&quot;&quot;) then
        return string.format(format, dat, dat)
     else
        return string.format(format, dat[&quot;buy&quot;][&quot;display_short&quot;],
                                     dat[&quot;sell&quot;][&quot;display_short&quot;])
     end
  end
  
  -- init the widget
  bitcoinwidget = wibox.widget.textbox()
  vicious.register(bitcoinwidget, worker, '&lt;span background=&quot;#313131&quot; font=&quot;Terminus 13&quot; rise=&quot;2000&quot;&gt;&lt;span font=&quot;Terminus 9&quot; color=&quot;#EEDDDD&quot;&gt;BTC&lt;/span&gt; &lt;span font=&quot;Terminus 9&quot; color=&quot;#7AC82E&quot;&gt;%s&lt;/span&gt; &lt;span font=&quot;Terminus 7&quot; color=&quot;#EEDDDD&quot;&gt;↓↑&lt;/span&gt; &lt;span font=&quot;Terminus 9&quot; color=&quot;#46A8C3&quot;&gt;%s &lt;/span&gt;&lt;/span&gt;', 10)

Hope someone finds this useful. Code adapted from [[http://www.robsearles.com/2011/04/06/awesome-wm-clicky-widget/]]

== bitcoinaverage.com Textbox ==

Here's a version which
* uses latest price from bitcoinaverage.com instead of emptygox
* uses EUR instead of USD
* uses mBTC instead of BTC
* works with awesome 3.4 on Ubuntu 13.04

  -- Builds a BitcoinAverage backed ticker for the bitcoin price
  json = require (&quot;dkjson&quot;)
  vicious = require(&quot;vicious&quot;)
  
  local price = &quot;n/a&quot;
  
  -- call the BitcoinAverage API, expecting JSON in return
  local function get_json()
     bitcoin_url = &quot;https://api.bitcoinaverage.com/ticker/global/EUR/&quot;
     -- get the visitors and actions for today
     command = 'curl -m 5 -s &quot;'..bitcoin_url..'&quot;'
     f = io.popen(command)
     if (not f) then return 0 end
     -- store the returned json as a string
     return f:read(&quot;*all&quot;)
  end
  
  -- parse the JSON from Bitcoin
  local function parse_json(j)
     local obj, pos, err = json.decode (j, 1, nil)
     if err then
        return &quot;Err&quot;
     else
        return obj
     end
  end
  
  -- the widget updater worker
  function worker(format, warg)
     dat = parse_json(get_json())
     if type(dat) == type(&quot;&quot;) then
        return string.format(format, dat, dat)
     else
        return string.format(format, 
                             math.floor(dat[&quot;bid&quot;]) / 1000.0,
                             math.floor(dat[&quot;ask&quot;]) / 1000.0)
     end
  end
  
  -- init the widget
  bitcoinwidget = widget({type=&quot;textbox&quot;, name=&quot;bitcoinwidget&quot;, align=&quot;right&quot;})
  vicious.register(bitcoinwidget, worker, '€/m฿ %s ↓↑ %s ', 10)


=== blockchain.info Linegraph and Textbox  ===

The following widget uses the awesome 3.5 and the [[Blingbling]] widget library to plot a line graph of the BTC price in USD.

[[File:BtcLinegraphAndTextbox.png|700px]]

Create the widgets
&lt;pre&gt;
local bb = require(&quot;blingbling&quot;) -- for fancy graphs
-- the widget updater worker
function getPrice()
   bitcoin_url = &quot;https://blockchain.info/q/24hrprice&quot;
   command = 'curl -m 2 -s &quot;'..bitcoin_url..'&quot;'
   f = io.popen(command)
   if (f) then
     price = f:read()
     f:close()
     return tonumber(price)
   else
     return nil
   end
end
-- convert prices to plot values between 0 and 1
function getPlotVal(min,max,price)
  b = -min/(max-min)
  m = 1/(max-min)
  return m*price+b
end
-- init the widget
btcPriceText = wibox.widget.textbox()
btcPriceGraph = bb.line_graph({width = 300,
                               show_text = true,
                               label = &quot;BTC(USD)&quot;,
                               rounded_size = 0.3 
                             })
maxBtcPrice = 0 
minBtcPrice = math.maxinteger
avgBtcPrice = 0 
btcTimer = timer({ timeout = 5 })
btcTimer:connect_signal(&quot;timeout&quot;,
function()
  price = getPrice()
  if ( price ~= nil ) then
    if ( price &gt; maxBtcPrice ) then
      maxBtcPrice = price
    end 
    if ( price &lt; minBtcPrice ) then
      minBtcPrice = price
    end 
    val = getPlotVal(minBtcPrice,maxBtcPrice,price)
    s = string.format(&quot;Now %.2f Max %.2f Min %.2f&quot;, price, maxBtcPrice,
minBtcPrice)
    btcPriceText:set_text(s)
    -- line_graph wants the values to be between 0 and 1
    btcPriceGraph:add_value(val)
  end 
end)
btcTimer:start()
&lt;/pre&gt;

Then add the widgets to the layout.
&lt;pre&gt;
    local left_layout = wibox.layout.fixed.horizontal()
    left_layout:add(btcPriceGraph)
    left_layout:add(btcPriceText)
&lt;/pre&gt;</text>
      <sha1>jbx82kzeohc56igmwi7d8bqeb4w753x</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Blingbling</title>
    <ns>0</ns>
    <id>734</id>
    <revision>
      <id>7462</id>
      <parentid>7461</parentid>
      <timestamp>2016-03-21T12:13:40Z</timestamp>
      <contributor>
        <username>Cedlemo</username>
        <id>719</id>
      </contributor>
      <comment>/* Dependencies */</comment>
      <text xml:space="preserve" bytes="19233">{{Languages}}

==Blingbling:==

Blingbling is a graphical widget library for Awesome Windows Manager. The goal of the Blingbling library is to provide more fancy, customisable and easy to setup graphical widgets, popups or signals for Awesome WM. Originally, I have written Blingbling for myself but I share it with the hope that it could interest someone. Testers, feedbacks  and suggestions are welcome! 

At this moment, the current version of blingbling is the v2.2. The next version, the v2.3, is the master branch on the github repository. There are two main versions: 

* the  v1.0 works for awesome 3.4.10 and 3.4.11. ( I don't maintain it anymore)
* the v2.* which works with awesome version &gt;= 3.5.

==Dependencies==
* Blingbling v2.*
The version 2 of blingbling uses lgi so if you have a working Awesome WM v3.5 it should work without any other dependencies.

* Blingbling v1.0
Blingbling requires oocairo. The address of the website of the project is : http://oocairo.naquadah.org.

Check you package manager to see if you can install an already packaged version of oocairo for your system.
  
For example on Archlinux:
  yaourt -S lua-oocairo-git

To install oocairo on Ubuntu
  $ mkdir temp
  $ cd temp
  # apt-get -b source oocairo
  # dpkg -i liblua5.1-oocairo0_1.4-1.2_amd64.deb
  # dpkg -i liblua5.1-oocairo-dev_1.4-1.2_amd64.deb
  $ cd ..
  $ rm -r temp


If you don't find an already packaged version of oocairo, you can install it from the source:

  git clone git://git.naquadah.org/oocairo.git
  cd oocairo*

and see the readme file for installation instructions.

==Installation==
* Blingbling v2.2
($XDG_CONFIG_HOME usually ~/.config)
With Git:

    cd $XDG_CONFIG_HOME/awesome/
    git clone git://github.com/cedlemo/blingbling.git
    cd blingbling
    git checkout v2.2

Download with command line tools

    cd $XDG_CONFIG_HOME/awesome/
    wget https://github.com/cedlemo/blingbling/archive/v2.2.zip
    unzip v2.2.zip blingbling

Download with your browser

go to : https://github.com/cedlemo/blingbling/tree/v2.2


* Blingbling v1.0
Two possibilities:

  cd $XDG_CONFIG_HOME/awesome/
  wget https://github.com/cedlemo/blingbling/archive/v1.0.zip
  unzip v1.0.zip

or
  cd $XDG_CONFIG_HOME/awesome/
  git clone git://github.com/cedlemo/blingbling.git
  cd blingbling
  git checkout v1.0

==Usage== 
===Blingbling v2.3===
(In progress)

* line_graph
* progress_graph
* triangular_progress_graph
* value_text_box
* volume
* popups
* net
* task_warrior
* udisks_glue
* system
* clock
* tagslist
* text_box
* calendar (new)
* extended_calendar (new)
* grid (new)
* transient

See https://github.com/cedlemo/blingbling. A lot of configuration files can be find  in the config_example directory.
In the doc directory there is an exhaustive documentation that I try to keep up to date, just open the index.html file.

===Blingbling v2.2===

* line_graph
* progress_graph
* triangular_progress_graph
* value_text_box
* volume
* popups
* net
* task_warrior
* udisks_glue
* system
* clock
* tagslist
* text_box
* calendar
* transient

===Blingbling v1.0===

You can easily configure the widgets, see the README file for all informations. 

====Blingbling provides:====

*'''Value text box''': 
:This is a text box that can get a value between 0 and 1 and display it as text (like classical textbox widget in awesome). The difference with this widget, is that user can display a colored background with rounded corner (or not) behind the text. Furthermore user can set different colors to display the value (not all the text). ( 30&gt;value&lt; 70 set text color as green, value &gt; 70% set text color as red for example).
*'''Classical graph'''(v1 and v2 line_graph): 
:looks like the graph widget of Awesome but with tranparency and text support and more method  to customize it.
*'''Tiled graph''': 
:like classical graph but value are displayed with tiles
*'''Progress graph''': 
:looks like the progress bar of Awesome but with tranparency and text support and more method  to customize it. Can increase/decrease horizontaly or verticaly.
*'''Progress bar''': 
:like progress graph but graph is displayed on a cylinder.
*'''Volume graph''': 
:widget that display a value using a triangle or for bars with tranparency and text support. Can autoupdate on the master or mpd volume.
*'''Mpd widget''': 
:widget dedicated to mpd. It's read the a fifo generated by mpd and display a graph based on the pcm output. It can displays informations on current song, mpd state and can be bind with mpc command(volume +/-, next song, toggle stop/play). 
*'''Net widget''': 
:widget that can display information on the internet connection of a device (upload/download) with arrows and text. Popup with information like ip address, gateway ip address, external ip adress and external tor ip address can be bind to it.
*'''Top popup''': 
:(doesn't need oocairo) popup, displaying colorized top output, that can be bind to any widget. Number of line of top output can be dynamically increase/decrease with mouse wheel up /wheel down
*'''Netstat popup''': 
:(doesn't need oocairo) poup, displaying colorized netstat output, that can be bind to any widget.
*'''System shutdown/Reboot button''': 
:(doesn't need oocairo) button that display a dialog menu for rebooting or shuting down the system. You need to an have active  console kit session. 
*'''Udisks-glue widget menu''': 
:(doesn't need oocairo) with a custom .udisks-glue.conf and this widget, you can have a menu linked to an icon that display dynamically devices handled by udisks-glue. This menu allows you to mount, unmount, detach or eject devices. Each event generate a popup displaying the type of device, the mount point and the action that have generated the popup (mount, unmount or remove device)
*'''Menu widget''':
:This widget is based on the original menu widget from awful. With this menu, width of menus or submenus is auto-adjusted.  There is no fixed width.
*'''Task warrior widget''':
:Task warrior widget is an basic interface for task warrior (http://taskwarrior.org/projects/show/taskwarrior). The goal is to provide a quick way to see active projects and tasks and to provide basic management of tasks or project (just set task done for the moment).
*'''Table widget layout''':
:This layout, when used in a wibox, allow users to display widgets like in a table. 
*'''Calendar widget''':
:It's a wibox that display a calendar of the current month with widgets. By default, you have two buttons for displaying next and previous month. Furthermore, you can see events of a day (from task warrior and remind by default) in a menu when the mouse pass on a day. Users can easily add or remove functions that get events from external applications.

====examples of value text box widgets: ====

[[File:Blingbling_value_text_box_example.png]]
  
  --First widget on the left (the configurations for the other widgets are the same)
  my_fs=blingbling.value_text_box.new()
  my_fs:set_height(18)
  my_fs:set_width(40)
  my_fs:set_v_margin(2)
  my_fs:set_filled(true)
  my_fs:set_filled_color(&quot;#00000099&quot;)
  my_fs:set_values_text_color(&lt;nowiki&gt;{{&quot;#88aa00ff&quot;,0}, --all value &gt; 0 will be displaying using this color
                              {&quot;#d4aa00ff&quot;, 0.75},
                              {&quot;#d45500ff&quot;,0.77}}&lt;/nowiki&gt;)
 --There is no maximum number of color that users can set, just put the lower values at first. 
  my_fs:set_default_text_color(beautiful.textbox_widget_as_label_font_color)
  my_fs:set_rounded_size(0.4)
  my_fs:set_background_color(&quot;#00000044&quot;)
  my_fs:set_label(&quot;usage: $percent %&quot;)
  vicious.register(my_fs, vicious.widgets.fs, &quot;${/home used_p}&quot;, 120)

====examples of classical graph, progress graph and netwidget: ====

[[File:Example 1.png]]

  require(&quot;blingbling&quot;)
  --
  cpulabel= widget({ type = &quot;textbox&quot; })
  cpulabel.text='&lt;span color=&quot;'..beautiful.textbox_widget_as_label_font_color..'&quot; '..pango_small..' '..pango_bold..'&gt;CPU: &lt;/span&gt;'
  --
  mycairograph=blingbling.classical_graph.new()
  mycairograph:set_height(18)
  mycairograph:set_width(360)
  mycairograph:set_tiles_color(&quot;#00000022&quot;)
  mycairograph:set_show_text(true)
  mycairograph:set_label(&quot;Load: $percent %&quot;)
  --
  --bind top popup on the graph
  blingbling.popups.htop(mycairograph.widget,
        { title_color =beautiful.notify_font_color_1, 
           user_color= beautiful.notify_font_color_2, 
           root_color=beautiful.notify_font_color_3, 
           terminal = &quot;urxvt&quot;})
 vicious.register(mycairograph, vicious.widgets.cpu,'$1',2)
  --
  memwidget=blingbling.classical_graph.new()
  memwidget:set_height(18)
  memwidget:set_width(200)
  memwidget:set_tiles_color(&quot;#00000022&quot;)
  memwidget:set_show_text(true)
  vicious.register(memwidget, vicious.widgets.mem, '$2', 2)
  --
  mycore1=blingbling.progress_graph.new()
  mycore1:set_height(18)
  mycore1:set_width(6)
  mycore1:set_filled(true)
  mycore1:set_h_margin(1)
  mycore1:set_filled_color(&quot;#00000033&quot;)
  vicious.register(mycore1, vicious.widgets.cpu, &quot;$2&quot;)
  -- 
  mycore2=blingbling.progress_graph.new()
  --
  --
  mycore4=blingbling.progress_graph.new()
  --
  --
  memlabel= widget({ type = &quot;textbox&quot; })
  memlabel.text='&lt;span color=&quot;'..beautiful.textbox_widget_as_label_font_color..'&quot; '..pango_small..'&gt;MEM: &lt;/span&gt;'
  memwidget=blingbling.classical_graph.new()
  memwidget:set_height(18)
  memwidget:set_width(200)
  memwidget:set_tiles_color(&quot;#00000022&quot;)
  memwidget:set_show_text(true)
  vicious.register(memwidget, vicious.widgets.mem, '$2', 2)
  --
  netwidget = widget({ type = &quot;textbox&quot;, name = &quot;netwidget&quot; })
  netwidget.text='&lt;span '..pango_small..'&gt;&lt;span color=&quot;'..beautiful.textbox_widget_as_label_font_color..'&quot;&gt;NET:&lt;/span&gt;&lt;/span&gt;'
  --bind nestat popup on textbox 
  blingbling.popups.netstat(netwidget,{ title_color = beautiful.notify_font_color_1, established_color= beautiful.notify_font_color_3, listen_color=beautiful.notify_font_color_2})
 --
  my_net=blingbling.net.new()
  my_net:set_height(18)
  --activate popup with ip informations on the net widget
  [[File:Blingbling_Example_4.png]]
  my_net:set_ippopup()
  my_net:set_show_text(true)
  my_net:set_v_margin(3)

[[File:Blingbling_rounded_corner_and_popup_example.png|200px|thumb]]

  mycairograph=blingbling.classical_graph.new()
  mycairograph:set_height(18)
  mycairograph:set_width(360)
  mycairograph:set_show_text(true)
  mycairograph:set_label(&quot;Load: $percent %&quot;)
  mycairograph:set_rounded_size(0.4)
  mycairograph:set_filled(true)
  mycairograph:set_filled_color(&quot;#00000033&quot;)
  vicious.register(mycairograph, vicious.widgets.cpu,'$1',2)
  --bind a top popup on the graph 
  blingbling.popups.htop(mycairograph.widget,
                        { title_color =beautiful.notify_font_color_1, 
                          user_color= beautiful.notify_font_color_2, 
                          root_color=beautiful.notify_font_color_3, 
                          terminal = &quot;urxvt&quot;})
  --
  mycore1=blingbling.progress_graph.new()
  mycore1:set_height(18)
  mycore1:set_width(20)
  mycore1:set_filled(true)
  mycore1:set_h_margin(1)
  mycore1:set_filled_color(&quot;#00000033&quot;)
  mycore1:set_show_text(true)
  mycore1:set_label(&quot;$percent&quot;)
  mycore1:set_rounded_size(0.4)
  vicious.register(mycore1, vicious.widgets.cpu, &quot;$2&quot;)
  --
  mycore2=blingbling.progress_graph.new()
  --same as mycore1
  mycore3=blingbling.progress_graph.new()
  --same as mycore1
  mycore4=blingbling.progress_graph.new()
  --same as mycore1

====examples of tiled graph: ====

[[File:Blingbling_Example_3.png]]

  mycairograph=blingbling.tiled_graph.new()
  mycairograph:set_height(18)
  mycairograph:set_width(360)
  mycairograph:set_tiles_color(&quot;#00000022&quot;)
  mycairograph:set_show_text(true)
  mycairograph:set_label(&quot;Load: $percent %&quot;)

====examples of progress bar and progress graph: ====

[[File:Blingbling_example_2.png]]

  my_fs=blingbling.progress_bar.new()
  my_fs:set_height(18)
  my_fs:set_width(40)
  my_fs:set_show_text(true)
  my_fs:set_horizontal(true)  
  --  
  my_fs_root=blingbling.progress_bar.new() 
  my_fs_root:set_height(18)
  my_fs_root:set_width(40)
  my_fs_root:set_v_margin(2)
  my_fs_root:set_show_text(true)
  my_fs_root:set_horizontal(true)
  --
  my_fs_data0=blingbling.progress_graph.new()
  my_fs_data0:set_height(18)
  my_fs_data0:set_width(40)
  my_fs_data0:set_show_text(true)
  my_fs_data0:set_horizontal(true)
  my_fs_data0:set_filled(true)
  --
  my_fs_data1=blingbling.progress_bar.new()
  my_fs_data1:set_height(18)
  my_fs_data1:set_width(40)
  my_fs_data1:set_show_text(true)
  my_fs_data1:set_horizontal(true)
  my_fs_data1:set_filled(true)

[[file:Blingbling_progress_bar.png]]

  my_fs=blingbling.progress_bar.new()
  my_fs:set_height(18)
  my_fs:set_width(40)
  my_fs:set_show_text(true)
  my_fs:set_horizontal(true)
  --
  my_fs_root=blingbling.progress_bar.new()
  my_fs_root:set_height(18)
  my_fs_root:set_width(40)
  my_fs_root:set_show_text(true)
  my_fs_root:set_horizontal(false)
  --
  my_fs_data0=blingbling.progress_bar.new()
  my_fs_data0:set_height(18)
  my_fs_data0:set_width(40)
  my_fs_data0:set_show_text(true)
  my_fs_data0:set_horizontal(false)
  -- 
  my_fs_data1=blingbling.progress_bar.new()
  my_fs_data1:set_height(18)
  my_fs_data1:set_width(40)
  my_fs_data1:set_show_text(true)
  my_fs_data1:set_horizontal(true)

====examples of volume bar and mpd visualizer: ====

[[File:Blingbling_Example_5.png]]
  mpdlabel= widget({ type = &quot;textbox&quot; })
  mpdlabel.text='&lt;span color=&quot;'..beautiful.textbox_widget_as_label_font_color..'&quot; '..pango_small..'&gt;MPD: &lt;/span&gt;'
  --
  my_mpd_volume=blingbling.volume.new()
  my_mpd_volume:set_height(18)
  my_mpd_volume:set_width(30)
  --bind the volume graph on mpd  
  my_mpd_volume:update_mpd()
  --use bar, default is a triangle
  my_mpd_volume:set_bar(true)
  --
  my_mpd=blingbling.mpd_visualizer.new()
  my_mpd:set_height(18)
  my_mpd:set_width(350)
  my_mpd:update()
  --display pcm graph with a line
  my_mpd:set_line(true)
  my_mpd:set_h_margin(4)
  --bind mpc commands on the widget
  my_mpd:set_mpc_commands()
  --Show the artist name and the current song
  my_mpd:set_show_text(true)
  my_mpd:set_label(&quot;$artist &gt; $title&quot;)
  --
  my_volume=blingbling.volume.new()
  my_volume:set_height(18)
  my_volume:set_width(30)
  --bind the volume widget on the master channel
  my_volume:update_master()
  my_volume:set_master_control()
  my_volume:set_bar(true)

====example of reboot button: ====

[[File:Blingbling_system_reboot.png]]
  reboot=blingbling.system.rebootmenu(beautiful.reboot, beautiful.dialog_ok,     beautiful.dialog_cancel)

====example of udisks-glue menu: ====

[[File:Blingbling_udisks-glue_menu.png]] [[File:Blingbling_udisks-glue_menu_mount_command.png]]

[[File:Blingbling_udisks-glue_menu_unmount_command.png]] [[File:Blingbling_udisks-glue_menu_cannot_eject.png]] [[File:Blingbling_udisks-glue_menu_can_eject.png]]

  udisks_glue=blingbling.udisks_glue.new(beautiful.dialog_ok)
  udisks_glue:set_mount_icon(beautiful.dialog_ok)
  udisks_glue:set_umount_icon(beautiful.dialog_cancel)
  udisks_glue:set_detach_icon(beautiful.dialog_cancel)
  udisks_glue:set_Usb_icon(beautiful.usb_icon)
  udisks_glue:set_Cdrom_icon(beautiful.cdrom_icon)

The udisks-glue.conf used:
  filter disks {
             optical = false
             partition_table = false
             usage = filesystem
  }
  filter optical {
            optical = true
  }
  match disks {
           automount = true
           automount_options = sync
           post_mount_command = &quot;echo \'udisks_glue:mount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Usb\&quot;)\' | awesome-client&quot;
           post_unmount_command = &quot;echo \'udisks_glue:unmount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Usb\&quot;)\' | awesome-client&quot;
           post_removal_command = &quot;echo \'udisks_glue:remove_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Usb\&quot;)\' | awesome-client&quot;
  }
  match optical {
          automount = true
          automount_options = ro
          post_mount_command = &quot;echo \'udisks_glue:mount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Cdrom\&quot;)\' | awesome-client&quot;
          post_unmount_command = &quot;echo \'udisks_glue:unmount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Cdrom\&quot;)\' | awesome-client&quot;
          post_removal_command = &quot;echo \'udisks_glue:remove_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Cdrom\&quot;)\' | awesome-client&quot;
  }
====example of task warrior widget (it uses blingbling version of the menu widget): ====

[[File:Blingbling_task_warrior_menu.png]]

  task_warrior=blingbling.task_warrior.new(beautiful.tasks_icon)
  task_warrior:set_task_done_icon(beautiful.task_done_icon)
  task_warrior:set_task_icon(beautiful.task_icon)
  task_warrior:set_project_icon(beautiful.project_icon)

====example of Table widget layout ====
This example is the blingbling calendar widget (when not finished). It uses the array layout:

[[File:Blingbling_table_layout.png]]

  calendarbox.widgets={
  {displayed_month_and_year, layout = blingbling.layout.array.line_center },
  {day_widgets[1], day_widgets[2], day_widgets[3], day_widgets[4],
  day_widgets[5], day_widgets[6], day_widgets[7], layout =blingbling.layout.array.line_center},
  {days_of_month[1],days_of_month[2], days_of_month[3], days_of_month[4],
  days_of_month[5],days_of_month[6],days_of_month[7],layout =blingbling.layout.array.line_center},
  {days_of_month[8],days_of_month[9], days_of_month[10], days_of_month[11],
  days_of_month[12],days_of_month[13],days_of_month[14],layout =blingbling.layout.array.line_center},
  {days_of_month[15],days_of_month[16], days_of_month[17], days_of_month[18],
  days_of_month[19],days_of_month[20],days_of_month[21],layout =blingbling.layout.array.line_center},
  {days_of_month[22],days_of_month[23], days_of_month[24], days_of_month[25],
  days_of_month[26],days_of_month[27],days_of_month[28],layout =blingbling.layout.array.line_center},
  {days_of_month[29],days_of_month[30], days_of_month[31], days_of_month[32],
  days_of_month[33],days_of_month[34],days_of_month[35],layout =blingbling.layout.array.line_center},
  layout = blingbling.layout.array.stack_lines
  }

====example of Calendar widget ====
[[File:Blingbling_calendar_basic.png]]

  my_cal =blingbling.calendar.new({type = &quot;imagebox&quot;, image = beautiful.calendar_icon})
  --you can set blingbling.calendar.new({type = &quot;textbox&quot;, text = &quot;calendar&quot;}) if you prefer a textbox
  my_cal:set_cell_padding(4)
  my_cal:set_columns_lines_titles_text_color(beautiful.text_font_color_2)
  my_cal:set_title_text_color(beautiful.bg_focus)
  --with only this you have a calendar  with 2 buttons (next and previous month)

[[File:Blingbling_calendar_remind.png|400px]]  [[File:Blingbling_calendar_task.png|400px]]

Menu appears when you pass your mouse on a day.Switch between events from remind and task warrior (and all events you had) is done with mouse wheel (up/down).

  my_cal =blingbling.calendar.new({type = &quot;imagebox&quot;, image = beautiful.calendar_icon})
  my_cal:set_cell_padding(4)
  my_cal:set_columns_lines_titles_text_color(beautiful.text_font_color_2)
  my_cal:set_title_text_color(beautiful.bg_focus)
  my_cal:set_link_to_external_calendar(true)
  --This last line activate the functions that get events for a day from remind or task warrior (you can remove them and add your own)</text>
      <sha1>nkncanvo4lnlg5gvfrmoesaflz37ev7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Blingbling/ru</title>
    <ns>0</ns>
    <id>1105</id>
    <revision>
      <id>6722</id>
      <timestamp>2014-06-07T16:35:43Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Blingbling (translating page)</comment>
      <text xml:space="preserve" bytes="22826">{{Languages|Blingbling}}

==Описание Blingbling==

Blingbling это графическая библиотека виджетов для оконного менеджера Awesome. Целью библиотеки Blingbling является обеспечение больше фееричности, настраиваемости и легкости для настройки графических виджетов, всплывающих окон или сигналов в Awesome. Изначально Blingbling писался для личного использования, но я делюсь им с вами, в надежде, что кому то может быть это интересно. Тестеры, обратная связь и предложения приветсвуются!

На данный момент Blingbling существует в 2 версиях. 

* версия v1.0 работает с awesome версий 3.4 (на данный момент только поддержка, но не развитие)
* версия v2.0 которая работает с awesome версий 3.5.

==Зависимости==
* Blingbling v2.0
Версия 2 Blingbling использует lgi, так что если у вас есть уже работающий Awesome WM v3.5 она будет работать без каких либо дополнительных зависимостей.

* Blingbling v1.0
Эта версия Blingbling требует oocairo. Адрес сайта проекта : http://oocairo.naquadah.org.

Проверьте ваш менеджер пакетов, возможно уже есть пакет oocairo доступный для вашей системы.
  
Например в Archlinux:
  yaourt -S lua-oocairo-git

Для установки oocairo в Ubuntu
  $ mkdir temp
  $ cd temp
  # apt-get -b source oocairo
  # dpkg -i liblua5.1-oocairo0_1.4-1.2_amd64.deb
  # dpkg -i liblua5.1-oocairo-dev_1.4-1.2_amd64.deb
  $ cd ..
  $ rm -r temp


Если вы не можете найти готовый пакет oocairo для вашей системы, вы можете установить его из исходников:

  git clone git://git.naquadah.org/oocairo.git
  cd oocairo*

Затем прочтите файл readme, в нем находятся инструкции по установке.

==Установка==
*Blingbling v2.0
($XDG_CONFIG_HOME usually ~/.config)
  
  cd $XDG_CONFIG_HOME/awesome/
  git clone git://github.com/cedlemo/blingbling.git

*Blingbling v1.0
Существует 2 способа:

  cd $XDG_CONFIG_HOME/awesome/
  wget https://github.com/cedlemo/blingbling/archive/v1.0.zip
  unzip v1.0.zip

или
  cd $XDG_CONFIG_HOME/awesome/
  git clone git://github.com/cedlemo/blingbling.git
  cd blingbling
  git checkout v1.0

==Использование== 
(В процессе разработки автором)

===Blingbling v2.0===
Смотрите https://github.com/cedlemo/blingbling и мой текущий файл конфигурации и темы https://github.com/cedlemo/blingbling/tree/master/config_example

===Blingbling v1.0===

Вы можете легко настроить виджеты, для этого смотрите файл README. 

====Blingbling предоставляет:====

*'''Value text box''': 
:Это текстовое поле, которе может принимать значения между 0 и 1, и отобразить его как текст (как обычный виджет textbox в Awesome). Различие с этим класическим виджетом заключается в том, что пользователь может отобразить текст с цветным фоном имеющим закругленные (или обычные) края. Кроме того, пользователь может устанавливать различные цвета для отображения значения (не на весь текст). Например, 30&gt;значение&lt;70 установит зеленый цвет текста, &gt;70% цвет текста будет красным.
*'''Classical graph'''(v1 и v2 line_graph): 
:Выглядит как виджет graph  в Awesome, но с поддержкой прозрачности и текста на нем, а также множества методов для его настройки.
*'''Tiled graph''': 
:Выглядит как обычный graph, но значение отображается с плиткой
*'''Progress graph''': 
:Выглядит как progress bar в Awesome, но с поддержкой прозрачности и текста на нем, а также множества методов для его настройки. Может увеличиваться/уменьшаться по горизонтали или вертикали.
*'''Progress bar''': 
:Выглядит как progress graph, но graph отображается в виде цилиндра.
*'''Volume graph''': 
:Виджет, который отображает значение используя треугольник или столбиков с поддержкой прозрачности и текста. Может автоматически обновляться для Master или MPD звука.
*'''Mpd widget''': 
:Виджет посвященный MPD. Он считывает FIFO генерируемым MPD и отображает graph основанный на выводе PCM. Он может оботражать следующую информацию: текущую песню, состояние MPD и может быть связан с командами mpc (громкость +/-, следующий трек, переключение stop/play). 
*'''Net widget''': 
:Виджет который может отображать информацию по интернет соединению (upload/download) со стрелками и текстом. Всплывающее уведомление с информацией, например ip-адресом, ip-адрес шлюза, внешний ip адрес и внешний tor ip адрес может быть привязан к нему.
*'''Top popup''': 
:(не требует oocairo) Всплывающее уведомление, имеющее цветной вывод, может быть привязано к любому виджету. Количество строк в верхнем выводе может быть динамически увеличено/уменьшено с помощью колеса мыши
*'''Netstat popup''': 
:(не требует oocairo) Всплывающе уведомление, отображающее раскрашенную статистику сети, которая может быть привязана к любому виджету.
*'''System shutdown/Reboot button''': 
:(не требует oocairo) Кнопка, которая отображает диалоговое меню для перезагрузки или завершения работы системы. Вам необходимо иметь активированную сессию console kit. 
*'''Udisks-glue widget menu''': 
:(не требует oocairo) С пользовательским udisks-glue.conf и этим виджетом, вы можете привязать меню к иконке, которая динамически отображает устройства подключенные udisks-glue. Это меню позволяет вам монтировать, отмонтировать, отсоединять или извлекать устройства. Каждое событие генерирует уведомление отображающее тип устройства, точку монтирования и действие, которое породило это уведомление (mount, unmount или remove device)
*'''Menu widget''':
:Этот виджет основан на оригинальном виджете меню из awful. В этом меню ширина самого меню или его подменю является автоматически настраиваемой. Он не имеет фиксированной ширины.
*'''Task warrior widget''':
:Task warrior widget это базовый интерфейс для task warrior (http://taskwarrior.org/projects/show/taskwarrior). Целью виджета является обеспечение быстрого способа посмотреть активные проекты и задачи, и обеспечить основное управление задачами или проектами (просто моментально устанавливает задание выполненным).
*'''Table widget layout''':
:Этот layout, при использовании в wibox, позволяет пользователям отображать виджеты как в таблице.
*'''Calendar widget''':
:Этот wibox отображает календарь текущего месяца с помощью виджета. По умолчанию у вас есть две кнопки для переключения на предыдущий и следующий месяц. Кроме того, вы можете просмотреть события для какого либо дня (из task warrior и напоминания по умолчанию) в меню, когда мышь находится над этим днем. Пользователи могут легко добавить или удалить функции, для получения события из внешних приложений. 

====Пример значений виджета text box: ====

[[File:Blingbling_value_text_box_example.png]]
  
  --First widget on the left (the configurations for the other widgets are the same)
  my_fs=blingbling.value_text_box.new()
  my_fs:set_height(18)
  my_fs:set_width(40)
  my_fs:set_v_margin(2)
  my_fs:set_filled(true)
  my_fs:set_filled_color(&quot;#00000099&quot;)
  my_fs:set_values_text_color(&lt;nowiki&gt;{{&quot;#88aa00ff&quot;,0}, --all value &gt; 0 will be displaying using this color
                              {&quot;#d4aa00ff&quot;, 0.75},
                              {&quot;#d45500ff&quot;,0.77}}&lt;/nowiki&gt;)
 --There is no maximum number of color that users can set, just put the lower values at first. 
  my_fs:set_default_text_color(beautiful.textbox_widget_as_label_font_color)
  my_fs:set_rounded_size(0.4)
  my_fs:set_background_color(&quot;#00000044&quot;)
  my_fs:set_label(&quot;usage: $percent %&quot;)
  vicious.register(my_fs, vicious.widgets.fs, &quot;${/home used_p}&quot;, 120)

====Пример classical graph, progress graph и netwidget: ====

[[File:Example 1.png]]

  require(&quot;blingbling&quot;)
  --
  cpulabel= widget({ type = &quot;textbox&quot; })
  cpulabel.text='&lt;span color=&quot;'..beautiful.textbox_widget_as_label_font_color..'&quot; '..pango_small..' '..pango_bold..'&gt;CPU: &lt;/span&gt;'
  --
  mycairograph=blingbling.classical_graph.new()
  mycairograph:set_height(18)
  mycairograph:set_width(360)
  mycairograph:set_tiles_color(&quot;#00000022&quot;)
  mycairograph:set_show_text(true)
  mycairograph:set_label(&quot;Load: $percent %&quot;)
  --
  --bind top popup on the graph
  blingbling.popups.htop(mycairograph.widget,
        { title_color =beautiful.notify_font_color_1, 
           user_color= beautiful.notify_font_color_2, 
           root_color=beautiful.notify_font_color_3, 
           terminal = &quot;urxvt&quot;})
 vicious.register(mycairograph, vicious.widgets.cpu,'$1',2)
  --
  memwidget=blingbling.classical_graph.new()
  memwidget:set_height(18)
  memwidget:set_width(200)
  memwidget:set_tiles_color(&quot;#00000022&quot;)
  memwidget:set_show_text(true)
  vicious.register(memwidget, vicious.widgets.mem, '$2', 2)
  --
  mycore1=blingbling.progress_graph.new()
  mycore1:set_height(18)
  mycore1:set_width(6)
  mycore1:set_filled(true)
  mycore1:set_h_margin(1)
  mycore1:set_filled_color(&quot;#00000033&quot;)
  vicious.register(mycore1, vicious.widgets.cpu, &quot;$2&quot;)
  -- 
  mycore2=blingbling.progress_graph.new()
  --
  --
  mycore4=blingbling.progress_graph.new()
  --
  --
  memlabel= widget({ type = &quot;textbox&quot; })
  memlabel.text='&lt;span color=&quot;'..beautiful.textbox_widget_as_label_font_color..'&quot; '..pango_small..'&gt;MEM: &lt;/span&gt;'
  memwidget=blingbling.classical_graph.new()
  memwidget:set_height(18)
  memwidget:set_width(200)
  memwidget:set_tiles_color(&quot;#00000022&quot;)
  memwidget:set_show_text(true)
  vicious.register(memwidget, vicious.widgets.mem, '$2', 2)
  --
  netwidget = widget({ type = &quot;textbox&quot;, name = &quot;netwidget&quot; })
  netwidget.text='&lt;span '..pango_small..'&gt;&lt;span color=&quot;'..beautiful.textbox_widget_as_label_font_color..'&quot;&gt;NET:&lt;/span&gt;&lt;/span&gt;'
  --bind nestat popup on textbox 
  blingbling.popups.netstat(netwidget,{ title_color = beautiful.notify_font_color_1, established_color= beautiful.notify_font_color_3, listen_color=beautiful.notify_font_color_2})
 --
  my_net=blingbling.net.new()
  my_net:set_height(18)
  --activate popup with ip informations on the net widget
  [[File:Blingbling_Example_4.png]]
  my_net:set_ippopup()
  my_net:set_show_text(true)
  my_net:set_v_margin(3)

[[File:Blingbling_rounded_corner_and_popup_example.png|200px|thumb]]

  mycairograph=blingbling.classical_graph.new()
  mycairograph:set_height(18)
  mycairograph:set_width(360)
  mycairograph:set_show_text(true)
  mycairograph:set_label(&quot;Load: $percent %&quot;)
  mycairograph:set_rounded_size(0.4)
  mycairograph:set_filled(true)
  mycairograph:set_filled_color(&quot;#00000033&quot;)
  vicious.register(mycairograph, vicious.widgets.cpu,'$1',2)
  --bind a top popup on the graph 
  blingbling.popups.htop(mycairograph.widget,
                        { title_color =beautiful.notify_font_color_1, 
                          user_color= beautiful.notify_font_color_2, 
                          root_color=beautiful.notify_font_color_3, 
                          terminal = &quot;urxvt&quot;})
  --
  mycore1=blingbling.progress_graph.new()
  mycore1:set_height(18)
  mycore1:set_width(20)
  mycore1:set_filled(true)
  mycore1:set_h_margin(1)
  mycore1:set_filled_color(&quot;#00000033&quot;)
  mycore1:set_show_text(true)
  mycore1:set_label(&quot;$percent&quot;)
  mycore1:set_rounded_size(0.4)
  vicious.register(mycore1, vicious.widgets.cpu, &quot;$2&quot;)
  --
  mycore2=blingbling.progress_graph.new()
  --same as mycore1
  mycore3=blingbling.progress_graph.new()
  --same as mycore1
  mycore4=blingbling.progress_graph.new()
  --same as mycore1

====Пример tiled graph: ====

[[File:Blingbling_Example_3.png]]

  mycairograph=blingbling.tiled_graph.new()
  mycairograph:set_height(18)
  mycairograph:set_width(360)
  mycairograph:set_tiles_color(&quot;#00000022&quot;)
  mycairograph:set_show_text(true)
  mycairograph:set_label(&quot;Load: $percent %&quot;)

====Пример progress bar и progress graph: ====

[[File:Blingbling_example_2.png]]

  my_fs=blingbling.progress_bar.new()
  my_fs:set_height(18)
  my_fs:set_width(40)
  my_fs:set_show_text(true)
  my_fs:set_horizontal(true)  
  --  
  my_fs_root=blingbling.progress_bar.new() 
  my_fs_root:set_height(18)
  my_fs_root:set_width(40)
  my_fs_root:set_v_margin(2)
  my_fs_root:set_show_text(true)
  my_fs_root:set_horizontal(true)
  --
  my_fs_data0=blingbling.progress_graph.new()
  my_fs_data0:set_height(18)
  my_fs_data0:set_width(40)
  my_fs_data0:set_show_text(true)
  my_fs_data0:set_horizontal(true)
  my_fs_data0:set_filled(true)
  --
  my_fs_data1=blingbling.progress_bar.new()
  my_fs_data1:set_height(18)
  my_fs_data1:set_width(40)
  my_fs_data1:set_show_text(true)
  my_fs_data1:set_horizontal(true)
  my_fs_data1:set_filled(true)

[[file:Blingbling_progress_bar.png]]

  my_fs=blingbling.progress_bar.new()
  my_fs:set_height(18)
  my_fs:set_width(40)
  my_fs:set_show_text(true)
  my_fs:set_horizontal(true)
  --
  my_fs_root=blingbling.progress_bar.new()
  my_fs_root:set_height(18)
  my_fs_root:set_width(40)
  my_fs_root:set_show_text(true)
  my_fs_root:set_horizontal(false)
  --
  my_fs_data0=blingbling.progress_bar.new()
  my_fs_data0:set_height(18)
  my_fs_data0:set_width(40)
  my_fs_data0:set_show_text(true)
  my_fs_data0:set_horizontal(false)
  -- 
  my_fs_data1=blingbling.progress_bar.new()
  my_fs_data1:set_height(18)
  my_fs_data1:set_width(40)
  my_fs_data1:set_show_text(true)
  my_fs_data1:set_horizontal(true)

====Пример volume bar и mpd visualizer: ====

[[File:Blingbling_Example_5.png]]
  mpdlabel= widget({ type = &quot;textbox&quot; })
  mpdlabel.text='&lt;span color=&quot;'..beautiful.textbox_widget_as_label_font_color..'&quot; '..pango_small..'&gt;MPD: &lt;/span&gt;'
  --
  my_mpd_volume=blingbling.volume.new()
  my_mpd_volume:set_height(18)
  my_mpd_volume:set_width(30)
  --bind the volume graph on mpd  
  my_mpd_volume:update_mpd()
  --use bar, default is a triangle
  my_mpd_volume:set_bar(true)
  --
  my_mpd=blingbling.mpd_visualizer.new()
  my_mpd:set_height(18)
  my_mpd:set_width(350)
  my_mpd:update()
  --display pcm graph with a line
  my_mpd:set_line(true)
  my_mpd:set_h_margin(4)
  --bind mpc commands on the widget
  my_mpd:set_mpc_commands()
  --Show the artist name and the current song
  my_mpd:set_show_text(true)
  my_mpd:set_label(&quot;$artist &gt; $title&quot;)
  --
  my_volume=blingbling.volume.new()
  my_volume:set_height(18)
  my_volume:set_width(30)
  --bind the volume widget on the master channel
  my_volume:update_master()
  my_volume:set_master_control()
  my_volume:set_bar(true)

====Пример reboot button: ====

[[File:Blingbling_system_reboot.png]]
  reboot=blingbling.system.rebootmenu(beautiful.reboot, beautiful.dialog_ok,     beautiful.dialog_cancel)

====Пример меню udisks-glue: ====

[[File:Blingbling_udisks-glue_menu.png]] [[File:Blingbling_udisks-glue_menu_mount_command.png]]

[[File:Blingbling_udisks-glue_menu_unmount_command.png]] [[File:Blingbling_udisks-glue_menu_cannot_eject.png]] [[File:Blingbling_udisks-glue_menu_can_eject.png]]

  udisks_glue=blingbling.udisks_glue.new(beautiful.dialog_ok)
  udisks_glue:set_mount_icon(beautiful.dialog_ok)
  udisks_glue:set_umount_icon(beautiful.dialog_cancel)
  udisks_glue:set_detach_icon(beautiful.dialog_cancel)
  udisks_glue:set_Usb_icon(beautiful.usb_icon)
  udisks_glue:set_Cdrom_icon(beautiful.cdrom_icon)

В конфигурации udisks-glue.conf используйте:
  filter disks {
             optical = false
             partition_table = false
             usage = filesystem
  }
  filter optical {
            optical = true
  }
  match disks {
           automount = true
           automount_options = sync
           post_mount_command = &quot;echo \'udisks_glue:mount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Usb\&quot;)\' | awesome-client&quot;
           post_unmount_command = &quot;echo \'udisks_glue:unmount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Usb\&quot;)\' | awesome-client&quot;
           post_removal_command = &quot;echo \'udisks_glue:remove_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Usb\&quot;)\' | awesome-client&quot;
  }
  match optical {
          automount = true
          automount_options = ro
          post_mount_command = &quot;echo \'udisks_glue:mount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Cdrom\&quot;)\' | awesome-client&quot;
          post_unmount_command = &quot;echo \'udisks_glue:unmount_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Cdrom\&quot;)\' | awesome-client&quot;
          post_removal_command = &quot;echo \'udisks_glue:remove_device(\&quot;%device_file\&quot;,\&quot;%mount_point\&quot;,\&quot;Cdrom\&quot;)\' | awesome-client&quot;
  }
====Пример виджета task warrior (здесь используется blingbling версия виджета меню): ====

[[File:Blingbling_task_warrior_menu.png]]

  task_warrior=blingbling.task_warrior.new(beautiful.tasks_icon)
  task_warrior:set_task_done_icon(beautiful.task_done_icon)
  task_warrior:set_task_icon(beautiful.task_icon)
  task_warrior:set_project_icon(beautiful.project_icon)

====Пример таблицы виджетов layout ====
Этот пример виджета календаря blingbling (пока не закончен). Используется массив layout:

[[File:Blingbling_table_layout.png]]

  calendarbox.widgets={
  {displayed_month_and_year, layout = blingbling.layout.array.line_center },
  {day_widgets[1], day_widgets[2], day_widgets[3], day_widgets[4],
  day_widgets[5], day_widgets[6], day_widgets[7], layout =blingbling.layout.array.line_center},
  {days_of_month[1],days_of_month[2], days_of_month[3], days_of_month[4],
  days_of_month[5],days_of_month[6],days_of_month[7],layout =blingbling.layout.array.line_center},
  {days_of_month[8],days_of_month[9], days_of_month[10], days_of_month[11],
  days_of_month[12],days_of_month[13],days_of_month[14],layout =blingbling.layout.array.line_center},
  {days_of_month[15],days_of_month[16], days_of_month[17], days_of_month[18],
  days_of_month[19],days_of_month[20],days_of_month[21],layout =blingbling.layout.array.line_center},
  {days_of_month[22],days_of_month[23], days_of_month[24], days_of_month[25],
  days_of_month[26],days_of_month[27],days_of_month[28],layout =blingbling.layout.array.line_center},
  {days_of_month[29],days_of_month[30], days_of_month[31], days_of_month[32],
  days_of_month[33],days_of_month[34],days_of_month[35],layout =blingbling.layout.array.line_center},
  layout = blingbling.layout.array.stack_lines
  }

====Пример Calendar widget ====
[[File:Blingbling_calendar_basic.png]]

  my_cal =blingbling.calendar.new({type = &quot;imagebox&quot;, image = beautiful.calendar_icon})
  --you can set blingbling.calendar.new({type = &quot;textbox&quot;, text = &quot;calendar&quot;}) if you prefer a textbox
  my_cal:set_cell_padding(4)
  my_cal:set_columns_lines_titles_text_color(beautiful.text_font_color_2)
  my_cal:set_title_text_color(beautiful.bg_focus)
  --with only this you have a calendar  with 2 buttons (next and previous month)

[[File:Blingbling_calendar_remind.png|400px]]  [[File:Blingbling_calendar_task.png|400px]]

Меню появляется при нахождение мыши на датой. Переключение между событиями из напоминаний и task warrior (и всеми событиями которые у вас есть) осуществляется колесом мыши.

  my_cal =blingbling.calendar.new({type = &quot;imagebox&quot;, image = beautiful.calendar_icon})
  my_cal:set_cell_padding(4)
  my_cal:set_columns_lines_titles_text_color(beautiful.text_font_color_2)
  my_cal:set_title_text_color(beautiful.bg_focus)
  my_cal:set_link_to_external_calendar(true)
  --This last line activate the functions that get events for a day from remind or task warrior (you can remove them and add your own)</text>
      <sha1>2ei0wwtsug5z1awvzt7yt0t0j0sl6sr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Blinking text</title>
    <ns>0</ns>
    <id>608</id>
    <revision>
      <id>6587</id>
      <parentid>4557</parentid>
      <timestamp>2014-05-21T18:02:31Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1208">{{Languages}}

First, you will need this function:

 blinkers = {}
 function blinking(tb,iv)
     if (tb==nil) then 
         return
     end
     local fiv = iv or 1
     if blinkers[tb] then
         if blinkers[tb].timer.started then
             blinkers[tb].timer:stop()
         else
             blinkers[tb].timer:start()
         end
     else
         if (tb.text == nil) then
             return
         end
         blinkers[tb]= {}
         blinkers[tb].timer = timer({timeout=fiv})
         blinkers[tb].text = tb.text
         blinkers[tb].empty = 0
 
         blinkers[tb].timer:add_signal(&quot;timeout&quot;, function ()
             if (blinkers[tb].empty==1) then
                 tb.text = blinkers[tb].text
                 blinkers[tb].empty=0
             else
                 blinkers[tb].empty=1
                 tb.text = &quot;&quot;
             end
         end)
 
         blinkers[tb].timer:start()
 
     end
 end

After this you can use ''blinking(any_textbox_widget,blinking_interval_in_seconds)''. The call of ''blinking'' function toggles the blinking of text.

I'm using ''blinking'' when I've any &quot;critical&quot; situation (e.g. battery charge or free space on a partition is very low, etc.).</text>
      <sha1>65ezzg89w23bj0gk47q9rhdemtow5ad</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Blinking text/ru</title>
    <ns>0</ns>
    <id>1068</id>
    <revision>
      <id>6590</id>
      <timestamp>2014-05-22T07:50:38Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Blinking text (translating page)</comment>
      <text xml:space="preserve" bytes="1566">{{DISPLAYTITLE:Мигающий текст в виджете}}
{{Languages|Blinking text}}

Для начала вам потребуется функция:

 blinkers = {}
 function blinking(tb,iv)
     if (tb==nil) then 
         return
     end
     local fiv = iv or 1
     if blinkers[tb] then
         if blinkers[tb].timer.started then
             blinkers[tb].timer:stop()
         else
             blinkers[tb].timer:start()
         end
     else
         if (tb.text == nil) then
             return
         end
         blinkers[tb]= {}
         blinkers[tb].timer = timer({timeout=fiv})
         blinkers[tb].text = tb.text
         blinkers[tb].empty = 0
 
         blinkers[tb].timer:add_signal(&quot;timeout&quot;, function ()
             if (blinkers[tb].empty==1) then
                 tb.text = blinkers[tb].text
                 blinkers[tb].empty=0
             else
                 blinkers[tb].empty=1
                 tb.text = &quot;&quot;
             end
         end)
 
         blinkers[tb].timer:start()
 
     end
 end

Добавьте ее в ваш rc.lua. После этого вы можете использовать ''blinking(any_textbox_widget,blinking_interval_in_seconds)''. Вызов функции ''blinking'' переключает мигание текста.

Я использую ''blinking'' когда возникают какие то &quot;критические&quot; ситуации (например заряд аккумулятора или свободное место на диске заканчивается, и т.д.).</text>
      <sha1>goviwlfcgodh4q9ynibh56rmy56euwq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bob Marley Algorithm</title>
    <ns>0</ns>
    <id>475</id>
    <revision>
      <id>3524</id>
      <parentid>3514</parentid>
      <timestamp>2009-08-27T23:58:27Z</timestamp>
      <contributor>
        <username>Koniu</username>
        <id>143</id>
      </contributor>
      <minor/>
      <comment>/* Solution in awesome: BMA */ fix typo</comment>
      <text xml:space="preserve" bytes="2462">The Bob Marley Algorithm (BMA) is a method used in awesome to fix a certain number of problem regarding the sloppy focus.

= Description of the problem =
The problems are well described on [http://people.cs.uchicago.edu/~ahiorean/ahwm/sloppy-focus.html this page].

Basically, when the mouse cursor move we want the window it is entering to have focus. When the mouse pointer enters a window, the window manager receives a EnterNotify event. When the mouse pointer leave a window, the window manager receives a LeaveNotify event. Based on this event, we can now on which window the mouse is and then give the focus to it (or do any other thing).

When you give focus with such a method, that's called sloppy focus.

But in a certain number of case, it can be the window that move, appear or disappear. An in such cases, X will also send you a EnterNotify or LeaveNotify event. We qualify this event as spurious, because the mouse pointer did not move at all: that means that basically the user did not do anything, it just a window that has moved or re-sized itself under the cursor.

= Solution in ahwm =
Alex Hioreanu who described the problem very well in the page linked above, came up with a light solution, based on events serial number. Unfortunately, this method is not very reliable and can fail in some case.

= Solution in awesome: BMA =
I came up with a solution one day while listening to the great Bob, hence the name of this method.
The problems addressed and resolved by this idea are problem 2, 3, and a part of problem 5.

Problem 4 and the other part of problem 5 is addressed by awful.autofocus.

Actually, the solution is quite simple: we know, as a window manager, when a window will be moved or resized, because we either send this event, or listen for them.

So before doing any action like moving, resizing, mapping or unmapping a window, we just readjust the event list we are listening on all clients to be the same as usual but without the EnterNotify and LeaveNotify event.

This has to be readjusted on all clients: when you are unmapping a window, you don't know exactly which window is under the cursor. Even if you know, you can't be sure something will happen between your unmap and the event notification (unless you grab the server, which is a bit ugly and more complicated).

This method has the advantage to work very well, but also the disadvantage of sending 2*N X messages to the server to readjust the client event mask.</text>
      <sha1>3s68h21v5lsf93qk35eho6tic3tvmvp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Building awesome</title>
    <ns>0</ns>
    <id>78</id>
    <revision>
      <id>7002</id>
      <parentid>6990</parentid>
      <timestamp>2014-09-09T06:59:34Z</timestamp>
      <contributor>
        <username>Kierun</username>
        <id>1040</id>
      </contributor>
      <comment>/* Red Hat */</comment>
      <text xml:space="preserve" bytes="2205">{{Languages}}

Here are instructions for building awesome on different platforms. 
== Debian ==
* [[Awesome-3-debian]] - Installing Awesome3 on Debian/Lenny.
* [[Awesome-3-git-debian]] - Building Debian packages from Awesome GIT version.

== Gentoo == 
* [[Awesome-3-Gentoo-Portage]] - Emerge the stable version of awesome 3
* [[Awesome-3-Gentoo-Paludis]] - Build awesome 3 release or current git with your package manager.
* [[Awesome-3-git-Gentoo]] - Build awesome 3 from git locally.

== Fedora == 
* [[Awesome-3-fedora]] - Building awesome on fedora platform
==Mandriva==
* [[Awesome-3-Mandriva-Spring]] Building awesome 3.2.1 on Mandriva 2009 Spring
* [[Awesome-3-Mandriva-Cooker]] - Building awesome 3.3 on Mandriva Cooker
== Ubuntu ==
* [[Awesome-3-Ubuntu-git]] - Building awesome 3.0 on Ubuntu Hardy from a git checkout.
* [[Awesome-3.4.11/git-Ubuntu-Lucid]] - Bulding git version of awesome on Ubuntu Lucid
* [[Awesome-3-git-Ubuntu-Intrepid]] - Building awesome on Ubuntu Intrepid from a git checkout
* [[Ubuntu Gutsy]] - Building awesome on Ubuntu and setting it up for use with gdm.
* [[Ubuntu Hardy]] - Building awesome on Ubuntu and setting it up for use with gdm.

== Arch Linux ==
* [[Arch Linux]] - Install awesome on Arch Linux
== FreeBSD ==

  cd /usr/ports/x11-wm/awesome &amp;&amp; make install clean

(/usr/ports/x11-wm/awesome2 is still available)

==Aurora==
* [[AuroraUX]] - Building and Installing Awesome 2/3.
==Slackware==
* [[Awesome-3-Slackware]] - SlackBuilds for building Awesome on Slackware
==Sabayon Linux==
(As root, in a terminal)

* Entropy version:
  equo update &amp;&amp; equo install awesome

* Portage version:
  emerge [options] awesome

== PLD Linux ==
Run ''install awesome'' in poldek (or run ''poldek -i awesome'').

== GIT / universal ==
* [[Awesome-3-git]] - Building awesome on any *nix platform from a git checkout.

[[Category: Awesome3]]

== Red Hat ==
* [[Awesome-3-RHEL5]] - Building and installing Awesome 3 on RHEL5
* [[Awesome-3-RHEL6]] - Building and Installing Awesome 3 on RHEL6 Beta
* ('''Solved''') Unix.Stackexchange question about how to install awesome on CentOS 7 [http://unix.stackexchange.com/questions/152258/using-awesome-window-manager-on-centos-7].</text>
      <sha1>2hmd09mcobikhb3di25gndxjndeprqg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Building awesome/fr</title>
    <ns>0</ns>
    <id>399</id>
    <revision>
      <id>3350</id>
      <parentid>3300</parentid>
      <timestamp>2009-07-15T19:00:16Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use DISPLAYTITLE instead of the Title template</comment>
      <text xml:space="preserve" bytes="2620">{{DISPLAYTITLE:Installer awesome}}
{{Languages|Building awesome}}


__NOTOC__
Vous trouverez ci-dessous une liste des articles décrivant les instructions pour installer awesome sur différentes plate-formes. Dans le pire des cas, vous pouvez toujours compiler la version git d’awesome sur n’importe quelle plate-forme *NIX ''via''&lt;br/&gt;&lt;code&gt;git clone git://git.naquadah.org/awesome.git&lt;/code&gt; ou &lt;code&gt;git clone http://git.naquadah.org/git/awesome.git&lt;/code&gt;.

Nous vous conseillons ensuite de lire quelques informations pour [[Getting started/fr|bien débuter avec awesome]].



;Arch Linux
*[[Arch Linux|awesome 3 sur Arch Linux]] : installer awesome sur Arch Linux


;Aurora UX
*[[AuroraUX|awesome 3.1.1 sur AuroraUX]] : compiler awesome sur AuroraUX


;Debian
* [[Awesome-3-debian/fr|awesome 3 sur Debian Lenny]] : installer awesome 3 sur Debian 5.0 Lenny (« stable » actuelle)
* awesome 3.3.1 sur Debian ''testing'' (« Squeeze ») ou ''sid'' : installez simplement le paquet '''awesome'''
* [[Awesome-3-git-debian|awesome git sur Debian]] : compiler des paquets Debian depuis la version git d’awesome


;FreeBSD
* [http://www.freshports.org/x11-wm/awesome/ awesome 3.3.1 sur FreeBSD] : port pour installer awesome sur FreeBSD


;Gentoo
* [[Awesome-3-Gentoo-Paludis/fr|awesome 3.3.1 sur Gentoo]] : installer les versions 3 ou git d’awesome avec gestionnaire de paquets
* [[Awesome-3-git-Gentoo|awesome git sur Gentoo]] : compiler localement la version git d’awesome


;Mandriva
*[[Awesome-3-Mandriva-Cooker/fr|awesome 3.3 sur Mandriva Cooker]] : installer awesome 3.3 sur Mandriva Cooker


;OpenSuse
* [http://download.opensuse.org/repositories/home://llipavsky/openSUSE_Factory/ awesome 3.3.1 sur OpenSuse] : paquets '''.rpm''' et sources pour installer ou compiler awesome 3.3.1 sur OpenSuse


;Slackware
*[[Awesome-3-Slackware|awesome 3 sur Slackware 12.2]] : SlackBuilds pour installer awesome sur Slackware


;Source Mage GNU–Linux
* [http://dbg.download.sourcemage.org/grimoire/codex/test/windowmanagers/awesome/ awesome 3.2.1 sur Source Mage GNU–Linux] : archive à installer pour Source Mage GNU–Linux


;T2SDE
* [http://t2-project.org/packages/awesome.html awesome 3.2.1 sur T2SDE] : archive à installer pour T2SDE


;Ubuntu
* [[Ubuntu Hardy|awesome 3.3.1 sur Ubuntu 8.04]] : compiler awesome sur Ubuntu 8.04 Hardy Heron
* awesome 3.3.1 sur Ubuntu 9.10 : installez simplement le paquet '''awesome''' sur Ubuntu 9.10 Karmic Koala
* [[Awesome-3-git-Ubuntu-Intrepid|awesome git sur Ubuntu 8.10]] : compiler la version git d’awesome sur Ubuntu 8.10 Intrepid Ibex


[[Category:Awesome3]]</text>
      <sha1>q88dt2izr45dnjkyq2pkrxpk7zxr8m4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Bzed's awesome newsticker</title>
    <ns>0</ns>
    <id>228</id>
    <revision>
      <id>2703</id>
      <parentid>1966</parentid>
      <timestamp>2009-05-23T07:38:50Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Definitly worth the awesome3 category</comment>
      <text xml:space="preserve" bytes="1720">== AWESOMEFEEDER ==
This module for awesome provides a simple newsticker.
It's the first time I've coded something in Lua, so please bear with me!

Although it's kinda hacky, awesomefeeder uses a small Python script
to retrieve the rss feeds as I was too lazy to implement a feed parser in
Lua :)

=== Screenshot ===
[[Image:Awesomefeeder.png]]

=== Requirements ===
What you need to run:
* python-beautifulsoup
* python-cjson
* python-feedparser
* python-imaging
* liblua5.1-json (The Debian package is waiting in NEW at the moment)

=== Usage ===
* Download the tarball and extract it to ''~/.config/awesome''
* Add something like the following code to your rc.lua: &lt;pre&gt;myfeed_text, myfeed_image = awesomefeeder.widgets(&quot;right&quot;, 12)&lt;/pre&gt; (&quot;right&quot; is the widget alignment, 12 the number of seconds to wait before displaying the next news line). &lt;br&gt;Then you can add ''myfeed_text'' and ''myfeed_image'' to the wiboxes of your choice.
* Edit ''newsfeeder.cfg'' to configure the list of RSS feeds.

=== Download ===
The tarball and a Debian package of ''liblua5.1-json'' is available here: [http://devel.recluse.de/~bzed/awesome/]

=== Bugs ===
Neither PIL nor PythonMagick seem to be able to handle alpha channels in .ico files properly.
In case you find any other bugs - please send reports and patches to ''bzed@debian.org''.

=== Copyright and License ===
Copyright (C) 2008  Bernd Zeimetz &lt;bzed@debian.org&gt;.&lt;br&gt;
Licensed under GPL, either version 2 of the License, or (at your option) any later version.

The default feed image (''images/feed.png'') was taken from the [http://www.famfamfam.com/lab/icons/silk/ Silk icon set] and is licensed under a Creative Commons Attribution 2.5 License.

[[Category:Awesome3]]</text>
      <sha1>k2uqpn1bravcz9adh0vz7p5w1w3kuv8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>CPU Governor/Freq. Widget for Linux (Pure Lua)</title>
    <ns>0</ns>
    <id>302</id>
    <revision>
      <id>2460</id>
      <parentid>2451</parentid>
      <timestamp>2009-03-17T10:53:49Z</timestamp>
      <contributor>
        <username>Frax</username>
        <id>113</id>
      </contributor>
      <text xml:space="preserve" bytes="3617">by [[User:Frax|Fredrik Ax]] &lt;mailto:frax@axnet.nu&gt;
{|cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; style=&quot;margin: 0em&quot; width=&quot;100%&quot;
|- style=&quot;background: #aea&quot;
| This widget is written entirely in LUA for awesome 3.2.
It depends on sudo, cpufreq-set and Linux CPU_FREQ_GOV and SYSFS (/sys/devices/system/cpu/cpu0/cpufreq/scaling_*).
|}

It provides a textbox widget that shows your current governor and what frequence your cpu currently is using.

When left-clicked it opens a menu that allow you to select another governor (if you have the appropriate line
in sudoers). Right-clicked it simply updates it self.


== Prerequisites: ==

sudo and cpufreq-set must be in your path e.g. in Debian, as root do:
 apt-get install sudo cpufrequtils

You must be allowed to run the command &quot;sudo cpufreq-set ...&quot; passwordless, e.g. by adding the following line to your /etc/sudoers:
 username	ALL=(ALL) NOPASSWD:/usr/bin/cpufreq-set
where username is ... guess what ... your user name.


== Code to be inserted into your rc.lua ==

The widget must be defined before it is added to the wibox where it is going to be used.
So using the mywibox as defined in the default rc.lua the code should be inserted '''before'''
the loop (for s = 1, screen.count() do) containing the statement starting with:
 mywibox[s].widgets = {

This is the code to be inserted:
 -- Create fraxcpumenu, and add all available governors to it
 fraxcpumenu = {}
 local fh= io.open(&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_available_governors&quot;, &quot;r&quot;)
 if fh ~= nil then 
    govstr= fh:read()
    fh:close()
    local i= 1
    for w in string.gmatch(govstr, &quot;%a+&quot;) do
       fraxcpumenu[i]= { w, &quot;sudo cpufreq-set  --governor &quot;..w}
       i= i + 1
    end
 end
 fraxcpumenu = awful.menu.new( { items= fraxcpumenu }  )
 
 -- Create fraxcpu widget
 fraxcpu=  widget({ type = &quot;textbox&quot;, name = &quot;fraxcpu&quot;, align = &quot;right&quot; })
 fraxcpu.text= 'fraxcpu'
 
 -- Function for updating the fraxcpu widget
 fraxcpuupd=1
 function hook_fraxcpu (tbw)
    if not fraxcpuupd then return(nil) end
    local freq= ''
    local gov= ''
    local fh= io.open(&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_governor&quot;, &quot;r&quot;)
    if fh then
       gov= fh:read()..':'
       fh:close()
    end
    fh= io.open(&quot;/sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq&quot;, &quot;r&quot;)
    if fh then
       freq= fh:read()
       fh:close()
       freq= tostring(math.ceil(tonumber(freq)/1000))
    else
       fraxcpuupd= nil
       fh= io.open(&quot;/proc/cpuinfo&quot;, &quot;r&quot;)
       if fh then
 	 for l in fh:lines() do
 	    freq= string.match(l, '^%s*cpu MHz%s*:%s*([0-9]+)')
 	    if freq ~= nil then break end
 	    freq= ''
 	 end
       end
    end
    tbw.text= gov..freq
 end
 
 -- Mouse button bindings for fraxcpu widget
 fraxcpu.buttons(fraxcpu,{ button({ }, 1, function () awful.menu.toggle(fraxcpumenu) end),
 			  button({ }, 2, function () hook_fraxcpu(fraxcpu) end),
 			  button({ }, 3, function () hook_fraxcpu(fraxcpu) end) })

Don't forget to make the widget visible, e.g. by adding it to the mywibox as defined by the default rc.lua,
look for the line starting with
 mywibox[s].widgets = {
and insert &quot;fraxcpu,&quot; into the list of widgets.

Finally you need to register a timer that keeps the widget updated. For it to be informational in environments
where the freq changes dynamically (e.g. when using the ondemand governor) it needs to be updated often.

To update it every second add the following at the end of your rc.lua:
 -- Update the fraxcpu widget every second
 awful.hooks.timer.register(1, function ()
     hook_fraxcpu(fraxcpu) 
 end)


[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>gjmt8knjpk37ddv0non0p3y5j0cxh9t</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>CPU Usage</title>
    <ns>0</ns>
    <id>353</id>
    <revision>
      <id>4121</id>
      <parentid>4120</parentid>
      <timestamp>2010-03-09T15:15:00Z</timestamp>
      <contributor>
        <username>G4c9z</username>
        <id>433</id>
      </contributor>
      <comment>/* The Code */</comment>
      <text xml:space="preserve" bytes="2751">This article will show the user how to add a simple CPU Usage display to their Awesome status bar.  This widget is written in pure Lua, without any external programs or scripts, and gets the CPU information by polling /proc/stat.  This code was tested on awesome 3.3pre20090421-1 with the kernel 2.6.29-ARCH.  Adjustments may be necessary for other systems.
== The Code ==
The function to retrieve the CPU information from /proc/stat is as follows:

    jiffies = {}
    function activecpu()
        local s = &quot;&quot;
        for line in io.lines(&quot;/proc/stat&quot;) do
            local cpu, newjiffies = string.match(line, &quot;(cpu%d*)\ +(%d+)&quot;)
            if cpu and newjiffies then
                if not jiffies[cpu] then
                    jiffies[cpu] = newjiffies
                end
                --The string.format prevents your task list from jumping around 
                --when CPU usage goes above/below 10%
                s = s .. &quot; &quot; .. cpu .. &quot;: &quot; .. string.format(&quot;%02d&quot;, newjiffies-jiffies[cpu]) .. &quot;% &quot;
                jiffies[cpu] = newjiffies
            end
        end
        return s
    end

This code first defines a table to store old values for each processor.  Inside the function, it reads /proc/stat line by line looking for processors.  When it finds one, it reads the name and the processor and the current value for user processes, measured in jiffies.  A &quot;jiffy&quot;, in this context, is a unit of time equal to 1/100th of a second.  The kernel counts how many jiffies were spent in each of the possible &quot;modes&quot;, including, but not limited to, user processes, system processes, and idle time.  To get the processor utilization in percent, we can simply pole user jiffies at a frequency of 1Hz and take the difference of the two measurements.  The resulting values are formatted into a string and returned as the result of the function.

Next we create a text box to display the information in:
    cpuinfo = widget({ type = &quot;textbox&quot;, align = &quot;right&quot; })

And register the hook to update the display.
    awful.hooks.timer.register(1, function() cpuinfo.text = activecpu() end)

Note that this updates every one second.  This is important.  If you want to make updates more or less frequent, you have to scale the CPU usage values accordingly.  For example, if you want to have it update every two seconds, you need to edit this line:
                s = s .. &quot; &quot; .. cpu .. &quot;: &quot; .. string.format(&quot;%02d&quot;, newjiffies-jiffies[cpu]) .. &quot;% &quot;
And divide it by the number of seconds between updates:
                s = s .. &quot; &quot; .. cpu .. &quot;: &quot; ..  string.format(&quot;%02d&quot;, (newjiffies-jiffies[cpu])/2) .. &quot;% &quot;

All that needs to be done after this is add the widget to the [[Awesome_3.0_to_3.1#statusbar|status bar's list of widgets]].</text>
      <sha1>tosin5uco6citpg2iv0bfvmh0zp82zf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Calendar widget</title>
    <ns>0</ns>
    <id>288</id>
    <revision>
      <id>5598</id>
      <parentid>5488</parentid>
      <timestamp>2012-09-03T19:18:35Z</timestamp>
      <contributor>
        <username>Duthils</username>
        <id>1072</id>
      </contributor>
      <minor/>
      <comment>fix broken link</comment>
      <text xml:space="preserve" bytes="11034">== Calendar Widget ==

=== Original Version ===

I've created a simple calendar extention to the normal time widget (mytextbox), using naughty.
See [http://bzed.de/posts/2009/02/awesome_calendar_widget/ my blog entry] for details.

--[[User:Bzed|Bzed]] 01:31, 23 February 2009 (UTC)

=== Horizontal view with week (for 3.3) ===

Base on the original work, the following code propose a horizontal view 



&lt;pre&gt;
function displayMonth(month,year,weekStart)
    local t,wkSt=os.time{year=year, month=month+1, day=0},weekStart or 1
    local d=os.date(&quot;*t&quot;,t)
    local mthDays,stDay=d.day,(d.wday-d.day-wkSt+1)%7

    print(mthDays ..&quot;\n&quot; .. stDay)
    local lines = &quot;    &quot;

    for x=0,6 do
        lines = lines .. os.date(&quot;%a &quot;,os.time{year=2006,month=1,day=x+wkSt})
    end

    lines = lines .. &quot;\n&quot; .. os.date(&quot; %V&quot;,os.time{year=year,month=month,day=1})

    local writeLine = 1
    while writeLine &lt; (stDay + 1) do
        lines = lines .. &quot;    &quot;
        writeLine = writeLine + 1
    end

    for x=1,mthDays do
        if writeLine == 8 then
            writeLine = 1
            lines = lines .. &quot;\n&quot; .. os.date(&quot; %V&quot;,os.time{year=year,month=month,day=x})
        end
        if (#(tostring(x)) == 1) then
            x = &quot; &quot; .. x
        end
        lines = lines .. &quot;  &quot; .. x
        writeLine = writeLine + 1
    end
    local header = os.date(&quot;%B %Y\n&quot;,os.time{year=year,month=month,day=1})
    --header = string.rep(&quot; &quot;, math.floor(((#(lines)) - #header) / 2 )) .. header

    return header .. &quot;\n&quot; .. lines
end

local calendar = {}
function switchNaughtyMonth(switchMonths)
    if (#calendar &lt; 3) then return end
    local swMonths = switchMonths or 1
    calendar[1] = calendar[1] + swMonths
    calendar[3].box.widgets[2].text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, displayMonth(calendar[1], calendar[2], 2))
end

function switchNaughtyGoToToday()
        if (#calendar &lt; 3) then return end
        local swMonths = switchMonths or 1
        calendar[1] = os.date(&quot;*t&quot;).month
        calendar[2] = os.date(&quot;*t&quot;).year
       switchNaughtyMonth(0)
end

timetextbox.mouse_enter = function ()
    local month, year = os.date('%m'), os.date('%Y')
    calendar = { month, year, 
                naughty.notify({
                    text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, displayMonth(month, year, 2)),
                    timeout = 0, hover_timeout = 0.5,
                    width = 270, screen = mouse.screen
                })
               }
end 
mytextbox.mouse_leave = function () naughty.destroy(calendar[3]) end

mytextbox:buttons({
    button({ }, 1, function()
        switchNaughtyMonth(-1)
    end),
    awful.button({ }, 2, switchNaughtyGoToToday),
    button({ }, 3, function()
        switchNaughtyMonth(1)
    end),
    button({ }, 4, function()
        switchNaughtyMonth(-1)
    end),
    button({ }, 5, function()
        switchNaughtyMonth(1)
    end),
    button({ 'Shift' }, 1, function()
        switchNaughtyMonth(-12)
    end),
    button({ 'Shift' }, 3, function()
        switchNaughtyMonth(12)
    end),
    button({ 'Shift' }, 4, function()
        switchNaughtyMonth(-12)
    end),
    button({ 'Shift' }, 5, function()
        switchNaughtyMonth(12)
    end)
})
&lt;/pre&gt;

=== Widget for 3.4 ===

Based on previous code, this one works in 3.4. And as a minor improvement, underlines current day.

&lt;pre&gt;
function displayMonth(month,year,weekStart)
	local t,wkSt=os.time{year=year, month=month+1, day=0},weekStart or 1
	local d=os.date(&quot;*t&quot;,t)
	local mthDays,stDay=d.day,(d.wday-d.day-wkSt+1)%7

	print(mthDays ..&quot;\n&quot; .. stDay)
	local lines = &quot;    &quot;

	for x=0,6 do
		lines = lines .. os.date(&quot;%a &quot;,os.time{year=2006,month=1,day=x+wkSt})
	end

	lines = lines .. &quot;\n&quot; .. os.date(&quot; %V&quot;,os.time{year=year,month=month,day=1})

	local writeLine = 1
	while writeLine &lt; (stDay + 1) do
		lines = lines .. &quot;    &quot;
		writeLine = writeLine + 1
	end

	for d=1,mthDays do
		local x = d
		local t = os.time{year=year,month=month,day=d}
		if writeLine == 8 then
			writeLine = 1
			lines = lines .. &quot;\n&quot; .. os.date(&quot; %V&quot;,t)
		end
		if os.date(&quot;%Y-%m-%d&quot;) == os.date(&quot;%Y-%m-%d&quot;, t) then
			x = &quot;&lt;u&gt;&quot; .. d .. &quot;&lt;/u&gt;&quot;
		end
		if (#(tostring(d)) == 1) then
			x = &quot; &quot; .. x
		end
		lines = lines .. &quot;  &quot; .. x
		writeLine = writeLine + 1
	end
	local header = os.date(&quot;%B %Y\n&quot;,os.time{year=year,month=month,day=1})

	return header .. &quot;\n&quot; .. lines
end

local calendar = {}
function switchNaughtyMonth(switchMonths)
	if (#calendar &lt; 3) then return end
	local swMonths = switchMonths or 1
	calendar[1] = calendar[1] + swMonths
	calendar[3].box.widgets[2].text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, displayMonth(calendar[1], calendar[2], 2))
end

function switchNaughtyGoToToday()
        if (#calendar &lt; 3) then return end
        local swMonths = switchMonths or 1
        calendar[1] = os.date(&quot;*t&quot;).month
        calendar[2] = os.date(&quot;*t&quot;).year
       switchNaughtyMonth(0)
end

mytextbox:add_signal('mouse::enter', function ()
	local month, year = os.date('%m'), os.date('%Y')
	calendar = { month, year, 
	naughty.notify({
		text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, displayMonth(month, year, 2)),
		timeout = 0,
		hover_timeout = 0.5,
		screen = mouse.screen
	})
}
end)
mytextbox:add_signal('mouse::leave', function () naughty.destroy(calendar[3]) end)

mytextbox:buttons(awful.util.table.join(
awful.button({ }, 1, function()
	switchNaughtyMonth(-1)
end),
awful.button({ }, 2, switchNaughtyGoToToday),
awful.button({ }, 3, function()
	switchNaughtyMonth(1)
end),
awful.button({ }, 4, function()
	switchNaughtyMonth(-1)
end),
awful.button({ }, 5, function()
	switchNaughtyMonth(1)
end),
awful.button({ 'Shift' }, 1, function()
	switchNaughtyMonth(-12)
end),
awful.button({ 'Shift' }, 3, function()
	switchNaughtyMonth(12)
end),
awful.button({ 'Shift' }, 4, function()
	switchNaughtyMonth(-12)
end),
awful.button({ 'Shift' }, 5, function()
	switchNaughtyMonth(12)
end)
))
&lt;/pre&gt;

=== Module for 3.4 ===

Here is a modified version of the latest code above from Bzed. It is a simple module which can attach a calendar to any widget.

Copy the following code into 'calendar2.lua' in your config directory:
&lt;pre&gt;
-- original code made by Bzed and published on http://awesome.naquadah.org/wiki/Calendar_widget
-- modified by Marc Dequènes (Duck) &lt;Duck@DuckCorp.org&gt; (2009-12-29), under the same licence,
-- and with the following changes:
--   + transformed to module
--   + the current day formating is customizable

local string = string
--local print = print
local tostring = tostring
local os = os
local capi = {
    mouse = mouse,
    screen = screen
}
local awful = require(&quot;awful&quot;)
local naughty = require(&quot;naughty&quot;)
module(&quot;calendar2&quot;)

local calendar = {}
local current_day_format = &quot;&lt;u&gt;%s&lt;/u&gt;&quot;

function displayMonth(month,year,weekStart)
        local t,wkSt=os.time{year=year, month=month+1, day=0},weekStart or 1
        local d=os.date(&quot;*t&quot;,t)
        local mthDays,stDay=d.day,(d.wday-d.day-wkSt+1)%7

        --print(mthDays ..&quot;\n&quot; .. stDay)
        local lines = &quot;    &quot;

        for x=0,6 do
                lines = lines .. os.date(&quot;%a &quot;,os.time{year=2006,month=1,day=x+wkSt})
        end

        lines = lines .. &quot;\n&quot; .. os.date(&quot; %V&quot;,os.time{year=year,month=month,day=1})

        local writeLine = 1
        while writeLine &lt; (stDay + 1) do
                lines = lines .. &quot;    &quot;
                writeLine = writeLine + 1
        end

        for d=1,mthDays do
                local x = d
                local t = os.time{year=year,month=month,day=d}
                if writeLine == 8 then
                        writeLine = 1
                        lines = lines .. &quot;\n&quot; .. os.date(&quot; %V&quot;,t)
                end
                if os.date(&quot;%Y-%m-%d&quot;) == os.date(&quot;%Y-%m-%d&quot;, t) then
                        x = string.format(current_day_format, d)
                end
                if (#(tostring(d)) == 1) then
                        x = &quot; &quot; .. x
                end
                lines = lines .. &quot;  &quot; .. x
                writeLine = writeLine + 1
        end
        local header = os.date(&quot;%B %Y\n&quot;,os.time{year=year,month=month,day=1})

        return header .. &quot;\n&quot; .. lines
end

function switchNaughtyMonth(switchMonths)
        if (#calendar &lt; 3) then return end
        local swMonths = switchMonths or 1
        calendar[1] = calendar[1] + swMonths
        calendar[3].box.widgets[2].text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, displayMonth(calendar[1], calendar[2], 2))
end

function switchNaughtyGoToToday()
        if (#calendar &lt; 3) then return end
        local swMonths = switchMonths or 1
        calendar[1] = os.date(&quot;*t&quot;).month
        calendar[2] = os.date(&quot;*t&quot;).year
       switchNaughtyMonth(0)
end

function addCalendarToWidget(mywidget, custom_current_day_format)
  if custom_current_day_format then current_day_format = custom_current_day_format end

  mywidget:add_signal('mouse::enter', function ()
        local month, year = os.date('%m'), os.date('%Y')
        calendar = { month, year,
        naughty.notify({
                text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, displayMonth(month, year, 2)),
                timeout = 0,
                hover_timeout = 0.5,
                screen = capi.mouse.screen
        })
  }
  end)
  mywidget:add_signal('mouse::leave', function () naughty.destroy(calendar[3]) end)

  mywidget:buttons(awful.util.table.join(
    awful.button({ }, 1, function()
        switchNaughtyMonth(-1)
    end),
    awful.button({ }, 2, switchNaughtyGoToToday),
    awful.button({ }, 3, function()
        switchNaughtyMonth(1)
    end),
    awful.button({ }, 4, function()
        switchNaughtyMonth(-1)
    end),
    awful.button({ }, 5, function()
        switchNaughtyMonth(1)
    end),
    awful.button({ 'Shift' }, 1, function()
        switchNaughtyMonth(-12)
    end),
    awful.button({ 'Shift' }, 3, function()
        switchNaughtyMonth(12)
    end),
    awful.button({ 'Shift' }, 4, function()
        switchNaughtyMonth(-12)
    end),
    awful.button({ 'Shift' }, 5, function()
        switchNaughtyMonth(12)
    end)
  ))
end
&lt;/pre&gt;

And you can use it like this:
&lt;pre&gt;
require('calendar2')

calendar2.addCalendarToWidget(datewidget)
&lt;/pre&gt;

If you want the current day to be in green color instead of underlined:
&lt;pre&gt;
calendar2.addCalendarToWidget(datewidget, &quot;&lt;span color='green'&gt;%s&lt;/span&gt;&quot;)
&lt;/pre&gt;


[[User:Duck|Duck]] 21:16, 29 December 2009 (UTC)

Use the middle button to switch back to the current month.

[[User:Steelman|Steelman]] 21:26, 18 May 2012 (CEST)

=== Module for 3.4 using tooltip ===
I modify the calendar2 module to using awful.tooltip instead of naughty.

So it don't get in conflict with regular desktop notifications.

Also it is possible to add this tooltip to several widgets.

You can get the code from [https://github.com/Mic92/utils/blob/master/cal.lua github]. (install instruction included)

[[Category:Awesome3]]
[[Category:Widgets]]</text>
      <sha1>pcriorblz12ahrwm8szhzp98w41wwx0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Calendars</title>
    <ns>0</ns>
    <id>788</id>
    <revision>
      <id>7354</id>
      <parentid>7351</parentid>
      <timestamp>2015-10-05T12:19:15Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>add link for taskwarrior</comment>
      <text xml:space="preserve" bytes="1843">{{Languages}}

Note: I search about graphical calendar solution, but I also found calendar with agenda (events and reminder manager, ...)

* [http://www.kolumbus.fi/~w408237/orage/ orage] - Calendar for Xfce Desktop Environment [calendar+agenda?] ([http://www.ghacks.net/2010/07/09/orage-xfce-calendar-application/ article])
* Rainlendar - ... [calendar+agenda?] ([http://www.customize.org/rainlendar skins]
* [http://clayo.org/osmo/ osmo] - personal organizer for GTK+ [calendar+agenda] - (fr) http://www.framasoft.net/article4956.html
* gnome-calendar? (GNOME component) - TODO: the exact name ? is it from Evolution ? [calendar+agenda?]
* Korganizer - (a KDE component) [calendar+agenda]
* [http://www.mozilla.org/projects/calendar/sunbird/ Mozilla Sunbird] - (Iceowl on debian) [calendar+agenda]
* [http://www.day-planner.org/screenshots Day Planner] - ... [calendar+agenda](?)
* [http://mbcsoft.com/index.php?option=com_content&amp;task=view&amp;id=28&amp;Itemid=50 Borg] - ... [calendar+agenda](?)
* [http://coyote.octets.fr/simpleagenda/wiki/ScreenShots Simple Agenda] - ... [calendar+agenda](?)
* [http://palcal.sourceforge.net/ palcal] - ... [calendar+agenda](?)
* cal - Simple text calendar [calendar only]
* [http://calcurse.org/ calcurse] - text/curses calendar
* xcal - ugly...
* Google Calendar - web service
* [http://taskwarrior.org Taskwarrior], while not a calendar per se, it does have support for recurring tasks. Taskwarrior manages your TODO list from your command line. 

== all links ==

7 free calendars for linux : http://www.rawcomputing.co.uk/linux/calendars.html

http://www.toocharger.com/linux/bureautique/agenda/

http://www.toocharger.com/linux/bureautique/calendrier/

(fr) http://www.tux-planet.fr/afficher-le-calendrier-google-sur-votre-bureau-linux/

(fr) http://www.le-libriste.fr/2011/09/gnome-shell-google-calendar/</text>
      <sha1>et1fvo1m6h9vtw9hf884dv6ft0pmpt9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Calendars/ru</title>
    <ns>0</ns>
    <id>1107</id>
    <revision>
      <id>7355</id>
      <parentid>6735</parentid>
      <timestamp>2015-10-05T12:20:40Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>add taskwarrior description</comment>
      <text xml:space="preserve" bytes="2628">{{Languages|Calendars}}

Примечание: Я искал календари с графическим оформлением, но также нашел и календари с планировщиками (события, напоминания и т.д.)

* [http://www.kolumbus.fi/~w408237/orage/ orage] - Календарь для рабочего стола Xfce [календарь+планировщик?] ([http://www.ghacks.net/2010/07/09/orage-xfce-calendar-application/ article])
* Rainlendar - ... [календарь+планировщик?] ([http://www.customize.org/rainlendar skins]
* [http://clayo.org/osmo/ osmo] - персональный органайзер на  GTK+ [календарь+планировщик] - (fr) http://www.framasoft.net/article4956.html
* gnome-calendar? (является компонентом GNOME) - TODO: точное название? это Evolution ? [календарь+планировщик?]
* Korganizer - (входит в состав KDE) [календарь+планировщик]
* [http://www.mozilla.org/projects/calendar/sunbird/ Mozilla Sunbird] - (Iceowl в debian) [календарь+планировщик]
* [http://www.day-planner.org/screenshots Day Planner] - ... [календарь+планировщик](?)
* [http://mbcsoft.com/index.php?option=com_content&amp;task=view&amp;id=28&amp;Itemid=50 Borg] - ... [календарь+планировщик](?)
* [http://coyote.octets.fr/simpleagenda/wiki/ScreenShots Simple Agenda] - ... [календарь+планировщик](?)
* [http://palcal.sourceforge.net/ palcal] - ... [календарь+планировщик](?)
* cal - Простой текстовый календарь [только календарь]
* [http://calcurse.org/ calcurse] - text/curses calendar
* xcal - скоро будет добавлено описание
* Google Calendar - веб сервис календарь+планировщик
* [http://taskwarrior.org Taskwarrior], — продвинутый менеджер задач и планирования времени для командной строки (также доступны GUI-фронтэнды, библиотеки и дополнения).

== Все ссылки ==

7 свободных календарей для linux : http://www.rawcomputing.co.uk/linux/calendars.html

http://www.toocharger.com/linux/bureautique/agenda/

http://www.toocharger.com/linux/bureautique/calendrier/

(fr) http://www.tux-planet.fr/afficher-le-calendrier-google-sur-votre-bureau-linux/

(fr) http://www.le-libriste.fr/2011/09/gnome-shell-google-calendar/</text>
      <sha1>qn08yhzyfrefaadykgajadbana7am46</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Change default layout</title>
    <ns>0</ns>
    <id>514</id>
    <revision>
      <id>3850</id>
      <parentid>3849</parentid>
      <timestamp>2009-11-27T18:20:49Z</timestamp>
      <contributor>
        <username>Qubodup</username>
        <id>397</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="573">How to change Awesome's default layout?

In ~/.config/awesome/rc.lua change
 tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s)
to
 tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s, awful.layout.suit.tile.left)
or use any of the other layouts, as seen in the [http://awesome.naquadah.org/doc/api/index.html documentation].

You can learn to understand this solution [http://awesome.naquadah.org/doc/api/modules/awful.tag.html#new here].

This solution is provided to you by the curiosity of qubodup, the helpfulness of ataraxia and the existence of [[IRC|#awesome]].</text>
      <sha1>8i14rfz1kui320v9ldr68xanyodk455</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Change keyboard layout</title>
    <ns>0</ns>
    <id>1278</id>
    <revision>
      <id>7249</id>
      <parentid>7248</parentid>
      <timestamp>2014-12-29T14:37:54Z</timestamp>
      <contributor>
        <username>Fstor</username>
        <id>4247</id>
      </contributor>
      <text xml:space="preserve" bytes="2678">{{ Languages }}

=== Changing layouts with setxkbmap ===
Changing keyboard layout in X can be done easily by running
 setxkbmap

For example to change to a norwegian layout you run:
 setxkbmap no

And back to english:
 setxkbmap us

You can check the current settings and rules by running:
 setxkbmap -query -v

To see a list of available layouts:
 cat /usr/share/X11/xkb/rules/xorg.lst
 
=== Changing layouts with shortcuts ===

If you prefer to work with multiple keyboard layouts you'd probably want
to switch between them using keyboard shortcuts.

As an example:
 SHIFT + ALT + 1 -&gt; changes the keyboard layout to russian (ru)
 SHIFT + ALT + 2 -&gt; changes the keyboard layout to english (us)

This can be achieved by adding some keybindings in rc.lua.
Add this to the existing globalkeys entry:
 globalkeys = awful.util.table.join(
  ...
  '''awful.key({ &quot;Shift&quot;, &quot;Mod1&quot;   }, &quot;1&quot;, function ()'''
    '''awful.util.spawn_with_shell(&quot;setxkbmap ru&quot;)'''
  '''end),'''
  '''awful.key({ &quot;Shift&quot;, &quot;Mod1&quot;   }, &quot;2&quot;, function ()'''
    '''awful.util.spawn_with_shell(&quot;setxkbmap us&quot;)'''
  '''end)'''
  ...
 )

Or if you want to toggle between two layouts using one key combination instead, see this [http://awesome.naquadah.org/wiki/Persian_keyboard_layout example].
Save your rc.lua and restart, or even better test it in a separate window by using [http://awesome.naquadah.org/wiki/Using_Xephyr Xephyr]!

=== Adding a layout widget ===
For convenience let's add a text widget that shows the current keyboard layout.
Note that the following syntax is for awesome versions &gt;= 3.5, use [http://awesome.naquadah.org/wiki/Widgets_in_awesome this] for older versions.

First add a couple of text widgets and initialize them:
 -- Custom widgets
 sep = wibox.widget.textbox()
 sep:set_text(&quot;|&quot;)
 layout_textbox = wibox.widget.textbox()
 layout_textbox:set_text(&quot;us&quot;)

Then add the widgets somewhere on the wibox, we'll add them next to the system tray:
 -- Widgets that are aligned to the right
 local right_layout = wibox.layout.fixed.horizontal()
 '''right_layout:add(sep)'''
 '''right_layout:add(layout_textbox)'''
 '''right_layout:add(sep)'''
 ...

Finally we need to add a line to the custom keybinding that updates the text in the layout widget:
 awful.key({ &quot;Shift&quot;, altkey   }, &quot;1&quot;, function ()
   awful.util.spawn_with_shell(&quot;setxkbmap ru&quot;)
   '''layout_textbox:set_text(&quot;ru&quot;)'''
 end),
 awful.key({ &quot;Shift&quot;, altkey   }, &quot;2&quot;, function ()
   awful.util.spawn_with_shell(&quot;setxkbmap us&quot;)
   '''layout_textbox:set_text(&quot;us&quot;)'''
 end)

Alternatively you could call
 setxkbmap -query | grep layout | awk '{print $2}'
and update the widget with the result for a more dynamic configuration.</text>
      <sha1>awyz7dtez467q0f67bzj5wlln4f3mtc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Change keyboard maps</title>
    <ns>0</ns>
    <id>317</id>
    <revision>
      <id>7125</id>
      <parentid>7124</parentid>
      <timestamp>2014-12-04T22:12:01Z</timestamp>
      <contributor>
        <username>MohsenPahlevanzadeh</username>
        <id>4089</id>
      </contributor>
      <comment>/* How to test keyboard */</comment>
      <text xml:space="preserve" bytes="5332">To be able to switch between different keyboard languages/layouts and to display the current layout, you can use external applications or add widgets.

== Awesome WM solutions ==

These widgets indicate the current layout and allow switching by clicking the widget, using keyboard shortcuts or both.

=== setxkbmap method ===

This widget displays the layout used by the keyboard. If clicked, it switchs between the list of user defined layouts. You have to set the current index to your default layout in order to be consistent with your system configuration.

'setxkbmap' is used to set the layout.

==== rc.lua code ====

Paste the following code into your rc.lua somewhere before the wibox definition. Custom arguments can be passed in the kbdcfg.layout array. Replace Foo and Bar with custom names that will appear in the widget.

 -- Keyboard map indicator and changer
 kbdcfg = {}
 kbdcfg.cmd = &quot;setxkbmap&quot;
 kbdcfg.layout = { { &quot;us&quot;, &quot;&quot; , &quot;Foo&quot; }, { &quot;us&quot;, &quot;dvorak&quot; , &quot;Bar&quot; } } 
 kbdcfg.current = 1  -- us is our default layout
 kbdcfg.widget = wibox.widget.textbox()
 kbdcfg.widget:set_text(&quot; &quot; .. kbdcfg.layout[kbdcfg.current][3] .. &quot; &quot;)
 kbdcfg.switch = function ()
   kbdcfg.current = kbdcfg.current % #(kbdcfg.layout) + 1
   local t = kbdcfg.layout[kbdcfg.current]
   kbdcfg.widget:set_text(&quot; &quot; .. t[3] .. &quot; &quot;)
   os.execute( kbdcfg.cmd .. &quot; &quot; .. t[1] .. &quot; &quot; .. t[2] )
 end
 
  -- Mouse bindings
 kbdcfg.widget:buttons(
  awful.util.table.join(awful.button({ }, 1, function () kbdcfg.switch() end))
 )

Then add kbdcfg.widget to your wibox and restart Awesome.

 -- Add widget to your layout
 right_layout:add(kbdcfg.widget)

If you want your default keyboard layout to be something else than the standard US, you would need to click on the item once after every restart. To fix this, add the following to your ~.xinitrc :

 # Set the keyboard layout once at startup. 
 # (Replace &quot;de&quot; with the layout of your choice.)
 setxkbmap de



Legacy code for 3.4:

     -- Keyboard map indicator and changer
     kbdcfg = {}
     kbdcfg.cmd = &quot;setxkbmap&quot;
     kbdcfg.layout = { &quot;us&quot;, &quot;fr&quot;, &quot;dvorak&quot; }
     kbdcfg.current = 1  -- us is our default layout
     kbdcfg.widget = widget({ type = &quot;textbox&quot;, align = &quot;right&quot; })
     kbdcfg.widget.text = &quot; &quot; .. kbdcfg.layout[kbdcfg.current] .. &quot; &quot;
     kbdcfg.switch = function ()
        kbdcfg.current = kbdcfg.current % #(kbdcfg.layout) + 1
        local t = &quot; &quot; .. kbdcfg.layout[kbdcfg.current] .. &quot; &quot;
        kbdcfg.widget.text = t
        os.execute( kbdcfg.cmd .. t )
     end
     
     -- Mouse bindings
     kbdcfg.widget:buttons(awful.util.table.join(
         awful.button({ }, 1, function () kbdcfg.switch() end)
     ))

==== Enabling accelerator keys ====

Accelerator keys (e.g. CTRL-C in Firefox) will not work in layouts lacking Latin letters. A simple way to fix this is to always pass the &quot;us&quot; layout to setxkbmap after the primary layout.

    kbdcfg.current = kbdcfg.current % #(kbdcfg.layout) + 1
    local layout = kbdcfg.layout[kbdcfg.current]
    kbdcfg.widget.text = &quot; &quot; .. layout .. &quot; &quot;
    os.execute( kbdcfg.cmd .. &quot; &quot; .. layout .. &quot;,us&quot; )

This seems inefficient but works fine. Alternatives welcome.

==== Keyboard bindings ====

Example [[Global Keybindings|global keybindings]] to switch layouts:

     -- Alt + Right Shift switches the current keyboard layout
     awful.key({ &quot;Mod1&quot; }, &quot;Shift_R&quot;, function () kbdcfg.switch() end)

== External solutions ==

=== setxkbmap method ===

{{Warning|text=This unfortunately will make the run prompt unusable as long as you're not using the first layout, see [https://awesome.naquadah.org/bugs/index.php?do=details&amp;task_id=1053 task 1053]}}

Configure your X server with ~/.xinitrc or similar by adding the following line:
  setxkbmap us,ru

=== KDE 4 method ===

To remember the last layout used on every window, the KDE 4 keyboard service can be started manually. To do this you will need some KDE packages installed (in Ubuntu you'll need at least kdelibs-bin and kde-workspace-bin) and the qdbus utility. Add the following to your ~/.xinitrc file:

 (pidof kded4 || kded4) &amp;&amp; qdbus org.kde.kded /kded loadModule keyboard &amp;

Once the service is running, you'll see a neat keyboard layout indicator (with country flags, if you have them installed). You can right click it and choose Configure (alternatively, you can run 'kcmshell4 keyboard' from the command line), and set the Switching Policy to your preference.

== How to test keyboard ==
The keycodes used by Xorg are reported by a utility called xev, which is provided by the xorg-xev package. Of course to execute xev, you need to be in a graphical environment, not in the console.
With the following command you can start xev and show only the relevant parts: 

  $ xev | grep -A2 --line-buffered '^KeyRelease' | sed -n '/keycode /s/^.*keycode \([0-9]*\).* (.*, \(.*\)).*$/\1 \2/p'

Here is an example output: 
  108 Meta_R
  62 Shift_R
  13 4
  14 5
  36 Return
If you press a key and nothing appears in the terminal, it means that either the key does not have a scancode, the scancode is not mapped to a keycode, or some other process is capturing the keypress. If you suspect that a process listening to X server is capturing the keypress, you can try running xev from a clean X session:
  $ xinit /usr/bin/xterm -- :1




[[Category:awesome3]]</text>
      <sha1>2exvd1ut17egvuk7lsi93kwyedyo9v7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Check for new mail in a maildir folder</title>
    <ns>0</ns>
    <id>295</id>
    <revision>
      <id>2694</id>
      <parentid>2390</parentid>
      <timestamp>2009-05-23T07:33:25Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Awesome3 category here too</comment>
      <text xml:space="preserve" bytes="1100">A simple widget for Awesome 3.x that checks for new mail in a maildir folder. Requires the [http://www.keplerproject.org/luafilesystem/index.html Lua Filesystem Library] and is currently designed to be used with [[Wicked]].

Download: [http://github.com/dmj/dotfiles/tree/master/.config/awesome/mailcheck.lua github.com/dmj]

==Usage==

rc.lua:

 require(&quot;mailcheck&quot;)
 [...]
 widgets.mail = widget({ type = &quot;textbox&quot;, align = &quot;right&quot;, name = &quot;mail&quot;, width = 100 })
 mailcheck.register( widgets.mail, settings.env.home .. &quot;/Mail&quot;, &quot;black&quot;, &quot;darkgreen&quot; )
 wicked.register(widgets.mail, mailcheck.check, &quot; &lt;span color='orange'&gt;mail: $1&lt;/span&gt; &quot;)
 [...]

mailcheck.register takes two mandatory and two optional parameters:
# the textbox widget itself (mandatory)
# the maildir folder to check (mandatory)
# the widget's background color if mailbox is empty (optional, defaults to &quot;black&quot;)
# the widget's background color if there are new messages (optional, defaults to &quot;darkgreen&quot;)

mailcheck.check() returns the number of new messages and sets the widget's background accordingly

[[Category:Awesome3]]</text>
      <sha1>1mrxzztfsfehb5gl7rh0fccc24nu75h</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Check for new mail in a mbox</title>
    <ns>0</ns>
    <id>561</id>
    <revision>
      <id>4309</id>
      <timestamp>2010-06-14T18:49:40Z</timestamp>
      <contributor>
        <username>Zeus</username>
        <id>480</id>
      </contributor>
      <comment>Created page with 'A simple an easy to understand widget for Awesome 3.x which display in a textbox widget the amount of mails in the mbox.  This it's an useful widget if you use fetchmail as I do …'</comment>
      <text xml:space="preserve" bytes="907">A simple an easy to understand widget for Awesome 3.x which display in a textbox widget the amount of mails in the mbox.

This it's an useful widget if you use fetchmail as I do =)

 mailbox = widget({type = &quot;textbox&quot;, align = &quot;right&quot; })
 mailbox.text = &quot;Mail 0&quot;
 mailbox_timer = timer({ timeout = 15 })
 mailbox_timer:add_signal(&quot;timeout&quot;, function()
                                       local mfile = io.popen( &quot;python -c \&quot;import mailbox\nprint len(mailbox.mbox(\'/var/mail/zeus/\'))\&quot;&quot;, &quot;r&quot;)
                                       mailbox.text = &quot;Mail &quot;..mfile:read(&quot;*a&quot;)
                                    end
                      )
 mailbox_timer:start()


Then it just must be added to your wibox =).

As you can see you can modified to check maildir or any other type of mail container supported by Python.

You should install python which it comes with most the popular distribution by default.</text>
      <sha1>do71vej52j7p0ps6qchlblo06bv6ibo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Clearlooks theme</title>
    <ns>0</ns>
    <id>234</id>
    <revision>
      <id>2776</id>
      <parentid>1978</parentid>
      <timestamp>2009-05-23T11:20:31Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Themes]]</comment>
      <text xml:space="preserve" bytes="1893">== To do ==
This is a first shot (clearlooks 0.1, or maybe could we write 0.0.0-1)
* I have to make an archive an post it somewhere
* Inlude more buttons
* And of course, main request I (or someone else) have (has) to make it better.

== Colors and Fonts ==
First, theme settings : please replace font with the one you wish.
&lt;pre&gt;
---------------------------
-- Clearlooks 0.1 awesome theme --
---------------------------
                                                                                      
font          = sans 8

bg_normal     = #E7E7E7
bg_focus      = #E7E7E7
bg_urgent     = #A36666

fg_normal     = #000000
fg_focus      = #438FFF
fg_urgent     = #A36666

border_width  = 1
border_normal = #E7E7E7
border_focus  = #438FFF
border_marked = #A3BA8C
&lt;/pre&gt;

== Buttons ==
Use the black buttons (layout)
&lt;pre&gt;
# You can use your own layout icons like this:
layout_dwindle = ~/.config/awesome/theme/clearlooks/layouts/dwindle.png
layout_fairh = ~/.config/awesome/theme/clearlooks/layouts/fairh.png
layout_fairv = ~/.config/awesome/theme/clearlooks/layouts/fairv.png
layout_floating = ~/.config/awesome/theme/clearlooks/layouts/floating.png
layout_magnifier = ~/.config/awesome/theme/clearlooks/layouts/magnifier.png
layout_max = ~/.config/awesome/theme/clearlooks/layouts/max.png
layout_spiral = ~/.config/awesome/theme/clearlooks/layouts/spiral.png
layout_tilebottom = ~/.config/awesome/theme/clearlooks/layouts/tilebottom.png
layout_tileleft = ~/.config/awesome/theme/clearlooks/layouts/tileleft.png
layout_tile = ~/.config/awesome/theme/clearlooks/layouts/tile.png
layout_tiletop = ~/.config/awesome/theme/clearlooks/layouts/tiletop.png
&lt;/pre&gt;

Then the main button ; to be downloaded and placed to clearlooks folder.
[[Image:Clear awesome16.png]]
&lt;pre&gt;
awesome_icon = ~/.config/awesome/theme/clearlooks/Clear_awesome16.png
&lt;/pre&gt;

[[category:awesome3]]
[[Category:Themes]]</text>
      <sha1>6qwd3t503un7wlzmpuz6agg4qflorb2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Closured Battery Widget</title>
    <ns>0</ns>
    <id>554</id>
    <revision>
      <id>5618</id>
      <parentid>5612</parentid>
      <timestamp>2012-10-17T05:56:58Z</timestamp>
      <contributor>
        <username>Krigstask</username>
        <id>456</id>
      </contributor>
      <comment>Mention `vicious`, update link to repo</comment>
      <text xml:space="preserve" bytes="4471">This is yet another notebook battery (Linux-only) monitoring widget for Awesome. Some day it was based on [[Gigamo Battery Widget]], but was rewritten completely since then. In fact, as a trivial text widget it lacks anything interesting. But function empowering it is somewhat original: utilizing closure concept supported by Lua, it keeps its state between calls, thus allowing for more advanced behaviour of function itself. Oh, and of course there's fancy Unicode symbols!

Take a look at ''$XDG_CONFIG_HOME/awesome/battery.lua'' (if you want to see remaining time and have ACPI command-line client installed, you can use [[Closured Battery Widget with time]]) (or make use of [[Vicious]], which calculates it for you).
&lt;pre&gt;
local io = io
local math = math
local naughty = naughty
local beautiful = beautiful
local tonumber = tonumber
local tostring = tostring
local print = print
local pairs = pairs

module(&quot;battery&quot;)

local limits = {{25, 5},
          {12, 3},
          { 7, 1},
            {0}}

function get_bat_state (adapter)
    local fcur = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/charge_now&quot;)
    local fcap = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/charge_full&quot;)
    local fsta = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/status&quot;)
    local cur = fcur:read()
    local cap = fcap:read()
    local sta = fsta:read()
    fcur:close()
    fcap:close()
    fsta:close()
    local battery = math.floor(cur * 100 / cap)
    if sta:match(&quot;Charging&quot;) then
        dir = 1
    elseif sta:match(&quot;Discharging&quot;) then
        dir = -1
    else
        dir = 0
        battery = &quot;&quot;
    end
    return battery, dir
end

function getnextlim (num)
    for ind, pair in pairs(limits) do
        lim = pair[1]; step = pair[2]; nextlim = limits[ind+1][1] or 0
        if num &gt; nextlim then
            repeat
                lim = lim - step
            until num &gt; lim
            if lim &lt; nextlim then
                lim = nextlim
            end
            return lim
        end
    end
end


function batclosure (adapter)
    local nextlim = limits[1][1]
    return function ()
        local prefix = &quot;⚡&quot;
        local battery, dir = get_bat_state(adapter)
        if dir == -1 then
            dirsign = &quot;↓&quot;
            prefix = &quot;Bat:&quot;
            if battery &lt;= nextlim then
                naughty.notify({title = &quot;⚡ Beware! ⚡&quot;,
                            text = &quot;Battery charge is low ( ⚡ &quot;..battery..&quot;%)!&quot;,
                            timeout = 7,
                            position = &quot;bottom_right&quot;,
                            fg = beautiful.fg_focus,
                            bg = beautiful.bg_focus
                            })
                nextlim = getnextlim(battery)
            end
        elseif dir == 1 then
            dirsign = &quot;↑&quot;
            nextlim = limits[1][1]
        else
            dirsign = &quot;&quot;
        end
        if dir ~= 0 then battery = battery..&quot;%&quot; end
        return &quot; &quot;..prefix..&quot; &quot;..dirsign..battery..dirsign..&quot; &quot;
    end
end
&lt;/pre&gt;

The idea is to ''naughtify'' you '''not every time''' function has been run (if charge is lower than limit, that is), but at certain intervals: every 5% below 25%, every 3% below 12% and every percent below 7% in this case (see ''limits'' table).

If you get the following error &quot;battery.lua:21: attemp to index local 'fcur' (a nil value)&quot;, check whether you have in directory /sys/class/power_supply/BAT0/ files charge_now and charge_full (substitute BAT0 with your battery alias). There might be energy_now and energy_full files, in which case you need to change lines 18 and 19 in your battery.lua accordingly. Original author has switched to [[Vicious]], which should take care of this differences (see link to repository below).

Now create new widget in your ''$XDG_CONFIG_HOME/awesome/rc.lua'' and bind new function to it. Here's example for Awesome 3.4:
&lt;pre&gt;
-- Battery
require(&quot;battery&quot;)

batterywidget = widget({type = &quot;textbox&quot;, name = &quot;batterywidget&quot;, align = &quot;right&quot; })

bat_clo = battery.batclosure(&quot;BAT0&quot;)
batterywidget.text = bat_clo()
battimer = timer({ timeout = 30 })
battimer:add_signal(&quot;timeout&quot;, function() batterywidget.text = bat_clo() end)
battimer:start()
&lt;/pre&gt;

Current original author's version is kept in [https://bitbucket.org/skrattaren/awesome/src/ BitBucket repo] (see ''widgets.lua'' and ''widget_fun.lua'' files) and has evolved quite a bit since this article was written.

[[Category:Widgets]]
[[Category:Awesome3]]</text>
      <sha1>cpqp9yj16wpp9dz9lniamzjr92b1p25</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Closured Battery Widget with time</title>
    <ns>0</ns>
    <id>861</id>
    <revision>
      <id>5611</id>
      <timestamp>2012-10-02T08:03:43Z</timestamp>
      <contributor>
        <username>Haisaul</username>
        <id>1115</id>
      </contributor>
      <comment>closured battery widget with time</comment>
      <text xml:space="preserve" bytes="2671">This is updated version of file battery.lua from [[Closured Battery Widget]], which shows remaining battery time. You need to have ACPI command-line client installed.
&lt;pre&gt;
local io = io
local math = math
local naughty = naughty
local beautiful = beautiful
local tonumber = tonumber
local tostring = tostring
local print = print
local pairs = pairs

module(&quot;battery&quot;)

local limits = {{25, 5},
          {12, 3},
          { 7, 1},
            {0}}

function get_bat_state (adapter)
    local fcur = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/energy_now&quot;)
    local fcap = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/energy_full&quot;)
    local fsta = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/status&quot;)
    local facp = io.popen(&quot;acpi -b&quot;)
    local cur = fcur:read()
    local cap = fcap:read()
    local sta = fsta:read()
    local acp = facp:read()
    fcur:close()
    fcap:close()
    fsta:close()
    facp:close()
    local battery = math.floor(cur * 100 / cap)
    if sta:match(&quot;Charging&quot;) then
        dir = 1
    elseif sta:match(&quot;Discharging&quot;) then
        dir = -1
    else
        dir = 0
        battery = &quot;&quot;
    end
    local idx = acp:find('remaining')
    local time = acp:sub(idx - 8, idx - 5)
    return battery, dir, time
end

function getnextlim (num)
    for ind, pair in pairs(limits) do
        lim = pair[1]; step = pair[2]; nextlim = limits[ind+1][1] or 0
        if num &gt; nextlim then
            repeat
                lim = lim - step
            until num &gt; lim
            if lim &lt; nextlim then
                lim = nextlim
            end
            return lim
        end
    end
end


function batclosure (adapter)
    local nextlim = limits[1][1]
    return function ()
        local prefix = &quot;⚡&quot;
        local battery, dir, time = get_bat_state(adapter)
        if dir == -1 then
            dirsign = &quot;↓&quot;
            prefix = &quot;Bat: &quot;
            prefix = prefix .. time
            if battery &lt;= nextlim then
                naughty.notify({title = &quot;⚡ Beware! ⚡&quot;,
                            text = &quot;Battery charge is low ( ⚡ &quot;..battery..&quot;%)!&quot;,
                            timeout = 7,
                            position = &quot;bottom_right&quot;,
                            fg = beautiful.fg_focus,
                            bg = beautiful.bg_focus
                            })
                nextlim = getnextlim(battery)
            end
        elseif dir == 1 then
            dirsign = &quot;↑&quot;
            nextlim = limits[1][1]
        else
            dirsign = &quot;&quot;
        end
        if dir ~= 0 then battery = battery..&quot;%&quot; end
        return &quot; &quot;..prefix..&quot; &quot;..dirsign..battery..dirsign..&quot; &quot;
    end
end
&lt;/pre&gt;</text>
      <sha1>c6tpd5r0ey3q9qm7dytq2e9fzqw4cc9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Colors in awesome</title>
    <ns>0</ns>
    <id>60</id>
    <revision>
      <id>1259</id>
      <timestamp>2008-10-16T14:41:42Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1524">==awesome 2.x==
: Changing the colors in awesome is pretty simple. Just edit your .awesomerc, and modify the following values:

  colors
  {
    normal_border = &quot;#222222&quot;
    normal_bg = &quot;#222222&quot;
    normal_fg = &quot;#919191&quot;
    focus_border = &quot;#99ccff&quot;
    focus_bg = &quot;#222222&quot;
    focus_fg = &quot;#ffffff&quot;
    urgent_fg = &quot;#ffffff&quot;
    urgent_bg = &quot;#D53737&quot;
  }

==awesome 2.3==
:There are different sections for the type of color:

    styles
    {
        ####
        # colors in this theme
        # #604040 Maroon
        # #606040 Dark Olive Green
        # #222211 Darker Olive Green
        # #a0a0a0 Light Grey
        # #402020
        ####
        normal
        {
            #font = &quot;sans 8&quot;
            # use the silkscreen font from kottke.org
            font = &quot;silkscreen 6&quot;
            fg = &quot;#808080&quot;
            bg = &quot;#222211&quot;
            border = &quot;#222222&quot;
        }
        focus
        {
            fg = &quot;#a0a0a0&quot;
            bg = &quot;#606040&quot;
            border = &quot;#FFFFFF&quot;
        }
        urgent
        {
            fg = &quot;#FFFFFF&quot;
            bg = &quot;#D53737&quot;
        }
     }

:The colors are simple RGB entries, exactly the same as HTML color codes. You can [http://html-color-codes.com/ lookup] these color codes all over the internet and mix and match to suite your needs.

==awesome 3==
:awesome 3 uses pango-markup for gettings styles: [[http://library.gnome.org/devel/pango/unstable/PangoMarkupFormat.html]].
:See also [[Beautiful]]

[[Category:Themes]][[Category:awesome2]][[Category:awesome3]]</text>
      <sha1>fupf7epurmq15s8ygmpobm40crbvask</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Command Reference 2 0</title>
    <ns>0</ns>
    <id>13</id>
    <revision>
      <id>1224</id>
      <timestamp>2008-10-15T16:01:36Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="42104">&lt;table style=&quot;border-collapse: collapse;&quot; border=&quot;1&quot;&gt;
  &lt;caption&gt;Commands of Awesome 2.0&lt;/caption&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;4&quot; colspan=&quot;8&quot;/&gt;
      &lt;th colspan=&quot;5&quot; class=&quot;client&quot;&gt;Client&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;3&quot; class=&quot;client&quot;/&gt;
      &lt;th colspan=&quot;4&quot; class=&quot;tag&quot;&gt;Tag&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th rowspan=&quot;2&quot; class=&quot;tag&quot;/&gt;
      &lt;th colspan=&quot;3&quot; class=&quot;layout&quot;&gt;Layout&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th class=&quot;layout&quot;/&gt;
      &lt;th colspan=&quot;2&quot; class=&quot;root&quot;&gt;Root&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th colspan=&quot;4&quot; class=&quot;action&quot;&gt;Action&lt;/th&gt;
      &lt;th colspan=&quot;4&quot; class=&quot;key&quot;&gt;Key&lt;/th&gt;
      &lt;th colspan=&quot;4&quot; class=&quot;pointer&quot;&gt;Pointer&lt;br/&gt;Button&lt;/th&gt;
      &lt;th class=&quot;code&quot;&gt;Code&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; colspan=&quot;4&quot; class=&quot;action terminal level-1 odd parity-odd&quot;&gt;Terminal&lt;/td&gt;
      &lt;td class=&quot;key terminal level-1 odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key terminal level-1 odd parity-odd&quot;&gt;Return&lt;/td&gt;
      &lt;td class=&quot;client terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code terminal level-1 odd parity-odd&quot;&gt;spawn(exec xterm)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;client terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout terminal level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root terminal level-1 odd parity-odd&quot;&gt;3&lt;/td&gt;
      &lt;td class=&quot;code terminal level-1 odd parity-odd&quot;&gt;spawn(exec xterm)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;4&quot; class=&quot;action window level-1 even parity-even&quot;&gt;Window&lt;/td&gt;
      &lt;td class=&quot;key window level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;client window level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;tag window level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;layout window level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;root window level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;code window level-1 even parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;9&quot; class=&quot;action window level-1 even parity-even&quot;&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action window level-2 even-odd parity-odd&quot;&gt;Focus&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;client window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code window level-2 even-odd parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; class=&quot;action window level-2 even-odd parity-odd&quot;&gt;&amp;nbsp;&amp;nbsp;&lt;/td&gt;
      &lt;td colspan=&quot;2&quot; class=&quot;action window level-3 even-odd-odd parity-even&quot;&gt;+&lt;/td&gt;
      &lt;td class=&quot;key window level-3 even-odd-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key window level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-3 even-odd-odd parity-even&quot;&gt;K&lt;/td&gt;
      &lt;td class=&quot;client window level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag window level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout window level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root window level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code window level-3 even-odd-odd parity-even&quot;&gt;client_focusprev&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;2&quot; class=&quot;action window level-3 even-odd-even parity-odd&quot;&gt;-&lt;/td&gt;
      &lt;td class=&quot;key window level-3 even-odd-even parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key window level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-3 even-odd-even parity-odd&quot;&gt;J&lt;/td&gt;
      &lt;td class=&quot;client window level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag window level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout window level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root window level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;code window level-3 even-odd-even parity-odd&quot;&gt;client_focusnext&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action window level-2 even-even parity-even&quot;&gt;Maximize&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;&gt;M&lt;/td&gt;
      &lt;td class=&quot;client window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;tag window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;layout window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;root window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;code window level-2 even-even parity-even&quot;&gt;client_togglemax&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action window level-2 even-odd parity-odd&quot;&gt;Float&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;&gt;Ctrl&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;&gt;Space&lt;/td&gt;
      &lt;td class=&quot;client window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code window level-2 even-odd parity-odd&quot;&gt;client_togglefloating&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action window level-2 even-even parity-even&quot;&gt;Raise&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;client window level-2 even-even parity-even&quot;&gt;1&lt;/td&gt;
      &lt;td class=&quot;tag window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;layout window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;root window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;code window level-2 even-even parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action window level-2 even-odd parity-odd&quot;&gt;Move&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;client window level-2 even-odd parity-odd&quot;&gt;1&lt;/td&gt;
      &lt;td class=&quot;tag window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code window level-2 even-odd parity-odd&quot;&gt;client_movemouse&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action window level-2 even-even parity-even&quot;&gt;Resize&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;client window level-2 even-even parity-even&quot;&gt;3&lt;/td&gt;
      &lt;td class=&quot;tag window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;layout window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;root window level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;code window level-2 even-even parity-even&quot;&gt;client_resizemouse&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action window level-2 even-odd parity-odd&quot;&gt;Kill&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key window level-2 even-odd parity-odd&quot;&gt;C&lt;/td&gt;
      &lt;td class=&quot;client window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root window level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code window level-2 even-odd parity-odd&quot;&gt;client_kill&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;4&quot; class=&quot;action tag-section level-1 odd parity-even&quot;&gt;Tag&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td class=&quot;client tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td class=&quot;root tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td class=&quot;code tag-section level-1 odd parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;4&quot; class=&quot;action tag-section level-1 odd parity-even&quot;/&gt;
      &lt;td rowspan=&quot;2&quot; colspan=&quot;3&quot; class=&quot;action tag-section level-2 odd-odd parity-odd&quot;&gt;Set&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key tag-section level-2 odd-odd parity-odd&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-odd parity-odd&quot;&gt;#&lt;/td&gt;
      &lt;td class=&quot;client tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code tag-section level-2 odd-odd parity-odd&quot;&gt;client_tag(#)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key tag-section level-2 odd-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;client tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tag-section level-2 odd-odd parity-odd&quot;&gt;1&lt;/td&gt;
      &lt;td class=&quot;layout tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root tag-section level-2 odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code tag-section level-2 odd-odd parity-odd&quot;&gt;client_tag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; colspan=&quot;3&quot; class=&quot;action tag-section level-2 odd-even parity-even&quot;&gt;Toggle&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-even parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-even parity-even&quot;&gt;Ctrl&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-even parity-even&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-even parity-even&quot;&gt;#&lt;/td&gt;
      &lt;td class=&quot;client tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;tag tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;layout tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;root tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;code tag-section level-2 odd-even parity-even&quot;&gt;client_toggletag(#)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key tag-section level-2 odd-even parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;key tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;key tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;client tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;tag tag-section level-2 odd-even parity-even&quot;&gt;3&lt;/td&gt;
      &lt;td class=&quot;layout tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;root tag-section level-2 odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;code tag-section level-2 odd-even parity-even&quot;&gt;client_toggletag&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;4&quot; class=&quot;action view level-1 even parity-odd&quot;&gt;View&lt;/td&gt;
      &lt;td class=&quot;key view level-1 even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-1 even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-1 even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-1 even parity-odd&quot;/&gt;
      &lt;td class=&quot;client view level-1 even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag view level-1 even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout view level-1 even parity-odd&quot;/&gt;
      &lt;td class=&quot;root view level-1 even parity-odd&quot;/&gt;
      &lt;td class=&quot;code view level-1 even parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;11&quot; class=&quot;action view level-1 even parity-odd&quot;/&gt;
      &lt;td rowspan=&quot;2&quot; colspan=&quot;3&quot; class=&quot;action view level-2 even-odd parity-even&quot;&gt;Set&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;&gt;#&lt;/td&gt;
      &lt;td class=&quot;client view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code view level-2 even-odd parity-even&quot;&gt;tag_view(#)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;client view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-odd parity-even&quot;&gt;1&lt;/td&gt;
      &lt;td class=&quot;layout view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code view level-2 even-odd parity-even&quot;&gt;tag_view&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; colspan=&quot;3&quot; class=&quot;action view level-2 even-even parity-odd&quot;&gt;Toggle&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;&gt;Crtl&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;&gt;#&lt;/td&gt;
      &lt;td class=&quot;client view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;code view level-2 even-even parity-odd&quot;&gt;tag_toggleview(#)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;client view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-even parity-odd&quot;&gt;3&lt;/td&gt;
      &lt;td class=&quot;layout view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;code view level-2 even-even parity-odd&quot;&gt;tag_toggleview&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;3&quot; colspan=&quot;3&quot; class=&quot;action view level-2 even-odd parity-even&quot;&gt;+&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;&gt;Right&lt;/td&gt;
      &lt;td class=&quot;client view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-odd parity-even&quot;/&gt;
      &lt;td rowspan=&quot;3&quot; class=&quot;code view level-2 even-odd parity-even&quot;&gt;tag_viewnext&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;client view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-odd parity-even&quot;&gt;4&lt;/td&gt;
      &lt;td class=&quot;layout view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-odd parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;client view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-odd parity-even&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;3&quot; colspan=&quot;3&quot; class=&quot;action view level-2 even-even parity-odd&quot;&gt;-&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;&gt;Left&lt;/td&gt;
      &lt;td class=&quot;client view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-even parity-odd&quot;/&gt;
      &lt;td rowspan=&quot;3&quot; class=&quot;code view level-2 even-even parity-odd&quot;&gt;tag_viewprev&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;client view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-even parity-odd&quot;&gt;5&lt;/td&gt;
      &lt;td class=&quot;layout view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-even parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;client view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout view level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-even parity-odd&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action view level-2 even-odd parity-even&quot;&gt;Previous&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key view level-2 even-odd parity-even&quot;&gt;Esc&lt;/td&gt;
      &lt;td class=&quot;client view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root view level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code view level-2 even-odd parity-even&quot;&gt;tag_prev_selected&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;4&quot; class=&quot;action layout-section level-1 odd parity-odd&quot;&gt;Layout&lt;/td&gt;
      &lt;td class=&quot;key layout-section level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;client layout-section level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag layout-section level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout-section layout level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root layout-section level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code layout-section level-1 odd parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;6&quot; class=&quot;action layout-section level-1 odd parity-odd&quot;/&gt;
      &lt;td rowspan=&quot;3&quot; colspan=&quot;3&quot; class=&quot;action layout-section level-2 odd-odd parity-even&quot;&gt;+&lt;/td&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;&gt;Space&lt;/td&gt;
      &lt;td class=&quot;client layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout-section layout level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td rowspan=&quot;3&quot; class=&quot;code layout-section level-2 odd-odd parity-even&quot;&gt;tag_setlayout(+1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;client layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout-section layout level-2 odd-odd parity-even&quot;&gt;1&lt;/td&gt;
      &lt;td class=&quot;root layout-section level-2 odd-odd parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;client layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag layout-section level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout-section layout level-2 odd-odd parity-even&quot;&gt;4&lt;/td&gt;
      &lt;td class=&quot;root layout-section level-2 odd-odd parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;3&quot; colspan=&quot;3&quot; class=&quot;action layout-section level-2 odd-even parity-odd&quot;&gt;-&lt;/td&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;&gt;Space&lt;/td&gt;
      &lt;td class=&quot;client layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout-section layout level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td rowspan=&quot;3&quot; class=&quot;code layout-section level-2 odd-even parity-odd&quot;&gt;tag_setlayout(-1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;client layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout-section layout level-2 odd-even parity-odd&quot;&gt;3&lt;/td&gt;
      &lt;td class=&quot;root layout-section level-2 odd-even parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;client layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag layout-section level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout-section layout level-2 odd-even parity-odd&quot;&gt;5&lt;/td&gt;
      &lt;td class=&quot;root layout-section level-2 odd-even parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;4&quot; class=&quot;action tile-layout level-1 even parity-even&quot;&gt;Tile Layout&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;client tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-1 even parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;15&quot; class=&quot;action tile-layout level-1 even parity-even&quot;/&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action tile-layout level-2 even-odd parity-odd&quot;&gt;Master&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;client tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-2 even-odd parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;8&quot; class=&quot;action tile-layout level-2 even-odd parity-odd&quot;/&gt;
      &lt;td rowspan=&quot;2&quot; colspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-odd-odd parity-even&quot;&gt;Set&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;&gt;Ctrl&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;&gt;Return&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td rowspan=&quot;2&quot; class=&quot;code tile-layout level-3 even-odd-odd parity-even&quot;&gt;client_zoom&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;client tile-layout level-3 even-odd-odd parity-even&quot;&gt;2&lt;/td&gt;
      &lt;td class=&quot;tag tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-odd-even parity-odd&quot;&gt;Boundry&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;client tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-3 even-odd-even parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-odd-even parity-odd&quot;&gt;&amp;nbsp;&lt;/td&gt;
      &lt;td class=&quot;action tile-layout level-4 even-odd-even-odd parity-even&quot;&gt;Right&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-even-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-even-odd parity-even&quot;&gt;L&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-4 even-odd-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-4 even-odd-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-4 even-odd-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-4 even-odd-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-4 even-odd-even-odd parity-even&quot;&gt;tag_setmwfact(+0.05)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;action tile-layout level-4 even-odd-even-even parity-odd&quot;&gt;Left&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-even-even parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-even-even parity-odd&quot;&gt;H&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-4 even-odd-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-4 even-odd-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-4 even-odd-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-4 even-odd-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-4 even-odd-even-even parity-odd&quot;&gt;tag_setmwfact(-0.05)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-odd-odd parity-even&quot;&gt;Quantity&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;client tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;action tile-layout level-4 even-odd-odd-odd parity-odd&quot;&gt;+&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-odd-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-odd-odd parity-odd&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-odd-odd parity-odd&quot;&gt;H&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-4 even-odd-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-4 even-odd-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-4 even-odd-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-4 even-odd-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-4 even-odd-odd-odd parity-odd&quot;&gt;tag_setnmaster(+1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td class=&quot;action tile-layout level-4 even-odd-odd-even parity-even&quot;&gt;-&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-odd-even parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-odd-even parity-even&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-4 even-odd-odd-even parity-even&quot;&gt;L&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-4 even-odd-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-4 even-odd-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-4 even-odd-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-4 even-odd-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-4 even-odd-odd-even parity-even&quot;&gt;tag_setnmaster(-1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action tile-layout level-2 even-even parity-odd&quot;&gt;Rank&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;client tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-2 even-even parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; class=&quot;action tile-layout level-2 even-even parity-odd&quot;/&gt;
      &lt;td colspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-even-odd parity-even&quot;&gt;+&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-even-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-even-odd parity-even&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-even-odd parity-even&quot;&gt;K&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-3 even-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-3 even-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-3 even-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-3 even-even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-3 even-even-odd parity-even&quot;&gt;client_swapprev&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-even-even parity-odd&quot;&gt;-&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-even-even parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-even-even parity-odd&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-even-even parity-odd&quot;&gt;J&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-3 even-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-3 even-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-3 even-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-3 even-even-even parity-odd&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-3 even-even-even parity-odd&quot;&gt;client_swapnext&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action tile-layout level-2 even-odd parity-even&quot;&gt;Columns&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;client tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-2 even-odd parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; class=&quot;action tile-layout level-2 even-odd parity-even&quot;/&gt;
      &lt;td colspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-odd-odd parity-odd&quot;&gt;+&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-odd&quot;&gt;Ctrl&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-odd parity-odd&quot;&gt;H&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-3 even-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-3 even-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-3 even-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-3 even-odd-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-3 even-odd-odd parity-odd&quot;&gt;tag_setncol(+1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;2&quot; class=&quot;action tile-layout level-3 even-odd-even parity-even&quot;&gt;-&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-even parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-even parity-even&quot;&gt;Ctrl&lt;/td&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;key tile-layout level-3 even-odd-even parity-even&quot;&gt;L&lt;/td&gt;
      &lt;td class=&quot;client tile-layout level-3 even-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;tag tile-layout level-3 even-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;layout tile-layout level-3 even-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;root tile-layout level-3 even-odd-even parity-even&quot;/&gt;
      &lt;td class=&quot;code tile-layout level-3 even-odd-even parity-even&quot;&gt;tag_setncol(-1)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;4&quot; class=&quot;action screen level-1 odd parity-odd&quot;&gt;Screen&lt;/td&gt;
      &lt;td class=&quot;key screen level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key screen level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key screen level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key screen level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;client screen level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag screen level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;screen layout level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root screen level-1 odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code screen level-1 odd parity-odd&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;2&quot; class=&quot;action screen level-1 odd parity-odd&quot;/&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action screen level-2 odd-odd parity-even&quot;&gt;+&lt;/td&gt;
      &lt;td class=&quot;key screen level-2 odd-odd parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key screen level-2 odd-odd parity-even&quot;&gt;Ctrl&lt;/td&gt;
      &lt;td class=&quot;key screen level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;key screen level-2 odd-odd parity-even&quot;&gt;J&lt;/td&gt;
      &lt;td class=&quot;client screen level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;tag screen level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;screen layout level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;root screen level-2 odd-odd parity-even&quot;/&gt;
      &lt;td class=&quot;code screen level-2 odd-odd parity-even&quot;&gt;screen_focusnext&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action screen level-2 odd-even parity-odd&quot;&gt;-&lt;/td&gt;
      &lt;td class=&quot;key screen level-2 odd-even parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key screen level-2 odd-even parity-odd&quot;&gt;Ctrl&lt;/td&gt;
      &lt;td class=&quot;key screen level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;key screen level-2 odd-even parity-odd&quot;&gt;K&lt;/td&gt;
      &lt;td class=&quot;client screen level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;tag screen level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;screen layout level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;root screen level-2 odd-even parity-odd&quot;/&gt;
      &lt;td class=&quot;code screen level-2 odd-even parity-odd&quot;&gt;screen_focusprev&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;4&quot; class=&quot;action awesome level-1 even parity-even&quot;&gt;Awesome&lt;/td&gt;
      &lt;td class=&quot;key awesome level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key awesome level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key awesome level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;key awesome level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;client awesome level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;tag awesome level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;layout awesome level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;root awesome level-1 even parity-even&quot;/&gt;
      &lt;td class=&quot;code awesome level-1 even parity-even&quot;/&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td rowspan=&quot;3&quot; class=&quot;action awesome level-1 even parity-even&quot;/&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action awesome level-2 even-odd parity-odd&quot;&gt;Bar&lt;/td&gt;
      &lt;td class=&quot;key awesome level-2 even-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key awesome level-2 even-odd parity-odd&quot;&gt;B&lt;/td&gt;
      &lt;td class=&quot;client awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code awesome level-2 even-odd parity-odd&quot;&gt;togglebar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action awesome level-2 even-even parity-even&quot;&gt;Configuration&lt;/td&gt;
      &lt;td class=&quot;key awesome level-2 even-even parity-even&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key awesome level-2 even-even parity-even&quot;&gt;Ctrl&lt;/td&gt;
      &lt;td class=&quot;key awesome level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;key awesome level-2 even-even parity-even&quot;&gt;R&lt;/td&gt;
      &lt;td class=&quot;client awesome level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;tag awesome level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;layout awesome level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;root awesome level-2 even-even parity-even&quot;/&gt;
      &lt;td class=&quot;code awesome level-2 even-even parity-even&quot;&gt;reloadconfig&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td colspan=&quot;3&quot; class=&quot;action awesome level-2 even-odd parity-odd&quot;&gt;Quit&lt;/td&gt;
      &lt;td class=&quot;key awesome level-2 even-odd parity-odd&quot;&gt;Mod4&lt;/td&gt;
      &lt;td class=&quot;key awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;key awesome level-2 even-odd parity-odd&quot;&gt;Shift&lt;/td&gt;
      &lt;td class=&quot;key awesome level-2 even-odd parity-odd&quot;&gt;Q&lt;/td&gt;
      &lt;td class=&quot;client awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;tag awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;layout awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;root awesome level-2 even-odd parity-odd&quot;/&gt;
      &lt;td class=&quot;code awesome level-2 even-odd parity-odd&quot;&gt;quit&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
&lt;ul&gt;
  &lt;li&gt;Often&lt;ul&gt;
    &lt;li&gt;Mod4 = Windows or Logo key&lt;/li&gt;
    &lt;li&gt;Mod1 = Alt key&lt;/li&gt;
    &lt;li&gt;Pointer Buttons&lt;ul&gt;
      &lt;li&gt;1 = Left Mouse Button&lt;/li&gt;
      &lt;li&gt;2 = Middle or Left &amp;amp; Right Mouse Button(s)&lt;/li&gt;
      &lt;li&gt;3 = Right Mouse Button&lt;/li&gt;
      &lt;li&gt;4 = Down Mouse Wheel&lt;/li&gt;
      &lt;li&gt;5 = Up Mouse Wheel&lt;/li&gt;
    &lt;/ul&gt;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
  &lt;li&gt;&quot;#&quot; Refers to a Tag Number&lt;/li&gt;
  &lt;li&gt;Pointer Button Targets&lt;ul&gt;
    &lt;li&gt;Client = Application Window&lt;/li&gt;
    &lt;li&gt;Tag = Tag Displayed on the Awesome Toolbar&lt;/li&gt;
    &lt;li&gt;Layout = Layout Symbol Displayed on the Awesome Toolbar&lt;/li&gt;
    &lt;li&gt;Root = &quot;Desktop&quot;&lt;/li&gt;
  &lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;


[[Category:Awesome2]]</text>
      <sha1>mw8cvcmqwt7l905f22hcju9jtpgqej3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Completion for the Lua eval prompt</title>
    <ns>0</ns>
    <id>201</id>
    <revision>
      <id>2693</id>
      <parentid>1558</parentid>
      <timestamp>2009-05-23T07:33:07Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>No idea what this is, but it goes into the awesome3 category</comment>
      <text xml:space="preserve" bytes="1854">This isn't very useful, maybe, but it's kinda cool that it is even possible!

Use this function as the completion_callback argument to awful.prompt.run.

&lt;pre&gt;
function lua_completion (line, cur_pos, ncomp)
   -- Only complete at the end of the line, for now
   if cur_pos ~= #line + 1 then
      return line, cur_pos
   end

   -- We're really interested in the part following the last (, [, comma or space
   local lastsep = #line - (line:reverse():find('[[(, ]') or #line)
   local lastidentifier
   if lastsep ~= 0 then
      lastidentifier = line:sub(lastsep + 2)
   else
      lastidentifier = line
   end

   local environment = _G

   -- String up to last dot is our current environment
   local lastdot = #lastidentifier - (lastidentifier:reverse():find('.', 1, true) or #lastidentifier)
   if lastdot ~= 0 then
      -- We have an environment; for each component in it, descend into it
      for env in lastidentifier:sub(1, lastdot):gmatch('([^.]+)') do
         if not environment[env] then
            -- Oops, no such subenvironment, bail out
            return line, cur_pos
         end
         environment = environment[env]
      end
   end

   local tocomplete = lastidentifier:sub(lastdot + 1)
   if tocomplete:sub(1, 1) == '.' then
      tocomplete = tocomplete:sub(2)
   end

   local completions = {}
   for k, v in pairs(environment) do
      if type(k) == &quot;string&quot; and k:sub(1, #tocomplete) == tocomplete then
         table.insert(completions, k)
      end
   end

   if #completions == 0 then
      return line, cur_pos
   end
   
   while ncomp &gt; #completions do
      ncomp = ncomp - #completions
   end

   local str = &quot;&quot;
   if lastdot + lastsep ~= 0 then
      str = line:sub(1, lastsep + lastdot + 1)
   end
   str = str .. completions[ncomp]
   cur_pos = #str + 1
   return str, cur_pos
end
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>kbnx9xoqwugur8y0rizir8gqf70g3fn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Composite Managers</title>
    <ns>0</ns>
    <id>600</id>
    <revision>
      <id>7109</id>
      <parentid>4806</parentid>
      <timestamp>2014-11-11T12:44:05Z</timestamp>
      <contributor>
        <username>Wernight</username>
        <id>3322</id>
      </contributor>
      <text xml:space="preserve" bytes="515">Compositors for X11 windowing system are required for &quot;true&quot; transparency support. You run a compositor alongside awesome to enable transparency. An (incomplete) list of available composite managers:

* compton [https://github.com/chjj/compton] – A bug-fixed fork of dcompmgr, which is a fork of xcompmgr
* xcompmgr
* compiz [http://www.compiz.org/]
* Unagi [http://projects.mini-dweeb.org/projects/unagi]
* cairo-compmgr [http://cairo-compmgr.tuxfamily.org/]
* compmgr [http://github.com/gustavosbarreto/compmgr]</text>
      <sha1>ed62mht59tjuh26wotd6c66omncyab1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Configuration d'awesome 3</title>
    <ns>0</ns>
    <id>404</id>
    <redirect title="Awesome 3 configuration/fr" />
    <revision>
      <id>3027</id>
      <timestamp>2009-06-25T20:17:20Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Configuration d'awesome 3]] to [[Awesome 3 configuration/fr]] over redirect: This is only a translation of the english version of this page and thus should be grouped to it. (Plus this fixes [[Template:Languages]])</comment>
      <text xml:space="preserve" bytes="40">#REDIRECT [[Awesome 3 configuration/fr]]</text>
      <sha1>htvs0ka0cw2j680h7qm4qwpokbvn44l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Conky HUD</title>
    <ns>0</ns>
    <id>947</id>
    <revision>
      <id>7370</id>
      <parentid>7369</parentid>
      <timestamp>2015-10-14T18:00:18Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <minor/>
      <comment>Remove rules without any effect</comment>
      <text xml:space="preserve" bytes="2757">{{Languages}}

[http://conky.sourceforge.net/ Conky] is a highly flexible system monitor that usually resides on your desktop. It is covered up when another window is open, especially in a tiling window manager. However, thanks to the power of ''awesome'', we can turn Conky into a heads-up display (HUD) of sorts. Pressing a key would cause Conky to raise itself above all other windows (see screenshot).

It is also possible to turn Conky into a wibox that is not overlapped by windows in the first place, as described in [[Conky bar]].

==Configuration==
===Awesome===
Add the following functions into '''rc.lua''':
&lt;pre&gt;
do
    local conky = nil

    function get_conky(default)
        if conky and conky.valid then
            return conky
        end

        conky = awful.client.iterate(function(c) return c.class == &quot;Conky&quot; end)()
        return conky or default
    end

    function raise_conky()
        get_conky({}).ontop = true
    end

    function lower_conky()
        get_conky({}).ontop = false
    end

    local t = gears.timer({ timeout = 0.01 })
    t:connect_signal(&quot;timeout&quot;, function()
        t:stop()
        lower_conky()
    end)
    function lower_conky_delayed()
        t:again()
    end

    function toggle_conky()
        local conky = get_conky({})
        conky.ontop = not conky.ontop
    end
end
&lt;/pre&gt;

Then place the following into the '''awful.rules''' table, unless you're using another client-matching system like [[Shifty]] or [[Tyrannical]]:
&lt;pre&gt;
{ rule = { class = &quot;Conky&quot; },
  properties = {
      floating = true,
      sticky = true,
      ontop = false,
      focusable = false
  } }
&lt;/pre&gt;

Then assign the keybindings. For a &quot;press and hold&quot; system in which Conky will raise itself as long as a key is held down, use:
&lt;pre&gt;
awful.key({}, &quot;F10&quot;, function() raise_conky() end, function() lower_conky_delayed() end)
&lt;/pre&gt;
Or for a toggle key, use:
&lt;pre&gt;
awful.key({}, &quot;Pause&quot;, function() toggle_conky() end)
&lt;/pre&gt;

===Conky===
Make sure the following lines are in your '''.conkyrc''':
&lt;pre&gt;
own_window yes
own_window_type desktop
own_window_hints below,skip_taskbar,skip_pager
&lt;/pre&gt;

If this doesn't work use this:
&lt;pre&gt;
own_window yes
own_window_type normal
own_window_hints below,skip_taskbar,skip_pager
&lt;/pre&gt;

You will probably want a translucent background ([[Composite Managers|compositing manager]] required), so use something like:
&lt;pre&gt;
own_window_colour 000000
own_window_argb_visual yes
own_window_argb_value 110
&lt;/pre&gt;

==Notes==
* We have to tell Conky to draw a normal window to allow awesome to control it, but this means that if awesome is restarted, the Conky window could be resized/moved.

==Screenshots==
[[File:ConkyHUD.png|thumb|left|300px|A conky window raised above Firefox.]]</text>
      <sha1>tany8cedcllwxr85fgmqkp5zm6n8c3o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Conky HUD/ru</title>
    <ns>0</ns>
    <id>1075</id>
    <revision>
      <id>6871</id>
      <parentid>6616</parentid>
      <timestamp>2014-07-25T09:59:05Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>Обновление перевода(update translating)</comment>
      <text xml:space="preserve" bytes="4099">{{Languages|Conky HUD}}

[http://conky.sourceforge.net/ Conky] является весьма гибким системным монитором, который обычно располагается на рабочем столе. Но в тайлинговых оконных менеджерах окна Conky обычно перекрываются другими окнами. Однако используя возможности Awesome мы можем сделать Conky heads-up display (HUD). Нажимая заданный клавиши, мы поднимаем окно Conky поверх всех других окон (см. скриншот).

Также возможно исползовать wibox для Conky, который не перекрывается окнами, как описано в статье [[Conky bar/ru|Панель Conky]].

== Конфигурация ==
=== Awesome ===
Добавьте следующие функции в '''rc.lua''':
&lt;pre&gt;
function get_conky()
    local clients = client.get()
    local conky = nil
    local i = 1
    while clients[i]
    do
        if clients[i].class == &quot;Conky&quot;
        then
            conky = clients[i]
        end
        i = i + 1
    end
    return conky
end
function raise_conky()
    local conky = get_conky()
    if conky
    then
        conky.ontop = true
    end
end
function lower_conky()
    local conky = get_conky()
    if conky
    then
        conky.ontop = false
    end
end
function toggle_conky()
    local conky = get_conky()
    if conky
    then
        if conky.ontop
        then
            conky.ontop = false
        else
            conky.ontop = true
        end
    end
end
&lt;/pre&gt;

Затем поместите следующий код в таблицу '''awful.rules''', если вы не собираетесь использовать другие системы client-matching, такие как [[Shifty]] или [[Tyrannical]]:
&lt;pre&gt;
{ rule = { class = &quot;Conky&quot; },
  properties = {
      floating = true,
      sticky = true,
      ontop = false,
      focusable = false,
      size_hints = {&quot;program_position&quot;, &quot;program_size&quot;}
  } }
&lt;/pre&gt;

Затем присвойте клавиатурное сочетание. 
При нажатой и удерживаемой клавише F10 Conky будет отображена поверх всех окон, до тех пор пока удерживается клавиша:
&lt;pre&gt;
awful.key({}, &quot;F10&quot;, function() raise_conky() end, function() lower_conky() end)
&lt;/pre&gt;
Или для переключения режимов отображения, используйте клавишу Pause:
&lt;pre&gt;
awful.key({}, &quot;Pause&quot;, function() toggle_conky() end)
&lt;/pre&gt;

=== Conky ===
Убедитесь, что следующие строки есть в '''.conkyrc''':
&lt;pre&gt;
own_window yes
own_window_type desktop
own_window_hints below,skip_taskbar,skip_pager
&lt;/pre&gt;

Если он не будет работать, используйте следующий код:
&lt;pre&gt;
own_window yes
own_window_type normal
own_window_hints below,skip_taskbar,skip_pager
&lt;/pre&gt;

Если вы хотите использовать прозрачный фон, (вам потребуется [[Composite Managers|композитный менеджер]], для настройки которого используйте статью [https://awesome.naquadah.org/wiki/Transparency/ru Прозрачность]), то используйте что то подобное:
&lt;pre&gt;
own_window_colour 000000
own_window_argb_visual yes
own_window_argb_value 110
&lt;/pre&gt;

== Примечание ==
* Мы заставили Conky отрисовать обычное окно для того, чтобы им можно было управлять в Awesome, но это означает, что при перезапуске Awesome, окно Conky может изменить размер или передвинуто.

== Скриншот ==
[[File:ConkyHUD.png|thumb|left|300px|Окно Conky размещенное поверх Firefox.]]</text>
      <sha1>fxnm2bdes8xkzd2am1mr4xbzy59984x</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Conky bar</title>
    <ns>0</ns>
    <id>679</id>
    <revision>
      <id>6611</id>
      <parentid>5521</parentid>
      <timestamp>2014-05-23T01:53:14Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2975">{{Languages}}

== Summary ==

Conky[http://conky.sourceforge.net] is a light-weight system monitor which can be completely customized to your needs. In Awesome2, it was possible to pipe its output to awesome-client. As far as I know this doesn't work in Awesome3, so I came up with another way of having a Conky bar at the bottom of my screen.

This technique creates a wibox at the bottom of the screen that is empty; this prevents Awesome from placing windows there.  Conky is then configured to draw its system info on the root window in the empty space reserved by the wibox.

== Awesome configuration ==

&lt;pre&gt;
mystatusbar = awful.wibox({ position = &quot;bottom&quot;, screen = 1, ontop = false, width = 1, height = 16 })
&lt;/pre&gt;

* position = &quot;bottom&quot; puts the wibox at the bottom of the screen
* screen = 1 places the wibox on screen 1
* ontop = false means it doesn't have to be on top of other windows (it'll be empty anyway)
* width = 1: one pixel wide is enough
* height = 16: in my case, this is exactly the height of my Conky, so windows will touch it without overlapping

== Conky configuration ==

This is configured in ~/.conkyrc
In the TEXT block, notice the \ at the end of every line - this is equivalent to putting the whole thing on one line, only it's easier to read and maintain. There should be no blank lines after the last configuration line, because Conky ''will'' draw them.

Of course, if you want {n} lines, you can. Just make sure to adjust the height of your wibox accordingly.

&lt;pre&gt;
alignment bottom_middle
background yes
border_width 1
cpu_avg_samples 2
default_color 222222
default_outline_color 222222
draw_borders no
draw_graph_borders yes
draw_outline no
draw_shades no
use_xft yes
xftfont Sans Mono:size=8
gap_x 5
gap_y 0
minimum_size 1260 6
maximum_width 1260
net_avg_samples 2
no_buffers yes
out_to_console no
out_to_stderr no
extra_newline no
own_window no
own_window_class Conky
own_window_type desktop
own_window_transparent yes
stippled_borders 0
update_interval 1.0
uppercase no
use_spacer left
show_graph_scale no
show_graph_range no
format_human_readable yes

color1 666666
color2 888888
color3 444444

mpd_host 127.0.0.1

TEXT
${if_mpd_playing} [${mpd_status} - ${mpd_elapsed}/${mpd_length}] ${scroll 35 5 ${mpd_smart}} ${else} \
${color1}Activity on /dev/sda:${color} ${diskiograph 10,50 000000 ff0000 -t}${endif} \
${alignr}${color1}br0 [${color3}${addr br0}${color}]: ${color1}Up:${color} ${upspeed br0} ${color1} - Down:${color} ${downspeed br0}     \
${alignr}${color1}Battery: [${color3}${acpiacadapter}${color1}] ${color}${battery_percent BAT1}% ${battery_bar 5,50 BAT1} | \
${color1}CPU: ${color} ${cpu}% ${cpubar cpu0 5,50} ${color2}CPU1: ${cpubar cpu1 5,50} CPU2: ${cpubar cpu2 5,50} ${color}| \
${color1}RAM:${color} ${memperc}% ${membar 5,50}
&lt;/pre&gt;

== Eye candy (aka screenshots) ==

[[File:AwesomeConky.png|200px|thumb|left|MPD stopped]]
[[File:AwesomeConkyMusic.png|200px|thumb|left|MPD playing]]

[[Category:awesome3]]</text>
      <sha1>jqagi80qcnfq0dzhacoux0ar2gdiiqc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Conky bar/ru</title>
    <ns>0</ns>
    <id>1074</id>
    <revision>
      <id>6613</id>
      <timestamp>2014-05-23T02:47:06Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Conky bar (translating page)</comment>
      <text xml:space="preserve" bytes="3913">{{DISPLAYTITLE:Conky bar}}
{{Languages|Conky bar}}

== Введение ==

[http://conky.sourceforge.net Conky] это легковесный системный монитор, который может быть полностью настроен под ваши нужды. В Awesome2, было возможно использовать его с выводом в awesome-client напрямую. Сейчас насколько я знаю, эта возможность не работает в Awesome3, поэтому я пошел другим путем для отображения панели Conky внизу моего экрана. 

Этот метод создает пустой wibox в нижней части экрана; что не дает Awesome размещать в этом месте окна. В то же время Conky настроен отображать свою информацию как root окно в пустой области занятой wibox.

== Настройка Awesome ==

&lt;pre&gt;
mystatusbar = awful.wibox({ position = &quot;bottom&quot;, screen = 1, ontop = false, width = 1, height = 16 })
&lt;/pre&gt;

* position = &quot;bottom&quot; размещает wibox в нижней части экрана
* screen = 1 размещает wibox на screen 1
* ontop = false озчает, что он может перекрыватся другими окнами (он все равно)
* width = 1: одного пикселя в ширину будет достаточно
* height = 16: в моем случае, это высота моего Conky, поэтому окна будут размещаться без перекрытия

== Настройка Conky ==

Настройки мы делаем в ~/.conkyrc
В блоке TEXT, обратите внимание на \ в конце каждой строки - что эквивалентов размещению всей строк в одну линию, это сделано для облегчения чтения и разработки. Не должно быть никаких пустых строк в конце файла, т.к. Conky отрисует ее.

Конечно если вам нужно несколько строк, вы можете это сделать. Только убедитесь сначала, что вам хватит соотвествующей высоты в вашем wibox.

&lt;pre&gt;
alignment bottom_middle
background yes
border_width 1
cpu_avg_samples 2
default_color 222222
default_outline_color 222222
draw_borders no
draw_graph_borders yes
draw_outline no
draw_shades no
use_xft yes
xftfont Sans Mono:size=8
gap_x 5
gap_y 0
minimum_size 1260 6
maximum_width 1260
net_avg_samples 2
no_buffers yes
out_to_console no
out_to_stderr no
extra_newline no
own_window no
own_window_class Conky
own_window_type desktop
own_window_transparent yes
stippled_borders 0
update_interval 1.0
uppercase no
use_spacer left
show_graph_scale no
show_graph_range no
format_human_readable yes

color1 666666
color2 888888
color3 444444

mpd_host 127.0.0.1

TEXT
${if_mpd_playing} [${mpd_status} - ${mpd_elapsed}/${mpd_length}] ${scroll 35 5 ${mpd_smart}} ${else} \
${color1}Activity on /dev/sda:${color} ${diskiograph 10,50 000000 ff0000 -t}${endif} \
${alignr}${color1}br0 [${color3}${addr br0}${color}]: ${color1}Up:${color} ${upspeed br0} ${color1} - Down:${color} ${downspeed br0}     \
${alignr}${color1}Battery: [${color3}${acpiacadapter}${color1}] ${color}${battery_percent BAT1}% ${battery_bar 5,50 BAT1} | \
${color1}CPU: ${color} ${cpu}% ${cpubar cpu0 5,50} ${color2}CPU1: ${cpubar cpu1 5,50} CPU2: ${cpubar cpu2 5,50} ${color}| \
${color1}RAM:${color} ${memperc}% ${membar 5,50}
&lt;/pre&gt;

== Eye candy (или скриншоты) ==

[[File:AwesomeConky.png|200px|thumb|left|MPD stopped]]
[[File:AwesomeConkyMusic.png|200px|thumb|left|MPD playing]]

[[Category:awesome3]]</text>
      <sha1>kj9eqgqqrfkbeae647vd2zn6ni20xt3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Cool blue theme</title>
    <ns>0</ns>
    <id>137</id>
    <revision>
      <id>2783</id>
      <parentid>1258</parentid>
      <timestamp>2009-05-23T11:22:46Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Themes]]</comment>
      <text xml:space="preserve" bytes="713">&lt;pre&gt;
---------------------------------                                                                                            
-- cool blue theme                                                                                            
---------------------------------                                                                                            
font          = cure

bg_normal     = #272C30
bg_focus      = #7985A3
bg_urgent     = #A36666

fg_normal     = #707678
fg_focus      = #D7DFE5
fg_urgent     = #A36666

border_width  = 1
border_normal = #272C30
border_focus  = #7985A3
border_marked = #A3BA8C

#wallpaper_cmd = nitrogen --restore
&lt;/pre&gt;

[[Category:awesome3]]
[[Category:Themes]]</text>
      <sha1>ank11v7vd2e0nhpdblrx74501124ex6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Couth</title>
    <ns>0</ns>
    <id>767</id>
    <revision>
      <id>6705</id>
      <parentid>5205</parentid>
      <timestamp>2014-06-04T15:05:08Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="370">{{Languages}}

=== couth ===

Couth is another extension library for awesome. It currently includes a couple plugins that use awful to display visual volume indicators for alsa and/or mpd volumes.

You can get it from [https://github.com/gorlowski/couth the couth github project page]

The github project page also includes a more-detailed description and documentation.</text>
      <sha1>834qd3kr1pmkakqj4o4k3q17yjynazw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Couth/ru</title>
    <ns>0</ns>
    <id>1098</id>
    <revision>
      <id>6707</id>
      <timestamp>2014-06-04T15:30:01Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Couth (translating page)</comment>
      <text xml:space="preserve" bytes="612">{{Languages|Couth}}

=== couth ===

Couth еще одна библиотека расширений для Awesome. В настоящее время она включает пару плагинов, которые используют awful для отображения индикаторов громкости для alsa и/или mpd. 

Вы можете скачать его со [https://github.com/gorlowski/couth страницы проекта на Github]


На странице проекта Github вы также найдете более менее подробную документацию.</text>
      <sha1>i96d8e9fjf9ll3w2jc2y5lw5fazquvi</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Coverart display</title>
    <ns>0</ns>
    <id>513</id>
    <revision>
      <id>6997</id>
      <parentid>6495</parentid>
      <timestamp>2014-09-02T16:43:51Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>add using dbus for mocp</comment>
      <text xml:space="preserve" bytes="8336">{{Languages}}

[[Image:Capreview.png|thumb|Screenshot]]
Displaying Cover Art for mpd tracks with the help of naughty.

Cover Art should be in the same directory with song file.

= Used scripts =

I created two shellscripts for this task:

1) coverart.sh - Detects current song file directory and finds coverart within it

&lt;pre&gt;
#!/bin/bash
# coverart.sh

DEFAULT_COVER=&quot;/path/to/defaultcover.png&quot;

# for 'mpd' users
MUSICDIR=`cat /etc/mpd.conf | grep -v &quot;#&quot; | grep music_directory`
MUSICDIR=${MUSICDIR:16}
MUSICDIR=${MUSICDIR%/$}

MFILE=`mpc current -f %file%`
MFILE=${MFILE%/*}
MFILE=${MFILE%/$}

FULLDIR=&quot;$MUSICDIR/$MFILE&quot;

## for 'moc' users under Debian, not sure if other distros use the 'mocp' name for the program:
#MFILE=`mocp --format &quot;%file&quot;`
#[ -n &quot;$MFILE&quot; ] &amp;&amp; FULLDIR=`dirname &quot;$MFILE&quot;`


[ -n &quot;$FULLDIR&quot; ] &amp;&amp; COVERS=`ls &quot;$FULLDIR&quot; | grep &quot;\.jpg\|\.png\|\.gif&quot;`

if [ -z &quot;$COVERS&quot; ]; then
	COVERS=&quot;$DEFAULT_COVER&quot;
else
	TRYCOVERS=`echo &quot;$COVERS&quot; | grep -i &quot;cover\|front\|folder\|albumart&quot; | head -n 1`

	if [ -z &quot;$TRYCOVERS&quot; ]; then
		TRYCOVERS=`echo &quot;$COVERS&quot; | head -n 1`
		if [ -z &quot;$TRYCOVERS&quot; ]; then
			TRYCOVERS=&quot;$DEFAULT_COVER&quot;
		else
			TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
		fi
	else
		TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
	fi

	COVERS=&quot;$TRYCOVERS&quot;
fi

echo -n &quot;$COVERS&quot;
&lt;/pre&gt;

2) musicinfo.sh - Prints any info you want to see in tooltip

&lt;pre&gt;
#!/bin/bash
#musicinfo.sh

echo &quot;Artist: `mpc current -f %artist%`&quot;
echo &quot;Album: `mpc current -f %album%`&quot;
echo -n &quot;Year: `mpc current -f %date%`&quot;
&lt;/pre&gt;

for those who use '''moc''' under Debian.  Other distros might not use the '''mocp''' name for the program:

&lt;pre&gt;
#!/bin/bash
#musicinfo.sh

date +&quot;%F%n%a %b %d, %-l:%M%P&quot;

if mocp --info 2&gt;/dev/null | grep -q PLAY; then
    mocp -Q &quot;
Artist:	%artist
Album:	%album
Song:	%song
Time:	%ct/%tt&quot;
else
    echo &quot;Nothing playing...&quot;
fi
&lt;/pre&gt;

= Changes in rc.lua =
1) You need to add function to show/hide tooltip

&lt;pre&gt;
local coverart_nf
function coverart_show()
    -- destroy old popup, needed when bound to a key
    coverart_hide()
    local img = awful.util.pread(&quot;/path/to/coverart.sh&quot;)
    local ico = image(img)
    local txt = awful.util.pread(&quot;/path/to/musicinfo.sh&quot;)
    -- set desired position of popup during creation
    coverart_nf = naughty.notify({icon = ico, icon_size = 100, text = txt, position = &quot;bottom_left&quot;})
end

function coverart_hide()
    if coverart_nf ~= nil then
	    naughty.destroy(coverart_nf)
    end
end
&lt;/pre&gt;

2) You need to add mouse event handlers to a widget, or a key binding.  The position of the popup is set in the '''coverart_show()''' function above.

Note: '''mpdw''' is my widget displaying mpd info.  '''mytextclock''' would work just as well if you haven't got a '''mpdw''' widget running.

&lt;pre&gt;
mpdw:add_signal(&quot;mouse::enter&quot;, function()
	coverart_show()
end)

mpdw:add_signal(&quot;mouse::leave&quot;, function()
	coverart_hide()
end)
&lt;/pre&gt;

A sample key binding that you would add to your '''globalkeys''' table:

&lt;pre&gt;
awful.key({ modkey,           }, &quot;slash&quot;, function () coverart_show() end),
&lt;/pre&gt;

= Add some dynamics =

If you'd like to display coverart on song change, or if you'd like to display coverart as a widget on your root window and change all fields dynamically, it is a very simple task with the help of [[Bashets]].

1. To display coverart on a song change, you need to register a simple callback function:

 ctitle = &quot;&quot;
 function mpd_callback(data)
 	if data[1] ~= ctitle then                     --here &quot;1&quot; may be &quot;3&quot; or &quot;2&quot;, or any other number of your variable
 		ctitle = data[1]
 		coverart_show()                       
 	end
 end
 bashets.register(&quot;mpd.sh&quot;, {update_time = 1, separator = &quot;|&quot;, callback = mpd_callback})

Here mpd.sh is your shellscript which returns separator-separated values. For example, here is a simplified version of my mpd.sh:

 TITLE=`mpc | head -n 1`
 MTIME=`mpc | head -n 2 | tail -n 1 | awk '{print $3}'`
 CURR=`mpc current`
 if [ -z &quot;$CURR&quot; ]; then
 	TITLE=&quot;mpd `mpd --version | head -n 1 | awk '{print $6}'`&quot;
 	MTIME=&quot;stopped&quot;
 fi
 echo -n &quot;$TITLE|$MTIME&quot;

which returns something like

 Artist - Song|00:00/99:99

Here &quot;Artist - Song&quot; corresponds to the first variable - $1 in format string or data[1] in data table, and &quot;00:00/99:99&quot; corresponds to the second variable. The separator is &quot;|&quot;, as mentioned above in ''register'' call.

2. To display a coverart widget on your root window, you are able to define it yourself (see naughty sources for example how to arrange elements within a wibox, then add your wibox to current screen with a geometry you prefer) and to register all it's textbox widgets in bashets:

 bashets.register(&quot;mpd.sh&quot;, {widget = mpdw, format = '&lt;span color=&quot;' .. bright_color .. '&quot; face=&quot;Monospace&quot;&gt;$1&lt;/span&gt; | $2', update_time = 1, separator = '|'})
 bashets.register(&quot;mpd.sh&quot;, {widget = mpdw, format = '$3', update_time = 1, separator = '|'})

Also you can combine callback call with widget updates, e.g.:
 bashets.register(&quot;mpd.sh&quot;, {widget = mpdw, format = '&lt;span color=&quot;' .. bright_color .. '&quot; face=&quot;Monospace&quot;&gt;$1&lt;/span&gt; | $2', update_time = 1, separator = '|', callback = mpd_callback})

''Note:'' callbacks are available since bashets '''0.4'''.

= Using dbus for coverart =

In the script using the mapping of the cover and title of the song there is some drawback, for it is necessary to create a separate widget (which for me turned out to be uncomfortable). Found in the network scripts notifications work through '' notify-send '', whose Debian's default is not, and it is not advisable, because if you switch one song after another (for example, in search of music in the mood), you will see a lot of pop-ups, that is not very nice. So I suggest you slightly revised version of the above scripts but working via D-Bus, and automatically replaces/closing the old notice, plus a cover of the track displays. Additionally, both scripts combined into one. Script reworked to moc/mocp.

Unfortunately mocp not support dbus, but it can cause an external command when changing the track (and not only for details to the documentation).

Add in mocp config:
&lt;pre&gt;
OnSongChange = &quot;/home/user/script/changesong.sh %f %a %t %d %r %n&quot;
&lt;/pre&gt;
Here we are passing all the required parameters: the path to the file, artist, title, time, album, in order then to not pull mocp again to get the data, as indicated in the original versions of these scripts.

Then, create a script (changesong.sh) for the cover and the formation of the text:
&lt;pre&gt;
#!/bin/bash
# changesong.sh

DEFAULT_COVER=&quot;/home/user/Images/no-cover.jpg&quot;

if mocp --info 2&gt;/dev/null | grep -q PLAY; then
	[ -n &quot;$1&quot; ] &amp;&amp; FULLDIR=`dirname &quot;$1&quot;`

	[ -n &quot;$FULLDIR&quot; ] &amp;&amp; COVERS=`ls &quot;$FULLDIR&quot; | grep &quot;\.jpg\|\.png\|\.gif&quot;`

	if [ -z &quot;$COVERS&quot; ]; then
		COVERS=&quot;$DEFAULT_COVER&quot;
	else
		TRYCOVERS=`echo &quot;$COVERS&quot; | grep -i &quot;cover\|front\|folder\|albumart&quot; | head -n 1`

		if [ -z &quot;$TRYCOVERS&quot; ]; then
			TRYCOVERS=`echo &quot;$COVERS&quot; | head -n 1`
			if [ -z &quot;$TRYCOVERS&quot; ]; then
				TRYCOVERS=&quot;$DEFAULT_COVER&quot;
			else
				TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
			fi
		else
			TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
		fi
		
		COVERS=&quot;$TRYCOVERS&quot;
	fi

	#echo -n &quot;$COVERS&quot;

	MTITLE=&quot;

	Artist: $2
	Title: $3
	Album:	$5
	Track:  	$6
	Time: 	$4&quot;
	
	if [ -z $1 ]; then
		MTITLE=`mocp -Q &quot; 

	Artist:	%artist 
	Title:	%song  
	Album: 	%album  
	Time:  	%tt&quot; ` 
	fi
else
	MTITLE=&quot;


	Nothing playing...&quot;
	COVERS=&quot;$DEFAULT_COVER&quot;
fi


dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/mocp ru.console.mocp.songChanged \
		string:&quot;$MTITLE&quot; \
		string:&quot;$COVERS&quot;  
&lt;/pre&gt;
Give the right to the script execution:
&lt;pre&gt;
chmod +x changesong.sh
&lt;/pre&gt;
Adds handlers to the Awesome:
&lt;pre&gt;
function notifyHide(mynotification)    --функция удаляет уведомление по переданному идентификатору 
	if mynotification ~= nil then 
		naughty.destroy(mynotification)
		return nil
	else
		return true
	end
end

dbus.request_name(&quot;session&quot;, &quot;ru.console.mocp&quot;
dbus.add_match(&quot;session&quot;, &quot;interface='ru.console.mocp', member='songChanged' &quot;)
dbus.add_signal(&quot;ru.console.mocp&quot;, function(...)
    local data = {...}
    --убираем старую информацию
    notifyHide(coverart_nf)
    coverart_nf = naughty.notify({icon = data[3], icon_size = 100, text = data[2], position = &quot;bottom_left&quot;})
    end )
&lt;/pre&gt;</text>
      <sha1>bwyen1od1a82t5i4zt3krvprxivv6wp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Coverart display/ru</title>
    <ns>0</ns>
    <id>1045</id>
    <revision>
      <id>6996</id>
      <parentid>6500</parentid>
      <timestamp>2014-09-02T16:25:47Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>/* Примечания переводчика */ add dbus version for script</comment>
      <text xml:space="preserve" bytes="12859">{{DISPLAYTITLE:Отображение обложки песни}}
{{Languages|Coverart display}}

[[Image:Capreview.png|thumb|Скриншот]]
Отображает обложку для треков mpd с помощью библиотеки naughty.

Обложка должна находиться в том же каталоге, что и файл с песней.

= Используемые скрипты =

Я создал 2 скрипта для этой задачи:

1) coverart.sh - Определяет каталог с текущей песней и находит в нем обложку

&lt;pre&gt;
#!/bin/bash
# coverart.sh

DEFAULT_COVER=&quot;/path/to/defaultcover.png&quot;

# для пользователей 'mpd'
MUSICDIR=`cat /etc/mpd.conf | grep -v &quot;#&quot; | grep music_directory`
MUSICDIR=${MUSICDIR:16}
MUSICDIR=${MUSICDIR%/$}

MFILE=`mpc current -f %file%`
MFILE=${MFILE%/*}
MFILE=${MFILE%/$}

FULLDIR=&quot;$MUSICDIR/$MFILE&quot;

## для пользователей 'moc' в Debian, не уверен что в других дистрибутивах используется 'mocp' в качестве имени программы:
#MFILE=`mocp --format &quot;%file&quot;`
#[ -n &quot;$MFILE&quot; ] &amp;&amp; FULLDIR=`dirname &quot;$MFILE&quot;`


[ -n &quot;$FULLDIR&quot; ] &amp;&amp; COVERS=`ls &quot;$FULLDIR&quot; | grep &quot;\.jpg\|\.png\|\.gif&quot;`

if [ -z &quot;$COVERS&quot; ]; then
	COVERS=&quot;$DEFAULT_COVER&quot;
else
	TRYCOVERS=`echo &quot;$COVERS&quot; | grep -i &quot;cover\|front\|folder\|albumart&quot; | head -n 1`

	if [ -z &quot;$TRYCOVERS&quot; ]; then
		TRYCOVERS=`echo &quot;$COVERS&quot; | head -n 1`
		if [ -z &quot;$TRYCOVERS&quot; ]; then
			TRYCOVERS=&quot;$DEFAULT_COVER&quot;
		else
			TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
		fi
	else
		TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
	fi

	COVERS=&quot;$TRYCOVERS&quot;
fi

echo -n &quot;$COVERS&quot;
&lt;/pre&gt;

2) musicinfo.sh - Печатает любую информацию которыю вы захотите видеть в подсказках

&lt;pre&gt;
#!/bin/bash
#musicinfo.sh

echo &quot;Исполнитель: `mpc current -f %artist%`&quot;
echo &quot;Альбом: `mpc current -f %album%`&quot;
echo -n &quot;Год: `mpc current -f %date%`&quot;
&lt;/pre&gt;

для тех, кто использует '''moc''' в Debian. В других дистрибутивах может не использоваться '''mocp''' в качестве названия для программы:

&lt;pre&gt;
#!/bin/bash
#musicinfo.sh

date +&quot;%F%n%a %b %d, %-l:%M%P&quot;

if mocp --info 2&gt;/dev/null | grep -q PLAY; then
    mocp -Q &quot;
Исполнитель:	%artist
Альбом: 	%album
Название:	%song
Время:  	%ct/%tt&quot;
else
    echo &quot;Ничего не воспроизводится...&quot;
fi
&lt;/pre&gt;

= Изменения в rc.lua =
1) Вам необходимо добавить функцию отображения/скрытия подсказки

&lt;pre&gt;
local coverart_nf
function coverart_show()
    -- destroy old popup, needed when bound to a key
    coverart_hide()
    local img = awful.util.pread(&quot;/path/to/coverart.sh&quot;)
    local ico = image(img)
    local txt = awful.util.pread(&quot;/path/to/musicinfo.sh&quot;)
    -- set desired position of popup during creation
    coverart_nf = naughty.notify({icon = ico, icon_size = 100, text = txt, position = &quot;bottom_left&quot;})
end

function coverart_hide()
    if coverart_nf ~= nil then
	    naughty.destroy(coverart_nf)
    end
end
&lt;/pre&gt;

2) Вам необходимо добавить обработчик событий мыши для виджета, или клавиатурные сочетания. Позиция всплывающего окнаустанавливается функцией описанной выше'''coverart_show()''', в свойстве position.

Замечание: '''mpdw''' это мой виджет для отображения информации. '''mytextclock''' работает также, даже если виджет '''mpdw''' не запущен.

&lt;pre&gt;
mpdw:add_signal(&quot;mouse::enter&quot;, function()
	coverart_show()
end)

mpdw:add_signal(&quot;mouse::leave&quot;, function()
	coverart_hide()
end)
&lt;/pre&gt;

Простейший способ добавить клавиатурные сочетания, добавить их в таблицу '''globalkeys''':

&lt;pre&gt;
awful.key({ modkey,           }, &quot;slash&quot;, function () coverart_show() end),
&lt;/pre&gt;

= Добавляем динамику =

Если вы хотите отображать обложку при изменении песни, или если вы хотите отображать обложку как виджет на вашем главном окне или изменять поля динамически, то этого легко добиться с помощью библиотеки [[Bashets/ru|Bashets]].

1. Для отображения обложки при изменении песни, вам необходимо зарегистрировать простую callback функцию:

 ctitle = &quot;&quot;
 function mpd_callback(data)
 	if data[1] ~= ctitle then                     --here &quot;1&quot; may be &quot;3&quot; or &quot;2&quot;, or any other number of your variable
 		ctitle = data[1]
 		coverart_show()                       
 	end
 end
 bashets.register(&quot;mpd.sh&quot;, {update_time = 1, separator = &quot;|&quot;, callback = mpd_callback})

Здесь mpd.sh это ваш скрипт, который возвращает разделенное разделителем значение. Например, ниже упрощеная версия моего mpd.sh:

 TITLE=`mpc | head -n 1`
 MTIME=`mpc | head -n 2 | tail -n 1 | awk '{print $3}'`
 CURR=`mpc current`
 if [ -z &quot;$CURR&quot; ]; then
 	TITLE=&quot;mpd `mpd --version | head -n 1 | awk '{print $6}'`&quot;
 	MTIME=&quot;stopped&quot;
 fi
 echo -n &quot;$TITLE|$MTIME&quot;

которая возвращает что то подобное:

 Artist - Song|00:00/99:99

Здесь &quot;Artist - Song&quot; соответсвует первой переменной - $1 в формате строки или data[1] в таблице данных, а &quot;00:00/99:99&quot; соответсвует второй переменной. Разделителем как уже упоминалось выше является &quot;|&quot; в вызове ''register''.

2. Для отображения обложки в виде виджета на главном окне, вам необходимо определить его (смотрите исходники naughty для изучения того, как организовать виджеты на wibox, затем добавьте ваш wibox на текущий экран с нужной вам геометрией) и зарегистрировать все его текстовые виджеты в  bashets:

 bashets.register(&quot;mpd.sh&quot;, {widget = mpdw, format = '&lt;span color=&quot;' .. bright_color .. '&quot; face=&quot;Monospace&quot;&gt;$1&lt;/span&gt; | $2', update_time = 1, separator = '|'})
 bashets.register(&quot;mpd.sh&quot;, {widget = mpdw, format = '$3', update_time = 1, separator = '|'})

Также вы можете объединить callback с обновлением виджетов, например:
 bashets.register(&quot;mpd.sh&quot;, {widget = mpdw, format = '&lt;span color=&quot;' .. bright_color .. '&quot; face=&quot;Monospace&quot;&gt;$1&lt;/span&gt; | $2', update_time = 1, separator = '|', callback = mpd_callback})

''Замечание:'' callbacks доступна с bashets '''0.4'''.

= Примечания переводчика =

У скрипта использующего отображение обложки и названия песни есть один недостаток, для него нужно создавать отдельный виджет (что лично для меня оказалось неудобным). Т.е. если нет виджета нет и возможности посмотреть что играет, соответственно теряется весь смысл этих скриптов. Найденные в сети скрипты уведомления работают через ''notify-send'', коего в Debian по умолчанию нет, да и использовать его не рекомендуется, т.к. если вы переключаете песню за песней (например в поисках музыки под настроение), то увидите множество всплывающих окон, что не очень то приятно. 
Поэтому я предлагаю вам чуть-чуть переработанный вариант описанных выше скриптов, но работающих через D-Bus и автоматически заменяющий\закрывающий старые уведомления, плюс отображающий обложку трека. Дополнительно оба скрипта объединены в один. Скрипт переработан для moc/mocp.

К сожалению сам mocp не поддерживает dbus, но он может вызывать внешнюю команду при смене трека (и не только, за подробностями к документации).

В конфиге для mocp я добавил свой обработчик:
&lt;pre&gt;
OnSongChange = &quot;/home/user/script/changesong.sh %f %a %t %d %r %n&quot;
&lt;/pre&gt;
Здесь мы передаем все необходимые значения: путь к файлу, исполнитель, название, время, альбом, для того, чтобы потом не дергать mocp еще раз, чтобы получить эти данные, как указано в изначальных версиях этих скриптов.

Затем, создаем скрипт (changesong.sh) для получения обложки и формирования текста:
&lt;pre&gt;
#!/bin/bash
# changesong.sh

DEFAULT_COVER=&quot;/home/faiver/Images/no-cover.jpg&quot;

if mocp --info 2&gt;/dev/null | grep -q PLAY; then
	#MFILE=$1
	[ -n &quot;$1&quot; ] &amp;&amp; FULLDIR=`dirname &quot;$1&quot;`

	[ -n &quot;$FULLDIR&quot; ] &amp;&amp; COVERS=`ls &quot;$FULLDIR&quot; | grep &quot;\.jpg\|\.png\|\.gif&quot;`

	if [ -z &quot;$COVERS&quot; ]; then
		COVERS=&quot;$DEFAULT_COVER&quot;
	else
		TRYCOVERS=`echo &quot;$COVERS&quot; | grep -i &quot;cover\|front\|folder\|albumart&quot; | head -n 1`

		if [ -z &quot;$TRYCOVERS&quot; ]; then
			TRYCOVERS=`echo &quot;$COVERS&quot; | head -n 1`
			if [ -z &quot;$TRYCOVERS&quot; ]; then
				TRYCOVERS=&quot;$DEFAULT_COVER&quot;
			else
				TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
			fi
		else
			TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
		fi
		
		COVERS=&quot;$TRYCOVERS&quot;
	fi

	#echo -n &quot;$COVERS&quot;

	MTITLE=&quot;

	Исполнитель: $2
	Название: $3
	Альбом:	$5
	Трек:  	$6
	Время: 	$4&quot;
	
# в случае если мы запускаем скрипт после паузы, необходимо явно запросить данные от mocp
	if [ -z $1 ]; then
		MTITLE=`mocp -Q &quot; 

	Исполнитель:	%artist 
	Название:	%song  
	Альбом: 	%album  
	Время:  	%tt&quot; ` 
	fi
else
	MTITLE=&quot;


	Ничего не воспроизводится...&quot;
	COVERS=&quot;$DEFAULT_COVER&quot;
fi


dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/mocp ru.console.mocp.songChanged \
		string:&quot;$MTITLE&quot; \
		string:&quot;$COVERS&quot;  
	#здесь кавычки нужны, т.к. в тексте могут быть пробелы, иначе некорректно передаст строку

# скрипт позволяет отрабатывать состояние переключения на паузу/повторный запуск
&lt;/pre&gt;
Даем скрипту права на исполнение:
&lt;pre&gt;
chmod +x changesong.sh
&lt;/pre&gt;
Добавляем обработчик в Awesome:
&lt;pre&gt;
dbus.request_name(&quot;session&quot;, &quot;ru.console.mocp&quot;
dbus.add_match(&quot;session&quot;, &quot;interface='ru.console.mocp', member='songChanged' &quot;)
dbus.add_signal(&quot;ru.console.mocp&quot;, function(...)
    local data = {...}
    --убираем старую информацию
    notifyHide(coverart_nf)
    coverart_nf = naughty.notify({icon = data[3], icon_size = 100, text = data[2], position = &quot;bottom_left&quot;})
    end )
&lt;/pre&gt;
И добавьте в rc.lua следующий код:
&lt;pre&gt;
function notifyHide(mynotification)    --функция удаляет уведомление по переданному идентификатору 
	if mynotification ~= nil then 
		naughty.destroy(mynotification)
		return nil
	else
		return true
	end
end
&lt;/pre&gt;
Хотя результат и будет тем же самым, что и в изначальном варианте, но разница будет в том, что система не зависнет если жесткий диск будет занят, плюс мы используем один скрипт вместо 2х в первоначальной версии.

Собственно это все, перезапукаем awesome (Ctrl+Mod4+r), и наслаждаемся уведомлениями.</text>
      <sha1>hkprsq7ja7jnsfg6ggaqeu1ix3vz64n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Current track</title>
    <ns>0</ns>
    <id>548</id>
    <revision>
      <id>4184</id>
      <parentid>4182</parentid>
      <timestamp>2010-04-14T17:22:54Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Last edit renamed the widget in the .sh script, rename it in lua, too</comment>
      <text xml:space="preserve" bytes="1504">To display the current track in the status bar, your can use your favorite music client along with awesome-client.

The following script filters the title from information given by the cmus player. If you use another player, you should change the first title= line.

&lt;pre&gt;
#!/bin/sh

while true; do
        if [ &quot;$(cmus-remote -Q)&quot; == &quot;&quot; ]
        then
            echo -e &quot;nowplaying.text=\&quot;\&quot;&quot; | /usr/bin/awesome-client;
            sleep 5
            continue
        else

        playing=$(cmus-remote -Q | grep 'playing');

        status=&quot;playing&quot;
        if [ &quot;$playing&quot; == &quot;&quot; ]
        then
            status=&quot;paused&quot;
        fi

        title=$(cmus-remote -Q | sed -n 's/tag title \(.*\)/\1/p');
        title=$(echo $title | sed 's/\&quot;/\\\&quot;/g'); # escape title
        echo -e &quot;nowplaying.text=\&quot;&lt;b&gt;Now $status:&lt;/b&gt; $title\&quot;&quot; | /usr/bin/awesome-client;
        sleep 1;
    fi
done
&lt;/pre&gt;


Now you should add the curtrack widget to your status bar.

&lt;pre&gt;
-- Create a widget for current track
nowplaying  = widget({ type = &quot;textbox&quot;, align = &quot;right&quot;})

...
    mywibox[s].widgets = {
        {
            mylauncher,
            mytaglist[s],
            mypromptbox[s],
            layout = awful.widget.layout.horizontal.leftright
        },
        mylayoutbox[s],
        mytextclock,
        separator,
        nowplaying,                         &lt;-----
        s == 1 and mysystray or nil,
        mytasklist[s],
        layout = awful.widget.layout.horizontal.rightleft
    }
&lt;/pre&gt;</text>
      <sha1>d3ts3u016f5hra8gd11xco09cy9zas3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Custom Prompts</title>
    <ns>0</ns>
    <id>524</id>
    <revision>
      <id>4994</id>
      <parentid>4992</parentid>
      <timestamp>2011-08-03T04:12:34Z</timestamp>
      <contributor>
        <username>Xfs</username>
        <id>678</id>
      </contributor>
      <minor/>
      <comment>fixing typo</comment>
      <text xml:space="preserve" bytes="1154">This page contains a few customized prompts you can use with awful's prompt:

* [[SSH: prompt]] - Statusbar ssh prompt similar to Run: prompt with hostname completion.
* [[Lua prompt improvements|Improving the Lua prompt]] - Completion and a more useful eval for the Lua prompt.
* [[Kooky wikipedia completion|Wikipedia Completion]] - Wikipedia prompt with article completion.
* [[Kooky geo|Geo Prompt]] - Prompt for calculating the distance between two locations.
* [[Anrxcs Manual Prompt | Manual Pages Prompt]] - Prompt for reading manual pages in your favorite application.
* [[Anrxcs WebSearch Prompt | Web Search Prompt]] - Prompt for searching the web, giving you acess to &lt;b&gt;any&lt;/b&gt; search form.
* [[Anrxcs Calculator Prompt | Calculator Prompt]] - Simple calculator prompt utilizing xmessage to display results.
* [[Identica Prompt | Identi.ca Prompt]] - Post dents/tweets directly from the wm.
* [[Launch In Terminal Keyword]] - A run prompt that accepts an intial keyword &quot;:&quot; to launch command in a terminal.
* [[Run in Terminal]] - Mod-Shift-r to launch command in a terminal.
* [[Google Translate]] - Use Google Translate to translate texts.</text>
      <sha1>ez2mmpeward28njob3h62nhbl4406ur</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Customizing Fonts</title>
    <ns>0</ns>
    <id>36</id>
    <revision>
      <id>6183</id>
      <parentid>4553</parentid>
      <timestamp>2013-12-10T13:10:20Z</timestamp>
      <contributor>
        <username>Martin-ueding</username>
        <id>3122</id>
      </contributor>
      <comment>/* Adding a custom font directory */ Fix bash snippets, make them safe with regard to spaces and dashes in filenames</comment>
      <text xml:space="preserve" bytes="1840">{{Languages}}

In some of the nifty screenshots you see of awesome, people have added/changed fonts around. This is a quick guide on how to do this. There are several types of fonts out there available for use in X, but this will focus on xcf style fonts, which have been around for awhile.

== Adding a custom font directory ==

1) Download the font you wish to use. It should be an .xcf format. [http://www.proggyfonts.com/index.php?menu=download Proggyfonts] has some nice fonts that can be used.

2) Uncompress the file you downloaded. If it is a raw .xcf font, like FontName.xcf, it will need to be compressed using gzip. The following snippit can compress all the fonts in a directory:

   for x in ./*.xcf; do gzip &quot;$x&quot;; done

3) I have a custom font path configured just for my user in a ~/.awesome directory I created. This directory can be anywhere on your system, of course. Copy the compressed .xcf fonts to this directory.

4) cd to this directory and run mkfontdir. This will create the hints file to make X happy.
   
   cd ~/.awesome/fonts; mkfontdir

5) Now, tell X about the font path you just created:

   xset fp+ &quot;$HOME/.awesome/fonts&quot;

then tell X to reload the font information

   xset fp rehash

6) Now, run 'xlsfonts | grep &lt;fontname&gt;' or xfontsel, and your font should be available.

7) Finally, configure awesome to use the new font. Edit your rc.lua and add the following line:

    awesome.font = &quot;&lt;fontname&gt; &lt;size&gt;&quot;

If you use beautiful, change the font variable in your theme file too.

== Clean Fonts ==

Locations of fonts that are clean to be used in awesome.

* [http://www.proggyfonts.com/index.php?menu=download Proggyfonts] has some nice fonts that can be used.
* [http://www.kottke.org/plus/type/silkscreen/ Silkscreen] is a TTF block-font that is very read-able at small sizes.

[[Category:Themes]]</text>
      <sha1>pogzjxia7tfwbndn38rg35eznk789k5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Customizing Fonts/fr</title>
    <ns>0</ns>
    <id>430</id>
    <revision>
      <id>3337</id>
      <parentid>3215</parentid>
      <timestamp>2009-07-15T18:36:00Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use DISPLAYTITLE instead of Templaet:Title</comment>
      <text xml:space="preserve" bytes="2406">{{DISPLAYTITLE:Fontes personnalisées}}
{{Languages|Customizing Fonts}}

Dans certaines des [[Beautiful_themes/fr|captures d’écrans très chouettes]] que vous voyez d’awesome, les utilisateurs ont ajouté ou changé les fontes par-ci par-là. Voici un guide rapide sur la façon de faire la même chose. Il y a de nombreux types de fontes disponibles pour X un peu partout, mais ce guide se concentrera sur les fontes du style xcf, qui sont disponibles maintenant depuis un certain temps.

== Ajout d’un dossier de fontes personnalisées ==

# Téléchargez la fonte que vous voulez. Elle devrait être au format '''.xcf''' ; vous pourrez en trouver des sympas sur [http://www.proggyfonts.com/index.php?menu=download Proggyfonts].
# Décompressez le fichier téléchargé. Si c’est un fichier '''.xcf''' brut, du genre '''NomDeLaFonte.xcf''', il faudra le compresser avec ''gzip''. Le bout de code suivant peut compresser toutes les fontes d’un dossier :&lt;br/&gt;&lt;pre&gt;for x in ls *.xcf; do gzip ${x}; done&lt;/pre&gt;
# Créez un dossier de fontes pour vous, par exemple dans '''~/.awesome''' ou n’importe où dans votre système, et copiez les fontes '''.xcf''' compressées dedans.
# Faites un « ''cd'' » vers ce répertoire, et lancez ''mkfontdir''. Ça va créer des fichiers qui rendront X content. Sur un exemple :&lt;br/&gt;&lt;pre&gt;cd ~/.awesome/fontes; mkfontdir&lt;/pre&gt;
# Maintenant, on va dire à X qu’il peut utiliser notre dossier de fontes :&lt;br/&gt;&lt;pre&gt;xset fp+ /home/&lt;user&gt;/.awesome/fontes&lt;/pre&gt;puis on lui dit de recharger les informations concernant les fontes :&lt;br/&gt;&lt;pre&gt;xset fp rehash&lt;/pre&gt;
# Maintenant, lancez « ''xlsfonts | grep &lt;NomDeFonte&gt;'' » ou ''xfontsel'', et votre fonte devrait être disponible.
# Pour terminer, configurez awesome pour qu’il utilise la nouvelle fonte. Modifiez votre '''rc.lua''' en ajoutant la ligne suivante :&lt;br/&gt;&lt;pre&gt;awesome.font_set(&quot;&lt;NomDeFonte&gt; &lt;Taille&gt;&quot;)&lt;/pre&gt;Si vous utilisez beautiful, changez aussi la variable de fonte de votre fichier de thème.

== Fontes bien sympathiques ==
Voici des endroits où vous trouverez des fontes qui sont nickel pour être utilisées dans awesome :
* [http://www.proggyfonts.com/index.php?menu=download Proggyfonts] a des fontes sympas qui peuvent être utilisées ;
* [http://www.kottke.org/plus/type/silkscreen/ Silkscreen] est une fonte TTF en bloc très lisible en petites tailles.

[[Category:Themes]]</text>
      <sha1>8lt1svuwepx4srd5js7i9xe6woqben1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Customizing Fonts/ru</title>
    <ns>0</ns>
    <id>1034</id>
    <revision>
      <id>6428</id>
      <timestamp>2014-05-02T17:45:52Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{DISPLAYTITLE:Настройка шрифтов}} {{Languages|Customizing Fonts}}  В некоторых скриншотах, вы можете увидеть, что люд...&quot;</comment>
      <text xml:space="preserve" bytes="3237">{{DISPLAYTITLE:Настройка шрифтов}}
{{Languages|Customizing Fonts}}

В некоторых скриншотах, вы можете увидеть, что люди добавляют/измеяют стандрартные шрифты. Это небольшое руководство расскажет вам, как сдлелать это. Есть несолько типов шрифтов доступных для использования в X, но здесь мы сосредоточимся на шрифтах ''xcf'', которые наиболее доступны.

== Добавление собственного каталога шрифтов ==

1) Скачайте шрифт, который планируете использовать. Он должен быть в формате .xcf. На сайте [http://www.proggyfonts.com/index.php?menu=download Proggyfonts] вы можете найти несколько шрифтов, которые могут вам понравится.

2) Извлеките из архива скачанный файл. Если он уже в формате .xcf, например FontName.xcf, он должен быть сжат с использованием gzip. Следующий скрипт сожмет все шрифты в каталоге:

   for x in ./*.xcf; do gzip &quot;$x&quot;; done

3) Создайте каталог для собственных шрифтов в каталоге awesome. Конечно этот каталог может быть где угодно в вашей системе. Скопируйте сжатые шрифты  .xcf в этот каталог.

4) Перейдите в этот каталог и запустите mkfontdir. Эта утилита создаст файл подсказку для X.
   
   cd ~/.config/awesome/fonts; mkfontdir

5) Затем, объясните X где находятся ваши шрифты:

   xset fp+ &quot;$HOME/.config/awesome/fonts&quot;

и заставьте X обновить информацию о шрифтах

   xset fp rehash

6) Теперь, запустите 'xlsfonts | grep &lt;fontname&gt;' или xfontsel, и ваши шрифты станут доступны.

7) В завершении, сконфигурируйте awesome для использования нового шрифта. Отредактируйте файл rc.lua добавив следующий код:

    awesome.font = &quot;&lt;fontname&gt; &lt;size&gt;&quot;

Если вы используете библиотеку beautiful, также измените переменную шрифта в вашей теме.

== Свободные шрифты ==

Месторасположение шрифтов для свободного использования в awesome.

* [http://www.proggyfonts.com/index.php?menu=download Proggyfonts] здесь вы можете найти несколько неплохих шрифтов, которые можно использовать.
* [http://www.kottke.org/plus/type/silkscreen/ Silkscreen] здесь вы можете найти шрифты TTF которые читабельны при малых размерах.

[[Category:Themes]]</text>
      <sha1>j9f58o7jukza2eo65dg0jowh8ilou0z</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Customizing GTK Apps</title>
    <ns>0</ns>
    <id>101</id>
    <revision>
      <id>5662</id>
      <parentid>5638</parentid>
      <timestamp>2012-11-30T17:48:39Z</timestamp>
      <contributor>
        <username>Justmao945</username>
        <id>1596</id>
      </contributor>
      <text xml:space="preserve" bytes="2922">{{Languages}}

If you are used to GNOME, you might want to learn how to change your theme without using the GNOME Theme Manager. GTK apps first try to get their themeing information through an [http://www.freedesktop.org/wiki/Specifications/xsettings-spec XSettings] provider, such as gnome-settings-daemon or xsettings-kde, and in absence of these reverts to files, ~/.gtkrc for gtk2 apps, ~/.config/gtk-3.0/settings.ini for gtk3 apps.

=Manually=

==Initial Setup==

First, create a file called &quot;.gtkrc-2.0&quot; in your home folder, and put this line in it:

 include '/home/&lt;username&gt;/.gtkrc.mine'

Next, create &quot;.gtkrc-1.2-gnome2&quot; and add the same line. Now create &quot;.gtkrc.mine&quot;. 

==GTK Themes==

To apply a theme, add this line to .gtkrc.mine:

 gtk-theme-name = &quot;Clearlooks&quot;

replacing the example name with the name to the theme you want to use (probably in /home/&lt;username&gt;/.themes).

===For GTK3 apps===

create the file ~/.config/gtk-3.0/settings.ini with contents:

[Settings]

gtk-icon-theme-name = &lt;icon-theme-name&gt;

gtk-theme-name = &lt;gtk-3-theme-name&gt;

==Icon Themes==

To apply an icon theme, add this line to '.gtkrc.mine':

  gtk-icon-theme-name = &quot;Tango&quot;

The name of the icon theme can be found in the index.theme file in the theme folder (probably in ~/.icons).

==Fonts==

To change the fonts of GTK apps, add this to your '.gtkrc.mine' file:

 style &quot;schrift&quot;
 {
 font_name = &quot;DejaVu Sans 10&quot;
 }
 widget_class &quot;*&quot; style &quot;schrift&quot;
 gtk-font-name = &quot;DejaVu Sans 10&quot;

==Toolbars==

To change the look of certain apps' toolbars (like gedit), add one of the following lines to your '.gtkrc.mine' file:

 gtk-toolbar-style   = GTK_TOOLBAR_ICONS              #Only icons
 gtk-toolbar-style   = GTK_TOOLBAR_TEXT	             #Only text
 gtk-toolbar-style   = GTK_TOOLBAR_BOTH	             #Both icons and text
 gtk-toolbar-style   = GTK_TOOLBAR_BOTH_HORIZ	     #Icons and text next to the icons

You can also change the size of the icons:
 gtk-toolbar-icon-size = 16,16

=Automatically=

There a few apps that you can use to change your theme without invoking gnome-settings-daemon:

* [http://www.gnomefiles.org/app.php/LXAppearance LXappearance] (Support gtk2 and gkt3)
* [http://www.muhri.net/nav.php3?node=gts gtk-theme-switch]
* [http://plasmasturm.org/code/gtk-chtheme/ gtk-chtheme]
* [http://gnomecc.sourceforge.net/ gnome-color-chooser]

=Example=

The following is an example '.gtkrc.mine' file:

 ##################
 #      GTK       #
 ##################
 
 include &quot;/usr/share/themes/Clearlooks/gtk-2.0/gtkrc&quot;
 
 
 ##################
 #     FONTS      #
 ##################
 
 style &quot;schrift&quot;
 {
 font_name = &quot;Myriad Web 9&quot;
 }
 widget_class &quot;*&quot; style &quot;schrift&quot;
 gtk-font-name = &quot;Myriad Web 9&quot;
 
 
 ##################
 #     ICONS      #
 ##################
 
 gtk-icon-theme-name = &quot;Crashbit&quot;
 
 
 ##################
 #    TOOLBARS    #
 ##################
 
 gtk-toolbar-style   = GTK_TOOLBAR_ICONS</text>
      <sha1>esxakzriwef5qvyhja78m5zvn0satjq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Customizing GTK Apps/fr</title>
    <ns>0</ns>
    <id>429</id>
    <revision>
      <id>3351</id>
      <parentid>3214</parentid>
      <timestamp>2009-07-15T19:00:57Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Don't use Template:Title, but DISPLAYTITLE</comment>
      <text xml:space="preserve" bytes="3284">{{DISPLAYTITLE:Personnaliser les applications GTK}}
{{Languages|Customizing GTK Apps}}

Si vous êtes habitué à Gnome, vous voudrez peut-être savoir comment changer votre thème sous utiliser le gestionnaire de thèmes de Gnome, puisqu’il repose sur ''gnome-settings-daemon'', un processus qui est en permanence en mémoire et gaspille les ressources système. Toutefois, il est possible de changer le thème des applications GTK à la main sans ce processus.

== À la main ==
=== Configuration de départ ===
Tout d’abord, créez un fichier '''.gtkrc-2.0''' dans votre dossier personnel, avec la ligne suivante :
 include '~/.gtkrc.mine'

Vous pouvez remplacer '''~''' par '''/home/nom_d’utilisateur'''. Ensuite, créez un fichier '''.gtkrc-1.2-gnome2''' avec le même contenu.

Maintenant, il ne vous reste plus qu’à créer un fichier '''.gtkrc.mine''' et à le remplir avec les informations suivantes :

=== Thèmes GTK ===
Pour appliquer un thème, ajoutez la ligne suivante :
 include '/usr/share/themes/Clearlooks/gtk-2.0/gtkrc'

en remplaçant le chemin d’exemple par le chemin vers le fichier '''gtkrc''' du thème que vous voulez. Il peut être dans '''~/.themes'''.

=== Thèmes d’icônes ===
Pour appliquer un thème d’icônes, ajoutez la ligne suivante dans '''.gtkrc.mine''' :
 gtk-icon-theme-name = &quot;Tango&quot;

Le nom du thème d’icône peut être trouvé dans le fichier '''index.theme''' du dossier de thème. À nouveau, il peut être dans '''~/.icons'''.

=== Fontes ===
Pour changer les fontes dans applications GTK, c’est ce qui suit qu’il faut ajouter à votre fichier '''.gtkrc.mine''' :
 style &quot;schrift&quot;
 {
 font_name = &quot;DejaVu Sans 10&quot;
 }
 widget_class &quot;*&quot; style &quot;schrift&quot;
 gtk-font-name = &quot;DejaVu Sans 10&quot;

=== Barres d’outils ===
Pour changer l’apparence des barres d’outils de certaines applications, telles que ''gedit'', ajoutez l’une de ces lignes dans votre fichier '''.gtkrc.mine''' :
 gtk-toolbar-style = GTK_TOOLBAR_ICONS		# Icônes seulement
 gtk-toolbar-style = GTK_TOOLBAR_TEXT		# Texte seulement
 gtk-toolbar-style = GTK_TOOLBAR_BOTH		# Icônes et texte
 gtk-toolbar-style = GTK_TOOLBAR_BOTH_HORIZ	# Icônes et texte à côté

Vous pouvez également changer la taille des icônes :
 gtk-toolbar-icon-size = 16,16

== Automatiquement ==
Il y a quelques applications que vous pouvez utilisez pour changer votre thème sans avoir recours à ''gnome-settings-daemon'' :
* [http://www.gnomefiles.org/app.php/LXAppearance LXappearance] ;
* [http://www.muhri.net/nav.php3?node=gts gtk-theme-switch] ;
* [http://plasmasturm.org/code/gtk-chtheme/ gtk-chtheme] ;
* [http://gnomecc.sourceforge.net/ gnome-color-chooser].

== Exemple ==
Voici un exemple de fichier '''.gtkrc.mine''' :

 ####################
 #       GTK        #
 ####################
 
 include &quot;/usr/share/themes/Clearlooks/gtk-2.0/gtkrc&quot;
 
 
 ####################
 #      FONTES      #
 ####################
 
 style &quot;schrift&quot;
 {
 font_name = &quot;Myriad Web 9&quot;
 }
 widget_class &quot;*&quot; style &quot;schrift&quot;
 gtk-font-name = &quot;Myriad Web 9&quot;
 
 
 ####################
 #      ICONES      #
 ####################
 
 gtk-icon-theme-name = &quot;Crashbit&quot;
 
 
 ####################
 # BARRES  D’OUTILS #
 ####################
 
 gtk-toolbar-style   = GTK_TOOLBAR_ICONS</text>
      <sha1>539y3hqfirh65u7j0aqqmjtrzdua0yg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Customizing GTK Apps/ru</title>
    <ns>0</ns>
    <id>463</id>
    <revision>
      <id>6730</id>
      <parentid>3464</parentid>
      <timestamp>2014-06-09T05:08:27Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>upgrading translate for current version</comment>
      <text xml:space="preserve" bytes="4532">{{DISPLAYTITLE:Настройка приложений GTK}}
{{Languages|Customizing GTK Apps}}

Если Вы привыкли к GNOME, то, возможно, захотите узнать, как изменять темы GTK, не используя GNOME Theme Manager, так как для работы последнего необходим запущенный процесс gnome-settings-daemon, расходующий системные ресурсы. Темы приложений GTK можно изменять и другими способами. 
GTK приложения сначала пытаются получить оформление через [http://www.freedesktop.org/wiki/Specifications/xsettings-spec XSettings], такие как gnome-settings-daemon или xsettings-kde, и при их отсутствии обращается к файлам: ~/.gtkrc для приложений gtk2, ~/.config/gtk-3.0/settings.ini для приложений gtk3.

=Вручную=

==Начальная настройка==

Для начала создайте в домашнем каталоге файл &quot;.gtkrc-2.0&quot; и добавьте в него строку:

 include '~/.gtkrc.mine'

~ можно заменить на '/home/&lt;имя пользователя&gt;'. Теперь создайте файл &quot;.gtkrc-1.2-gnome2&quot; с таким же содержимым, а затем файл &quot;.gtkrc.mine&quot;. 

==Темы GTK==

Чтобы выбрать тему, добавьте в &quot;.gtkrc.mine&quot;:
 gtk-theme-name = &quot;Clearlooks&quot;
или непосредственно указав каталог и файл с темой
 include '/usr/share/themes/Clearlooks/gtk-2.0/gtkrc'

замените путь из примера на путь к теме, которую Вы хотите использовать (обычно пользовательские темы находятся в ~/.themes).

=== Темы приложений GTK3 ===

создайте файл ~/.config/gtk-3.0/settings.ini со следующим содержимым:

[Settings]

gtk-icon-theme-name = &lt;icon-theme-name&gt;

gtk-theme-name = &lt;gtk-3-theme-name&gt;

==Темы значков==

Для выбора темы значков добавьте в &quot;.gtkrc.mine&quot;:

  gtk-icon-theme-name = &quot;Tango&quot;

Имя темы можно узнать из файла index.theme в каталоге темы (обычно они находятся в ~/.icons).

==Шрифты==

Чтобы изменить шрифты, используемые приложениями GTK, добавьте в &quot;.gtkrc.mine&quot;:

 style &quot;schrift&quot;
 {
 font_name = &quot;DejaVu Sans 10&quot;
 }
 widget_class &quot;*&quot; style &quot;schrift&quot;
 gtk-font-name = &quot;DejaVu Sans 10&quot;

==Панели инструментов==

Для изменения внешнего вида панелей инструментов в некоторых приложениях (к примеру, gedit), добавьте в &quot;.gtkrc.mine&quot; одну из следующих строк:

 gtk-toolbar-style   = GTK_TOOLBAR_ICONS              #Только значки
 gtk-toolbar-style   = GTK_TOOLBAR_TEXT	             #Только текст
 gtk-toolbar-style   = GTK_TOOLBAR_BOTH	             #Значки и текст
 gtk-toolbar-style   = GTK_TOOLBAR_BOTH_HORIZ	     #Значки и текст справа от них

Также можно изменить размер значков:
 gtk-toolbar-icon-size = 16,16

=Автоматизация=

Существует несколько приложений, которые могут изменять темы без gnome-settings-daemon (многие из них практически без зависимостей):

* [http://www.gnomefiles.org/app.php/LXAppearance LXappearance]
* [http://www.muhri.net/nav.php3?node=gts gtk-theme-switch]
* [http://plasmasturm.org/code/gtk-chtheme/ gtk-chtheme]
* [http://gnomecc.sourceforge.net/ gnome-color-chooser]

=Пример=

Вот пример файла &quot;.gtkrc.mine&quot;:

 ##################
 #      GTK       #
 ##################
 
 include &quot;/usr/share/themes/Clearlooks/gtk-2.0/gtkrc&quot;
 
 
 ##################
 #     FONTS      #
 ##################
 
 style &quot;schrift&quot;
 {
 font_name = &quot;Myriad Web 9&quot;
 }
 widget_class &quot;*&quot; style &quot;schrift&quot;
 gtk-font-name = &quot;Myriad Web 9&quot;
 
 
 ##################
 #     ICONS      #
 ##################
 
 gtk-icon-theme-name = &quot;Crashbit&quot;
 
 
 ##################
 #    TOOLBARS    #
 ##################
 
 gtk-toolbar-style   = GTK_TOOLBAR_ICONS</text>
      <sha1>skqjvjkw1bc4k8t4nm5ktst01gp4tpq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Cycling Random Wallpaper Or Xscreensaver</title>
    <ns>0</ns>
    <id>586</id>
    <revision>
      <id>7424</id>
      <parentid>6584</parentid>
      <timestamp>2016-01-29T17:21:21Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>/* Change the wallpaper randomly after a (relatively random) time (for awesome &lt;= 3.4) : */ 3.4 doesn't have :connect_signal(), thanks Thomas Sautter for the report</comment>
      <text xml:space="preserve" bytes="4816">{{Languages}}

''Note : Don't use BOTH functions at the same time, as the screensaver will overwrite the picture!''

You will need to seed the random number generator and ''&quot;pop a few&quot;'' ( official term from the lua documentation) first. If you don't do this you will always have the same sequence. Add those lines before adding any of the following code snippets :

&lt;pre&gt;
-- seed and &quot;pop a few&quot;
math.randomseed( os.time())
for i=1,1000 do tmp=math.random(0,1000) end
&lt;/pre&gt;
== Change the wallpaper randomly (for awesome &gt;= 3.5) : ==

add this to your ''rc.lua''

&lt;pre&gt;
-- configuration - edit to your liking
wp_index = 1
wp_timeout  = 10
wp_path = &quot;/path/to/wallpapers/&quot;
wp_files = { &quot;01.jpg&quot;, &quot;02.jpg&quot;, &quot;03.jpg&quot; }
 
-- setup the timer
wp_timer = timer { timeout = wp_timeout }
wp_timer:connect_signal(&quot;timeout&quot;, function()
 
  -- set wallpaper to current index
  gears.wallpaper.maximized( wp_path .. wp_files[wp_index] , s, true)
 
  -- stop the timer (we don't need multiple instances running at the same time)
  wp_timer:stop()
 
  -- get next random index
  wp_index = math.random( 1, #wp_files)
 
  --restart the timer
  wp_timer.timeout = wp_timeout
  wp_timer:start()
end)
 
-- initial start when rc.lua is first run
wp_timer:start()
&lt;/pre&gt;

== Change the wallpaper randomly after a (relatively random) time (for awesome &lt;= 3.4) : ==

add this to your ''rc.lua''

&lt;pre&gt;

x = 0

-- setup the timer
mytimer = timer { timeout = x }
mytimer:add_signal(&quot;timeout&quot;, function()

  -- tell awsetbg to randomly choose a wallpaper from your wallpaper directory
  os.execute(&quot;awsetbg -T -r /usr/share/wallpapers&amp;&quot;)

  -- stop the timer (we don't need multiple instances running at the same time)
  mytimer:stop()

  -- define the interval in which the next wallpaper change should occur in seconds
  -- (in this case anytime between 10 and 20 minutes)
  x = math.random( 600, 1200)

  --restart the timer
  mytimer.timeout = x
  mytimer:start()
end)

-- initial start when rc.lua is first run
mytimer:start()
&lt;/pre&gt;

== Use an xscreensaver module as an animated wallpaper and switch to another after some time ==

''(Warning : using transparency with this will result in weird effects and in the worst case scenario you won't see anything but the wallpaper!)''

So your CPU is idling most of the time and you want some funky eye candy? Here is your solution : run a screensaver as wallpaper!
You will need to install [[xscreensaver]] first, then add the following code to your rc.lua :

&lt;pre&gt;
x= 0

-- setup the timer
mytimer = timer { timeout = x }
mytimer:connect_signal(&quot;timeout&quot;, function()

    -- list the wallpaper you want to use (They can be found in /usr/lib/xscreensaver/) followed by any additional 
    -- parameters you need in a separate array element
    back = { &quot;atlantis&quot;, &quot;-whalespeed 826 -size 3027 -count 15&quot;,  &quot;substrate&quot;, &quot;&quot;, &quot;fliptext&quot;, &quot;&quot;, &quot;glmatrix&quot;, &quot;-mode hex&quot; }

    -- kill any screensaver from the list that might be running
    for i=1, table.getn(back),2 do
        os.execute(&quot;killall -I &quot;.. back[i] .. &quot; 2&gt; /dev/null&quot;)
    end

    -- set the background colour to black (just in case, as sometimes the screensavers seem to keep whatever is in the videobuffer)
    os.execute(&quot;xsetroot -bg black&quot;)

    -- select a new screensaver
    y = math.random( 1, (table.getn(back)/2))-1
    os.execute( &quot;/usr/lib/xscreensaver/&quot; .. back[ (y*2) + 1] .. &quot; -root &quot; .. back[ (y*2) + 2] .. &quot;&amp;&quot;)

    -- define the interval in which the next wallpaper change should occur in seconds
    -- (in this case anytime between 10 and 20 minutes)
    x = math.random( 600, 1200)

    -- reset the timer
    mytimer:stop()
    mytimer.timeout = x
    mytimer:start()
end)

-- initial start on the first run
mytimer:start()
&lt;/pre&gt;

== Toggle the timer on and off ==


You will probably need a way to toggle the timer on and off. Add this block to  mymainmenu in the default rc.lua to do that for the xscreensaver timer :

&lt;pre&gt;
{ &quot;toggle wallpaper&quot;, function()

     -- check whether the timer is running
     if mytimer.started then
        -- stop and set the timer to 0
	mytimer:stop() 
	mytimer.timeout = 0
        -- kill any running xscreensaver from the list used earlier on (no need for the parameters this time)
	back = { &quot;atlantis&quot;,  &quot;substrate&quot;, &quot;fliptext&quot;, &quot;glmatrix&quot; }
	for i=1, table.getn(back) do
	    os.execute(&quot;killall -I &quot;.. back[i] .. &quot; 2&gt; /dev/null&quot;)
        end                                                        
        -- optionally set a random static wallpaper 
        os.execute(&quot;awsetbg -T -r /usr/share/wallpapers&amp;&quot;)                                                                  
     else
        -- reset and restart the timer
	mytimer.timeout = 0
	mytimer:start()
     end
  end
},
&lt;/pre&gt;

Writing a toggle for the static wallpaper timer is similar (but much shorter)</text>
      <sha1>8g0motdpccrlft8ps0dfyzkq6xkuu2m</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Cycling Random Wallpaper Or Xscreensaver/ru</title>
    <ns>0</ns>
    <id>1067</id>
    <revision>
      <id>6586</id>
      <timestamp>2014-05-21T18:01:16Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Cycling Random Wallpaper Or Xscreensaver (translating page)</comment>
      <text xml:space="preserve" bytes="6895">{{DISPLAYTITLE:Случайные обои или Xscreensaver}}
{{Languages|Cycling Random Wallpaper Or Xscreensaver}}

''Примечание : Не испльзуйте одновременно ОБЕ функции, иначе в качестве заставки будет использоваться изображение!''

Для начала вам необходимо будет инициализировать генератор случайных числе и  ''&quot;pop a few&quot;'' (официальный термин из документации Lua). Если вы этого не сделаете, то всегда будете иметь одну и ту же последовательность. Добавьте эти строки перед добавлением любого следующего фрагмента кода:

&lt;pre&gt;
-- seed and &quot;pop a few&quot;
math.randomseed( os.time())
for i=1,1000 do tmp=math.random(0,1000) end
&lt;/pre&gt;
== Случайное изменение фоновой картинки (для awesome &gt;= 3.5) ==

Добавьте этот код в ''rc.lua''

&lt;pre&gt;
-- конфигурация - отредактируйте по своему вкусу
wp_index = 1
wp_timeout  = 10
wp_path = &quot;/path/to/wallpapers/&quot;
wp_files = { &quot;01.jpg&quot;, &quot;02.jpg&quot;, &quot;03.jpg&quot; }
 
-- установка таймера
wp_timer = timer { timeout = wp_timeout }
wp_timer:connect_signal(&quot;timeout&quot;, function()
 
  -- установка обоев в текущий индекс
  gears.wallpaper.maximized( wp_path .. wp_files[wp_index] , s, true)
 
  -- остановка таймера (нам не нужны многочисленные экземпляры запущенные в то же время)
  wp_timer:stop()
 
  -- получаем следующий случайный индекс
  wp_index = math.random( 1, #wp_files)
 
  --перезапуск таймера
  wp_timer.timeout = wp_timeout
  wp_timer:start()
end)
 
-- инициализируйте запуск при первом запуске rc.lua
wp_timer:start()
&lt;/pre&gt;

== Случайное изменение фонового изображения (относительно случайно) для awesome &lt;= 3.4 ==

добавьте этот код в ''rc.lua''

&lt;pre&gt;

x = 0

-- настройка таймера
mytimer = timer { timeout = x }
mytimer:connect_signal(&quot;timeout&quot;, function()

  -- указать awsetbg на случайный выбор обоев из каталога с обоями
  os.execute(&quot;awsetbg -T -r /usr/share/wallpapers&amp;&quot;)

  -- остановка таймера (нам не нужны многочисленные экземпляры запущенные в то же время)
  mytimer:stop()

  -- определяем интервал до смены обоев, в секундах
  -- (в данном случае в промежутке между 10 и 20 минутами)
  x = math.random( 600, 1200)

  --перезапускаем таймер
  mytimer.timeout = x
  mytimer:start()
end)

-- инициализируйте запуск при первом запуске rc.lua
mytimer:start()
&lt;/pre&gt;

== Использование модуля xscreensaver для анимации фоновой картинки и ее изменения через заданное время ==

''(Предупреждение : использование прозрачности с этим кодам приводит к странным результатам и в худшем случае вы не увидите ничего кроме обоев!)''

Вваш CPU большую часть времени простаивает, и вы хотите сделать картинку приятной глазу? Здесь приведено решение для вас: запустите скринсейвер в качестве обоев!
Для начала вам необходимо установить [[xscreensaver]], а затем добавить следующий код в rc.lua :

&lt;pre&gt;
x= 0

-- setup the timer
mytimer = timer { timeout = x }
mytimer:connect_signal(&quot;timeout&quot;, function()

    -- list the wallpaper you want to use (They can be found in /usr/lib/xscreensaver/) followed by any additional 
    -- parameters you need in a separate array element
    back = { &quot;atlantis&quot;, &quot;-whalespeed 826 -size 3027 -count 15&quot;,  &quot;substrate&quot;, &quot;&quot;, &quot;fliptext&quot;, &quot;&quot;, &quot;glmatrix&quot;, &quot;-mode hex&quot; }

    -- kill any screensaver from the list that might be running
    for i=1, table.getn(back),2 do
        os.execute(&quot;killall -I &quot;.. back[i] .. &quot; 2&gt; /dev/null&quot;)
    end

    -- set the background colour to black (just in case, as sometimes the screensavers seem to keep whatever is in the videobuffer)
    os.execute(&quot;xsetroot -bg black&quot;)

    -- select a new screensaver
    y = math.random( 1, (table.getn(back)/2))-1
    os.execute( &quot;/usr/lib/xscreensaver/&quot; .. back[ (y*2) + 1] .. &quot; -root &quot; .. back[ (y*2) + 2] .. &quot;&amp;&quot;)

    -- define the interval in which the next wallpaper change should occur in seconds
    -- (in this case anytime between 10 and 20 minutes)
    x = math.random( 600, 1200)

    -- reset the timer
    mytimer:stop()
    mytimer.timeout = x
    mytimer:start()
end)

-- инициализируйте запуск при первом запуске
mytimer:start()
&lt;/pre&gt;

== Вкл/выкл таймер ==


Иногда вам может потребоваться включить или выключить таймер. Добавьте следующий блок в секцию mymainmenu в rc.lua, для работы с таймером xscreensaver:

&lt;pre&gt;
{ &quot;toggle wallpaper&quot;, function()

     -- проверяем запущен ли таймер
     if mytimer.started then
        -- останавливаем и устанавливаем таймер на 0
	mytimer:stop() 
	mytimer.timeout = 0
        -- kill все запущенные xscreensaver из списка использованного ранее (в этот раз не нужны параметры)
	back = { &quot;atlantis&quot;,  &quot;substrate&quot;, &quot;fliptext&quot;, &quot;glmatrix&quot; }
	for i=1, table.getn(back) do
	    os.execute(&quot;killall -I &quot;.. back[i] .. &quot; 2&gt; /dev/null&quot;)
        end                                                        
        -- опционально устанавливаем случайные статические обои
        os.execute(&quot;awsetbg -T -r /usr/share/wallpapers&amp;&quot;)                                                                  
     else
        -- сбрасываем и перезапускаем таймер
	mytimer.timeout = 0
	mytimer:start()
     end
  end
},
&lt;/pre&gt;

Написание переключателя для статического(не скринсейвера) таймера обоев сходно (но значительно короче).</text>
      <sha1>5qjta3irs1f2i4x88mzfr85phkls4k1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Darkblue Theme</title>
    <ns>0</ns>
    <id>685</id>
    <revision>
      <id>4899</id>
      <parentid>4897</parentid>
      <timestamp>2011-06-13T13:24:58Z</timestamp>
      <contributor>
        <username>Nevious</username>
        <id>656</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="3630">[[Image:Darkblue_theme.png|thumb|Screenshot]]

&lt;pre&gt;

---------------------------------------------------
--  dark blue theme for awesome wm
--    By Chris S. (cs@nevious.ch)
--    Original theme: zenburn by Adrian C. (anrxc)
-- 
-- Licence:
--      GNU GPLv2
----------------------------------------------------

-- {{{ Main
theme = {}
theme.wallpaper_cmd = {&quot;awsetbg -t -r &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/wallpapers/&quot;}
-- }}}

-- {{{ Styles
theme.font      = &quot;terminus 8&quot;

-- {{{ Colors
theme.fg_normal = &quot;#d7d2d0&quot;
theme.fg_focus  = &quot;#3599c9&quot;
theme.fg_urgent = &quot;#e34c10&quot;
theme.bg_normal = &quot;#3b3b3b&quot;
theme.bg_focus  = &quot;#2d2d2d&quot;
theme.bg_urgent = &quot;#3F3F3F&quot;
-- }}}

-- {{{ Borders
theme.border_width  = &quot;1&quot;
theme.border_normal = &quot;#3f3f3f&quot;
theme.border_focus  = &quot;#00a6dc&quot;
theme.border_marked = &quot;#CC9393&quot;
-- }}}

-- {{{ Titlebars
theme.titlebar_bg_focus  = &quot;#254090&quot;
theme.titlebar_bg_normal = &quot;#3F3F3F&quot;
-- }}}

-- There are other variable sets
-- overriding the default one when
-- defined, the sets are:
-- [taglist|tasklist]_[bg|fg]_[focus|urgent]
-- titlebar_[normal|focus]
-- tooltip_[font|opacity|fg_color|bg_color|border_width|border_color]
theme.taglist_bg_focus = &quot;#000000&quot;
-- }}}

-- {{{ Widgets
-- You can add as many variables as
-- you wish and access them by using
-- beautiful.variable in your rc.lua
--theme.fg_widget        = &quot;#AECF96&quot;
--theme.fg_center_widget = &quot;#88A175&quot;
--theme.fg_end_widget    = &quot;#FF5656&quot;
--theme.bg_widget        = &quot;#494B4F&quot;
-- theme.border_widget    = &quot;#3F3F3F&quot;
-- }}}

-- {{{ Mouse finder
theme.mouse_finder_color = &quot;#CC9393&quot;
-- mouse_finder_[timeout|animate_timeout|radius|factor]
-- }}}

-- {{{ Menu
-- Variables set for theming the menu:
-- menu_[bg|fg]_[normal|focus]
-- menu_[border_color|border_width]
theme.menu_height = &quot;15&quot;
theme.menu_width  = &quot;100&quot;
theme.menu_border_color = &quot;#000000&quot;
-- }}}

-- {{{ Icons
-- {{{ Taglist
theme.taglist_squares_sel   = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/taglist/squarefz.png&quot;
theme.taglist_squares_unsel = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/taglist/squarez.png&quot;
--theme.taglist_squares_resize = &quot;false&quot;
-- }}}

-- {{{ Misc
theme.awesome_icon           = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/awesome-icon.png&quot;
theme.tasklist_floating_icon = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/tasklist/floating.png&quot;
-- }}}

-- {{{ Layout
theme.layout_tile       = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/tile.png&quot;
theme.layout_tileleft   = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/tileleft.png&quot;
theme.layout_tilebottom = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/tilebottom.png&quot;
theme.layout_tiletop    = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/tiletop.png&quot;
theme.layout_fairv      = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/fairv.png&quot;
theme.layout_fairh      = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/fairh.png&quot;
theme.layout_spiral     = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/spiral.png&quot;
theme.layout_dwindle    = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/dwindle.png&quot;
theme.layout_max        = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/max.png&quot;
theme.layout_fullscreen = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/fullscreen.png&quot;
theme.layout_magnifier  = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/magnifier.png&quot;
theme.layout_floating   = awful.util.getdir(&quot;config&quot;) .. &quot;/themes/darkblue/layouts/floatingw.png&quot;
-- }}}
return theme
&lt;/pre&gt;
[http://nevious.ch/dump/darkblue_theme.tar.gz Download]

[[Category:Themes]]</text>
      <sha1>a1bn6trtmlioeo9yg8hv8vf7ufv33ow</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Darklooks theme</title>
    <ns>0</ns>
    <id>640</id>
    <revision>
      <id>4693</id>
      <parentid>4685</parentid>
      <timestamp>2011-01-21T02:49:10Z</timestamp>
      <contributor>
        <username>Tj</username>
        <id>575</id>
      </contributor>
      <text xml:space="preserve" bytes="248">[[Image:Darklooks.png|thumb|Screenshot]]

Dark theme that is designed to be used with Darklooks GTK+ theme. Includes full support for [[Delightful]] widgets.

Download information at http://solitudo.net/software/awesome/themes/

[[Category:Themes]]</text>
      <sha1>iwopai3ltesc044gaphwj8qeytabz2i</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Davids volume widget</title>
    <ns>0</ns>
    <id>1184</id>
    <revision>
      <id>6987</id>
      <parentid>6985</parentid>
      <timestamp>2014-08-22T22:41:04Z</timestamp>
      <contributor>
        <username>David</username>
        <id>3473</id>
      </contributor>
      <text xml:space="preserve" bytes="4062">=== Introduction ===
This is a very low-profile volume widget. I designed it for awesome 3.5. I use pulseaudio, but if your commands for increase/decrease/mute volume differ it should be easy to adapt this widget.

=== Functionality ===
The widget is a small vertical progress bar, pictured below:

[[File:davids_volume_widget_normal.png]]

The height of the green bar corresponds to the current volume. If the volume is muted then the bar is red:

[[File:davids_volume_widget_muted.png]]

If the volume exceeds 100% (i.e. it's amplified) a blue bar is drawn over the green one. If the volume exceeds 200% the blue bar resets (so you have to remember the hundreds digit past 100, but you probably don't want to amplify that much anyway):

[[File:davids_volume_widget_over_100.png]]

The excerpts of my conf files below also provide key bindings for increasing, decreasing, and muting the volume.

=== volume.lua ===
Create the file volume.lua with the following contents:

  -- Creates a volume display widget
  -- Copied/adapted from https://awesome.naquadah.org/wiki/Davids_volume_widget
  ---------------------------------
  
  local awful = require(&quot;awful&quot;)
  
  -- Color constants
  local normal_color = '#33cc33'
  local over_100_color = '#3333cc'
  local mute_color = '#cc3333'
  local background_color = '#222222'
  local background_over_100_color = normal_color
  
  -- Functions to fetch volume information (pulseaudio)
  function get_volume() -- returns the volume as a float (1.0 = 100%)
      local fd = io.popen(&quot;pactl list | grep -A 9001 'Sink #0' | grep Volume | head -n 1 | awk -F / '{print $2}' | sed 's/[^0-9]*//g'&quot;)
      local volume_str = fd:read(&quot;*all&quot;)
      fd:close()
      return tonumber(volume_str) / 100
  end
  
  function get_mute() -- returns a true value if muted or a false value if not
      fd = io.popen(&quot;pactl list | grep -A 9001 'Sink #0' | grep Mute | head -n 1&quot;)
      local mute_str = fd:read(&quot;*all&quot;)
      fd:close()
      return string.find(mute_str, &quot;yes&quot;)
  end
  
  -- Updates the volume widget's display
  function update_volume(widget)
      local volume = get_volume()
      local mute = get_mute()
  
      -- color
      color = normal_color
      bg_color = background_color
      if volume &gt; 1 then
          color = over_100_color
          bg_color = background_over_100_color
          volume = volume % 1
      end
      color = (mute and mute_color) or color
  
      widget:set_color(color)
      widget:set_background_color(bg_color)
  
      widget:set_value(volume)
  end
  
  -- Volume control functions for external use
  function inc_volume(widget)
      awful.util.spawn(&quot;pactl set-sink-volume 0 -- +3%&quot;, false)
      update_volume(widget)
  end
  
  function dec_volume(widget)
      awful.util.spawn(&quot;pactl set-sink-volume 0 -- -3%&quot;, false)
      update_volume(widget)
  end
  
  function mute_volume(widget)
      awful.util.spawn(&quot;pactl set-sink-mute 0 toggle&quot;, false)
      update_volume(widget)
  end
  
  function create_volume_widget()
      -- Define volume widget
      volume_widget = awful.widget.progressbar()
      volume_widget:set_width(8)
      volume_widget:set_vertical(true)
      volume_widget:set_border_color('#666666')
  
      -- Init the widget
      update_volume(volume_widget)
  
      -- Update the widget on a timer
      mytimer = timer({ timeout = 1 })
      mytimer:connect_signal(&quot;timeout&quot;, function () update_volume(volume_widget) end)
      mytimer:start()
  
      return volume_widget
  end

=== rc.lua ===
Require the volume file at the top of rc.lua along with your other requirements:

  require(&quot;volume&quot;)

Create the volume widget and add it to your layout:

  volume_widget = create_volume_widget()
  right_layout:add(volume_widget)

To set up key bindings, add the following to your globalkeys:

    awful.key({ }, &quot;XF86AudioRaiseVolume&quot;, function () inc_volume(volume_widget) end),
    awful.key({ }, &quot;XF86AudioLowerVolume&quot;, function () dec_volume(volume_widget) end),
    awful.key({ }, &quot;XF86AudioMute&quot;, function() mute_volume(volume_widget) end),</text>
      <sha1>fyz3xl57304fh0iuowmj5kncor8ccum</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Dbus, naughty and logs</title>
    <ns>0</ns>
    <id>265</id>
    <revision>
      <id>6508</id>
      <parentid>6267</parentid>
      <timestamp>2014-05-15T16:37:26Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="7435">{{Languages}}

You can make your computer watch your logs and tell you by a popup notification when there is a new log. 

== Features of this tutorial ==

* Window manager independant (relies on dbus to send the notifications, so any notify-daemon like naughty could do the job)
* No monitoring is used, the notifications come in real time thanks to the [http://en.wikipedia.org/wiki/Inotify inotify feature of the linux kernel]

== Other implementations ==
* There is another implementation which doesn't rely on any external tools (only ''luainotify'' bindings): [[Naughty log watcher]]
* Approach of this script will lead to inaccurate results if log is updating too frequently. the following [http://git.ierton.ru/?p=awesomerc;a=blob_plain;f=logmonitor;hb=master script] has been written for the same purpose. This modification uses 'tail -F -n0' instead of 'inotifywait' .

== Requirements ==

You'll need to install '''libnotify''', '''libnotify-bin''', '''inotify-tools''', '''incron''' and '''source-highlight'''.

=== verify that naughty has support for dbus ===

  notify-send hello world

If no popup appears, check that you have 'require(&quot;naughty&quot;)' in you rc.lua.

=== make sure you can display you logs ===

  tail -n 10 /var/log/kernel.log

If your system tells you you can't do that because of poor rights, you must add yourself to the log group (gpasswd -a &lt;user&gt; log), then logout/login to enable the modification.

=== enable source-highlight for awesome ===

source-highlight is a tool that does syntax highlighting. The output can be in html, terminal escape color codes, and as it is very extendable, you can provide your own output format. A cool feature of naughty is that it can display colored words, using
&lt;pre&gt;
&lt;span color=&quot;mycolor&quot;&gt;word&lt;/span&gt;
&lt;/pre&gt;
Here is a file to provide to source-highlight so that it outputs in naughty format. Save it wherever you whish as 'awesome.outlang'.
&lt;pre&gt;
extension &quot;awesome&quot;

color &quot;&lt;span color=\&quot;$style\&quot;&gt;$text&lt;/span&gt;&quot;

colormap
&quot;green&quot; &quot;#33CC00&quot;
&quot;red&quot; &quot;#FF0000&quot;
&quot;darkred&quot; &quot;#990000&quot;
&quot;blue&quot; &quot;#0000FF&quot;
&quot;brown&quot; &quot;#9A1900&quot;
&quot;pink&quot; &quot;#CC33CC&quot;
&quot;yellow&quot; &quot;#FFCC00&quot;
&quot;cyan&quot; &quot;#66FFFF&quot;
&quot;purple&quot; &quot;#993399&quot;
&quot;orange&quot; &quot;#FF6600&quot;
&quot;brightorange&quot; &quot;#FF9900&quot;
&quot;brightgreen&quot; &quot;#33FF33&quot;
&quot;darkgreen&quot; &quot;#009900&quot;
&quot;black&quot; &quot;#000000&quot;
&quot;teal&quot; &quot;#008080&quot;
&quot;gray&quot; &quot;#808080&quot;
&quot;darkblue&quot; &quot;#000080&quot;
default &quot;#66FFFF&quot;
end
&lt;/pre&gt;

Note: This file is customisable: if you do not like the default colors, you can obviously modify them very easily. If you whish to perform advanced modifications, you'll find ressources to do it on [http://www.gnu.org/software/src-highlite/source-highlight.html#Output-format-style the source-highlight website]).

=== Write a script to output notifications ===

The following script reads the first line of a file, highlights it, and sends it to dbus as a notification. Save it wherever you want (say /home/me/scripts/popLog.sh)

&lt;pre&gt;
#!/bin/bash

# Usage: ./popLog.sh /var/log/yourlog
# pops a colored log with the last line of the log

export DISPLAY=&quot;:0.0&quot;
export SYNTAXHIGHLIGHTFILE=&quot;/home/joe/.config/awesome/awesome.outlang&quot; # CHANGE ME

#Urgency
infoUrgency='low'
warningUrgency='normal'
errorUrgency='critical'
securityUrgency='critical'
 
#Popup time
infoPopupTime=5000
warningPopupTime=8000
errorPopupTime=11000
securityPopupTime=11000
 
#Icons
infoIcon='/usr/share/icons/gnome/32x32/status/dialog-information.png'
warningIcon='/usr/share/icons/gnome/32x32/status/dialog-warning.png'
errorIcon='/usr/share/icons/gnome/32x32/status/dialog-error.png'
securityIcon='/usr/share/icons/gnome/32x32/status/security-medium.png'

coloredLog=$(tail -n 1 $1 |                   \
  source-highlight --failsafe                 \
                   --src-lang=log             \
                   --style-file=default.style \
                   --outlang-def=${SYNTAXHIGHLIGHTFILE})

if [ -n &quot;$coloredLog&quot; ] ; then
    #echo $coloredLog
    
    if $(echo $1|grep info) ; then messageType='info'; fi
    if $(echo $1|grep warn) ; then messageType='warning'; fi
    if $(echo $1|grep err) ; then messageType='error'; fi
    if $(echo $1|grep auth) ; then messageType='security'; fi
    if $(echo $1|grep access) ; then messageType='security';fi
    if $(echo $notification|grep 'UFW BLOCK INPUT') ; then
        messageType='security'; fi
    if [ -z &quot;$messageType&quot; ] ; then messageType='info'; fi
       
    case $messageType in
    info)
        urgency=$infoUrgency
        icon=$infoIcon
        popupTime=$infoPopupTime
    ;;
    warning)
        urgency=$warningUrgency
        icon=$warningIcon
        popupTime=$warningPopupTime
    ;;
    error)
        urgency=$errorUrgency
        icon=$errorIcon            
        popupTime=$errorPopupTime
    ;;
    security)
        urgency=$securityUrgency
        icon=$securityIcon        
        popupTime=$securityPopupTime
    ;;
    *)
        urgency=$errorUrgency
        icon=$errorIcon            
        popupTime=$errorPopupTime
    ;;
    esac

    notify-send -u $urgency -t $popupTime -i &quot;$icon&quot; &quot;$1&quot; &quot;$coloredLog&quot; 2&gt; /tmp/notify-send-error
    #Maybe you will get something like „(notify-send:15339): GLib-GObject-CRITICAL **: g_object_unref: assertion `G_IS_OBJECT (object)' failed“ when started from incrond :/ What to do in this case?
fi
&lt;/pre&gt;

If you get the above mentioned error when run thru incrond modify the notify-send command as follows (replace USERID with your username):
&lt;pre&gt;
    DBUS_SESSION_BUS_ADDRESS=&quot;&quot;                                                                                    
    pids=`pgrep -u USERID`
    for pid in $pids; do
                    grep -z DBUS_SESSION_BUS_ADDRESS \
                        /proc/$pid/environ | sed -e 's/DBUS_SESSION_BUS_ADDRESS=//'
                echo
     done|sort -u|while read DBUS_SESSION_BUS_ADDRESS
     do
          export DBUS_SESSION_BUS_ADDRESS=$DBUS_SESSION_BUS_ADDRESS                                                                                                                                                                                                                     
          notify-send -u $urgency -t $popupTime -i &quot;$icon&quot; &quot;$1&quot; &quot;$coloredLog&quot; 2&gt; /tmp/notify-send-error                                                                                                                                                                                 
    done
&lt;/pre&gt;

=== Monitor your logs with incron ===

Edit you incrontab with 'incrontab -e', and the following line to the crontab:
&lt;pre&gt;
/var/log/kernel.log IN_MODIFY sh /home/me/scripts/popLog.sh /var/log/kernel.log
&lt;/pre&gt;
Add the logs you wish. Beware careful when choosing what you want to monitor. For exemple, doing this on /var/log/everything.log can cause infinite loops (since it is going to log the execution of popLog.sh, which will cause a new notification to happen, which will log in /var/log/everything.log...).

=== Enjoy ===

You should now get nice colorized notifications! For example you can try to trigger the wifi button.

The script is a modification of [http://www.daemontux.org/?q=node/31]. Many thanks to Zanko!

Note: One could set width for naughty windows manually. Add those lines to rc.lua (tested on 3.4.2):

&lt;pre&gt;
naughty_width = 600 -- in pixels
naughty.config.presets.low.width = naughty_width
naughty.config.presets.normal.width = naughty_width
naughty.config.presets.critical.width = naughty_width
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>ijomdeictbnp6eiteokbzkdm1oidecf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Dbus, naughty and logs/ru</title>
    <ns>0</ns>
    <id>1047</id>
    <revision>
      <id>6510</id>
      <parentid>6509</parentid>
      <timestamp>2014-05-15T17:56:25Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Убедитесь, что вы можете отображать ваши логи */ актуализация имени файла и группы в debian</comment>
      <text xml:space="preserve" bytes="10187">{{DISPLAYTITLE:Dbus, naughty и logs}}
{{Languages|Dbus, naughty and logs}}

Вы можете застваить компьютер просматривать ваши логи и показывать всплывающие уведомления, когда появляется новая запись.

== Особенности туториала ==

* Свободный Window manager (зависит от DBus для получения уведомлений, поэтому любой демон-уведомление, например naughty может работать с ним).
* Не испльзуется мониторинг, уведомления приходят в реальном времени благодаря [http://en.wikipedia.org/wiki/Inotify особенности inotify ядра линукс]

== Прочие реализации ==
* Существуе еще одна реализация, которая не зависит от внешних утилит (только связка ''luainotify''): [[Naughty log watcher]]
* Использование этого скрипта, может привести к неточным результатм, если лог файл обновляется слишком часто. Следующий скрипт  [http://git.ierton.ru/?p=awesomerc;a=blob_plain;f=logmonitor;hb=master script] был написан для этой же цели. Данная модификация испльзует 'tail -F -n0' вместо 'inotifywait' .

== Требования ==

Вам необходимо установить '''libnotify''', '''libnotify-bin''', '''inotify-tools''', '''incron''' и '''source-highlight'''.

=== Проверьте, что naughty поддерживает dbus ===

  notify-send hello world

Если уведомления отсутсвует, проверьте, что у вас прописано 'require(&quot;naughty&quot;)' в rc.lua.

=== Убедитесь, что вы можете отображать ваши логи ===

  tail -n 10 /var/log/kernel.log
или 
  tail -n 10 /var/log/kern.log

Если система ответит вам, что у вас недостаточно прав, вам нужно добавить себя в log группы (gpasswd -a &lt;user&gt; log), затем logout/login для применения изменения.
Если группы log не существует, можно попробовать добавить себя в группу adm (gpasswd -a &lt;user&gt; adm)

=== Использование подсветки кода в awesome ===

Source-highlight это инструмент, который осуществляет подстветку синтаксис. Вывод может осуществляться в html, терминальных цветовых кодах, и что очень распространено, разработать собственный формат вывода. Отличительной особенностью naughty является то, что но может отображать цветной текст испльзуя
&lt;pre&gt;
&lt;span color=&quot;mycolor&quot;&gt;word&lt;/span&gt;
&lt;/pre&gt;
Вот пример файла для подсветки кода, который использует формат naughty. Сохраните его где нибудь как 'awesome.outlang'.
&lt;pre&gt;
extension &quot;awesome&quot;

color &quot;&lt;span color=\&quot;$style\&quot;&gt;$text&lt;/span&gt;&quot;

colormap
&quot;green&quot; &quot;#33CC00&quot;
&quot;red&quot; &quot;#FF0000&quot;
&quot;darkred&quot; &quot;#990000&quot;
&quot;blue&quot; &quot;#0000FF&quot;
&quot;brown&quot; &quot;#9A1900&quot;
&quot;pink&quot; &quot;#CC33CC&quot;
&quot;yellow&quot; &quot;#FFCC00&quot;
&quot;cyan&quot; &quot;#66FFFF&quot;
&quot;purple&quot; &quot;#993399&quot;
&quot;orange&quot; &quot;#FF6600&quot;
&quot;brightorange&quot; &quot;#FF9900&quot;
&quot;brightgreen&quot; &quot;#33FF33&quot;
&quot;darkgreen&quot; &quot;#009900&quot;
&quot;black&quot; &quot;#000000&quot;
&quot;teal&quot; &quot;#008080&quot;
&quot;gray&quot; &quot;#808080&quot;
&quot;darkblue&quot; &quot;#000080&quot;
default &quot;#66FFFF&quot;
end
&lt;/pre&gt;

Примечание: Этот файл является настраиваемым: если вам не нравятся цвета по умолчанию, вы можете лего изменить их. Если вам нужны дополнительные способы модификации, вы можете найти их на ресурсе [http://www.gnu.org/software/src-highlite/source-highlight.html#Output-format-style the source-highlight website]).

=== Пишем скрипт для вывода уведомений ===

Следующий скрипт читает первую строку файла, подсвечивает ее, и посылает через D-BUs как уведомление. Сохрание его в папку с вашими скриптами (скажем /home/user/scripts/popLog.sh)

&lt;pre&gt;
#!/bin/bash

# Использование: ./popLog.sh /var/log/yourlog
# выводит подсвеченную последнюю строку журнала log

export DISPLAY=&quot;:0.0&quot;
export SYNTAXHIGHLIGHTFILE=&quot;/home/joe/.config/awesome/awesome.outlang&quot; # CHANGE ME

#Urgency
infoUrgency='low'
warningUrgency='normal'
errorUrgency='critical'
securityUrgency='critical'
 
#Popup time
infoPopupTime=5000
warningPopupTime=8000
errorPopupTime=11000
securityPopupTime=11000
 
#Icons
infoIcon='/usr/share/icons/gnome/32x32/status/dialog-information.png'
warningIcon='/usr/share/icons/gnome/32x32/status/dialog-warning.png'
errorIcon='/usr/share/icons/gnome/32x32/status/dialog-error.png'
securityIcon='/usr/share/icons/gnome/32x32/status/security-medium.png'

coloredLog=$(tail -n 1 $1 |                   \
  source-highlight --failsafe                 \
                   --src-lang=log             \
                   --style-file=default.style \
                   --outlang-def=${SYNTAXHIGHLIGHTFILE})

if [ -n &quot;$coloredLog&quot; ] ; then
    #echo $coloredLog
    
    if $(echo $1|grep info) ; then messageType='info'; fi
    if $(echo $1|grep warn) ; then messageType='warning'; fi
    if $(echo $1|grep err) ; then messageType='error'; fi
    if $(echo $1|grep auth) ; then messageType='security'; fi
    if $(echo $1|grep access) ; then messageType='security';fi
    if $(echo $notification|grep 'UFW BLOCK INPUT') ; then
        messageType='security'; fi
    if [ -z &quot;$messageType&quot; ] ; then messageType='info'; fi
       
    case $messageType in
    info)
        urgency=$infoUrgency
        icon=$infoIcon
        popupTime=$infoPopupTime
    ;;
    warning)
        urgency=$warningUrgency
        icon=$warningIcon
        popupTime=$warningPopupTime
    ;;
    error)
        urgency=$errorUrgency
        icon=$errorIcon            
        popupTime=$errorPopupTime
    ;;
    security)
        urgency=$securityUrgency
        icon=$securityIcon        
        popupTime=$securityPopupTime
    ;;
    *)
        urgency=$errorUrgency
        icon=$errorIcon            
        popupTime=$errorPopupTime
    ;;
    esac

    notify-send -u $urgency -t $popupTime -i &quot;$icon&quot; &quot;$1&quot; &quot;$coloredLog&quot; 2&gt; /tmp/notify-send-error
    #Возможно вы получите что то похожее на „(notify-send:15339): GLib-GObject-CRITICAL **: g_object_unref: assertion `G_IS_OBJECT (object)' failed“ при старте через incrond :/Что делать в этом случае?
fi
&lt;/pre&gt;

Если вы получаете ошибку похожую на описаннуе выше при запуске через incrond, измените команду notify-send на следующую (замените USERID своим именем пользователя):
&lt;pre&gt;
    DBUS_SESSION_BUS_ADDRESS=&quot;&quot;                                                                                    
    pids=`pgrep -u USERID`
    for pid in $pids; do
                    grep -z DBUS_SESSION_BUS_ADDRESS \
                        /proc/$pid/environ | sed -e 's/DBUS_SESSION_BUS_ADDRESS=//'
                echo
     done|sort -u|while read DBUS_SESSION_BUS_ADDRESS
     do
          export DBUS_SESSION_BUS_ADDRESS=$DBUS_SESSION_BUS_ADDRESS                                                                                                                                                                                                                     
          notify-send -u $urgency -t $popupTime -i &quot;$icon&quot; &quot;$1&quot; &quot;$coloredLog&quot; 2&gt; /tmp/notify-send-error                                                                                                                                                                                 
    done
&lt;/pre&gt;

=== Мониторинг ваших логов через incron ===

Отредактируйте ваш incrontab с помощью команды 'incrontab -e', и следующейстрокой в crontab:
&lt;pre&gt;
/var/log/kernel.log IN_MODIFY sh /home/me/scripts/popLog.sh /var/log/kernel.log
&lt;/pre&gt;
Добавьте логи, которые вам нужны. Будьте внимательны при выборе того, что вы хотите мониторить. Например, использование /var/log/everything.log может привести к бесконечному циклу (поскольку он посылает логи выполянться в popLog.sh, который выводит новые уведомления, что вызовет новое уведомление, которое будет записано в это же файл /var/log/everything.log...).

=== Наслаждайтесь ===

Теперь вы будете получать раскрашенные уведомления! Например, вы можете опробовать кнопку с wifi.

Этот скрипт является модификацией [http://www.daemontux.org/?q=node/31]. Огромное спасибо Zanko!

Примечание: Можно задавать ширину для уведомления naughty вручную. Для этого добавьте следующие строки в rc.lua (проверено на 3.4.2):

&lt;pre&gt;
naughty_width = 600 -- in pixels
naughty.config.presets.low.width = naughty_width
naughty.config.presets.normal.width = naughty_width
naughty.config.presets.critical.width = naughty_width
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>9b660bwf5n28cf7nbjbk81kd3hjg8qr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Debugging</title>
    <ns>0</ns>
    <id>8</id>
    <revision>
      <id>671</id>
      <timestamp>2008-06-16T13:07:31Z</timestamp>
      <contributor>
        <username>Jd</username>
        <id>1</id>
      </contributor>
      <comment>/* Debugging with gdb */</comment>
      <text xml:space="preserve" bytes="1670">Making awesome with special cflags give more complete backtrace: '''make CFLAGS+='-O0 -fno-inline -ggdb3''''.

== Debugging with gdb ==

If you get a crash inside awesome (segmentation fault, signal 11), please give a backtrace. You can achieve that using gdb.

* Launch '''awesome'''
* Attach gdb (using tty1 is better) with '''gdb -p `pidof awesome`'''
* Type '''continue''' at gdb prompt
* Wait for the crash
* Type '''bt''' to get the backtrace, '''bt full''' to have more information
* You can move between calls by using '''frame #''' where # is the frame number, and then you can print variable using '''print'''

If awesome crashes at startup then you cannot attach gdb. Use this alternative:

* Login on tty1
* Start with '''X :1'''
* Set your DISPLAY environment variable to this X server: '''export DISPLAY=:1'''
* Run awesome inside with '''gdb awesome'''
* Launch awesome by running '''run'''
* When it has crashed, type '''bt''' to get the backtrace, '''bt full''' to have more information
* You can move between calls by using '''frame #''' where # is the frame number, and then you can print variable using '''print'''

== Debugging with a core dump ==

* Before running X, in the tty, type: '''ulimit -c unlimited'''
* startx, and reproduce the segfault of awesome. Ok. Segfaulted ? Good :)
* You'll have normally a file named 'core' in your home, or the directory where you have started X
* '''gdb awesome ./core''' and you get the &quot;gdb prompt&quot;
* Type '''bt''' to get the backtrace, '''bt full''' to have more information
* You can move between calls by using '''frame #''' where # is the frame number, and then you can print variable using '''print'''</text>
      <sha1>44hbnwd6pyr7i6x68bn223mu9ld878q</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Delightful</title>
    <ns>0</ns>
    <id>643</id>
    <revision>
      <id>4699</id>
      <parentid>4696</parentid>
      <timestamp>2011-01-21T03:48:25Z</timestamp>
      <contributor>
        <username>Tj</username>
        <id>575</id>
      </contributor>
      <text xml:space="preserve" bytes="5137">[[Image:Glossy.png|thumb|Screenshot showing Delightful in action]]
[[Image:Darklooks.png|thumb|Another screenshot of Delightful]]

=Delightful widgets for Awesome=

This is Delightful, a set of widgets for Awesome window manager.

==Why?==

Why another widget system for Awesome, you ask? We already have [[Vicious]], [[Wicked]], [[Obvious]], and [[:Category:Widgets|many others]].

==Justifications==

That is a valid question, let me try elaborating why Delightful was created.

===Shiny colors===

Your average Awesome widget is quite dull. Some might consider that a feature. In this case, Delightful is probably not for you. Delightful try to add some “bling” to the widgets. Not un-needed “bling” but something useful. Many Delightful widgets provide a dynamically updated icon along with the widget text. The icon might indicate the sound volume or battery level. Some of the widgets use Naughty based pop-ups and notifications to provide useful, additional information that doesn’t fit the Awesome wibox. Tooltips are used always when it makes sense.

You might find Delightful widgets to have resemblance to some of the popular GNOME applets. This is not coincidental. Whether you find it a good or bad thing is up to you.

===Configurable===

Delightful widgets are also very configurable outside of the widget code. Besides usual configurable attributes, such as location where to display weather information or which network devices to exclude from monitoring, you also can tinker about every widget parameter, such as the widget update interval, from your Awesome &lt;code&gt;rc.lua&lt;/code&gt; without having to edit the widget code. See the configuration section below for more information about configuring Delightful widgets and the themeing section about changing widget’s appearance.

===Leveraging existing functionality===

Delightful doesn’t try to re-invent the wheel. Widgets depend heavily on [[Vicious]] widget library. A few of the widgets just extend an existing Vicious widget by providing an icon and widget data display configuration for the Vicious widget used under the hoods. Some of the widgets provide features not available in existing Vicious widgets by implementing the Vicious widget interface and then add “the bling” on top of that.

=Included widgets=

Delightful features the following widgets.

==Battery widget==

&lt;code&gt;delightful.widget.battery&lt;/code&gt; shows a battery indicator as an icon and a progress bar. Extends &lt;code&gt;vicious.widgets.bat&lt;/code&gt; Vicious widget.

==CPU widget==

&lt;code&gt;delightful.widget.cpu&lt;/code&gt; displays horizontal usage trend graph of all the CPUs combined. Extends &lt;code&gt;vicious.widgets.cpu&lt;/code&gt; Vicious widget.

==Date and time widget==

Shows current date and time. When mouse cursor hovers over the widget, calendar is displayed as a popup. You can navigate between months by using mouse scroll wheel.

==IMAP widget==

&lt;code&gt;delightful.widget.imap&lt;/code&gt; monitors one or more IMAP accounts for incoming messages. Multiple mailboxes can be monitored on each account. Number of unread messages in each monitored mailbox is displayed in the widget. When new mail arrives in one of the monitored mailboxes, some details about the message is shown in a popup. When mouse cursor hovers over the widget, details about each mailbox is shown in a popup. Widget icon indicates the status whether there are some unread mail in the monitored mailboxes. The IMAP widget implements the Vicious widget interface.

==Memory widget==

&lt;code&gt;delightful.widget.memory&lt;/code&gt; displays a progress bar indicating current memory and swap usage. Extends &lt;code&gt;vicious.widgets.mem&lt;/code&gt; Vicious widget.

==Network widget==

&lt;code&gt;delightful.widget.network&lt;/code&gt; displays download and upload speeds of selected network devices of the system. An icon indicates the type of the device (wired, wireless or dialup). Extends &lt;code&gt;vicious.widgets.net&lt;/code&gt; Vicious widget.

==PulseAudio widget==

&lt;code&gt;delightful.widget.pulseaudio&lt;/code&gt; shows a PulseAudio mixer indicator as an icon and a progress bar. Mouse clicks and scroll wheel actions can used to perform various mixer-related functions such as muting the device and turn volume up and down. PulseAudio widget implements the Vicious widget interface.

==Weather widget==

&lt;code&gt;delightful.widget.weather&lt;/code&gt; monitors weather status of given locations. Widget displays current temperature and an icon indicating the current weather condition. Icon is updated dynamically according to the weather and time changes. If the weather is clear, the icon indicates whether it’s day or night in the monitored location. When mouse cursor hovers over the widget, details about the weather is shown in a popup. Weather widget implements the Vicious widget interface.

=Downloading, installing, configuring, customizing and using Delightful=

I'm not going to copy &amp; paste and convert from MarkDown markup to MediaWiki markup the [http://solitudo.net/software/awesome/delightful/README whole Delightful README] here so you need to continue reading at http://solitudo.net/software/awesome/delightful/. Thanks.

[[Category:Widgets]]</text>
      <sha1>5o36hxevughwxnugop4j6ubg08uv97s</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Devel/LuaObject</title>
    <ns>0</ns>
    <id>497</id>
    <revision>
      <id>3732</id>
      <parentid>3730</parentid>
      <timestamp>2009-10-26T17:23:09Z</timestamp>
      <contributor>
        <username>Jd</username>
        <id>1</id>
      </contributor>
      <text xml:space="preserve" bytes="245">Lua Object is a little frame-work developed inside awesome and use to build a tree of objects, that can be referenced or reference other objects, avoiding island pattern (cyclic dependency breaking the garbage collector).
[[Image:Luaobject.png]]</text>
      <sha1>a7vxndllormk95zxwpnb8p4ct4zkw08</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Development Environment with Xephyr and GNU Make</title>
    <ns>0</ns>
    <id>1304</id>
    <revision>
      <id>7326</id>
      <parentid>7325</parentid>
      <timestamp>2015-05-20T11:16:18Z</timestamp>
      <contributor>
        <username>Gpryor</username>
        <id>4294</id>
      </contributor>
      <text xml:space="preserve" bytes="368">== Makefile Enabling Easy Xephyr Development ==

'''Note''': Writeup in progress.

Until full description up, simply see https://github.com/gpryor/awesome_dev for a quick development environment using GNU Make. Works nicely with EMACS.


== Debugging ==

To print things, I suggest just using naughty in your rc.lua,

 naughty.notify({text='hey this might help me!'});</text>
      <sha1>qnefogrptz40k8c9dcv70w55n7rtvyf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Disable DPMS</title>
    <ns>0</ns>
    <id>1152</id>
    <revision>
      <id>7072</id>
      <parentid>7071</parentid>
      <timestamp>2014-10-21T22:35:22Z</timestamp>
      <contributor>
        <username>Awaxx</username>
        <id>3762</id>
      </contributor>
      <comment>/* Plugins to handle DPMS with mouse in the systray */</comment>
      <text xml:space="preserve" bytes="4492">{{Languages|Disable DPMS}}

[http://en.wikipedia.org/wiki/VESA_Display_Power_Management_Signaling DPMS]   is a standard from the VESA consortium for managing the power supply of video monitors for computers through the graphics card. Example usage includes shutting off the monitor after a period of idle time to save power.

Often, when you are seeing film in player or flash-video, your display is power off. This is very annoying. That article, help you solve it problem.

Here is used only rules Awesome and external utility '''xset'''.

When client send signal about it fullscreened, we are calling function that will breaking energy saving. After close the application or disable fullscreen mode, energy saving mode switched on again.

&lt;pre&gt;
local fullscreened_clients = {}

local function remove_client(tabl, c)
    local index = awful.util.table.hasitem(tabl, c)
    if index then
        table.remove(tabl, index)
        if #tabl == 0 then
            awful.util.spawn(&quot;xset s on&quot;)
            awful.util.spawn(&quot;xset +dpms&quot;)
        end             
    end
end

client.connect_signal(&quot;property::fullscreen&quot;,
    function(c)
        if c.fullscreen then
            table.insert(fullscreened_clients, c)
            if #fullscreened_clients == 1 then
                awful.util.spawn(&quot;xset s off&quot;)
                awful.util.spawn(&quot;xset -dpms&quot;)
            end
        else
            remove_client(fullscreened_clients, c)
        end
    end)
    
client.connect_signal(&quot;unmanage&quot;,
    function(c)
        if c.fullscreen then
            remove_client(fullscreened_clients, c)
        end
    end)
&lt;/pre&gt;
If you are using Awesome 3.4, replace ''connect_signal'' to 'add_signal''.
THe authors of the code are [https://www.linux.org.ru/forum/desktop/10729260 NeverLoved] and [https://www.linux.org.ru/forum/desktop/10729260?cid=10729803 Worron]


== A functional way which works ==
description : it handle automaticly screensaver when you set a window in fullscreen

Inside your rc.lua directly.
&lt;pre&gt;
local function dpms(c)
    if c then
        awful.util.spawn_with_shell(&quot;xset s off &amp;&amp; xset -dpms &amp;&quot;)
    else
        awful.util.spawn_with_shell(&quot;xset s on &amp;&amp; xset +dpms &amp;&quot;)
    end
end

-- at line 260~~ of rc.lua 
clientkeys = awful.util.table.join(
    awful.key({ modkey,           }, &quot;f&quot;,      
        function (c)
            c.fullscreen = not c.fullscreen
            dpms(c.fullscreen)
        end),
    awful.key({ modkey, &quot;Shift&quot;   }, &quot;c&quot;,
        function (c)
            if c.fullscreen then
                c.fullscreen = not c.fullscreen
                dpms(c.fullscreen)
            end
            c:kill()
        end),
...
&lt;/pre&gt;

== Plugins to handle DPMS with mouse in the systray ==
description : an icon in the systray clickable with the middle button of the mouse which handle screensaver (you need xset installed on your system)

put it inside you awesome directory as screensave.lua then,

inside your rc.lua add:
&lt;pre&gt;
require(&quot;screensave&quot;)

myscreensave = screensave()
&lt;/pre&gt;
then in the wibox which handle your taglist, tasklist, textclock, systray...
add
&lt;pre&gt;
myscreensave,
&lt;/pre&gt;
&lt;pre&gt;
-- by [Awaxx] for the love and awesome community
-- SET YOUR OWN ICONS!!!!!!!!!!!!!!!!!!!!!
local setmetatable = setmetatable
local os = os
local io = io
local image = image
local awful = require(&quot;awful&quot;)
local widget = widget
local string = string

local icons_path = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/themes/driftvm&quot;
local screensave = {
    enable    = icons_path .. &quot;/icons/screensaver16.png&quot;,
    disable   = icons_path .. &quot;/icons/screensaver_disable16.png&quot;
}

module(&quot;screensave&quot;)

local function screen_ctl()
    local f = io.popen(&quot;xset q | tail -2&quot;)
    local data = f:read(&quot;*all&quot;)
    f:close()
    local screen_info = string.match(data, &quot;E.....d&quot;) -- meh , i know i suck at regex with lua :/
    if not screen_info then
    	awful.util.spawn_with_shell(&quot;xset s on &amp;&amp; xset +dpms &amp;&quot;, false)
    	return screensave.enable
    else
    	awful.util.spawn_with_shell(&quot;xset s off &amp;&amp; xset -dpms &amp;&quot;, false)
    	return screensave.disable
    end
end

function new()
    local w = widget({ type = &quot;imagebox&quot; })
    w.image = image(screensave.enable)
    w:buttons(awful.util.table.join(
      awful.button({ }, 2, function() w.image = image(screen_ctl()) end) -- mute -- amixer set Master unmute
    ))
    return w
end

setmetatable(_M, { __call = function(_, ...) return new(...) end })

&lt;/pre&gt;

By [Awaxx] you can contact me with irc:oftc/#awesome</text>
      <sha1>cvvvch42gjk59w7strc5j3h9ama2zey</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Disable DPMS/ru</title>
    <ns>0</ns>
    <id>1151</id>
    <revision>
      <id>7154</id>
      <parentid>7009</parentid>
      <timestamp>2014-12-15T06:28:30Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>added last changes</comment>
      <text xml:space="preserve" bytes="5678">{{Languages|Disable DPMS}}
{{DISPLAYTITLE:Отключение DPMS}}

[https://ru.wikipedia.org/wiki/VESA_Display_Power_Management_Signaling DPMS] - стандарт консорциума VESA, определяющий функции управления энергосбережением компьютерных мониторов с помощью видеокарты (например, отключение монитора, если компьютер не использовался определенное время).

Если вас не устраивает, то, что при просмотре фильма или флеш включенных на полный экран, этот самый экран гаснет, то эта статья поможет вам настроить Awesome, и отключить функцию энергосбережения экрана. Используются лишь стандартные средства самого Awesome и утилита xset (входит в большинство дистрибутивов).

При получении сигнала, о том, что один из клиентов переключен в fullscreen режим, вызывается функция, отключающая энергосбережение. После отключений режима, или закрытии приложения, режим вновь включается.

&lt;pre&gt;
local fullscreened_clients = {}

local function remove_client(tabl, c)
    local index = awful.util.table.hasitem(tabl, c)
    if index then
        table.remove(tabl, index)
        if #tabl == 0 then
            awful.util.spawn(&quot;xset s on&quot;)
            awful.util.spawn(&quot;xset +dpms&quot;)
        end             
    end
end

client.connect_signal(&quot;property::fullscreen&quot;,
    function(c)
        if c.fullscreen then
            table.insert(fullscreened_clients, c)
            if #fullscreened_clients == 1 then
                awful.util.spawn(&quot;xset s off&quot;)
                awful.util.spawn(&quot;xset -dpms&quot;)
            end
        else
            remove_client(fullscreened_clients, c)
        end
    end)
    
client.connect_signal(&quot;unmanage&quot;,
    function(c)
        if c.fullscreen then
            remove_client(fullscreened_clients, c)
        end
    end)
&lt;/pre&gt;'
Если вы пользуетесь '''Awesome 3.4''', то замените в коде ''connect_signal'' на ''add_signal''

Авторами кода являются [https://www.linux.org.ru/forum/desktop/10729260 NeverLoved] и [https://www.linux.org.ru/forum/desktop/10729260?cid=10729803 Worron]

== Функциональный рабочий способ ==
Описание : Автоматическое управление скринсейвером при переходе окна в fullscreen режим

Разместите в вашем rc.lua
&lt;pre&gt;
local function dpms(c)
    if c then
        awful.util.spawn_with_shell(&quot;xset s off &amp;&amp; xset -dpms &amp;&quot;)
    else
        awful.util.spawn_with_shell(&quot;xset s on &amp;&amp; xset +dpms &amp;&quot;)
    end
end

-- приблизительно 260~~ строка rc.lua 
clientkeys = awful.util.table.join(
    awful.key({ modkey,           }, &quot;f&quot;,      
        function (c)
            c.fullscreen = not c.fullscreen
            dpms(c.fullscreen)
        end),
    awful.key({ modkey, &quot;Shift&quot;   }, &quot;c&quot;,
        function (c)
            if c.fullscreen then
                c.fullscreen = not c.fullscreen
                dpms(c.fullscreen)
            end
            c:kill()
        end),
...
&lt;/pre&gt;

== Плагин для управления DPMS с помощью мыши в трее ==
Описание : При нажатии на иконку в трее средней клавишей переключается режим скринсейвера (у вас должен быть установлен xset)

Разместите следующий код в файл screensave.lua находящийся в каталоге ~/.config/awesome
&lt;pre&gt;
-- by [Awaxx] for the love and awesome community
-- SET YOUR OWN ICONS!!!!!!!!!!!!!!!!!!!!!
local setmetatable = setmetatable
local os = os
local io = io
local image = image
local awful = require(&quot;awful&quot;)
local widget = widget
local string = string

local icons_path = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/themes/driftvm&quot;
local screensave = {
    enable    = icons_path .. &quot;/icons/screensaver16.png&quot;,
    disable   = icons_path .. &quot;/icons/screensaver_disable16.png&quot;
}

module(&quot;screensave&quot;)

local function screen_ctl()
    local f = io.popen(&quot;xset q | tail -2&quot;)
    local data = f:read(&quot;*all&quot;)
    f:close()
    local screen_info = string.match(data, &quot;E.....d&quot;) -- meh , i know i suck at regex with lua :/
    if not screen_info then
    	awful.util.spawn_with_shell(&quot;xset s on &amp;&amp; xset +dpms &amp;&quot;, false)
    	return screensave.enable
    else
    	awful.util.spawn_with_shell(&quot;xset s off &amp;&amp; xset -dpms &amp;&quot;, false)
    	return screensave.disable
    end
end

function new()
    local w = widget({ type = &quot;imagebox&quot; })
    w.image = image(screensave.enable)
    w:buttons(awful.util.table.join(
      awful.button({ }, 2, function() w.image = image(screen_ctl()) end) -- mute -- amixer set Master unmute
    ))
    return w
end

setmetatable(_M, { __call = function(_, ...) return new(...) end })

&lt;/pre&gt;

Затем в rc.lua добавьте:
&lt;pre&gt;
require(&quot;screensave&quot;)

myscreensave = screensave()
&lt;/pre&gt;
Далее в секции wibox в которой у вас определены taglist, tasklist, textclock, systray...
добавьте
&lt;pre&gt;
myscreensave,
&lt;/pre&gt;

By [Awaxx] you can contact me with irc:oftc/#awesome</text>
      <sha1>axoijlprm22zz3cfy90bk3h5ih6e28f</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Disable startup-notification globally</title>
    <ns>0</ns>
    <id>672</id>
    <revision>
      <id>6602</id>
      <parentid>4834</parentid>
      <timestamp>2014-05-22T15:10:29Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="380">{{Languages}}

This is a wrapper function to disable startup-notification globally.

&lt;pre&gt;
-- disable startup-notification globally
local oldspawn = awful.util.spawn
awful.util.spawn = function (s)
  oldspawn(s, false)
end
&lt;/pre&gt;

Put it e.g. at the bottom of your config file, if you are annoyed by the stopwatch/busy mouse cursor after starting programs with 'awful.util.spawn'.</text>
      <sha1>0ab2dczsgw5c2z1oyumi5eeopw8j2y2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Disable startup-notification globally/ru</title>
    <ns>0</ns>
    <id>1072</id>
    <revision>
      <id>6606</id>
      <parentid>6605</parentid>
      <timestamp>2014-05-22T16:28:35Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>добавление примечания</comment>
      <text xml:space="preserve" bytes="2581">{{Languages|Disable startup-notification globally}}
{{DISPLAYTITLE:Глобальное отключение уведомлений запуска}}

Эта функция-обертка позволяет отключить уведомления запуска глобально. Т.е. мы переопределяем стандартную функцию, передавая ей значение false для второго агрумента.

&lt;pre&gt;
-- disable startup-notification globally
local oldspawn = awful.util.spawn
awful.util.spawn = function (s)
  oldspawn(s, false)
end
&lt;/pre&gt;

Поместите ее например в конце ваше файла конфигурации, если вас раздражает занятый(в виде секундомера) курсор мыши после запуска программ с помощью  'awful.util.spawn'.

Примечание переводчика:
По умолчанию функция awful.util.spawn принимает до 3х значений. Т.е. она определена как awful.util.spawn(cmd, sn, screen). Где первый аргумент, это собственно сама запускаемая команда, второй аргумент sn - это startup-notification, а третий это экран. Если при вызове этой функции мы определяем только первый агрумент, то остальные устанавливаются по умолчанию, в частности sn=true, screen=capi.mouse.screen.
При передаче функции только одного параметра(команды), в этом случае экран/мышь/реакция на клавиатуру может &quot;зависнуть&quot; до окончания выполнения вызванной команды. И в это время awesome не будет реагировать на ваши действия. Если команда короткая, чаще всего это не вызывает проблемы, хотя и в этом случае возможны варианты.
Т.е. либо вам придется либо для каждого вызова функции явно определять второй аргумент, что может быть несколько накладно, либо определить отдельную функцию для установки значения sn=false. Как раз второй вариант и описан выше.</text>
      <sha1>8awxtea87ny88pmukxqfjwhje3l0xra</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Disk Usage Widget</title>
    <ns>0</ns>
    <id>45</id>
    <revision>
      <id>1261</id>
      <timestamp>2008-10-16T14:43:57Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1738">{|cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; style=&quot;margin: 0em&quot; width=&quot;100%&quot;
|- style=&quot;background: #aea&quot;
| This widget is written for awesome 2.3.
|}

== Simple progressbar example ==

This is how to use a progressbar widget withiin awesome.

1. Add an include directive into ~/.awesomerc

    screen 0
    {
        include(~/.awesome/bottom-status-bar)
    }

2. Create ~/.awesome/bottom-status-bar

    progressbar diskusage
    {
        data &quot;disk&quot;
        {
            bordercolor = &quot;#006e96&quot;
            bg          = &quot;#000000&quot;
            fg          = &quot;#ff0000&quot;
            fg_center   = &quot;#daaf0a&quot;
            fg_end      = &quot;#00ff00&quot;
        }
        width = 100
        align = &quot;left&quot;
    }

3. Check the configuration file for errors

    $ awesome -k
    Configuration file OK.

Note: If you see anything other than &quot;Configuration file OK,&quot; you have a typo somewhere.

4. Create ~/bin/awesome-diskusage

    #!/bin/sh
    while true; do
        # Edit the disk here for the disk you'd like to monitor.
        usage = `df /dev/sda5 | awk '/\/dev\/sda5/ { print 100-$5 }'`
        echo &quot;0 widget_tell mystatusbar diskusage data disk ${usage}&quot;
        echo &quot;&quot; # an empty line flushes data inside awesome
        sleep 600;
    done | awesome-client


Note: What we're saying is &quot;awesome-client, tell widget 'diskusage' to set it's 'data' property named 'disk' to ${usage}.&quot;

5. Make ~/bin/awesome-diskusage executable

  $ chmod a+x ~/bin/awesome-diskusage

6. Modify ~/.xinitrc

    ~/bin/awesome-diskusage &amp;
    exec awesome

7. Restart awesome

8. If your didn't get what you were expecting, take a look at
   ~/.xsession-errors or the terminal where X got started.

[[Category:StatusBars]]
[[Category:Widgets]]
[[Category:awesome2]]</text>
      <sha1>1n3r1fge6pctyfz7x0ahbh5jhvu6crx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Document keybindings</title>
    <ns>0</ns>
    <id>852</id>
    <revision>
      <id>6907</id>
      <parentid>6906</parentid>
      <timestamp>2014-08-11T13:45:56Z</timestamp>
      <contributor>
        <username>Shadow</username>
        <id>3384</id>
      </contributor>
      <comment>Use spairs function instead of standard pairs function in display. Groups will be alphabetically sorted and therefore always displayed in the same order.</comment>
      <text xml:space="preserve" bytes="5326">{{Languages}}

= Introduction =

It is sometimes difficult to remember some keybindings. You have to check in your rc.lua. The module below monkey-patch awful.key to add a documentation string to a keybinding. It also has a function to display a naugthy notification with all valid (global and window-related) documented keybindings. The module below may fail to work, because beautiful.&lt;foo_bar&gt; may not be in your theme.lua. If you get an error that beautiful.&lt;foo_bar&gt; is a nil value, then change the beautiful.&lt;foo_bar&gt; to an HTML color value.
For example, change beautiful.fg_widget_clock to &quot;#E0E0D1&quot; and be sure to include the quotes.

= Code =

&lt;pre&gt;
-- Document key bindings

local awful     = require(&quot;awful&quot;)
local table     = table
local ipairs    = ipairs
local pairs     = pairs
local math      = math
local string    = string
local type      = type
local modkey    = &quot;Mod4&quot;
local beautiful = require(&quot;beautiful&quot;)
local naughty   = require(&quot;naughty&quot;)
local capi      = {
   root = root,
   client = client
}

module(&quot;keydoc&quot;)

local doc = { }
local currentgroup = &quot;Misc&quot;
local orig = awful.key.new

-- Replacement for awful.key.new
local function new(mod, key, press, release, docstring)
   -- Usually, there is no use of release, let's just use it for doc
   -- if it's a string.
   if press and release and not docstring and type(release) == &quot;string&quot; then
      docstring = release
      release = nil
   end
   local k = orig(mod, key, press, release)
   -- Remember documentation for this key (we take the first one)
   if k and #k &gt; 0 and docstring then
      doc[k[1]] = { help = docstring,
		    group = currentgroup }
   end

   return k
end
awful.key.new = new		-- monkey patch

-- Turn a key to a string
local function key2str(key)
   local sym = key.key or key.keysym
   local translate = {
      [&quot;#14&quot;] = &quot;#&quot;,
      [&quot; &quot;] = &quot;Space&quot;,
   }
   sym = translate[sym] or sym
   if not key.modifiers or #key.modifiers == 0 then return sym end
   local result = &quot;&quot;
   local translate = {
      [modkey] = &quot;⊞&quot;,
      Shift    = &quot;⇧&quot;,
      Control  = &quot;Ctrl&quot;,
   }
   for _, mod in pairs(key.modifiers) do
      mod = translate[mod] or mod
      result = result .. mod .. &quot; + &quot;
   end
   return result .. sym
end

-- Unicode &quot;aware&quot; length function (well, UTF8 aware)
-- See: http://lua-users.org/wiki/LuaUnicode
local function unilen(str)
   local _, count = string.gsub(str, &quot;[^\128-\193]&quot;, &quot;&quot;)
   return count
end

-- Start a new group
function group(name)
   currentgroup = name
   return {}
end

local function markup(keys)
   local result = {}

   -- Compute longest key combination
   local longest = 0
   for _, key in ipairs(keys) do
      if doc[key] then
	 longest = math.max(longest, unilen(key2str(key)))
      end
   end

   local curgroup = nil
   for _, key in ipairs(keys) do
      if doc[key] then
	 local help, group = doc[key].help, doc[key].group
	 local skey = key2str(key)
	 result[group] = (result[group] or &quot;&quot;) ..
	    '&lt;span font=&quot;DejaVu Sans Mono 10&quot; color=&quot;' .. beautiful.fg_widget_clock .. '&quot;&gt; ' ..
	    string.format(&quot;%&quot; .. (longest - unilen(skey)) .. &quot;s  &quot;, &quot;&quot;) .. skey ..
	    '&lt;/span&gt;  &lt;span color=&quot;' .. beautiful.fg_widget_value .. '&quot;&gt;' .. -- if
   -- beautiful.fg_widget_value is not specified in your theme.lua, try changing it to &quot;#E0E0D1&quot;
   -- and include the quotes, because it is a string.
	    help .. '&lt;/span&gt;\n'
      end
   end

   return result
end

-- Customize version of standard function pairs that sort keys
-- (from Michal Kottman on Stackoverflow)
function spairs(t, order)
  -- collect the keys
  local keys = {}
  for k in pairs(t) do keys[#keys+1] = k end

  -- if order function given, sort by it by passing the table and keys a, b,
  -- otherwise just sort the keys 
  if order then
    table.sort(keys, function(a,b) return order(t, a, b) end)
  else
    table.sort(keys)
  end

  -- return the iterator function
  local i = 0
  return function()
    i = i + 1
    if keys[i] then
      return keys[i], t[keys[i]]
    end
  end
end

-- Display help in a naughty notification
local nid = nil
function display()
   local strings = markup(awful.util.table.join(
      capi.root.keys(),
      capi.client.focus and capi.client.focus:keys() or {}))

   local result = &quot;&quot;
   for group, res in spairs(strings) do
      if #result &gt; 0 then result = result .. &quot;\n&quot; end
      result = result ..
	 '&lt;span weight=&quot;bold&quot; color=&quot;' .. beautiful.fg_widget_value_important .. '&quot;&gt;' ..
	 group .. &quot;&lt;/span&gt;\n&quot; .. res
   end
   nid = naughty.notify({ text = result,
			  replaces_id = nid,
			  hover_timeout = 0.1,
			  timeout = 30 }).id
end
&lt;/pre&gt;

= Example of use =

You just need to import the module and add a docstring for any keybinding you want to document.

&lt;pre&gt;
local keydoc = require(&quot;keydoc&quot;)

[...]
   keydoc.group(&quot;Layout manipulation&quot;),
   awful.key({ modkey, &quot;Shift&quot;   }, &quot;j&quot;, function () awful.client.swap.byidx(  1)    end,
	     &quot;Swap with next window&quot;),
   awful.key({ modkey, &quot;Shift&quot;   }, &quot;k&quot;, function () awful.client.swap.byidx( -1)    end,
	     &quot;Swap with previous window&quot;),
[...]
   keydoc.group(&quot;Misc&quot;),
   awful.key({ modkey,           }, &quot;Return&quot;, function () awful.util.spawn(config.terminal) end,
	     &quot;Spawn a terminal&quot;),
[...]
   awful.key({ modkey, }, &quot;F1&quot;, keydoc.display)
&lt;/pre&gt;

Here is what you can get:


[[Image:keydoc.png]]</text>
      <sha1>kc4t9il2gj041astdsiy5zg0r1t5i8y</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Document keybindings/ru</title>
    <ns>0</ns>
    <id>1041</id>
    <revision>
      <id>6911</id>
      <parentid>6729</parentid>
      <timestamp>2014-08-11T16:39:02Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>upgrading translate for current version</comment>
      <text xml:space="preserve" bytes="6183">{{Languages|Document keybindings}}
{{DISPLAYTITLE:Документирование клавиатурых сочетаний}}

= Введение =

Порой бывает сложно всмомнить некоторые клавиатурные сочетания. Вам приходится проверять файл ''rc.lua''. Приведенный здесь модуль небольшой monkey-patch из awful.key добавляющий документированную строку для клавиатурных сочетаний. Модуль использует функции отображения библиотеки naughty, для выведения всех действующих (глобальных, или связанных с текущим окном) документированных сочетаний.
Модуль представленный ниже, может не работь, так как beautiful.&lt;foo_bar&gt; нет в вашем theme.lua. Если вы получаете ошибку что beautiful.&lt;foo_bar&gt; имеет нулевое значение, измените beautiful.&lt;foo_bar&gt; на значение цвета HTML.
Например измените значение beautiful.fg_widget_clock на &quot;#E0E0D1&quot; (включая кавычки). 

= Код =

&lt;pre&gt;
-- Document key bindings

local awful     = require(&quot;awful&quot;)
local table     = table
local ipairs    = ipairs
local pairs     = pairs
local math      = math
local string    = string
local type      = type
local modkey    = &quot;Mod4&quot;
local beautiful = require(&quot;beautiful&quot;)
local naughty   = require(&quot;naughty&quot;)
local capi      = {
   root = root,
   client = client
}

module(&quot;keydoc&quot;)

local doc = { }
local currentgroup = &quot;Misc&quot;
local orig = awful.key.new

-- Replacement for awful.key.new
local function new(mod, key, press, release, docstring)
   -- Usually, there is no use of release, let's just use it for doc
   -- if it's a string.
   if press and release and not docstring and type(release) == &quot;string&quot; then
      docstring = release
      release = nil
   end
   local k = orig(mod, key, press, release)
   -- Remember documentation for this key (we take the first one)
   if k and #k &gt; 0 and docstring then
      doc[k[1]] = { help = docstring,
		    group = currentgroup }
   end

   return k
end
awful.key.new = new		-- monkey patch

-- Turn a key to a string
local function key2str(key)
   local sym = key.key or key.keysym
   local translate = {
      [&quot;#14&quot;] = &quot;#&quot;,
      [&quot; &quot;] = &quot;Space&quot;,
   }
   sym = translate[sym] or sym
   if not key.modifiers or #key.modifiers == 0 then return sym end
   local result = &quot;&quot;
   local translate = {
      [modkey] = &quot;⊞&quot;,
      Shift    = &quot;⇧&quot;,
      Control  = &quot;Ctrl&quot;,
   }
   for _, mod in pairs(key.modifiers) do
      mod = translate[mod] or mod
      result = result .. mod .. &quot; + &quot;
   end
   return result .. sym
end

-- Unicode &quot;aware&quot; length function (well, UTF8 aware)
-- See: http://lua-users.org/wiki/LuaUnicode
local function unilen(str)
   local _, count = string.gsub(str, &quot;[^\128-\193]&quot;, &quot;&quot;)
   return count
end

-- Start a new group
function group(name)
   currentgroup = name
   return {}
end

local function markup(keys)
   local result = {}

   -- Compute longest key combination
   local longest = 0
   for _, key in ipairs(keys) do
      if doc[key] then
	 longest = math.max(longest, unilen(key2str(key)))
      end
   end

   local curgroup = nil
   for _, key in ipairs(keys) do
      if doc[key] then
	 local help, group = doc[key].help, doc[key].group
	 local skey = key2str(key)
	 result[group] = (result[group] or &quot;&quot;) ..
	    '&lt;span font=&quot;DejaVu Sans Mono 10&quot; color=&quot;' .. beautiful.fg_widget_clock .. '&quot;&gt; ' ..
	    string.format(&quot;%&quot; .. (longest - unilen(skey)) .. &quot;s  &quot;, &quot;&quot;) .. skey ..
	    '&lt;/span&gt;  &lt;span color=&quot;' .. beautiful.fg_widget_value .. '&quot;&gt;' .. -- if
   -- beautiful.fg_widget_value is not specified in your theme.lua, try changing it to &quot;#E0E0D1&quot;
   -- and include the quotes, because it is a string.
	    help .. '&lt;/span&gt;\n'
      end
   end

   return result
end

-- Customize version of standard function pairs that sort keys
-- (from Michal Kottman on Stackoverflow)
function spairs(t, order)
  -- collect the keys
  local keys = {}
  for k in pairs(t) do keys[#keys+1] = k end

  -- if order function given, sort by it by passing the table and keys a, b,
  -- otherwise just sort the keys 
  if order then
    table.sort(keys, function(a,b) return order(t, a, b) end)
  else
    table.sort(keys)
  end

  -- return the iterator function
  local i = 0
  return function()
    i = i + 1
    if keys[i] then
      return keys[i], t[keys[i]]
    end
  end
end

-- Display help in a naughty notification
local nid = nil
function display()
   local strings = markup(awful.util.table.join(
      capi.root.keys(),
      capi.client.focus and capi.client.focus:keys() or {}))

   local result = &quot;&quot;
   for group, res in spairs(strings) do
      if #result &gt; 0 then result = result .. &quot;\n&quot; end
      result = result ..
	 '&lt;span weight=&quot;bold&quot; color=&quot;' .. beautiful.fg_widget_value_important .. '&quot;&gt;' ..
	 group .. &quot;&lt;/span&gt;\n&quot; .. res
   end
   nid = naughty.notify({ text = result,
			  replaces_id = nid,
			  hover_timeout = 0.1,
			  timeout = 30 }).id
end
&lt;/pre&gt;

= Пример использования =

Вам просто нужно импортировать модуль и добавить документирующую стоку для всех клавиатурных сочетаний, которые вам нужны.

&lt;pre&gt;
local keydoc = require(&quot;keydoc&quot;)

[...]
   keydoc.group(&quot;Layout manipulation&quot;),
   awful.key({ modkey, &quot;Shift&quot;   }, &quot;j&quot;, function () awful.client.swap.byidx(  1)    end,
	     &quot;Swap with next window&quot;),
   awful.key({ modkey, &quot;Shift&quot;   }, &quot;k&quot;, function () awful.client.swap.byidx( -1)    end,
	     &quot;Swap with previous window&quot;),
[...]
   keydoc.group(&quot;Misc&quot;),
   awful.key({ modkey,           }, &quot;Return&quot;, function () awful.util.spawn(config.terminal) end,
	     &quot;Spawn a terminal&quot;),
[...]
   awful.key({ modkey, }, &quot;F1&quot;, keydoc.display)
&lt;/pre&gt;

Вот что вы можете получить:


[[Image:keydoc.png]]</text>
      <sha1>llgjz1nq4grlfz4ijlok7c17ih15r4n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>DoingARelease</title>
    <ns>0</ns>
    <id>859</id>
    <revision>
      <id>7420</id>
      <parentid>6362</parentid>
      <timestamp>2016-01-15T16:10:10Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Update to the current state of things</comment>
      <text xml:space="preserve" bytes="2416">== How to do a release ==

* Edit ''awesomeConfig.cmake'' and choose a codename that is not already listed in [[Releases]]. jd always picked a song title, you should do the same. 
* Commit this changes to ''awesomeConfig.cmake''
* Add the release version and date to [[Releases]]
* Change the version in [[Template:Stable-version]]
* Git sign with ''git tag -s vX.Y.Z -m 'awesome vX.Y.Z'''
* Push with ''git push'' and push tag with ''git push origin vX.Y.Z''
* Run ''make dist'' to create tarballs.
* Copy tarballs inside ''awesome.naquadah.org:/var/www/awesome.naquadah.org/download/''
* Edit ''download.mdwn''  from [http://git.naquadah.org/?p=awesome-www.git;a=summary the awesome www repository] to change the version information, links, etc
* Go into the 'src' submodule, and update it to vX.Y.Z with ''git checkout vX.Y.Z''. This will be used to build and publish the documentation online.
* Commit ''download.mdwn'' and ''src''.
* ''git push'' this
* Type ''make push'' in ''awesome-www'' to push changes to the website. Be careful to have ''ikiwiki'', ''asciidoc'' and imagemagick for Perl (''perlmagick'', otherwise images get broken)
* Send a mail to ''awesome@naquadah.org'' with any amount of information and jokes inside.
* Change the topic on IRC

For the announcement mail, the following shell script might be handy:

 #!/bin/sh
 VER=$1
 PREV_VER=$2
 TAG=&quot;v$VER&quot;
 PTAG=&quot;v$PREV_VER&quot;
 REVS=&quot;$PTAG..$TAG&quot;
 
 echo &quot;awesome version $VER has been released. It is available from:&quot;
 
 print_file()
 {
         EXT=&quot;$1&quot;
         URL=&quot;http://awesome.naquadah.org/download/awesome-$VER.$EXT&quot;
         FILE=&quot;/var/www/awesome.naquadah.org/download/awesome-$VER.$EXT&quot;
         MD5=$(ssh prometheus.naquadah.org &quot;md5sum $FILE&quot; 2&gt;/dev/null | cut -f1 -d ' ')
         SHA1=$(ssh prometheus.naquadah.org &quot;sha1sum $FILE&quot; 2&gt;/dev/null | cut -f 1 -d ' ')
 
         echo
         echo &quot;$EXT: $URL&quot;
         echo &quot;md5: $MD5&quot;
         echo &quot;sha1: $SHA1&quot;
 }
 
 print_headline()
 {
         HEAD=&quot;$@&quot;
         echo
         echo &quot;$HEAD&quot;
         echo &quot;$HEAD&quot; | sed -e 's/./-/g'
 }
 
 print_file &quot;tar.xz&quot;
 print_file &quot;tar.bz2&quot;
 
 print_headline &quot;number of changes&quot;
 git rev-list &quot;$REVS&quot; | wc -l
 
 print_headline &quot;number of commiters&quot;
 git log --format=format:%an &quot;$REVS&quot; | sort -u | wc -l
 
 print_headline &quot;shortlog&quot;
 git log &quot;$REVS&quot; | git shortlog --numbered | cat
 
 print_headline &quot;diffstat&quot;
 git diff --stat &quot;$REVS&quot; | cat</text>
      <sha1>4j4poa7qzx2lh1kiwl6dkuvcw8jsqcr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Drop-down terminal</title>
    <ns>0</ns>
    <id>320</id>
    <revision>
      <id>6530</id>
      <parentid>6284</parentid>
      <timestamp>2014-05-17T14:46:28Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="10475">{{Languages}}

== Introduction ==
A drop-down terminal pops up from the top of the screen in video game console fashion and can be toggled with a single hotkey.
Applications such as Yakuake, Guake or Tilda provide drop-down terminal functionality for the regular desktop environments.
With awesome and the power of lua, however, we can mimic this functionality and still use our precious light-weight terminal applications.

Adding the following function to your rc.lua and calling it in a keybinding will create a new window for the drop-down terminal when it does not exist, and will toggle between hidden and visible if one does exist.
The first argument is the program to run (eg. &quot;urxvtc&quot;), the second argument is the height (absolute pixels when &gt; 1 or a height percentage when &lt; 1, 0.2 (20% of the screen height) by default), and the third argument is the screen to toggle on.
The second and third arguments are optional.

=== Function ===
&lt;pre&gt;
-- This function is for awesome versions prior to 3.4

dropdown = {}

function dropdown_toggle(prog, height, s)
   if s == nil then s = mouse.screen end
   if height == nil then height = 0.2 end
   
   if not dropdown[prog] then
      -- Create table
      dropdown[prog] = {}
      
      -- Add unmanage hook for dropdown programs
      awful.hooks.unmanage.register(function (c)
                                       for scr, cl in pairs(dropdown[prog]) do
                                          if cl == c then
                                             dropdown[prog][scr] = nil
                                          end
                                       end
                                    end)
   end
   
   if not dropdown[prog][s] then
      spawnw = function (c)
                  -- Store client
                  dropdown[prog][s] = c
                  
                  -- Float client
                  awful.client.floating.set(c, true)
                  
                  -- Get screen geometry
                  screengeom = screen[s].workarea
                  
                  -- Calculate height
                  if height &lt; 1 then
                     height = screengeom.height*height
                  end

                  -- I like a different border with for the popup window
                  -- So I don't confuse it with terminals in the layout
                  bw = 2

                  -- Resize client
                  c:geometry({
                                x = screengeom.x,
                                y = screengeom.y - 1000,
                                width = screengeom.width - bw, 
                                height = height - bw
                             })

                  -- Mark terminal as ontop
                  --            c.ontop = true
                  --            c.above = true
                  c.border_width = bw

                  -- Focus and raise client
                  c:raise()
                  client.focus = c

                  -- Remove hook
                  awful.hooks.manage.unregister(spawnw)
               end

      -- Add hook
      awful.hooks.manage.register(spawnw)

      -- Spawn program
      awful.util.spawn(prog)

      dropdown.currtag = awful.tag.selected(s)
   else
      -- Get client
      c = dropdown[prog][s]
      
      -- Switch the client to the current workspace

      -- Focus and raise if not hidden
      if c.hidden then
         awful.client.movetotag(awful.tag.selected(s), c)
         c.hidden = false
         c:raise()
         client.focus = c
      else
         if awful.tag.selected(s) == dropdown.currtag then
            c.hidden = true
            local ctags = c:tags()
            for i, t in pairs(ctags) do
               ctags[i] = nil
            end
            c:tags(ctags)
         else
            awful.client.movetotag(awful.tag.selected(s), c)
            c:raise()
            client.focus = c
         end
      end
      dropdown.currtag = awful.tag.selected(s)
   end
end
&lt;/pre&gt;

== Scratch ==
Scratch is a drop-down applications and scratchpad manager for the awesome window manager. Its ''scratch.drop'' module is based on the above code and is compatable with awesome '''v3.4'''. For more information see the [[Scratchpad manager]] page.

== Another solution ==

The previous solution have two little quirks: the console window is detected as the first window being managed just after requesting one. There could be a race condition but it is unlikely. The second associated quirk is that when you restart awesome, you lose the fact that this window is a drop-down terminal. You now have one terminal which is sticky. This is a bit disturbing. Here is another solution that works around this by relying on a name given to the dropdown terminal:

&lt;pre&gt;
-- Quake like console on top
-- Similar to:
--   http://git.sysphere.org/awesome-configs/tree/scratch/drop.lua

-- But uses a different implementation. The main difference is that we
-- are able to detect the Quake console from its name
-- (QuakeConsoleNeedsUniqueName by default).

-- Use:

-- local quake = require(&quot;quake&quot;)
-- local quakeconsole = {}
-- for s = 1, screen.count() do
--    quakeconsole[s] = quake({ terminal = config.terminal,
-- 			        height = 0.3,
--                              screen = s })
-- end

-- config.keys.global = awful.util.table.join(
--    config.keys.global,
--    awful.key({ modkey }, &quot;`&quot;,
-- 	     function () quakeconsole[mouse.screen]:toggle() end)

-- If you have a rule like &quot;awful.client.setslave&quot; for your terminals,
-- ensure you use an exception for
-- QuakeConsoleNeedsUniqueName. Otherwise, you may run into problems
-- with focus.

local setmetatable = setmetatable
local string = string
local awful  = require(&quot;awful&quot;)
local capi   = { mouse = mouse,
		 screen = screen,
		 client = client,
		 timer = timer }

-- I use a namespace for my modules...
module(&quot;quake&quot;)

local QuakeConsole = {}

-- Display
function QuakeConsole:display()
   -- First, we locate the terminal
   local client = nil
   local i = 0
   for c in awful.client.iterate(function (c)
				  -- c.name may be changed!
				  return c.instance == self.name
			       end,
			       nil, self.screen) do
      i = i + 1
      if i == 1 then
	 client = c
      else
	 -- Additional matching clients, let's remove the sticky bit
	 -- which may persist between awesome restarts. We don't close
	 -- them as they may be valuable. They will just turn into a
	 -- classic terminal.
	 c.sticky = false
	 c.ontop = false
	 c.above = false
      end
   end

   if not client and not self.visible then
      -- The terminal is not here yet but we don't want it yet. Just do nothing.
      return
   end

   if not client then
      -- The client does not exist, we spawn it
      awful.util.spawn(self.terminal .. &quot; &quot; .. string.format(self.argname, self.name),
		       false, self.screen)
      return
   end

   -- Comptute size
   local geom = capi.screen[self.screen].workarea
   local width, height = self.width, self.height
   if width  &lt;= 1 then width = geom.width * width end
   if height &lt;= 1 then height = geom.height * height end
   local x, y
   if     self.horiz == &quot;left&quot;  then x = geom.x
   elseif self.horiz == &quot;right&quot; then x = geom.width + geom.x - width
   else   x = geom.x + (geom.width - width)/2 end
   if     self.vert == &quot;top&quot;    then y = geom.y
   elseif self.vert == &quot;bottom&quot; then y = geom.height + geom.y - height
   else   y = geom.y + (geom.height - height)/2 end

   -- Resize
   awful.client.floating.set(client, true)
   client.border_width = 0
   client.size_hints_honor = false
   client:geometry({ x = x, y = y, width = width, height = height })

   -- Sticky and on top
   client.ontop = true
   client.above = true
   client.skip_taskbar = true
   client.sticky = true

   -- This is not a normal window, don't apply any specific keyboard stuff
   client:buttons({})
   client:keys({})

   -- Toggle display
   if self.visible then
      client.hidden = false
      client:raise()
      capi.client.focus = client
   else
      client.hidden = true
   end
end

-- Create a console
function QuakeConsole:new(config)
   -- The &quot;console&quot; object is just its configuration.

   -- The application to be invoked is:
   --   config.terminal .. &quot; &quot; .. string.format(config.argname, config.name)
   config.terminal = config.terminal or &quot;xterm&quot; -- application to spawn
   config.name     = config.name     or &quot;QuakeConsoleNeedsUniqueName&quot; -- window name
   config.argname  = config.argname  or &quot;-name %s&quot;     -- how to specify window name

   -- If width or height &lt;= 1 this is a proportion of the workspace
   config.height   = config.height   or 0.25	       -- height
   config.width    = config.width    or 1	       -- width
   config.vert     = config.vert     or &quot;top&quot;	       -- top, bottom or center
   config.horiz    = config.horiz    or &quot;center&quot;       -- left, right or center

   config.screen   = config.screen or capi.mouse.screen
   config.visible  = config.visible or false -- Initially, not visible

   local console = setmetatable(config, { __index = QuakeConsole })
   capi.client.connect_signal(&quot;manage&quot;,
			  function(c)
			     if c.instance == console.name and c.screen == console.screen then
				console:display()
			     end
			  end)
   capi.client.connect_signal(&quot;unmanage&quot;,
			  function(c)
			     if c.instance == console.name and c.screen == console.screen then
				console.visible = false
			     end
			  end)

   -- &quot;Reattach&quot; currently running QuakeConsole. This is in case awesome is restarted.
   local reattach = capi.timer { timeout = 0 }
   reattach:connect_signal(&quot;timeout&quot;,
		       function()
			  reattach:stop()
			  console:display()
		       end)
   reattach:start()
   return console
end

-- Toggle the console
function QuakeConsole:toggle()
   self.visible = not self.visible
   self:display()
end

setmetatable(_M, { __call = function(_, ...) return QuakeConsole:new(...) end })
&lt;/pre&gt;

This only works for applications that accept to be given a name through the command line (xterm, rxvt). Example of use :

&lt;pre&gt;
local quake = require(&quot;quake&quot;)

local quakeconsole = {}
for s = 1, screen.count() do
   quakeconsole[s] = quake({ terminal = config.terminal,
			     height = 0.3,
			     screen = s })
end

config.keys.global = awful.util.table.join(
   config.keys.global,
   awful.key({ modkey }, &quot;`&quot;,
	     function () quakeconsole[mouse.screen]:toggle() end)
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>ajdl1nopmzvv2woo2a1j3hptaudgvj3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Drop-down terminal/ru</title>
    <ns>0</ns>
    <id>1053</id>
    <revision>
      <id>7327</id>
      <parentid>6535</parentid>
      <timestamp>2015-05-23T13:32:36Z</timestamp>
      <contributor>
        <username>Masterslave89</username>
        <id>3306</id>
      </contributor>
      <minor/>
      <comment>/* Другие решения */</comment>
      <text xml:space="preserve" bytes="12201">{{Languages|Drop-down terminal}}
{{DISPLAYTITLE:Выпадающий терминал}}

== Введение ==
Выпадающий терминал всплывает из верхней части экрана, как в консолях видеоигр и может переключаться с помьщью одной клавиши.
Приложения, такие как Yakuake, Guake или Tilda обеспечивают функциональность выпадающего терминала для обычных окружений рабочего стола.
Тем не менее, в awesome  и мощью lua, мы можем имитировать эту функциональность и при этом использовать наши обычные терминальные приложения.

Добавьте следующую функцию в ваш rc.lua и вызовите ее назначенной клавишей, что создаст новое окно для выпадающего(drop-down) терминала, если он еще не существует, или переключит его между скрытием и отображением, если он уже существует.
Первым аргументом является запускаемая программа (например &quot;urxvtc&quot;), вторым агрументом является высота (в абсолютных пикселях, при значении &gt;1 или проценте если &lt;1, например 0.2 (20% высота экрана по умолчанию), и третьим агрументом служит номер экрана(screen).
Второй аргумент является опциональным(не обязательным).

=== Функция ===
&lt;pre&gt;
-- Данная функция для awesome версии &lt;= 3.4

dropdown = {}

function dropdown_toggle(prog, height, s)
   if s == nil then s = mouse.screen end
   if height == nil then height = 0.2 end
   
   if not dropdown[prog] then
      -- Create table
      dropdown[prog] = {}
      
      -- Add unmanage hook for dropdown programs
      awful.hooks.unmanage.register(function (c)
                                       for scr, cl in pairs(dropdown[prog]) do
                                          if cl == c then
                                             dropdown[prog][scr] = nil
                                          end
                                       end
                                    end)
   end
   
   if not dropdown[prog][s] then
      spawnw = function (c)
                  -- Store client
                  dropdown[prog][s] = c
                  
                  -- Float client
                  awful.client.floating.set(c, true)
                  
                  -- Get screen geometry
                  screengeom = screen[s].workarea
                  
                  -- Calculate height
                  if height &lt; 1 then
                     height = screengeom.height*height
                  end

                  -- I like a different border with for the popup window
                  -- So I don't confuse it with terminals in the layout
                  bw = 2

                  -- Resize client
                  c:geometry({
                                x = screengeom.x,
                                y = screengeom.y - 1000,
                                width = screengeom.width - bw, 
                                height = height - bw
                             })

                  -- Mark terminal as ontop
                  --            c.ontop = true
                  --            c.above = true
                  c.border_width = bw

                  -- Focus and raise client
                  c:raise()
                  client.focus = c

                  -- Remove hook
                  awful.hooks.manage.unregister(spawnw)
               end

      -- Add hook
      awful.hooks.manage.register(spawnw)

      -- Spawn program
      awful.util.spawn(prog)

      dropdown.currtag = awful.tag.selected(s)
   else
      -- Get client
      c = dropdown[prog][s]
      
      -- Switch the client to the current workspace

      -- Focus and raise if not hidden
      if c.hidden then
         awful.client.movetotag(awful.tag.selected(s), c)
         c.hidden = false
         c:raise()
         client.focus = c
      else
         if awful.tag.selected(s) == dropdown.currtag then
            c.hidden = true
            local ctags = c:tags()
            for i, t in pairs(ctags) do
               ctags[i] = nil
            end
            c:tags(ctags)
         else
            awful.client.movetotag(awful.tag.selected(s), c)
            c:raise()
            client.focus = c
         end
      end
      dropdown.currtag = awful.tag.selected(s)
   end
end
&lt;/pre&gt;

== Scratch ==
Scratch обеспечивает выпадающие приложения и менеджер scratchpad manager для оконного менеджера awesome. Его модуль ''scratch.drop'' основан на коде описанном выше и совместим с awesome '''v3.4'''(сейчас также и с 3.5). Для большей информации, смотрите страницу [[Scratchpad manager/ru|Scratchpad manager]].

== Другие решения ==

Следующий код требует Lua 5.2 и Awesome 3.5
Предыдущее решение имеет два маленьких недостатка: консольное окно определяется как первое окно, и управляется только после первого запроса.
Это может привести к состоянию первенства, но это маловероятно. Второй недостаток проявляется при перезапуске awesome, выпадающий терминал, перестает быть таким. Вместо этого появляется один липкий терминал. Это несколько неправильно. Поэтому далее приведено другое решение, которое работает через зависимость от присвоенного терминалу имени:

&lt;pre&gt;
-- Quake like console on top
-- Similar to:
--   http://git.sysphere.org/awesome-configs/tree/scratch/drop.lua

-- But uses a different implementation. The main difference is that we
-- are able to detect the Quake console from its name
-- (QuakeConsoleNeedsUniqueName by default).

-- Use:

-- local quake = require(&quot;quake&quot;)
-- local quakeconsole = {}
-- for s = 1, screen.count() do
--    quakeconsole[s] = quake({ terminal = config.terminal,
-- 			        height = 0.3,
--                              screen = s })
-- end

-- config.keys.global = awful.util.table.join(
--    config.keys.global,
--    awful.key({ modkey }, &quot;`&quot;,
-- 	     function () quakeconsole[mouse.screen]:toggle() end)

-- If you have a rule like &quot;awful.client.setslave&quot; for your terminals,
-- ensure you use an exception for
-- QuakeConsoleNeedsUniqueName. Otherwise, you may run into problems
-- with focus.

local setmetatable = setmetatable
local string = string
local awful  = require(&quot;awful&quot;)
local capi   = { mouse = mouse,
		 screen = screen,
		 client = client,
		 timer = timer }

-- I use a namespace for my modules...
module(&quot;quake&quot;)

local QuakeConsole = {}

-- Display
function QuakeConsole:display()
   -- First, we locate the terminal
   local client = nil
   local i = 0
   for c in awful.client.iterate(function (c)
				  -- c.name may be changed!
				  return c.instance == self.name
			       end,
			       nil, self.screen) do
      i = i + 1
      if i == 1 then
	 client = c
      else
	 -- Additional matching clients, let's remove the sticky bit
	 -- which may persist between awesome restarts. We don't close
	 -- them as they may be valuable. They will just turn into a
	 -- classic terminal.
	 c.sticky = false
	 c.ontop = false
	 c.above = false
      end
   end

   if not client and not self.visible then
      -- The terminal is not here yet but we don't want it yet. Just do nothing.
      return
   end

   if not client then
      -- The client does not exist, we spawn it
      awful.util.spawn(self.terminal .. &quot; &quot; .. string.format(self.argname, self.name),
		       false, self.screen)
      return
   end

   -- Comptute size
   local geom = capi.screen[self.screen].workarea
   local width, height = self.width, self.height
   if width  &lt;= 1 then width = geom.width * width end
   if height &lt;= 1 then height = geom.height * height end
   local x, y
   if     self.horiz == &quot;left&quot;  then x = geom.x
   elseif self.horiz == &quot;right&quot; then x = geom.width + geom.x - width
   else   x = geom.x + (geom.width - width)/2 end
   if     self.vert == &quot;top&quot;    then y = geom.y
   elseif self.vert == &quot;bottom&quot; then y = geom.height + geom.y - height
   else   y = geom.y + (geom.height - height)/2 end

   -- Resize
   awful.client.floating.set(client, true)
   client.border_width = 0
   client.size_hints_honor = false
   client:geometry({ x = x, y = y, width = width, height = height })

   -- Sticky and on top
   client.ontop = true
   client.above = true
   client.skip_taskbar = true
   client.sticky = true

   -- This is not a normal window, don't apply any specific keyboard stuff
   client:buttons({})
   client:keys({})

   -- Toggle display
   if self.visible then
      client.hidden = false
      client:raise()
      capi.client.focus = client
   else
      client.hidden = true
   end
end

-- Create a console
function QuakeConsole:new(config)
   -- The &quot;console&quot; object is just its configuration.

   -- The application to be invoked is:
   --   config.terminal .. &quot; &quot; .. string.format(config.argname, config.name)
   config.terminal = config.terminal or &quot;xterm&quot; -- application to spawn
   config.name     = config.name     or &quot;QuakeConsoleNeedsUniqueName&quot; -- window name
   config.argname  = config.argname  or &quot;-name %s&quot;     -- how to specify window name

   -- If width or height &lt;= 1 this is a proportion of the workspace
   config.height   = config.height   or 0.25	       -- height
   config.width    = config.width    or 1	       -- width
   config.vert     = config.vert     or &quot;top&quot;	       -- top, bottom or center
   config.horiz    = config.horiz    or &quot;center&quot;       -- left, right or center

   config.screen   = config.screen or capi.mouse.screen
   config.visible  = config.visible or false -- Initially, not visible

   local console = setmetatable(config, { __index = QuakeConsole })
   capi.client.connect_signal(&quot;manage&quot;,
			  function(c)
			     if c.instance == console.name and c.screen == console.screen then
				console:display()
			     end
			  end)
   capi.client.connect_signal(&quot;unmanage&quot;,
			  function(c)
			     if c.instance == console.name and c.screen == console.screen then
				console.visible = false
			     end
			  end)

   -- &quot;Reattach&quot; currently running QuakeConsole. This is in case awesome is restarted.
   local reattach = capi.timer { timeout = 0 }
   reattach:connect_signal(&quot;timeout&quot;,
		       function()
			  reattach:stop()
			  console:display()
		       end)
   reattach:start()
   return console
end

-- Toggle the console
function QuakeConsole:toggle()
   self.visible = not self.visible
   self:display()
end

setmetatable(_M, { __call = function(_, ...) return QuakeConsole:new(...) end })
&lt;/pre&gt;

Вышеописанный код будет работать с приложениями, которые понимают присвоенные через терминал названия (xterm, rxvt). Пример использования:

&lt;pre&gt;
local quake = require(&quot;quake&quot;)

local quakeconsole = {}
for s = 1, screen.count() do
   quakeconsole[s] = quake({ terminal = config.terminal,
			     height = 0.3,
			     screen = s })
end

config.keys.global = awful.util.table.join(
   config.keys.global,
   awful.key({ modkey }, &quot;`&quot;,
	     function () quakeconsole[mouse.screen]:toggle() end)
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>ikk23bc33j6zpwsdoh6er03ufkon54y</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Débuter</title>
    <ns>0</ns>
    <id>150</id>
    <redirect title="Getting started/fr" />
    <revision>
      <id>3115</id>
      <parentid>1016</parentid>
      <timestamp>2009-06-26T11:32:51Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>Redirected page to [[Getting started/fr]]</comment>
      <text xml:space="preserve" bytes="31">#REDIRECT[[Getting started/fr]]</text>
      <sha1>b7toft5qkexbsssxl61d0r4onstzgq2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Débuter (français)</title>
    <ns>0</ns>
    <id>416</id>
    <redirect title="Getting started/fr" />
    <revision>
      <id>3114</id>
      <timestamp>2009-06-26T11:32:31Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Débuter (français)]] to [[Getting started/fr]]</comment>
      <text xml:space="preserve" bytes="32">#REDIRECT [[Getting started/fr]]</text>
      <sha1>b3kergj3ztumu27fljwkhlmzypsti8g</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>EMail notification widget</title>
    <ns>0</ns>
    <id>590</id>
    <revision>
      <id>6053</id>
      <parentid>5327</parentid>
      <timestamp>2013-06-26T17:20:10Z</timestamp>
      <contributor>
        <username>Brmiller</username>
        <id>3029</id>
      </contributor>
      <text xml:space="preserve" bytes="1679">[[Image:indicator_email_dmj.png]]

dmj has written a nice email notification widget:

&lt;del&gt;:[http://github.com/dmj/misc/tree/master/lua/imap.lua/ An IMAP client widget (pure lua, example widget)]&lt;/del&gt;

I've modified dmjs widget. Now it will work with awesome 3.4:

:[http://github.com/s-hell/misc/tree/master/lua/imap.lua/ An IMAP client widget (pure lua, example widget)]

Fetch that by using the command ''git clone http://github.com/s-hell/misc''. You'll have to move into a couple of directories and then copy the 2 files called mail-simple.lua and imap.lua to your ~/.config/awesome/

Make sure to set your username and password as directed in mail-simple.lua:

  imap_user = &quot;myimaploginname@myhost.com&quot;
  imap_padd = &quot;88693jkjfdkf&quot;

Also change the host name and other relevant details a few lines above- they don't need to be changed for gmail users though as it's set to gmail by default.

In rc.lua, at the top, I added under require(&quot;debian.menu&quot;) a new line:

  require(&quot;debian.menu&quot;)
  require(&quot;mail-simple&quot;) -- new line

Scroll down a bit to:

        -- mylayoutbox[s],
        mytextclock,
        s == 1 and mysystray or nil,
        w_imap,  -- ADD THIS NEW LINE HERE
        mytasklist[s],
        layout = awful.widget.layout.horizontal.rightleft

If you log out it should now work.

=== Dependencies ===

This widget depends on the Lua socket and ''sec'' libraries.  In Ubuntu 12.04, I had to

  apt-get install liblua5.1-socket2 liblua5.1-sec1

=== The other widget ===

The other widget has a longer display like Inbox: 3/4/5... Use mail-long.lua if you prefer it.

[[Image:fullescreen_email_dmj_not_popup.png]]

[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>1wth9op30vhnmiwaq2eus8db4tbkcf5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Effects</title>
    <ns>0</ns>
    <id>567</id>
    <revision>
      <id>4345</id>
      <parentid>4344</parentid>
      <timestamp>2010-07-03T18:41:00Z</timestamp>
      <contributor>
        <username>Schelm</username>
        <id>487</id>
      </contributor>
      <text xml:space="preserve" bytes="8074">With the Effect &quot;class&quot;, you can &quot;tween&quot; properties of objects or functions with different transitions

Its a port of the Mootools Fx classes

==Usage==
Simple use (for tweening the opacity):

 fx = Effect.create(client_instance, {
   duration = 0.8, -- seconds
   fps = 60, -- frames per second (defaults to 40)
   transition = Effect.Transitions.easeOut.Quint -- defaults to Effect.Transitions.linear
 })
 fx:start({
   opacity = 1
 })

When using a function instead of an object it is important that the function can set and return your properties via a table

Example (asuming you want to tween x and y of a client instance c):

 fx = Effect.create(function (geom) {
   return c:geometry(geom)
 end
 fx:start({x = 10, y = 10})



==my currently use:==
You can find a video of it on [http://vimeo.com/13056382 vimeo]

 function initEffect (c, options, name)
 	if not name then name = 'fx' end
 	
 	
 	if not awful.client.property.get(c, name) then
 	
 		require(&quot;effect&quot;);
 		
 		if not options then
 			options = {
 				duration = 1, 
 				transition = Effect.Transitions.easeIn.Bounce
 			}
 		end
 		
 		awful.client.property.set(c, name, Effect.create(
 			function (props) 
 				return c:geometry(props)
 			end, 
 			options
 		))
 	end
 	return awful.client.property.get(c, name)
 end
 
 -- Vogel functionality
 vogel = nil
 
 function vogelEffect ()
 	if not vogel then
 		return awful.util.spawn(terminal .. &quot; -title vogel&quot;)
 	end
 	vogel.screen = mouse.screen
 	client.focus = vogel
 	vogel:raise()
 	vogel:tags({awful.tag.selected(mouse.screen)})
 	initEffect(vogel):start({
 		x = mouse.coords().x - vogel:geometry().width/2, 
 		y = mouse.coords().y - vogel:geometry().height/2
 	})
 end
 
 globalkeys = awful.util.table.join(globalkeys,
 	awful.key({ &quot;Shift&quot; }, &quot;F1&quot;, vogelEffect)
 )
 
 client.add_signal(&quot;manage&quot;, function (c, startup)
 	if c.name == 'vogel' then
 		vogel = c
 		vogelEffect()
 	end
 end)
 
 client.add_signal(&quot;unmanage&quot;, function (c, startup)
 	if c.name == 'vogel' then
 		vogel = nil
 	end
 end)
 
 
 -- Move windows
 clientkeys = awful.util.table.join(clientkeys,
 	-- move client to right screen edge
 	awful.key({ modkey, &quot;Control&quot;  }, &quot;Right&quot;,		function (c)
 		initEffect(c):start({x = screen[c.screen].workarea.width - c:geometry().width});
 	end),
 	-- move client to left screen edge
 	awful.key({ modkey, &quot;Control&quot;  }, &quot;Left&quot;,		function (c)
 		initEffect(c):start({x = 0});
 	end),
 	-- move client to top screen edge
 	awful.key({ modkey, &quot;Control&quot;  }, &quot;Up&quot;,		function (c)
 		initEffect(c):start({y = 0});
 	end),
 	-- move client to bottom screen edge
 	awful.key({ modkey, &quot;Control&quot;  }, &quot;Down&quot;,		function (c)
 		initEffect(c):start({y = screen[c.screen].workarea.height - c:geometry().height});
 	end),
 	
 	-- make client height smaller
 	awful.key({ modkey, &quot;Control&quot;, &quot;Shift&quot;  }, &quot;Up&quot;,		function (c)
 		initEffect(c, {
 			duration = 0.2, 
 			transition = Effect.Transitions.linear
 		}, 'fx-size'):start({height = c:geometry().height - 50});
 	end),
 	-- make client height bigger
 	awful.key({ modkey, &quot;Control&quot;, &quot;Shift&quot;  }, &quot;Down&quot;,		function (c)
 		initEffect(c, {
 			duration = 0.2, 
 			transition = Effect.Transitions.linear
 		}, 'fx-size'):start({height = c:geometry().height + 50});
 	end),
 	-- make client width smaller
 	awful.key({ modkey, &quot;Control&quot;, &quot;Shift&quot;  }, &quot;Left&quot;,		function (c)
 		initEffect(c, {
 			duration = 0.2, 
 			transition = Effect.Transitions.linear
 		}, 'fx-size'):start({width = c:geometry().width - 50});
 	end),
 	-- make client width bigger
 	awful.key({ modkey, &quot;Control&quot;, &quot;Shift&quot;  }, &quot;Right&quot;,		function (c)
 		initEffect(c, {
 			duration = 0.2, 
 			transition = Effect.Transitions.linear
 		}, 'fx-size'):start({width = c:geometry().width + 50});
 	end)
 )

==The class==
I dont know if it is the best lua coding practices. If there are bugs or anything please tell me :)

Put this in ~/.config/awesome/effect.lua or ~/.config/awesome/effect/init.lua

 ---------------------------------------------------
 -- Effect class for the awesome window manager
 -- A port of mootools Fx Library
 ---------------------------------------------------
 -- Licensed under MIT License
 --  * (c) 2010, Georg Nagel &lt;g.schlmm@gmail.com&gt;
 ---------------------------------------------------
  
 Effect = {}
 Effect.__index = Effect
 
 function Effect.create(obj, options)
 	
 	local fx = {
 		options = {
 			fps = 40,
 			duration = 0.5
 		}
 	}
 	
 	setmetatable(fx,Effect)
 	
 	fx._obj = obj
 	
 	if type(options) == 'table' then
 		fx:setOptions(options)
 	end
 	
 	fx._timer = timer({ timeout = 1/fx.options.fps })
 	fx._timer:add_signal(&quot;timeout&quot;, function () fx:step() end)
 	
 	fx._is_func = (type(fx._obj) == 'function')
 	fx._props = {}
 
 	return fx
 	
 end
 
 function Effect:setOptions (options)
 	tmp = self.options
 	for k,v in pairs(options) do self.options[k] = v end
 end
 
 function Effect:start (properties) 
 	self._time = 0
 	o = self._obj
 	if self._is_func then
 		o = self._obj()
 	end
 	
 	if (self._timer.started) then
 		self._timer:stop()
 	end
 	
 	for k,v in pairs(self._props) do
 		if not properties[k] and properties[k] ~= 0  then
 			properties[k] = v.to
 		end
 	end
 	
 	for k,v in pairs(properties) do
 		if o[k] then
 			self._props[k] = { from = o[k], to = v }
 		end
 	end
 	self:validateTransition()
 	self._timer:start()
 end
 
 function Effect:stop() 
 	self._timer:stop()
 end
 
 
 function Effect:step ()
 	self._time = self._time + self._timer.timeout
 	local newProps = {}
 	if (self._time &lt; self.options.duration) then
 		for k,v in pairs(self._props) do 
 			local delta = self.transition(self._time / self.options.duration)
 			newProps[k] = self:compute(v.from, v.to, delta) 
 		end
 	else
 		for k,v in pairs(self._props) do
 			newProps[k] = v.to
 			self._timer:stop()
 		end
 	end
 	
 	self:set(newProps)
 end
 
 function Effect:set (props)
 	if self._is_func then
 		self._obj(props);
 	else
 		for k,v in pairs(self._props) do 
 			self._obj[prop] = value
 		end
 	end
 end
 
 function Effect:compute (from, to, delta)
 	return (to - from) * delta + from
 end
 
 
 function Effect:validateTransition ()
 	local trans = self.options.transition;
 	if type(trans) ~= 'function' then
 		trans = Effect.Transitions.linear
 	end
 	self.transition = trans;
 end
 
 
 Effect.Transitions = {}
 function Effect.Transitions.linear (zero)
 	return zero
 end
 
 local transitions = {}
 
 function transitions.Pow (p, x)
 	if type(x) == 'table' and x[0] then
 		x = x[0]
 	else
 		x = 6
 	end
 	return math.pow(p, x);
 end
 
 function transitions.Expo (p)
 	return math.pow(2, 8 * (p - 1));
 end
 
 function transitions.Circ (p)
 	return 1 - math.sin(math.acos(p));
 end
 
 function Effect.Transitions.Sine (p)
 	return 1 - math.sin((1 - p) * math.pi / 2);
 end
 
 function transitions.Back (p, x)
 	if type(x) == 'table' and x[0] then
 		x = x[0]
 	else
 		x = 1.618
 	end
 	return math.pow(p, 2) * ((x + 1) * p - x);
 end
 
 function transitions.Bounce (p)
 	if p &lt; 1/2.75 then
 		return 7.5625*p*p
 	end
 	if p &lt; 2/2.75 then
 		p = p - (1.5/2.75)
 		return 7.5625*p*p + 0.75
 	end
 	if p &lt; 2.5/2.75 then
 		p = p - (2.25/2.75)
 		return 7.5625*p*p + 0.9375
 	end
 	p = p - (2.625/2.75)
 	return 7.5625*p*p + 0.984375
 end
 
 function transitions.Elastic (p, x)
 	p = p - 1
 	if type(x) == 'table' and x[0] then
 		x = x[0]
 	else
 		x = 3
 	end
 	return match.pow(2, 10 * p) * math.cos(20 * p * math.pi * x / 3);
 end
 
 
 for i, name in pairs({'Quad', 'Cubic', 'Quart', 'Quint'}) do
 	transitions[name] = function (p) 
 		return math.pow(p, i + 2)
 	end
 end
 
 Effect.Transitions.easeIn = {}
 Effect.Transitions.easeOut = {}
 Effect.Transitions.easeInOut = {}
 
 for name,transition in pairs(transitions) do 
 	Effect.Transitions.easeIn[name] = transition
 	Effect.Transitions.easeOut[name] = function (p)
 		return 1 - transitions[name](1 - p);
 	end
 	Effect.Transitions.easeInOut[name] = function (p)
 		local x = p &lt;= 0.5 and 
 			transitions[name](2 * p, params) / 2 
 		or 
 			(2 - transitions[name](2 * (1 - p))) / 2
 		return x
 	end
 end</text>
      <sha1>gsvju574pbjft4y5a3n4pkzjta04ur9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Einfache Widgets integrieren</title>
    <ns>0</ns>
    <id>350</id>
    <redirect title="Integrating widgets into awesome/de" />
    <revision>
      <id>2798</id>
      <timestamp>2009-05-24T18:13:19Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Einfache Widgets integrieren]] to [[Integrating widgets into awesome/de]]:&amp;#32;Make this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="49">#REDIRECT [[Integrating widgets into awesome/de]]</text>
      <sha1>dfc7o8osf8ysvhpj4i6v96ra0wu6u4u</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ekg2 tips</title>
    <ns>0</ns>
    <id>261</id>
    <revision>
      <id>3264</id>
      <parentid>3263</parentid>
      <timestamp>2009-07-03T22:05:25Z</timestamp>
      <contributor>
        <username>Pawelz</username>
        <id>233</id>
      </contributor>
      <minor/>
      <comment>/* Naughty notifications */ spaces</comment>
      <text xml:space="preserve" bytes="923">= Naughty notifications =
There is a simple python script for [http://ekg2.org/ ekg2], that uses [[Naughty]] to notify user about incoming messages:

 import dbus
 import ekg
 
 def message_handler(session, uid, type, text, sent_time, ignore_level):
     no = dbus.SessionBus().get_object('org.freedesktop.Notifications', '/org/freedesktop/Notifications')
     ni = dbus.Interface(no, 'org.freedesktop.Notifications')
     ni.Notify(&quot;python&quot;, 0, '', uid[:40], text[:40], {}, {}, 5000)
 
     return 1
 
 ekg.handler_bind('protocol-message-received', message_handler)

= Running script =

Make sure that python plugin is loaded in ekg2. To enable notifications just type:
 /script:load /path/to/script.py
Refer ekg2 documentation for more details.

It works with new svn versions of ekg2 (2009-01-14). It does not work with last release (0.1.1). It seems that python support is broken in that release.

[[Category:awesome3]]</text>
      <sha1>kq30vf4uyez8i7xht6qohc3owzpw9xo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Elegant cold blue - mod of cool blue theme</title>
    <ns>0</ns>
    <id>191</id>
    <revision>
      <id>1498</id>
      <timestamp>2008-11-09T01:27:41Z</timestamp>
      <contributor>
        <username>GullibleJones</username>
        <id>181</id>
      </contributor>
      <text xml:space="preserve" bytes="411">&lt;pre&gt;
---------------------------------
-- Elegant Cold Blue
---------------------------------
font          = Dejavu Sans 7

bg_normal     = #262729
bg_focus      = #659FDB
bg_urgent     = #808080

fg_normal     = #659FDB
fg_focus      = #EAEAEA
fg_urgent     = #808080

border_width  = 1
border_normal = #262729
border_focus  = #659FDB
border_marked = #808080
&lt;/pre&gt;


[[Category:awesome3]][[Category:themes]]</text>
      <sha1>77h8okmrxerptipesrdllqgfnypdn4m</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Email maildir naughty hoover</title>
    <ns>0</ns>
    <id>675</id>
    <revision>
      <id>4847</id>
      <parentid>4846</parentid>
      <timestamp>2011-05-01T11:27:32Z</timestamp>
      <contributor>
        <username>Pazz</username>
        <id>638</id>
      </contributor>
      <text xml:space="preserve" bytes="4585">I'd like to share a bit of code I wrote for my mail setup.
I wanted something like the [[Delightful]] imap widget, but without the bloat of all the 
Delightful modules, that works with maildirs and in combination with vicious.
 
This module allows to wrap a naughty popup with maildir info around a widget in the style of
[[Calendar_widget#Module_for_3.4]].
I'm currently using it in combination with the maildir widget from vicious, which I configured to
display an envelope image in case i have new mail. placing the mouse over this widget then opens
the naughty popup. 
here is a screenshot:
[[File:email_maildir_hoover_ss.jpg]]


== code and usage ==

I have a file &quot;mailhoover.lua&quot; wich contains the following.
(get it here: https://github.com/pazz/configs/raw/master/.config/awesome/mailhoover.lua)
&lt;pre&gt;
local string = string
--local print = print
local tostring = tostring
local io = io
local table = table
local pairs = pairs
local capi = {
    mouse = mouse,
    screen = screen
}
local awful = require(&quot;awful&quot;)
local naughty = require(&quot;naughty&quot;)
local beautiful = require('beautiful')
module(&quot;mailhoover&quot;)

local popup
local account_format = &quot;&lt;span color='&quot; .. beautiful.fg_urgent ..&quot;'&gt;&lt;b&gt;%s&lt;/b&gt;&lt;/span&gt;&quot;
local dir_format = &quot;&lt;span color='&quot; .. beautiful.fg_normal ..&quot;'&gt;&lt;b&gt;%s&lt;/b&gt;&lt;/span&gt;&quot;
local newmail_format = &quot;&lt;span color='&quot; .. beautiful.fg_urgent .. &quot;'&gt;%s&lt;/span&gt;&quot;
local oldmail_format = &quot;&lt;span color='&quot; .. beautiful.fg_focus .. &quot;'&gt;%s&lt;/span&gt;&quot;

function addToWidget(mywidget, maildirs, accountname)
  mywidget:add_signal('mouse::enter', function ()
        local info = read_maildirs(maildirs)
        popup = naughty.notify({
                title = string.format(account_format,accountname),
                text = info,
                timeout = 0,
                hover_timeout = 0.5,
                screen = capi.mouse.screen
        })
  end)
  mywidget:add_signal('mouse::leave', function () naughty.destroy(popup) end)
end
function read_maildirs(md)
    local info = &quot;&quot;
    local count = 0

    for i=1, #md do
        mdir = md[i]
        mails = {}
        -- Recursively find new messages
        local f = io.popen(&quot;find &quot;..mdir..&quot; -type f -wholename '*/new/*'&quot;)
        for line in f:lines() do 
            table.insert(mails,format_mail(newmail_format,line)) 
        end
        f:close()

        -- Recursively find &quot;old&quot; messages lacking the Seen flag
        local f = io.popen(&quot;find &quot;..mdir..&quot; -type f -regex '.*/cur/.*2,[^S]*$'&quot;)
        for line in f:lines() do 
            table.insert(mails,format_mail(oldmail_format,line))
        end
        f:close()

        if #mails&gt;0 then info = info .. string.format(dir_format,mdir) .. ':\n' end
        for m=1, #mails do
            info = info .. mails[m]
        end
    end
   return info
end
function format_mail(template,mailpath)
    mailfile = io.open(mailpath,&quot;r&quot;)
    for line in mailfile:lines() do
       if line:find(&quot;^Subject:&quot;) then subject = string.match(line, &quot;^Subject: (.*)%s?&quot;) end
       if line:find(&quot;^From:&quot;) then 
           from = string.match(line, &quot;^From: (.*)&quot;) 
           from = string.gsub(from, &quot;&lt;.*&gt;&quot;,&quot;&quot;)
       end
    end
    mailfile:close()
    return string.format(&quot; %-30s %s\n&quot;, from, subject)
end
&lt;/pre&gt;




This is part of my rc.lua.

&lt;pre&gt;
require('mailhoover')
...
mailicon = widget({ type = 'imagebox', name = 'mailicon'})
mailfolders =   {
    '/home/pazz/mail/uoe/INBOX',
    '/home/pazz/mail/uoe/lists.seminars',
}
mailhoover.addToWidget(mailicon, mailfolders, ACCOUNTNAME')
vicious.register(mailicon, vicious.widgets.mdir,
function (widget, args)
        if args[1] &gt; 0 then
                mailicon.image = image(beautiful.widget_mail)
        else
                mailicon.image = image(beautiful.widget_nomail)
        end
        return nil
end, 10, mailfolders)
mailbuttons = awful.util.table.join(
        awful.button({ }, 1, function () awful.util.spawn(mail_cmd) end)
)
mailicon:buttons(mailbuttons)
&lt;/pre&gt;


The important bit is the line
&lt;pre&gt;
mailhoover.addToWidget(mailicon, mailfolders, 'ACCOUNTNAME')
&lt;/pre&gt;
that adds the mouseover effect to the widget &quot;mailicon&quot;.
the second argument is a table of maildir locations, the third is the title of the naughty-message.
The colours used are taken from 
beautiful.fg_urgent,beautiful.fg_normal and beautiful.fg_focus.

== non-features/bugs ==
* encoding problems: some subject lines still don't display correctly
* it would ne nice to have the popup triggered by a global keycombo instead of having to point the mouse over the widget
* vertical alignment of from and subject lines needs some fixing</text>
      <sha1>pv3zpayf7atdwphpiy1gd68he8btcln</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Email notification with mutt integration</title>
    <ns>0</ns>
    <id>670</id>
    <revision>
      <id>4910</id>
      <parentid>4909</parentid>
      <timestamp>2011-06-20T12:45:17Z</timestamp>
      <contributor>
        <username>Drebs</username>
        <id>631</id>
      </contributor>
      <comment>taking out debug notification</comment>
      <text xml:space="preserve" bytes="5366">This code creates a mailbar with buttons that appear when new mail arrives and launch mutt in the correct account/mailbox when clicked.

 &lt;nowiki&gt;
------------------------------------------------------------------------------
-- mailbar
------------------------------------------------------------------------------

-- table that holds all mailbar-related objects
mailbar = { }


-- mailbar configuration
mailbar['conf'] = {
  maildir = &quot;/home/user/Mail&quot;,
  accounts = { &quot;Account1&quot;, &quot;Account2&quot;, &quot;Account3&quot; },
  visible_by_default = false,
  check_interval = 60,
  notification_timeout = 30
}


-- prefills totalmail table
mailbar['totalmail'] = { }
for _, account in ipairs(mailbar['conf']['accounts']) do
  mailbar['totalmail'][account] = { new = 0, seen = 0 }
end


-- executes a command and returns a string as the result
function execute_command(command)
   local fh = io.popen(command)
   local str = &quot;&quot;
   for i in fh:lines() do
      str = str .. i
   end
   io.close(fh)
   return str
end


-- adds a button with text to a list
function add_button(list, text, func_press, func_release)
  local button = widget({ type = &quot;textbox&quot; })
  button.text = text
  button:buttons( awful.button({ }, 1, func_press or nil, func_release or nil) )
  return awful.util.table.join(list, { button })
end


-- notifies of new mail using naughty
function notify_newmail(account, new, seen)
  naughty.notify({
    text = new .. &quot;/&quot; .. seen,
    title = &quot;Novas mensagens em [&quot; .. account .. &quot;]&quot;,
    position = &quot;top_left&quot;,
    timeout = mailbar['conf']['notification_timeout'],
    fg=&quot;#ffggcc&quot;,
    bg=&quot;#bbggcc&quot;,
    ontop = true })
end


-- finds new mail in account and mailbox
function new_in_mailbox(account, mailbox)
  return tonumber(execute_command(&quot;find &quot; ..
                         mailbar['conf']['maildir'] .. &quot;/&quot; .. account .. &quot;/&quot; .. mailbox ..
                         &quot; -type f -wholename '*/new/*' | wc -l&quot;))
end


-- finds new but seen mail in account and mailbox
function seen_in_mailbox(account, mailbox)
  return tonumber(execute_command(&quot;find &quot; ..
                         mailbar['conf']['maildir'] .. &quot;/&quot; .. account .. &quot;/&quot; .. mailbox ..
                         &quot; -type f -regex '.*/cur/.*2,[^S]*$' | wc -l&quot;))
end


-- spawns a terminal with mutt in the mailbox listing for an account
function fspawn_account(account)
  return function ()
           awful.util.spawn(terminal .. &quot; -e \&quot;mutt -y\&quot;&quot;)
         end
end


-- spawns a terminal with mutt in an account's mailbox
function fspawn_mailbox(account, mailbox)
  return function (button)
           awful.util.spawn(terminal .. 
                            &quot; -e \&quot;mutt -f &quot; ..
                            mailbar['conf']['maildir'] .. &quot;/&quot; ..
                            account ..
                            &quot;/&quot; .. mailbox .. &quot;\&quot;&quot;)
           button.bg = &quot;#666666&quot;
         end
end


-- builds buttons for an account
function build_mailbuttons(account)
  local mailbuttons = {}
  local new = new_in_mailbox(account, &quot;&quot;)
  local seen = seen_in_mailbox(account, &quot;&quot;)

  -- notifies if new mail has arrived
  if new &gt; mailbar['totalmail'][account]['new']
     or seen &gt; mailbar['totalmail'][account]['seen']
  then
    notify_newmail(account, new, seen)
  end
  mailbar['totalmail'][account] = { new = new, seen = seen }
  
  -- builds buttons for the account if there is any new mail
  if (new + seen) ~= 0 then
    local fh = io.popen(&quot;ls -1 &quot; .. mailbar['conf']['maildir'] .. &quot;/&quot; .. account)
    mailbuttons = add_button(mailbuttons, &quot;:::&quot;)
    mailbuttons = add_button(mailbuttons,
                             &quot;   [&quot; .. account .. &quot;] (&quot; .. new ..
                             &quot;/&quot; .. seen .. &quot;)   &quot;,
                             fspawn_account(account))
    for mailbox in fh:lines() do
      seen = seen_in_mailbox(account, mailbox)
      new = new_in_mailbox(account, mailbox)
      if new + seen ~= 0 then
        mailbuttons = add_button(mailbuttons, &quot;:::&quot;)
        mailbuttons = add_button(mailbuttons,
                                 &quot;   &quot; .. mailbox .. &quot; (&quot; .. new .. &quot;/&quot; .. seen .. &quot;)   &quot;,
                                 fspawn_mailbox(account, mailbox))
      end
    end
    io.close(fh)
  end

  return mailbuttons
end


-- updates the mailbar with new info
function update_mailbar(accounts, mailbar)
  local buttons = { }
  for i, account in ipairs(accounts) do
    buttons = awful.util.table.join(buttons, build_mailbuttons(account))
  end
  mailbar.widgets = awful.util.table.join(buttons,
                                       { layout = awful.widget.layout.horizontal.leftright } )

  -- hides bar if there is no mail
  if #buttons == 0 then
    mailbar.visible = false
  end
end


-- creates the mailbar
mailbar['wibox'] = awful.wibox({ position = &quot;bottom&quot;, screen = 1 })
mailbar['wibox'].visible = mailbar['conf']['visible_by_default']
mailbar['wibox'].ontop = true


-- sets up a timer to update the bar
mailbar['timer'] = timer({ timeout = mailbar['conf']['check_interval'] })
update_mailbar(mailbar['conf']['accounts'], mailbar['wibox'])
mailbar['timer']:add_signal(&quot;timeout&quot;,
                     function() update_mailbar(mailbar['conf']['accounts'], mailbar['wibox']) end)
mailbar['timer']:start()


-- key bindings
globalkeys = awful.util.table.join(globalkeys,
    awful.key({ }, &quot;F12&quot;, function () mailbar['wibox'].visible = not mailbar['wibox'].visible end))
&lt;/nowiki&gt;</text>
      <sha1>7qidgk6tfxqh6tc8s3ncgdzz8g278vg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Eminent</title>
    <ns>0</ns>
    <id>95</id>
    <revision>
      <id>7388</id>
      <parentid>7080</parentid>
      <timestamp>2015-11-15T19:44:49Z</timestamp>
      <contributor>
        <username>Barlik</username>
        <id>4310</id>
      </contributor>
      <text xml:space="preserve" bytes="3035">{{Languages}}

== Dynamic tagging ==
This extension is unnecessary as the same behaviour can be achieved with default awesome installation by changing
the filter function when creating awful.widget.taglist.

Possible filter functions:

* awful.widget.taglist.filter.all - show all tags
* awful.widget.taglist.filter.noempty - show only non-empty tags
* awful.widget.taglist.filter.selected - show only selected tags

To change the default behaviour and only show tags with more than one client make the following change in your rc.lua:

From this:
&lt;pre&gt;
mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.filter.all, mytaglist.buttons)
&lt;/pre&gt;
to this:
&lt;pre&gt;
mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.filter.noempty, mytaglist.buttons)
&lt;/pre&gt;

= Eminent =
Eminent is a small lua library that monkey-patches awful to provide you with 
effortless and quick wmii-style dynamic tagging. Unlike [[shifty]], eminent does 
not aim to provide a comprehensive tagging system, but tries to make dynamic 
tagging as simple as possible. In fact, besides importing the eminent library, 
you do not have to change your rc.lua '''at all''', eminent does all the work for 
you.


== Getting Eminent ==
=== Arch Linux ===
If you are using Arch Linux, a PKGBUILD is already available over at the aur, 
get it here: [https://aur.archlinux.org/packages/eminent-git/ https://aur.archlinux.org/packages/eminent-git/].

=== Gentoo Linux ===
A gentoo package is available here
[http://overlays.gentoo.org/dev/matsuu/browser/awesome/x11-plugins/eminent/eminent-9999.ebuild eminent-9999.ebuild].

=== Manually ===
'''For awesome 3.4'''

If you are not using Arch or would like to fetch the library separately, you 
can fetch it from the git repository at 
[http://git.glacicle.org/eminent http://git.glacicle.org/eminent].

Install it manually as such:

&lt;pre&gt;
git clone git://git.glacicle.org/awesome/eminent.git
cp eminent/eminent.lua ~/.config/awesome/
&lt;/pre&gt;

'''For awesome 3.5'''

You could try:
&lt;pre&gt;
git clone https://github.com/guotsuan/eminent.git
cp eminent/eminent.lua ~/.config/awesome/
&lt;/pre&gt;

== Setting Up Eminent ==
Setting up eminent is as simple as adding &lt;code&gt;require(&quot;eminent&quot;)&lt;/code&gt; to 
the top of your rc.lua, after including awful.

You don't need to change '''anything''' else in your rc.lua. If something does go 
wrong (awesome is so versatile one can't possible test every setup), don't 
hesitate to send an email to [mailto:lucas@glacicle.org lucas@glacicle.org] 
with your bug report.

== Using Eminent ==
Use your awesome installation the same way you always did. You'll notice that 
any tags that have no clients on them are automatically hidden. Moving to the 
next tag after the last one will &quot;create&quot; (either re-use an existing but empty 
tag or actually create a new one dynamically) a new tag for you to use.

If you have any bindings set up on your number keys you should be able to use 
those to jump to a specific tag irregardless of what eminent thinks.

Happy tagging !

[[Category:Awesome3]]</text>
      <sha1>d8hfl85jfrad5qebc1hnq9d7xjn69hk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Eminent/ru</title>
    <ns>0</ns>
    <id>1102</id>
    <revision>
      <id>7156</id>
      <parentid>6715</parentid>
      <timestamp>2014-12-15T06:49:39Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>added last changes</comment>
      <text xml:space="preserve" bytes="3372">{{Languages|Eminent}}

Eminent это маленькая Lua библиотека которая позволяет awful легко и быстро имитировать динамические теги в стиле wmii. В отличие от [[Shifty/ru|Shifty]], Eminent не стремится обеспечить весь комплекс системы тегов, а лишь пытается сделать динамический теггинг максимально простым. По сути, кроме импорта библиотеки Eminent в вашем rc.lua, больше ничего делать не нужно, все остальное Eminent сделает за вас.

== Получение Eminent ==
=== Arch Linux ===
Если вы используете Arch Linux, PKGBUILD уже доступен через AUR, 
Вы можете получить его здесь: [[https://aur.archlinux.org/packages/eminent-git/ https://aur.archlinux.org/packages/eminent-git/].

=== Ручная установка ===
'''Для awesome 3.5'''

Вы можете скачать библиотеку из Git:
&lt;pre&gt;
git clone https://github.com/guotsuan/eminent.git
cp eminent/eminent.lua ~/.config/awesome/
&lt;/pre&gt;

== Установка Eminent ==
Для установки Eminent достаточно добавить  &lt;code&gt;require(&quot;eminent&quot;)&lt;/code&gt; в начале вашего rc.lua, после подключения awful.

Вам не нужно '''ничего''' больше изменять в rc.lua. Если что то не будет работать (awesome постоянно изменяется и невозможно проверить каждую его версию на совместимость), не стесняйтесь писать об этом на [mailto:lucas@glacicle.org lucas@glacicle.org] с описание проблемы.

== Использование Eminent ==
Работайте с вашим Awesome также, как делали это ранее. Вы заметите, что все теги не имеющие клиентов/приложений будут скрываться автоматически. Перемещение на следующий тег за последним &quot;создаст&quot; (пересоздаст ранее существующий или динамически создаст полностью новый) новый тег для вашего испльзования.

Если у вас есть цифровые клавиатурные привязки к вашим тегами, вы можете их использовать как обычно, вне зависимости от отображения/скрытия их Eminent

Happy tagging!

''От переводчика:'' часть текста пришлось удалить, так как в нем приведены мертвые ссылки, на мой запрос автор пока не ответил. Если вас интересует, что было в удаленной части, обратитесь пожалуйста к оригиналу [[Eminent]]. Если у вас есть актуальные данные для этих ссылок, поместите их сюда, а этот текст удалите.

[[Category:Awesome3]]</text>
      <sha1>jcnj26qfgo5m053zoeo2d37fzzquqxk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Example of applications rules</title>
    <ns>0</ns>
    <id>1134</id>
    <revision>
      <id>6988</id>
      <parentid>6896</parentid>
      <timestamp>2014-08-25T08:07:34Z</timestamp>
      <contributor>
        <username>Wernight</username>
        <id>3322</id>
      </contributor>
      <comment>/* Google Keep */ Fix instance ID</comment>
      <text xml:space="preserve" bytes="1779">Various rules for common applications mostly to mark floating windows as such when necessary.

You may want to grab some or all of those inside your '''rc.lua''' within the '''awful.rules.rules = {...}''' section.

== Google Chrome / Chromium ==

=== Hangouts (Chrome Extension) ===

 { rule = { instance = &quot;crx_nckgahadagoaajjgafhacjanaoiihapd&quot; },
   properties = { floating = true },
   callback = function(c)
       -- Show to titlebar else you may not know who you're talking with.
       awful.titlebar.add(c, { modkey = modkey })
   end },

Note: Normally after installing the [https://chrome.google.com/webstore/detail/hangouts/nckgahadagoaajjgafhacjanaoiihapd Hangouts extension] chat windows are docked at the bottom of the screen. This however seems not to yet work on Awesome.

=== Chrome App Launcher ===

 { rule = { instance = { &quot;chrome_app_list&quot;, &quot;chromium_app_list&quot; } }
   properties = { floating = true } },

=== Google Keep ===

If you start Google Keep from the Chrome Launcher you may want to have it floating:

 { rule = { instance = &quot;crx_hmjkmjkepdijhoojdojkdfohbdgmmhki&quot; },
   properties = { floating = true } },

=== Google Now/Notifications ===

N/A (xprop shows no WM_CLASS nor WM_NAME, nor WM_WINDOW_ROLE for that window and is of '''type = &quot;normal&quot;''' ).

== Terminator ==

 { rule = { name = &quot;Terminator Preferences&quot; },
   properties = { floating = true } },

== VirtualBox ==

 { rule = { class = &quot;VirtualBox&quot; },
   except = { name = &quot;Oracle VM VirtualBox Manager&quot; },
   properties = { floating = true } },

== Other ==

Other common application you probably want to have in floating mode:

 { rule_any = { class = { &quot;MPlayer&quot;, &quot;pinentry&quot;, &quot;gimp&quot;, &quot;Guake&quot;, &quot;feh&quot; } },
   properties = { floating = true } },

== See Also ==

* [[Understanding_Rules]]</text>
      <sha1>23r5qi1i66dlbk6d140uj57y7nicos4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ</title>
    <ns>0</ns>
    <id>7</id>
    <revision>
      <id>7467</id>
      <parentid>7389</parentid>
      <timestamp>2016-05-09T04:44:28Z</timestamp>
      <contributor>
        <username>Elv13</username>
        <id>375</id>
      </contributor>
      <comment>Replaced content with &quot;[http://awesomewm.github.io/apidoc/documentation/90-FAQ.md.html The FAQ has moved to the API documentation]&quot;</comment>
      <text xml:space="preserve" bytes="107">[http://awesomewm.github.io/apidoc/documentation/90-FAQ.md.html The FAQ has moved to the API documentation]</text>
      <sha1>djg4hi56505y07kf38hg6e1qrcyi7gn</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ/fr</title>
    <ns>0</ns>
    <id>124</id>
    <revision>
      <id>3926</id>
      <parentid>3333</parentid>
      <timestamp>2009-12-29T13:02:07Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>/* Quelles sont les dépendances de awesome ? */</comment>
      <text xml:space="preserve" bytes="10963">{{DISPLAYTITLE:Foire aux questions}}
{{Languages|FAQ}}

== Questions générales ==

=== Pourquoi awesome ? ===
Le nom « awesome » provient du mot anglais ''awesome'', « grandiose » en français, souvent utilisé par le personnage [http://en.wikipedia.org/wiki/Barney_Stinson Barney Stinson] de la série ''How I met your mother'' (''Comment je l’ai rencontrée'' en Belgique).

=== Quelles sont les dépendances de awesome ? ===
Afin de compiler awesome lui-même, vous aurez besoin des fichiers d’en-tête et des bibliothèques de :

* Xlib, Xinerama, Xrandr
* [http://www.nongnu.org/confuse/ libconfuse] ≥ 2.6
* cairo
* pango et pangocairo
* Imlib2
ou
* GTK+ (utilisez --with-gtk avec ./configure)

Afin de construire les pages de manuel d’awesome, vous aurez également besoin des outils suivants :

* asciidoc (version récente)
* xmlto (version récente)
* feuilles de style docbook

Enfin, la documentation développeur est générée en s’appuyant sur les outils suivants :

* doxygen
* graphviz

== Développement ==

=== J’ai trouvé un bogue, que puis-je faire ? ===
Tout d'abord, tester la version en développement pour vérifier si le bogue est toujours présent. Si le bogue est un comportement inattendu, expliquez quel comportement vous attendiez. Si le bogue est une erreur de segmentation, fournissez la pile d’appel complète du programme avec ''gdb''.

Tout ceci peut être posté ici : http://awesome.naquadah.org/bugs/

Dans tous les cas, essayez de préciser comment reproduire le problème.

=== Acceptez-vous les patches et améliorations ? ===
Oui. Envoyez-les sur la liste de diffusion pour revue. Consultez également [http://awesome.naquadah.org/devel/ la page de développement].

=== Comment suivre le développement des branches de awesome ? ===
Pour cloner la version de développement principal (git) :

  git-clone git://git.naquadah.org/awesome.git/
  cd awesome/

Pour obtenir une branche comme « awesome-3 » :

  git-fetch origin awesome-3:awesome-3
  git-checkout awesome-3

git-branch indique sur quelle branche on se trouve.

Sur certaines distributions, il est possible d’utiliser la touche de tabulation pour compléter les commandes de git ou le nom des branches.

Pour rester à jour avec la branche « awesome-3 », lancez ces commandes depuis le répertoire awesome :

  git-fetch origin
  git-reset --hard origin/awesome-3

Remarque : la branche « awesome-3 » contient la transition vers XCB et nécessite ''xcb-util''. Pour faciliter la vie des compagnons Archers, un PKGBUILD temporaire pour ''xcb-util'' a été créé [http://github.com/gigamo/config/tree/master/pkgbuilds/xcb-util/PKGBUILD ici].

Pour créer un patch :

  git-clone git://git.naquadah.org/awesome.git/
  ''edit file''
  git-commit ''filename''
  git-format-patch origin

Ceci génère un fichier nommé de la façon suivante :

  0001-le_nom_du_patch.patch


== Configuration ==
=== J’avais l'habitude d’utiliser un tube pour imprimer sur ''stdin'' avec awesome 1.x, cela ne fonctionne plus avec awesome 2.0. Pourquoi ? ===

Parce que nous avons implémenté un meilleur système. Vous pouvez maintenant employer ''awesome-client'' qui attend les données suivantes sur ''stdin'' :
 #screen uicb arg 

Ainsi, pour modifier le texte de la barre de statut sur l'écran 0, procédez de la façon suivante :

    echo &quot;0 setstatustext \&quot;Hello, awesome world\!\&quot;&quot; | awesome-client

Si vous voulez visualiser une autre étiquette sur l’écran 1 :

    echo &quot;1 tag_view 3&quot; | awesome-client

Remarque : ceci ne correspond qu’à la version 2.0. Pour la syntaxe réelle, consultez [http://www.calmar.ws/awesome/awesome-client.1.html '''awesome-client(1)'''].

=== Existe-t-il un lanceur ou un menu dans awesome ? ===

awesome 2.3 apporte une fonction de menu. Pour l’utiliser, créez un fichier contenant une entrée par ligne, comme par exemple '''~/.awesome/menu''' ci-dessous :

  xterm
  firefox
  pidgin

Puis ajoutez les lignes suivantes à votre fichier '''.awesomerc''' :

  key { 
    modkey = {&quot;Mod4&quot;} 
    key = &quot;p&quot; 
    command = &quot;spawn&quot; 
    arg = &quot;exec `cat ~/.awesome/menu | awesome-menu`&quot; 
  }

Consultez [[awesome-menu]] pour davantage de détails à ce sujet.

Il est également possible d’utiliser des outils tiers comme :
* [http://www.suckless.org/wiki/tools/xlib dmenu] : un lanceur de programmes. Par exemple :
  key { modkey = {&quot;Mod4&quot;} key = &quot;p&quot; command = &quot;spawn&quot; arg = &quot;exec `dmenu_path | dmenu -b`&quot; }
* [http://gotmor.googlepages.com/dzen dzen] : ''x-menu'', barre de statut, etc.
* [ftp://freefriends.org/arnold/Source/ 9menu] : ''x-menu'' simple. Par exemple :
  9menu -file ~/.9menurc
* [http://apwal.free.fr/ apwal] : icônes simples pour la fenêtre racine
* [http://sourceforge.net/projects/gmrun Gmrun] : Run-menu (GTK+)

=== Comment est-ce que j’obtiens l’expression rationnelle à employer pour le nom d’une règle ? ===
Utilisez la commande ''xprop''. Par exemple, pour Pidgin :

  me@myhost:~$ xprop | grep WM_NAME
  WM_NAME(STRING) = &quot;Buddy List&quot;
  _NET_WM_NAME(UTF8_STRING) = 0x42, 0x75, 0x64, 0x64, 0x79, 0x20, 0x4c, 0x69, 0x73, 0x74

Le nom d’une règle s’appuie sur le contenu du champ WM_NAME :

  rules
  {
      rule {
          name = &quot;Liste de contacts&quot;
          tags = &quot;one&quot;
          float = true
      }
  }


=== Il n’y a pas de zone de notification ! Comment puis-je recevoir les notifications de Pidgin ? ===
awesome comprend le drapeau « URGENT » utilisé par Pidgin, et peut modifier le fond de l’onglet dans la barre de statut de manière appropriée. Pour cela, lancez Pidgin, ouvrez Outils -&gt; Plugins, et assurez-vous que « Notification de message » est activé. Sélectionnez « Notification de message » et cliquez sur le bouton « Configurer le plugin » en bas de la fenêtre. Assurez-vous que l’option « Envoyer le message “URGENT” au gestionnaire de fenêtres » est cochée.

Ensuite, vérifiez que les lignes suivantes se trouvent bien dans la section « colors » de votre fichier '''~/.awesomerc''' (Pour awesome-2.2)

  colors {
    urgent_fg = &quot;#ffffff&quot;
    urgent_bg = &quot;#D53737&quot;
  }

Pour awesome-2.3 :

  styles {
     urgent
        {
            fg = &quot;#FFFFFF&quot;
            bg = &quot;#D53737&quot;
        }
  }

Lancez awesome -k pour vérifier que la configuration est valide, puis redémarrez awesome. Maintenant, lorsque Pidgin reçoit un message, l’affichage de l’onglet dans la barre de statut doit devenir rouge.

=== Les applications graphiques Java apparaissent comme un écran gris ! ===
Extrait du manuel d’awesome :

Les applications Java qui utilisent le moteur de traitement de la boîte à outils XAWT (Xtoolkit en anglais) ne peuvent dessiner que des fenêtres grises. Le moteur de traitement de la boîte à outils XAWT n’est pas compatible avec ICCCM dans la version JDK 1.5 et dans les premières version JDK 1.6, parce qu’il suppose un gestionnaire de fenêtres se définissant comme père de toutes les fenêtres qu’il gère. À titre de palliatif, vous pouvez utiliser JDK 1.4 (qui ne contient pas le moteur de traitement de la boîte à outils XAWT), ou bien vous pouvez positionner la variable d’environnement suivante (afin d’utiliser l’ancien moteur de traitement Motif à la place) : AWT_TOOLKIT=MToolkit 

=== Interstices ! Il y a des interstices ! Comment se débarrasser de ces espaces en haut ou en bas de l’écran ? ===
Ajoutez les lignes suivantes dans votre fichier .awesomerc, dans la section associée aux écrans pour lesquels vous ne voulez pas voir apparaître d’interstices :

  general
  {
      resize_hints = false
  }

Le fichier '''.awesomerc''' peut ne pas contenir cette section. Si elle n’est pas déjà présente, ajoutez-la.

=== Les barres de titre sont excellentes, mais comment les invalider pour une application donnée ? ===
Dans la section rules du fichier '''awesomerc''', ajoutez :

  titlebar { 
    position = off 
  }

=== Règle pour plusieurs onglets ===
 rule
 {
     name = &quot;Nom application&quot;
     float = true
     tags = &quot;tag1|tag2|…&quot;
 }

Il vous suffit de séparer les onglets par un « | ».

=== Je veux des widgets ===
Il vous suffit de regarder le dépôt « [[Obvious]] ».

== L’environnement français ==

=== Mes touches 0–9 ne sont pas reconnues lorsque j'essaie Super+[0;9] sur mon clavier azerty ! ===
Il faut modifier la configuration des touches proposée par défaut. Afin de le faire de manière consistante sur tout le fichier de configuration, et de ne pas avoir à le refaire à chaque installation d’awesome ou écrasement du fichier de configuration, il est possible d’utiliser l'outil suivant qui transformera n’importe quel fichier de configuration :

  #!/bin/sed -f
  s/key = &quot;0&quot;/key = &quot;agrave&quot;/g
  s/key = &quot;1&quot;/key = &quot;ampersand&quot;/g
  s/key = &quot;2&quot;/key = &quot;eacute&quot;/g
  s/key = &quot;3&quot;/key = &quot;quotedbl&quot;/g
  s/key = &quot;4&quot;/key = &quot;apostrophe&quot;/g
  s/key = &quot;5&quot;/key = &quot;parenleft&quot;/g
  s/key = &quot;6&quot;/key = &quot;minus&quot;/g
  s/key = &quot;7&quot;/key = &quot;egrave&quot;/g
  s/key = &quot;8&quot;/key = &quot;underscore&quot;/g
  s/key = &quot;9&quot;/key = &quot;ccedilla&quot;/g

Enregistrez ces lignes dans un fichier '''awesome-fr.sed''' et rendez-le exécutable : &lt;code&gt;chmod +x awesome-fr.sed&lt;/code&gt;. Pour appliquer les changements dans le fichier de configuration :

 ./awesome-fr.sed &lt; .awesomerc &gt; .awesomerc-fr
 mv .awesomerc-fr .awesomerc

Bien sûr, la solution proposée ci-dessus ne fonctionne que si les touches sont explicitement nommées dans le fichier. Pour awesome 3 et son fichier de configuration Lua, il est cependant tout à fait possible que l’affectation des touches soit faite dans une boucle, les touches de 0 à 9 se prêtant bien à l’exercice. Par exemple :

  for i = 1, keynumber do
     keybinding({ modkey }, i, function ()
        local screen = mouse.screen
        if tags[screen][i] then
           awful.tag.viewonly(tags[screen][i])
        end
     end):add()
     # ...
  end

Dans un tel cas, il est très facile de procéder à la transformation pour le clavier français en définissant un tableau vers le début du fichier de configuration :

  local french_numkeys = {
     [0]=&quot;agrave&quot;, &quot;ampersand&quot;, &quot;eacute&quot;, &quot;quotedbl&quot;, &quot;apostrophe&quot;,
     &quot;parenleft&quot;, &quot;minus&quot;, &quot;egrave&quot;, &quot;underscore&quot;, &quot;ccedilla&quot;
  }

La boucle devient alors :

  for i = 1, keynumber do
     keybinding({ modkey }, french_numkeys[i], function ()
        local screen = mouse.screen
        if tags[screen][i] then
           awful.tag.viewonly(tags[screen][i])
        end
     end):add()
     # ...
  end

Pour la variante belge de l’azerty, vous devez employer &quot;section&quot; à la place de &quot;6&quot; et &quot;exclam&quot; pour &quot;8&quot;.

Dans tous les cas, n’oubliez d’appliquer les changements en redémarrant awesome : &lt;code&gt;Mod4+Ctrl+r&lt;/code&gt;.

== Voir aussi ==
Quelques astuces sont disponibles à cette adresse : [http://olivier.dossmann.net/wiki/doku.php?id=configurations:awesome:index Configuration et utilisation de awesome].

[[Category:awesome3]]</text>
      <sha1>gp8n6k0h1eklvxsah6qan77a0q9i98q</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ/it</title>
    <ns>0</ns>
    <id>118</id>
    <revision>
      <id>6218</id>
      <parentid>6217</parentid>
      <timestamp>2014-01-14T09:48:06Z</timestamp>
      <contributor>
        <username>Eri trabiccolo</username>
        <id>3152</id>
      </contributor>
      <minor/>
      <comment>fixed</comment>
      <text xml:space="preserve" bytes="12451">{{Template:Languages|FAQ}}
{{Outdated}}

== Awesome ==
=== Perchè awesome? ===
Il nome ''awesome'' deriva dalla parola inglese ''awesome'' (fantastico) spesso usata da [http://en.wikipedia.org/wiki/Barney_Stinson Barney Stinson], co-protagonista della serie &quot;E alla fine arriva mamma&quot;.

== Installazione ==
=== Quali sono le dipendenze di awesome? ===
Vedi nel [http://git.naquadah.org/?p=awesome.git;a=blob;f=README README].

==Configurazione==
=== Come cambiare il layout di gestione delle finestre di default?===
Nel file di configurazione di default è impostato un layout per tutti i tag, che di solito è il layout ''floating''. Puoi cambiarlo modificando il ciclo per la creazione dei tag nel tuo ''rc.lua'':

    -- Each screen has its own tag table.
    tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s, layouts[1])

Nota che tutti i tag useranno il primo (''[1]'') layout della tua tabella dei layouts, che è definita subito prima che i tag siano creati. Per usare un altro layout di gestione delle finestre basta cambiare il numero del layout (indice della tabella layouts).

====Come cambiare il nome e il layout per ogni tag?====
Puoi modificare la tua sezione 'Tags', esistono diverse possibili implementazioni, eccone una semplice:

  -- {{{ Tags
  tags = {
    names  = { &quot;www&quot;, &quot;editor&quot;, &quot;mail&quot;, &quot;im&quot;, &quot;rss&quot;, 6, 7, &quot;rss&quot;, &quot;media&quot;},
    layout = { layouts[2], layouts[1], layouts[1], layouts[4], layouts[1],
               layouts[6], layouts[6], layouts[5], layouts[6]
  }}
  
  for s = 1, screen.count() do
      tags[s] = awful.tag(tags.names, s, tags.layout)
  end
  -- }}}

====Come impostare tags e layouts diversi per ogni schermo?====
Un altro esempio pratico per la tua sezione 'Tags':

  -- {{{ Tags
  tags = {
    settings = {
      { names  = { &quot;www&quot;, &quot;editor&quot;, &quot;mail&quot;, &quot;im&quot; },
        layout = { layouts[2], layouts[1], layouts[1], layouts[4] }
      },
      { names  = { &quot;rss&quot;,  6, 7,  &quot;media&quot; },
        layout = { layouts[3], layouts[2], layouts[2], layouts[5] }
  }}}
  
  for s = 1, screen.count() do
      tags[s] = awful.tag(tags.settings[s].names, s, tags.settings[s].layout)
  end
  -- }}}

=== Come eseguire automaticamente le applicazioni all'avvio? ===
Il metodo tradizionale consiste nell'usare il file ''~/.xinitrc'', puoi trovare informazioni riguardo questa e altre soluzioni nella pagina [[Autostart]].

=== Come usare monitor multipli? ===
Awesome ha un reale supporto al multihead (in modalità ''XRandR'', ''Xinerama'' o ''Zaphod'') con desktop(tag) diversi per ogni schermo, ed è distribuito con un semplice file di configurazione che è già configurato per dispaly multipli (per quanto riguarda le wibox, le taskbar e i widget ma ha anche delle scorciatoie da tastiera (''keybindings'') che ti permettono di spostare i client tra i diversi schermi e scambiare il focus tra essi). Leggi la guida completa &quot;[[Using Multiple Screens]]&quot; per ulteriori istruzioni.

=== Come impostare il blocco dello schermo? ===
Puoi usare uno strumento esterno come ''xlock'' o ''xscreensaver'', ''slock'', ''kscreenlocker''...

Esempio di key binding per '''globalkeys''':
  awful.key({ modkey }, &quot;F12&quot;, function () awful.util.spawn(&quot;xlock&quot;) end)

=== Come eseguire un comando in una shell? ===
Se vuoi eseguire un comando in una shell o hai necessità di eseguire un comando che usa redirezioni, pipe e via dicendo, non usare la funzione ''awful.util.spawn'' ma '''awful.util.spawn_with_shell'''. Ecco un semplice esempio:

  awful.key({ modkey }, &quot;F10&quot;, function () awful.util.spawn_with_shell(&quot;cal -m | xmessage -timeout 10 -file -&quot;) end)

=== Come sistemare e migliorare l'usabilità delle applicazioni Java? ===
Le applicazioni Java che usano il back-end XToolkit/XAWT potrebbero visualizzare solo una schermata grigia. Il back-end XToolkit/XAWT infrange la regola di conformità ICCM, nelle ultime versioni della JDK 1.5 e nelle prime della JDK 1.6, perché presuppone un [http://en.wikipedia.org/wiki/Re-parenting_window_manager reparenting window manager]. Puoi trovare soluzioni nella pagina del wiki [[Problems with Java]].

=== Come rimuovere lo spazio tra le finestre? ===
In awesome 3.4 e 3.5 puoi aggiungere '''size_hints_honor = false''' alla sezione ''properties'' della tua tabella delle regole ''awful.rules.rules'', per applicare questa regola a tutti i clients. Come alternativa (o per le versioni precedenti) puoi farlo aggiungendo '''c.size_hints_honor = false''' nella funzione del segnale ''manage'' (nel manage hook, per le versioni precedenti).

Se vuoi sapere cosa sono i ''size hints'', ciò è stato dibattuto molte volte sulla mailing list, qui puoi leggere la spiegazione: http://www.mail-archive.com/awesome@naquadah.org/msg01767.html

=== Le titlebar sono belle, ma come posso disabilitarle per una determinata applicazione? ===

Nella sezione rules in awesomerc, aggiungete:

  titlebar { 
    position = off 
  }

=== Come posso nascondere / visualizzare la statusbars in awesome 3.0? ===

Codice Lua:
  mystatusbar.position = &quot;off&quot;
o
  mystatusbar.screen = nil


Per usare Modkey-b per nascondere/visualizzare la statusbar attiva sullo schermo (come da di default awesome 2.3), aggiungete al vostro awesome/rc.lua:

  keybinding({ modkey }, &quot;b&quot;, function () 
       if mystatusbar[mouse.screen].screen == nil then 
          mystatusbar[mouse.screen].screen = mouse.screen
      else
          mystatusbar[mouse.screen].screen = nil
      end
  end):add()

=== C'è un un program-launcher o un menu in awesome? ===

In awesome 2.3 si può inserire un menu facilmente. E' molto semplice da usare, create un file da qualche parte con delle linee formattate come in questo esempio:

~/.awesome/menu contiene:
  xterm
  firefox
  pidgin

Quindi aggiungete questo codice in.awesomerc:
  key { 
    modkey = {&quot;Mod4&quot;} 
    key = &quot;p&quot; 
    command = &quot;spawn&quot; 
    arg = &quot;exec `cat ~/.awesome/menu | awesome-menu`&quot; 
  }

Vedete [[awesome-menu]] per ulteriori dettagli su questo.

Oppure, potete usare software alternativi come:
 
* [http://www.suckless.org/wiki/tools/xlib dmenu] - un program launcher
    e.g. key { modkey = {&quot;Mod4&quot;} key = &quot;p&quot; command = &quot;spawn&quot; arg = &quot;exec `dmenu_path | dmenu -b`&quot; }

* [http://gotmor.googlepages.com/dzen dzen] - x-menu / statusbar e altro...

* [ftp://freefriends.org/arnold/Source/ 9menu] - un semplice x-menu
    e.g.: 9menu -file ~/.9menurc

* [http://apwal.free.fr/ apwal] - per le icone nella finestra principale

* [http://sourceforge.net/projects/gmrun Gmrun] - Run-menu (GTK+)

=== Non c'è la tray! Come posso ricevere le notifiche di pidgin? ===

Awesome capisce il tag 'URGENT' inviato da Pidgin, ed è possibile gestirlo sulla tag nel modo appropriato. Per fare questo, avviate Pidgin, andate in Strumenti -&gt; Plugins, e siate sicuri che 'Notica messaggi' sia abilitato. Selezionate 'Notifica Messaggi', e cliccate sul pulsante 'Configura' in basso allo schermo. Siate sicuri che la voce 'Imposta lo stato 'URGENT' nel Window Manager' sia selezionato.

Il prossimo passo, è essere sicuri che questi valori sono nella sezione 'colors' in ~/.awesomerc (Per awesome-2.2)

  colors {
    urgent_fg = &quot;#ffffff&quot;
    urgent_bg = &quot;#D53737&quot;
  }

In awesome-2.3:

  styles {
     urgent
        {
            fg = &quot;#FFFFFF&quot;
            bg = &quot;#D53737&quot;
        }
  }

Avviate awesome -k per verificare che la configurazione è valida, e riavviate.

In awesome-3 edit ~/.config/awesome/themes/&lt;theme&gt;

   bg_urgent     = #ff0000
   fg_urgent     = #ffffff

Ora, quando riceverete un messaggio in Pidgin, il display della tag nella barra si colorerà di rosso.

=== Posso modificare la configurazione di awesome mentre è avviato? ===
Si, potete. Dovrete riavviare Awesome o i cambiamenti effettuati sul file di configurazione non avranno effetto. La scorciatoria da tastiera di default per riavviare Awesome 3.0 è Mod4 + Ctrl + r

=== Posso cambiare il tema del cursone in awesome? ===

Potete impostare il tema preferito con il comando xsetroot

  xsetroot -cursor_name TEMA

Questo potete anche aggiungerlo in ~/.xinitrc

==Uso==
=== Come posso avviare un'altra sessione di X ===

In KDE posso avviare una seconda sessione di X e passare da una sessione all'altra con F7 e F8. Come posso farlo usando awesome?

Potete passare in un nuovo terminale virtuale (VT) usando Ctrl+Alt+F8 per esempio, quindi entrate normalmente, e avviate X per un nuovo schermo virtuale, con il comando startx 

=== UNANSWERED: Starting programs should be more comfortable ===

I can start programs by pressing mod + F1, but I do not see, if they are loading, or if I mistyped the program name.

It would also be great, if there would be some way to see the output of the program, whether there are errors, or to be able to start a program with sudo and enter the root password.

=== Come posso sospendere / riavviare / riprendere il mio computer? ===

Inviato da Gregor Best nella fomailing list:

&quot;For logging out, simply kill your XServer by pressing Ctrl+Alt+Backspace. There's a keybinding for cleanly exiting, but I removed that a long time ago, so I don't remember it.&quot;

Potete normalmente usare la linea di comando, ''shutdown -h now'' per spegnere, ''shutdown -r now'' per riavviare, etc...

=== UNANSWERED: Where is the clipboard? How do I copy and paste? ===
One possibility provided by X is to mark text with the mouse and to paste it somewhere else with the middle mouse button or with &lt;SHIFT&gt;-&lt;INSERT&gt;.

??Another would be to install any kind of clipboard???

=== Ho avviato awesome, ma non ho idea di cosa fare. Come posso usarlo? ===

''man awesome'' è un'ottima guida, include le scorciatoie da tastiera di default.

=== In awesome 1.x usavo la pipe per mandare qualcosa a stdin (come in dwm), ma questo non funziona in awesome 2.0, perchè? ===

Perchè noi abbiamo implementato un sistema migliore. Se vuole può usare awesome-client che legge da stdin: #screen uicb arg

Potete anche cambiare il testo della statusbar sullo schermo 0, semplicemente con:

    echo &quot;0 setstatustext \&quot;Hello, awesome world\!\&quot;&quot; | awesome-client

Mentre se volete vedere un tag sullo schermo 1:

    echo &quot;1 tag_view 3&quot; | awesome-client

Note: Questo funziona solo per la versione 2.0. Per la sintassi corrente guardate [http://www.calmar.ws/awesome/awesome-client.1.html awesome-client(1)].

== Sviluppo ==
=== Ho trovato un bug, cosa posso fare? ===

Per prima cosa, prova la versione in sviluppo per vedere se il bug esiste ancora. Se il bug ha un comportamento inaspettatto, spiegateci perfavore quando si verifica. Se il bug è un &quot;segmentation fault&quot;, includete anche tutto il backtrace (usate gdb).

E possibilmente copiatelo qui: http://awesome.naquadah.org/bugs/

In ogni caso, provate a spiegarci come riprodurlo.

=== Accettate patch e abbellimenti? ===

Certo. Potete inviarmele direttamente a me oppure in mailing list. Date anche un'occhiata alla [http://awesome.naquadah.org/devel/ pagina dei sviluppatori].

=== Come tenere traccia dei branch di awesome ===
Per clonare la versione (git) in sviluppo:

  git-clone git://git.naquadah.org/awesome.git/
  cd awesome/

Per prendere il branch come 'awesome-3':

  git-fetch origin awesome-3:awesome-3
  git-checkout awesome-3

con git-branch potete sapere quali branch state usando.
In alcune distribuzioni potete usare &lt;tab&gt; per il completamento del nome di un branch (e altro) quando usate git.

Per essere sempre aggiornati al branch 'awesome-3'm eseguite questi comandi dalla directory di awesome:

  git-fetch origin
  git-reset --hard origin/awesome-3

Note: il branch 'awesome-3' è già passato a XCB, e necessita di xcb-util.
Per rendere la vita facile agli Arcieri, ho creato temporaneamente un PKGBUILD per xcb-util [http://github.com/gigamo/config/tree/master/pkgbuilds/xcb-util/PKGBUILD qui]


Per creare una patch:

  git-clone git://git.naquadah.org/awesome.git/
  ''edit file''
  git-commit ''filename''
  git-format-patch origin

Questo produce un file con un nome simile:
  0001-the-title-you-gave-it.patch

=== Come posso prendere il nome radice per creare una regola? ===

Potete usare il comando xprop -  Eseguite questi comandi (questo è per Pidgin):

  me@myhost:~$ xprop | grep WM_NAME
  WM_NAME(STRING) = &quot;Lista Contatti&quot;
  _NET_WM_NAME(UTF8_STRING) = 0x42, 0x75, 0x64, 0x64, 0x79, 0x20, 0x4c, 0x69, 0x73, 0x74

WM_NAME è il nome della regola che stiamo creando.

  rules
  {
      rule {
          name = &quot;Lista Contatti&quot;
          tags = &quot;one&quot;
          float = true
      }
  }</text>
      <sha1>n2a1lx3tw7nk3hijkps806g4z8ecx8o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ/ru</title>
    <ns>0</ns>
    <id>230</id>
    <revision>
      <id>6784</id>
      <parentid>6783</parentid>
      <timestamp>2014-06-12T16:24:45Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>/* Есть ли какая-то программа для запуска приложений или меню в awesome? */</comment>
      <text xml:space="preserve" bytes="41404">{{Template:Languages|FAQ}}

==О awesome==
=== Почему &quot;awesome&quot;? ===

Название ''awesome'' пришло от английского слова ''awesome'' которое часто использовали персонажи [http://en.wikipedia.org/wiki/Barney_Stinson Barney Stinson] из HIMYM и [http://ru.wikipedia.org/wiki/Eric_Cartman Eric Cartman] из [http://ru.wikipedia.org/wiki/South_Park South Park]

==Установка==
=== Какие приложения необходимы для установки awesome? ===

Смотрите файл README.

==Настройка==
=== Как изменить стандартную схему расположения окон в теге? ===

В стандартном конфигурационном файле для всех тегов, для которых не задана схема используется стандартная - ''плавающая'' схема. Вы можете изменить это изменив строки создания тегов в ''rc.lua'':

    -- Each screen has its own tag table.
    tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s, layouts[1])

Учитывайте что все теги будут использовать первый первую схему из таблицы схем, которая описывается перед созданием тегов. Просто измените номер схемы в строчке выше, чтобы использовать другую схему расположения окон в качестве стандартной.

==== Как изменить имя и схему для отдельного тега? ====

Вы можете изменить ваше определение тегов в rc.lua, есть много различных возможностей, вот простой пример:

  -- {{{ Теги
  tags = {
    names  = { &quot;www&quot;, &quot;editor&quot;, &quot;mail&quot;, &quot;im&quot;, &quot;rss&quot;, 6, 7, &quot;rss&quot;, &quot;media&quot;},
    layout = { layouts[2], layouts[1], layouts[1], layouts[4], layouts[1],
               layouts[6], layouts[6], layouts[5], layouts[6]
  }}
  
  for s = 1, screen.count() do
      tags[s] = awful.tag(tags.names, s, tags.layout)
  end
  -- }}}

==== Как установить разные теги и схемы расположения для экрана? ====

Измененное представление раздела объявления тегов:

  -- {{{ Теги
  tags = {
    settings = {
      { names  = { &quot;www&quot;, &quot;editor&quot;, &quot;mail&quot;, &quot;im&quot; },
        layout = { layouts[2], layouts[1], layouts[1], layouts[4] }
      },
      { names  = { &quot;rss&quot;,  6, 7,  &quot;media&quot; },
        layout = { layouts[3], layouts[2], layouts[2], layouts[5] }
  }}}
  
  for s = 1, screen.count() do
      tags[s] = awful.tag(tags.settings[s].names, s, tags.settings[s].layout)
  end
  -- }}}

=== Как настроить авто-запуск приложений? ===

Традиционный путь это использование файла ''~/.xinitrc'', вы можете прочесть об этом и некоторых других решениях на странице [[Autostart]].

=== Как использовать несколько мониторов? ===

Awesome поддерживает полную поддержку нескольких мониторов (''XRandR'', ''Xinerama'' или ''Zaphod'' ) с тегами для каждого, это распределяется с помощью простого конфигурационного файла, который уже установлен для нескольких мониторов (относительно контейнеров для виджетов, панелей задач и виджетов, а также комбинации клавиш, которые позволяют вам двигать клиенты между несколькими мониторами и переключать фокус между ними). Читайте полную статью: &quot;[[Using Multiple Screens/ru|Использование нескольких мониторов]]&quot; для дальнейших инструкций.

=== Как выполнить shell-команду? ===

Если вы хотите выполнить shell-команду или вам необходимо выполнить команду, которая использует пере-направление, pipe и тому подобное, не используйте функцию ''awful.util.spawn'', используйте '''awful.util.spawn_with_shell'''. Вот пример:

  awful.key({ modkey }, &quot;F10&quot;, function () awful.util.spawn_with_shell(&quot;cal -m | xmessage -timeout 10 -file -&quot;) end)

=== Как заблокировать экран если я отхожу от компьютера? ===

Воспользуйтесь внешним приложением, таким как 'xlock' или 'xscreensaver'. Я использую xlock
приблизительно так:

 key({ modkey }, &quot;F12&quot;, function () awful.util.spawn('xlock') end)

для xscreensaver это будет выглядеть так:

 key({ modkey }, &quot;F12&quot;, function () awful.util.spawn('xscreensaver-command -lock') end)

=== Приложения с GUI Java выводятся серым экраном! ===

Из man-страницы awesome:

Java-приложения, которые используют XToolkit/XAWT-бэкенд могут выглядеть как серое окно. XToolkit/XAWT-бэкенд нарушает ICCCM-совместимость последней JDK 1.5 и ранних версий JDK 1.6, потому что принимает унаследованный(?) оконный менеджер. Как обходной путь вы можете использовать JDK 1.4 (который не содержит XToolkit/XAWT-бэкенд) или вы можете настроить эту переменную окружения (чтобы использовать старый Motif-бэкенд взамен): AWT_TOOLKIT=MToolkit

Обходной путь для использования Java приложений которые требуют JDK 1.5 или выше это использование вложенного X-сервера, например Xephyr. Для примера, чтобы использовать [http://wiki.openstreetmap.org/index.php/JOSM Java OpenStreetMap], вы можете использовать следующий сниппет:

    $ cat bin/josm 
    #!/bin/sh
    Xephyr :1 -screen 1280x1000 -once -br &amp; 
    export DISPLAY=:1
    josm $1 
    killall Xephyr

Конечно, этот пример предполагает что вы запускаете только одну сессию Java-приложения, он может выглядеть не очень красиво на разрешениях отличных от 1280x1024, и запускает целый X-сервер, что является тратой ресурсов... Но вы уловили идею.

Возможно наиболее элегантное решение это использование [http://www.suckless.org/programs/wmname.html wmname]. wmname это приложение, которое изменяет название оконного менеджера видимое приложениями. Это может быть причиной проблем с другими приложениями, хотя ни одна еще не была найдена - пожалуйста отредактируйте это и добавьте проблему, если найдете её. Если вы добавите &quot;wmname DG3D&quot; в ваш .xinitrc, или запустите его другим путем, Java-приложения должны работать правильно. Заметьте, что это может не работать если у вас есть AWT_TOOLKIT. Это решение работает потому что у Java есть обходное решение для не-наследованных оконных менеджеров, но обнаруживает их только основываясь на параметре имени, которое задает wmname.

Эта проблема видимо решена в JDK 1.7.

=== Разрывы! Много разрывов! Как избавиться от разрывов верхней/нижней части экрана? ===

==== Awesome 2 ====
В вашем .awesomerc, под разделом screens если вы не хотите чтобы они появлялись снова, добавьте нижеследующее. В вашем .awesomerc может и не быть такого раздела - тогда добавьте его.

  general
  {
      resize_hints = false
  }

==== Awesome 3 ====
Поведением клиентов в данном случае управляет флаг 'honorsizehints' (или 'size_hints_honor' в новых версиях Awesome), которому по умолчанию в ловушке hook_manage присваивается значение true для всех клиентов. Измените значение на false, чтобы убрать разрывы.

=== Как добавить переключатель приложений? ===
Вы можете использовать Меню Клиентов как переключатель приложений. Стандартно оно открывается, если вы кликните правой кнопкой мыши на вашей панели задач, но вы можете также определить комбинацию клавиш для этого. Вот пример определения открытия меню по комбинации клавиш &quot;Alt + Esc&quot;, которое добавляется к вашим '''globalkeys''':

  awful.key({ &quot;Mod1&quot; }, &quot;Escape&quot;, function ()
      -- If you want to always position the menu on the same place set coordinates
      awful.menu.menu_keys.down = { &quot;Down&quot;, &quot;Alt_L&quot; }
      local cmenu = awful.menu.clients({width=245}, { keygrabber=true, coords={x=525, y=330} })
  end),

=== Как настроить и использовать виджеты? ===

Вы можете узнать все о виджетах и их создании на странице [[Widgets in awesome/ru|Виджеты в Awesome]].

Есть пользователи, которые создали библиотеки виджетов, которые придерживаются некоторых принципов. Они пытаются упростить создание виджетов для других, и имеют выгоду от того, что их библиотеки используются в большом количестве системных мониторов, и поэтому вам не нужно писать свои собственные. Два популярных проекта [[Vicious/ru|Vicious]] и [[Obvious/ru|Obvious]].

=== Как установить горизонтальные виджеты в вертикальном контейнере? ===
Левое или правое расположение контейнера виджета это отлично, но вертикальный текст становится трудным для чтения. На сегодняшний момент в awesome v3.4, очень трудно добиться идеального результата, но в версии awesome для разработчиков ''схемы виджетов'' уже полностью переписаны с учетом этого. Этот код позволяет с легкостью установить набор вертикальных панелей, как это позволяется в некоторых окружениях рабочего стола.

=== Заголовки окон - это прекрасно, но как отключить их у определённых приложений? ===

==== Awesome 2 ====
Добавьте в раздел rules файла awesomerc:

  titlebar { 
    position = off 
  }

==== Awesome 3 ====
Найдите в файле rc.lua код:

    if use_titlebar then
        -- Add a titlebar
        awful.titlebar.add(c, { modkey = modkey })
    end

И добавьте условия, при которых будет (или не будет) добавляться заголовок. Например:
    
    if use_titlebar and c.class ~= &quot;URxvt&quot; then
        -- Add a titlebar
        awful.titlebar.add(c, { modkey = modkey })
    end

В этом случае у окон, имеющих класс URxvt, заголовков не будет.

=== Как скрыть / показать панели в Awesome 3? ===
==== Awesome 3.0 ====

Код Lua:
  mystatusbar.screen = nil

Чтобы использовать сочетание клавиш Modkey-b для скрытия / показа панели mystatusbar (как это было по умолчанию в Awesome 2.3), добавьте в rc.lua:

  keybinding({ modkey }, &quot;b&quot;, function () 
       if mystatusbar[mouse.screen].screen == nil then 
          mystatusbar[mouse.screen].screen = mouse.screen
      else
          mystatusbar[mouse.screen].screen = nil
      end
  end):add()

==== Awesome 3.3 ====

Добавьте сочетание клавиш в таблицу globalkeys:
    awful.key({ modkey }, &quot;b&quot;,
        function ()
            if mywibox[mouse.screen].screen == nil then
                mywibox[mouse.screen].screen = mouse.screen
            else
                mywibox[mouse.screen].screen = nil
            end
        end)

=== Как настраивать заголовки окон? ===

Чтобы отключить заголовки окон для всех клиентов, удалите строку содержащую '''awful.titlebar.add(c, { modkey = modkey })''' из вашего обработчика сигнала ''manage'' (или ловушки manage hook в более старших версиях). Если вы хотите заголовки только для некоторых клиентов, вам не нужно возвращать эту строку обратно, вы можете сделать это с помощью таблицы ''awful.rules.rules'', где описаны правила. Пример правила:

  { rule = { class = &quot;Gimp&quot; }, callback = awful.titlebar.add  },


=== Как определить комбинацию клавиш для управления видимостью заголовка? ===

Вы можете использовать ''clientkeys'', вот пример:

    awful.key({ modkey, &quot;Shift&quot; }, &quot;t&quot;, function (c)
        if   c.titlebar then awful.titlebar.remove(c)
        else awful.titlebar.add(c, { modkey = modkey }) end
    end),


=== Как определить комбинацию клавиш для управления видимостью контейнера для виджетов? ===

Добавьте следующие строки, определяющие клавиши в таблицу '''globalkeys''':

  awful.key({ modkey }, &quot;b&quot;, function ()
      mywibox[mouse.screen].visible = not mywibox[mouse.screen].visible
  end),

=== Как определить комбинацию клавиш для управления состоянием клиента? ===
В стандартном ''rc.lua'' уже присутствует комбинация клавиш для этого, это &quot;Mod4 + Control + Space&quot;. Вы можете легко сменить её на что-то более легкое, вроде &quot;Mod4 + f&quot; или &quot;Mod4 + Shift + f&quot;.

    awful.key({ modkey, &quot;Shift&quot; }, &quot;f&quot;,  awful.client.floating.toggle ),

==== Почему некоторые плавающие клиенты не могут использовать тайлинг? ====

Если какие-либо ваши приложения(такие как Firefox, Opera и тому подобные) находятся в плавающем режиме, но вы не можете применять к ним схему тайлинга, и они ведут себя странно( не тегируются, всегда показываются верхними ) - не паникуйте. Они всего-лишь максимизированны вашим предыдущим оконным менеджером, или это осталось с предыдущей сессии. Стандартная комбинация клавиш для переключения максимизироавнного статуса это &quot;Mod4 + m&quot;.

Вы можете убедиться что ни одно приложение не будет запускаться в максимизированном режиме, если в первое правило в вашей таблице ''awful.rules.rules'', которое применяется к всем клиентам, будет добавлено следующее:

  -- Найдите вот эту строчку:
  keys = clientkeys,
  
  -- Добавьте две последующие:
  maximized_vertical   = false,
  maximized_horizontal = false,

=== Как избежать выхода за пределы экрана для плавающих клиентов? ===

Включите вызов '''awful.placement''' к вашему обработчику сигналов в rc.lua:

    -- Floating clients don't overlap, cover
    -- the titlebar or get placed offscreen
    awful.placement.no_overlap(c)
    awful.placement.no_offscreen(c)


=== Как передвинуть или изменить размер плавающего окна с помощью клавиатуры? ===
Вы можете использовать функцию ''awful.client.moveresize''. Следующий пример '''clientkeys''' будет двигать плавающие окна с помощью &quot;Mod4 + Arrow keys&quot; и изменять их размеры с помощью клавиш &quot;Mod4 + PgUP/DN&quot;:

    awful.key({ modkey }, &quot;Next&quot;,  function () awful.client.moveresize( 20,  20, -40, -40) end),
    awful.key({ modkey }, &quot;Prior&quot;, function () awful.client.moveresize(-20, -20,  40,  40) end),
    awful.key({ modkey }, &quot;Down&quot;,  function () awful.client.moveresize(  0,  20,   0,   0) end),
    awful.key({ modkey }, &quot;Up&quot;,    function () awful.client.moveresize(  0, -20,   0,   0) end),
    awful.key({ modkey }, &quot;Left&quot;,  function () awful.client.moveresize(-20,   0,   0,   0) end),
    awful.key({ modkey }, &quot;Right&quot;, function () awful.client.moveresize( 20,   0,   0,   0) end),

==== Как изменить размер клиентов в тайлинге? ====

Вы можете использовать функцию ''awful.tag.incmwfact'' для изменения размера основного клиента и функцию ''awful.client.incwfact'' для изменения размера дополнительных клиентов. Следующий пример '''globalkeys''' демонстрирует это:

    awful.key({ modkey }, &quot;l&quot;,          function () awful.tag.incmwfact( 0.05) end),
    awful.key({ modkey }, &quot;h&quot;,          function () awful.tag.incmwfact(-0.05) end),
    awful.key({ modkey, &quot;Shift&quot; }, &quot;l&quot;, function () awful.client.incwfact(-0.05) end),
    awful.key({ modkey, &quot;Shift&quot; }, &quot;h&quot;, function () awful.client.incwfact( 0.05) end),

=== Как изменять конфигурацию awesome, когда он запущен? ===

Вы можете изменять ''rc.lua'', но вы должны перезапустить awesome чтобы изменения вступили в силу. Стандартная комбинация клавиш для перезапуска awesome это &quot;Mod4 + Control + r&quot;.

=== Как запускать клиенты на специфическом теге или остальные как плавающие? ===

Вы можете добавлять правила в вашу таблицу ''awful.rules.rules''. По умолчанию в ''rc.lua'' уже есть некоторые примеры, но вот еще несколько:

  -- Установка Firefox всегда располагаться на втором теге первого монитора.
  { rule = { class = &quot;Firefox&quot; },  properties = {tag = tags[1][2]}},
  
  -- Установка Smplayer на тег 4 первого монитора.
  { rule = { class = &quot;Smplayer&quot; }, properties = {tag = tags[1][4]}},
  
  -- Установка Emacs на пятый тег второго монитора.
  { rule = { class = &quot;Emacs&quot;, instance = &quot;emacs&quot; }, properties = {tag = tags[2][5]}},
  
  -- Установка Alpine на шестой тег последнего монитора. 
  { rule = { name = &quot;Alpine&quot; },    properties = {tag = tags[screen.count()][6]}},
  
  -- Установка Akregator на восьмой тег последнего монитора и добавление заголовка через вызов.
  { rule = { class = &quot;Akregator&quot; },properties = {tag = tags[screen.count()][8]}, callback = awful.titlebar.add},
  
  -- Установка Xterm на несколько тегов первого монитора.
  { rule = { class = &quot;XTerm&quot; }, callback = function(c) c:tags({tags[1][5], tags[1][6]}) end},
  
  -- Установка ROX-Filer на второй тег текущего выбранного и активного монитора.
  { rule = { class = &quot;ROX-Filer&quot; }, callback = function(c) awful.client.movetotag(tags[mouse.screen][2], c) end},
  
  -- Установка ROX-Filer на восьмой тег первого монитора и немедленное переключение на тег.
  { rule = { class = &quot;ROX-Filer&quot; }, properties = { tag = tags[1][8], switchtotag = true } } 
  
  -- Установка Geeqie на тег с фокусом, как плавающий клиент
  { rule = { instance = &quot;geeqie&quot; }, properties = {floating = true}},
  
  -- Установка Xterm как плавающего окна с фиксируемой позицией
  { rule = { class = &quot;XTerm&quot; }, properties = {floating = true}, callback = function(c) c:geometry({x=0, y=0}) end},

=== Как запускать клиенты как дополнительные окна под главным? ===

Вы можете назначить окнам открываться как дополнительные, установив правило для всех клиентов:

  -- Запускать клиент как дополнительный. 
  { rule = { }, properties = { }, callback = awful.client.setslave }

=== Как использовать код клавиши в определении комбинаций клавиш? ===

Вы можете использовать формат '''#XYZ''' для кодов клавиш в ваших определениях комбинаций. Следующий пример демонстрирует определение мультимедийной/специальной клавиши(вот почему здесь не используется нажатие модификатора(но оно может быть)):

 awful.key({}, &quot;#160&quot;, function () awful.util.spawn(&quot;kscreenlocker --forcelock&quot;) end),

=== Как добавить индикатор клавиатурной раскладки? ===

Вы можете использовать утилиту [http://sourceforge.net/projects/xxkb/ xxkb]. Оно создает иконку в трее и поддерживает настройку раскладки для клиента. Как альтернатива вы можете использовать виджет awesome, вы можете найти некоторые примеры на страница [[Change keyboard maps]]&quot;, или в библиотеке виджетов [[Obvious/ru|Obvious]].

Другим путем является использовать клавиатурную комбинацию, без какого-либо визуального ответа. Первое решение это использование встроенного в X.org переключателя (смотрите пример ниже), другое решение это вызов '''setxkbmap &lt;layout&gt;''' из комбинаций клавиш для awesome:

    Section &quot;InputClass&quot;
        Identifier      &quot;keyboard&quot;
        Driver          &quot;evdev&quot;
        MatchIsKeyboard &quot;on&quot;
        Option     &quot;XkbModel&quot;    &quot;evdev&quot;
        # Switch between layouts by pressing both shift keys
        Option     &quot;XkbLayout&quot;   &quot;hr,us&quot;
        Option     &quot;XkbOptions&quot;  &quot;grp:shifts_toggle&quot;
    EndSection

=== Как сделать так, чтобы окна создавались под курсором мыши? ===

Если в вашем обработчике сигналов ''manage'' есть раздел расположений окна, вы можете добавить '''awful.placement.under_mouse(c)''' в существующие правила (или заменить их).

=== Как переключаться на специфическую схему с помощью клавиатурных комбинаций? ===

Вы можете вызвать функцию ''awful.layout.set()'', вот пример: 

    awful.key({ modkey }, &quot;q&quot;, function () awful.layout.set(awful.layout.suit.tile) end),

=== Почему иконки моих приложений в Wine отсутствуют, когда я присоединяю второй монитор к моему ноутбуку? ===

Запуск  KeePass это пример подобного. Это еще нерешенный баг(?). Вы можете обойти это, убедившись что ваш подключаемый монитор становится '''основным''' монитором. Введите подобную команду:

    xrandr --output VGA1 --auto --above LVDS1 --primary


=== Есть ли какая-то программа для запуска приложений или меню в awesome? ===

В Awesome 2.3 есть возможность использования меню. Достаточно создать где-нибудь файл, строки которого соответствуют пунктам меню, например:

файл ~/.awesome/menu:
  xterm
  firefox
  pidgin

Затем добавьте в Ваш .awesomerc:
  key { 
    modkey = {&quot;Mod4&quot;} 
    key = &quot;p&quot; 
    command = &quot;spawn&quot; 
    arg = &quot;exec `cat ~/.awesome/menu | awesome-menu`&quot; 
  }

Подробности смотрите в статье [[awful.menu/ru|awful.menu]].

В качестве альтернативы можно использовать сторонние программы, такие как:
 
* [http://www.suckless.org/programs/dmenu.html dmenu] - утилита для запуска программ
    пример: key { modkey = {&quot;Mod4&quot;} key = &quot;p&quot; command = &quot;spawn&quot; arg = &quot;exec `dmenu_path | dmenu -b`&quot; }

* [http://gotmor.googlepages.com/dzen dzen] - x-меню, строка состояния и прочее...

* [ftp://freefriends.org/arnold/Source/ 9menu] - простое x-menu
    пример: 9menu - файл ~/.9menurc

* [http://apwal.free.fr/ apwal] - простые значки на корневом (root) окне

* [http://sourceforge.net/projects/gmrun Gmrun] - меню для запуска приложений (использует GTK+)

В Awesome 3 меню есть по умолчанию, для добавления или удаления элементов отредактируйте rc.lua.

=== Отсутствует трей! Как мне получать уведомления от Pidgin? ===

Awesome понимает флаг 'URGENT', который выставляет Pidgin, и может изменить фон тега awesome. Для этого запустите Pidgin, перейдите в Tools -&gt; Plugins и включите модуль 'Message Notification'. Далее в настройках этого модуля включите 'Set Window Manager 'URGENT' hint'.

Настройте цвета для тегов в секции 'colors' в Вашем файле ~/.awesomerc (Для awesome-2.2):

  colors {
    urgent_fg = &quot;#ffffff&quot;
    urgent_bg = &quot;#D53737&quot;
  }

Для awesome-2.3:

  styles {
     urgent
        {
            fg = &quot;#FFFFFF&quot;
            bg = &quot;#D53737&quot;
        }
  }

Выполните команду awesome -k, чтобы убедиться, что конфиг не содержит ошибок, и перезапустите awesome.

Для awesome-3 отредактируйте файл ~/.config/awesome/themes/&lt;theme&gt;

  bg_urgent     = #ff0000
  fg_urgent     = #ffffff

В результате, когда Вы получите сообщение в Pidgin, тег, к которому прикреплен Pidgin, должен изменить цвет на красный.

===Можно ли изменить настройки awesome, когда он запущен?===

Да, можно. Тем не менее необходимо будет перезапустить Awesome, чтобы применить новые настройки. Стандартное сочетание клавиш для перезапуска Awesome 3.0 - Mod4 + Ctrl + r.

=== Как изменить тему курсора в Awesome? ===

Вы можете установить желаемую тему при помощи xsetroot

  xsetroot -cursor_name THEME

Эту команду можно поместить в ~/.xinitrc

=== Могу ли я прицепить окно так, чтобы держать его между мониторами? ===

Да, точно такого же эффекта можно добиться добавив окно на все теги (правый клик по тегу чтобы добавить его к текущему окну)/ '''Учтите,''' что теги awesome это не настоящие &quot;экраны&quot;, а нечто более гибкое.

=== Как узнать класс окна для использования в качестве идентификатора клиента в конфигурационном файле? ===

  xprop | grep -i class
Затем кликните по интересующему Вас окну и посмотрите в выводе значение WM_CLASS. Его можно
будет поместить, например, в таблицу floatapps, чтобы сделать окно приложения плавающим:
  floatapps = 
  { 
    -- by class 
    [&quot;MPlayer&quot;] = true, 
    [&quot;pinentry&quot;] = true, 
    [&quot;gimp&quot;] = true, 
    -- by instance 
    [&quot;mocp&quot;] = true 
  }

В качестве альтернативы можно использовать функцию, которая будет показывать информацию о выбранном в данный момент
клиенте, используя библиотеку [[Naughty]]. В Awesome 3.3 добавьте к таблице clientkeys:
    awful.key({ modkey, &quot;Control&quot; }, &quot;i&quot;,
        function (c)
            naughty.notify({ text = 
                &quot;Class: &quot; .. c.class ..
                &quot;\nInstance: &quot; .. c.instance .. 
                &quot;\nName: &quot; .. c.name .. &quot;\n&quot;,
                width = 400 })
        end)

Теперь при нажатии Ctrl+Modkey+i будет появляться всплывающее уведомление с информацией о
клиенте.

==Использование==


=== Я запустил awesome, и не знаю что делать. Как управлять этой штукой? ===

По-умолчанию, чтобы открыть терминал, нужно нажать ''Mod4+Enter'' (где Mod4 обычно клавиша 'Windows') или правую кнопку мыши.

Затем наберите ''man awesome''. Это весьма хорошее руководство, в нём также описаны комбинации клавиш.

=== Схемы ===

С стандартным конфигурационным файлом вы можете циклически изменять схему расположения окон, нажимая mod4+space (mod4+shift+space для обратной прокрутки) или кликая по кнопке схемы в верхнем левом углу экрана.

Смотрите на страницу [[layout/ru]] для того, чтобы прочесть описание того, как разные схемы располагают окна.

=== Как перезапустить или выйти из awesome? ===

Вы можете использовать комбинацию клавиш &quot;Mod4+Ctrl+r&quot; или выбрав пункт &quot;restart&quot; в меню. Вы можете вызвать даже ''awesome.restart()'' из виджета командной строки Lua или отдав сигнал соответствующему клиенту:

  $ echo 'awesome.restart()' | awesome-client

Вы также можете послать сигнал '''SIGHUP''' процессу awesome. Найдите PID процесса, используя ''pps'', ''pgrep'' или используйте ''pkill'':

  $ pkill -HUP awesome

=== Почему awesome не использует мой собственный новый конфигурационный файл? ===

Если '''awesome''' не может найти ''$XDG_CONFIG_HOME/awesome/rc.lua'', или не может его загрузить, он начинает использовать стандартный файл в ''/etc/xdg/awesome/rc.lua'' (вы же не изменяли его, я надеюсь, не так ли?). Даже если команда ''awesome --check'' не выдала никаких ошибок, это означает только то, что ваш ''rc.lua'' синтаксически корректен, но защита от других ошибок не гарантированна. Даже больше, awesome может принять только часть вашего конфигурационного файла и показывать ошибку в загрузке остального, это может привести к странным последствиям, как два набора тегов. Посмотрите следующий вопрос или попытайтесь найти проблему.

=== Где располагаются логи, сообщения о ошибках или что-то подобное? ===

Когда при применении вашей конфигурации что-то идет не так, awesome отправляет сообщение об ошибке в системный поток ''stderr''. Когда он запущен с обычным ''$ startx'', тогда ошибки будут выводиться прямо в терминал. Если вы используете что-то более целостное( например DM, такие как KDM или GDM), стандартный поток stderr перенаправляется куда-нибудь еще. Чтобы узнать куда, запустите следующую команду:

 $ ls -l /proc/$(pidof awesome)/fd/2

Вот простой путь для запуска awesome и пере-направления его стандартных потоков вывода и ошибок в файлы:

 exec /usr/bin/awesome &gt;&gt; ~/.cache/awesome/stdout 2&gt;&gt; ~/.cache/awesome/stderr

Если вы запишете это в ''.xinitrc'' (для ''startx'') или ''~/.xsession'' ([http://qingy.sourceforge.net/ qingy] использующий это, к примеру), вы сможете просматривать их (с помощью ''tail -f'') полностью прямо из awesome.

===как запустить другую X сессию===

В KDE Я могу запустить другую Х сессию и переключаться между ними с помощью F7 и F8. как сделать такое же в awesome?

: Переключитесь на новый виртуальный терминал (VT) используя например Ctrl+Alt+F8, залогиньтесь как обычно, и запустите X-ы там, Например с помощью команды &lt;tt&gt;startx -- :2&lt;/tt&gt;. ([[User:Grfgguvf|Grfgguvf]] 18:27, 30 September 2008 (UTC))

[http://qingy.sourceforge.net/ qingy] хороший инструмент для проделывания подобных вещей.


Можно использовать простой скрипт xlaunch, позволяющий запустить произвольную программу в новой Х-сессии:
[http://forums.gentoo.org/viewtopic-t-483004.html Страница xlaunch]

=== Как выключать / перезагружать / переводить компьютер в спящий режим ===

Стандартное сочетание клавиш для выхода из Awesome - Mod4+Shift+q.

: Из командной строки можно выполнить &lt;tt&gt;shutdown -h now&lt;/tt&gt; для выключения, &lt;tt&gt;shutdown -r now&lt;/tt&gt; для перезагрузки, и так далее... ([[User:Grfgguvf|Grfgguvf]] 18:28, 30 September 2008 (UTC))
: Также, по крайней мере в Ubuntu, можно использовать команду &lt;tt&gt;pmi action suspend&lt;/tt&gt; для перехода в режим ожидания. --[[User:Dhgwilliam|Dhgwilliam]] 21:16, 7 November 2008 (UTC)

=== Где буфер обмена? Как мне делать копирование и вставку?===

X-сервер предоставляет возможность выделить текст мышью и вставить его куда-либо, нажав среднюю кнопку мыши или сочетание клавиш &lt;SHIFT&gt;-&lt;INSERT&gt;.

В качестве альтернативы можно установить любое приложение для управления буфером обмена, например, klipper.


== Разработка==
=== Я обнаружил ошибку, что делать? ===

Во-первых, протестируйте версию для разработчиков, возможно, ошибку уже исправили. Если ошибка представляет собой неожиданное поведение программы, поясните, что вы ожидали вместо неё. Если это ошибка сегментации, приложите данные трассировки (например, с помощью gdb).

Всё вышеперечисленное отправляйте по этой ссылке: http://awesome.naquadah.org/bugs/

Во всех случаях, опишите действия, которые привели к ошибке, чтобы её можно было воспроизвести.

=== Вы принимаете патчи и улучшения? ===

Да, принимаю. Отправляйте их мне или в почтовую рассылку. Также зайдите на [http://awesome.naquadah.org/devel/ страничку для разработчиков].

=== Как отслеживать разные ветки awesome? ===

Чтобы скопировать обычную версию разработчика(из git):

  git clone git://git.naquadah.org/awesome.git/
  cd awesome/

Чтобы o взять ветвь, например, такого вида - 'awesome-3':

  git fetch origin awesome-3:awesome-3
  git checkout awesome-3

git-branch напишет вам о том, какая ветвь у вас.
На некоторых дистрибутивах также есть возможность &quot;дополнять&quot; ветви команд git(и даже больше).
git-branch will tell you on what branch you are.

Чтобы оставаться обновленным с веткой 'awesome-3', запустите это в директории awesome:

  git fetch origin
  git reset --hard origin/awesome-3

Чтобы создать патч:

  git clone git://git.naquadah.org/awesome.git/
  ''edit file''
  git commit ''filename''
  git format-patch origin
This yields a file name like
  0001-the-title-you-gave-it.patch

[[Category:awesome2]]
[[Category:awesome3]]</text>
      <sha1>mobblastuxi312zzfo0anirry4csubs</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ/zh</title>
    <ns>0</ns>
    <id>664</id>
    <revision>
      <id>5041</id>
      <parentid>4784</parentid>
      <timestamp>2011-09-17T05:41:33Z</timestamp>
      <contributor>
        <username>Lanhongyu</username>
        <id>703</id>
      </contributor>
      <text xml:space="preserve" bytes="16341">{{DISPLAYTITLE:常见问题}}
{{Languages|FAQ}}

==关于awesome==
=== 为什么叫awesome? ===
''awesome'' 这个名字来自于英文单词''awesome'' 经常被电视剧 HIMYM 中的角色[http://en.wikipedia.org/wiki/Barney_Stinson Barney Stinson] 所使用.

==安装==
=== awesome 依赖包? ===
查看 [http://git.naquadah.org/?p=awesome.git;a=blob;f=README README].

==配置==
=== 如何改变默认的窗口管理布局?===
在默认配置文件中所有的标签使用同一个布局,设置成 ''floating'' . 你可以通过编辑  ''rc.lua'' 中的标签创建循环语句进行修改:

    -- Each screen has its own tag table.
    tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s, layouts[1])

注意默认的设置为所有的标签使用在前面的部分定义的窗口布局表中的第一种. 改变布局编号可以使用其他的窗口布局类型.

====如何设置每个标签的名字和布局?====
你可以修改配置文件中的标签创建部分,有很多种方法都可以实现,下面显示了其中的一种:

  -- {{{ Tags
  tags = {
    names  = { &quot;www&quot;, &quot;editor&quot;, &quot;mail&quot;, &quot;im&quot;, &quot;rss&quot;, 6, 7, &quot;rss&quot;, &quot;media&quot;},
    layout = { layouts[2], layouts[1], layouts[1], layouts[4], layouts[1],
               layouts[6], layouts[6], layouts[5], layouts[6]
  }}
  
  for s = 1, screen.count() do
      tags[s] = awful.tag(tags.names, s, tags.layout)
  end
  -- }}}

====如何在每个不同的屏幕中设置不同的标签和布局?====
下面显示了标签段的另一种示例代码:

  -- {{{ Tags
  tags = {
    settings = {
      { names  = { &quot;www&quot;, &quot;editor&quot;, &quot;mail&quot;, &quot;im&quot; },
        layout = { layouts[2], layouts[1], layouts[1], layouts[4] }
      },
      { names  = { &quot;rss&quot;,  6, 7,  &quot;media&quot; },
        layout = { layouts[3], layouts[2], layouts[2], layouts[5] }
  }}}
  
  for s = 1, screen.count() do
      tags[s] = awful.tag(tags.settings[s].names, s, tags.settings[s].layout)
  end
  -- }}}

=== 如何自动启动程序? ===
传统的方法是使用 ''~/.xinitrc'' ,你可以查看 [[Autostart]] 页寻找其它的解决方案.

=== 如何使用多显示器? ===
Awesome能够真正支持每个屏幕桌面(标签)的多点输入 (''XRandR'', ''Xinerama'' or ''Zaphod'' 模式), 在它的发布包中的示例配置文件中已经设置好为多显示器使用(输入框, 任务条, 挂件以及允许你在不同的屏幕中移动程序和切换焦点后的输入). 查看 &quot;[[Using Multiple Screens]]&quot;  的完全手册以获得更多的说明.

=== 当我离开时如何锁定屏幕? ===
你可使用一些屏幕锁定程序: ''xlock'', ''xscreensaver'', ''slock'', ''kscreenlocker''...

然后在 '''globalkeys''' 绑定快捷键,示例:

  awful.key({ modkey }, &quot;F12&quot;, function () awful.util.spawn(&quot;xlock&quot;) end)

=== 如何执行Shell命令? ===
如果你想执行shell命令或者一些用户命令,管道命令等等,不要使用 ''awful.util.spawn'' 函数,而应该用 '''awful.util.spawn_with_shell'''. 示例:

  awful.key({ modkey }, &quot;F10&quot;, function () awful.util.spawn_with_shell(&quot;cal -m | xmessage -timeout 10 -file -&quot;) end)

=== How to fix and improve usability of Java applications? ===
Java applications which use the XToolkit/XAWT back-end may draw grey windows only. The XToolkit/XAWT back-end breaks ICCCM-compliance in recent JDK 1.5 and early JDK 1.6 versions, because it assumes a reparenting window manager. You can find solutions and workarounds on the [[Problems with Java]] wiki page.

=== How to remove gaps between windows? ===
In awesome 3.4 you can add '''size_hints_honor = false''' to the ''properties'' section in your ''awful.rules.rules'' table, it will match and apply this rule to all clients. As an alternative (or in older versions) you can do it by adding '''c.size_hints_honor = false''' in the ''manage'' signal function (or manage hook in older versions).

If you want to know what are size hints it has been debated many times on the mailing list, so you can read the explanation: http://www.mail-archive.com/awesome@naquadah.org/msg01767.html

=== 如何控制标题条? ===
要在所有的客户程序中禁止标题条你应该从 ''manage'' 信号处理过程中移除包含内容 '''awful.titlebar.add(c, { modkey = modkey })''' 的行(老版本中为 manage 钩子过程). 如果你只需要特定的客户显示标题条, 不需要那么做, 你可以在 ''awful.rules.rules'' 表中加入规则就可以了. 示例规则:

  { rule = { class = &quot;Gimp&quot; }, callback = awful.titlebar.add  },

=== How to add an application switcher? ===
You can use the Clients Menu as an application switcher. By default it will open if you right-click on your taskbar, but you may also bind it to a key combination. Here is an example, toggled by &quot;Alt + Esc&quot;, that you can add to your '''globalkeys''':

  awful.key({ &quot;Mod1&quot; }, &quot;Escape&quot;, function ()
      -- If you want to always position the menu on the same place set coordinates
      awful.menu.menu_keys.down = { &quot;Down&quot;, &quot;Alt_L&quot; }
      local cmenu = awful.menu.clients({width=245}, { keygrabber=true, coords={x=525, y=330} })
  end),

=== How to configure and use widgets? ===
You can learn all about widgets, and how to create them on the [[Widgets in awesome]] page.

Some users created widget libraries applying the above principles. They try to simplify widget creation for others, and have the advantage of being distributed with a big number of system monitors, so you don't have to write your own. Two popular projects are [[Vicious]] and [[Obvious]].

=== How to setup horizontal widgets on a vertical wibox? ===
Left or right placement of the wibox is cool, but vertical text is hard to read. At the moment, in awesome v3.4, it is tricky to get a perfect result, but in the development branch of awesome the ''widget layouts'' have already been rewritten with this in mind. This code allows to easily setup complex vertical panels, like some desktop environments provide.

=== How to toggle wibox visibility? ===
Add the following key binding to your '''globalkeys''':

  awful.key({ modkey }, &quot;b&quot;, function ()
      mywibox[mouse.screen].visible = not mywibox[mouse.screen].visible
  end),

=== 如何切换窗口的浮动状态? ===
默认的配置文件 ''rc.lua'' 中已经有一个快捷键 &quot;Mod4 + Control + Space&quot; 绑定为该功能. 你可以按自己的习惯简单的修改它, 比如设为 &quot;Mod4 + f&quot; 或者 &quot;Mod4 + Shift + f&quot;.

    awful.key({ modkey, &quot;Shift&quot; }, &quot;f&quot;,  awful.client.floating.toggle ),

==== 为什么一些浮动的窗口不能为自动平铺好? ====
一些应用程序(如:Firefox, Opera...)浮动出来又不能自动平铺, 而且可能还有一些奇怪的特性(不能被打标, 总是在最前面...), 不用担心, 这只是在最近调用窗口被最大化了, 默认的快捷键 &quot;Mod4 + m&quot; 可以切换它的最大化状态.

你可以确保在 ''awful.rules.rules'' 表的规则中没有应用程序被定义为最大化启动, 对所有的程序应用可以添加:

  -- Search for this rule,
  keys = clientkeys,
  
  -- add the following two: 
  maximized_vertical   = false,
  maximized_horizontal = false,

=== 如何用键盘移动和调整浮动窗口? ===
你可以使用 ''awful.client.moveresize'' 函数. 在下面的 '''clientkeys''' 示例中移动浮窗使用 &quot;Mod4 + Arrow keys&quot; 而调整浮窗大小使用 &quot;Mod4 + PgUP/DN&quot; 键:

    awful.key({ modkey }, &quot;Next&quot;,  function () awful.client.moveresize( 20,  20, -40, -40) end),
    awful.key({ modkey }, &quot;Prior&quot;, function () awful.client.moveresize(-20, -20,  40,  40) end),
    awful.key({ modkey }, &quot;Down&quot;,  function () awful.client.moveresize(  0,  20,   0,   0) end),
    awful.key({ modkey }, &quot;Up&quot;,    function () awful.client.moveresize(  0, -20,   0,   0) end),
    awful.key({ modkey }, &quot;Left&quot;,  function () awful.client.moveresize(-20,   0,   0,   0) end),
    awful.key({ modkey }, &quot;Right&quot;, function () awful.client.moveresize( 20,   0,   0,   0) end),

==== 如何调整排列窗口的大小? ====
你可以使用 ''awful.tag.incmwfact'' 函数调整主应用和 ''awful.client.incwfact'' 函数调整从应用窗口的大小.  '''globalkeys''' 中设置示例如下:

    awful.key({ modkey }, &quot;l&quot;,          function () awful.tag.incmwfact( 0.05) end),
    awful.key({ modkey }, &quot;h&quot;,          function () awful.tag.incmwfact(-0.05) end),
    awful.key({ modkey, &quot;Shift&quot; }, &quot;l&quot;, function () awful.client.incwfact(-0.05) end),
    awful.key({ modkey, &quot;Shift&quot; }, &quot;h&quot;, function () awful.client.incwfact( 0.05) end),

=== 如何在awesome运行的时候改变配置? ===
你可以修改 ''rc.lua'', 但是你必须重启 awesome 以生效. 默认的重启 awesome 快捷键绑定为 &quot;Mod4 + Control + r&quot;.

=== 如何改变光标主题? ===
光标重置为默认外观的原因是因XCB不支持Xcursor. 在邮件列表[http://www.mail-archive.com/awesome@naquadah.org/msg01183.html a few] [http://www.mail-archive.com/awesome@naquadah.org/msg00202.html times]中曾被讨论过.

使用xsetroot 命令可以使用你的光标主题启用:

  $ xsetroot -cursor_name left_ptr

你可以将上面的命令加入 ''~/.xinitrc'' 文件. 另一个通用的解决方案是使用 [http://www.gnome-look.org/content/show.php?content=48837 Neutral Plus] 主题, 这个光标主题和X默认主题类似,但是包括了阴影和动画效果.

=== 如何找出窗口的类名以及其它的一些标识信息? ===
你可以使用 '''xprop''' 工具, 你可以观注输出信息中的 ''WM_CLASS'' 和 ''WM_NAME'' 部分:

  $ xprop

当光标变为 &quot;+&quot; 时点击你想查看的客户窗口,在它的输出信息中你可以参考下面的图示应用在awesome的match中:

  WM_CLASS(STRING) = &quot;smplayer&quot;, &quot;Smplayer&quot;
                      |           |
                      |           |--- class
                      |
                      |--- instance
                      
  WM_NAME(STRING) = &quot;SMPlayer&quot;
                     |
                     |--- name

或者你也可以将以下的别名放入Shell的配置文件中, 可以快速获取当前客户窗口的信息(你可以将 ''xmessage''  替换成 ''zenity'' 或者 ''notify-send'' 给 [[Naughty]] 使用):

  xpop= $( xprop | grep --color=none &quot;WM_CLASS\|^WM_NAME&quot; | xmessage -file - )

你可以将上面的标识信息(实例,类和名称)应用于 ''awful.rules.rules'' 表中进行匹配, 打标或者其它一些操作. 查看后面的FAQ和示例.

=== How to start clients on specific tags and others as floating? ===
You can add matching rules to your ''awful.rules.rules'' table. The default ''rc.lua'' already has several examples, but here are some more:

  -- Set Firefox to always map on tag number 2 of screen 1
  { rule = { class = &quot;Firefox&quot; },  properties = {tag = tags[1][2]}},
  
  -- Set Smplayer to tag 4 of screen 1
  { rule = { class = &quot;Smplayer&quot; }, properties = {tag = tags[1][4]}},
  
  -- Set Emacs to tag 5 of screen 2
  { rule = { class = &quot;Emacs&quot;, instance = &quot;emacs&quot; }, properties = {tag = tags[2][5]}},
  
  -- Set Alpine to tag 6 of the last screen 
  { rule = { name = &quot;Alpine&quot; },    properties = {tag = tags[screen.count()][6]}},
  
  -- Set Akregator to tag 8 of the last screen and add a titlebar trough callback
  { rule = { class = &quot;Akregator&quot; },properties = {tag = tags[screen.count()][8]}, callback = awful.titlebar.add},
  
  -- Set Xterm to multiple tags on screen 1
  { rule = { class = &quot;XTerm&quot; }, callback = function(c) c:tags({tags[1][5], tags[1][6]}) end},
  
  -- Set ROX-Filer to tag 2 of the currently selected and active screen
  { rule = { class = &quot;ROX-Filer&quot; }, callback = function(c) awful.client.movetotag(tags[mouse.screen][2], c) end},
  
  -- Set Geeqie to the currently focused tag, as floating
  { rule = { instance = &quot;geeqie&quot; }, properties = {floating = true}},
  
  -- Set Xterm as floating with a fixed position
  { rule = { class = &quot;XTerm&quot; }, properties = {floating = true}, callback = function(c) c:geometry({x=0, y=0}) end},

=== 如何启动客户程序作为从窗口而不是主窗口? ===
你可以设置下面的规则让所有客户程序的窗口打开始为从窗口:

  -- Start windows as slave
  { rule = { }, properties = { }, callback = awful.client.setslave }

=== How to use a keycode in a keybinding? ===
You can use the format '''#XYZ''' for keycodes in your bindings. The following example shows a mapped multimedia/extra key, that's why the modifier is not present (but it could be):

 awful.key({}, &quot;#160&quot;, function () exec(&quot;kscreenlocker --forcelock&quot;) end),

=== How to add a keyboard layout switcher ? ===
You can use the [http://sourceforge.net/projects/xxkb/ xxkb] utility. It has a tray icon and supports settings layouts per client. As an alternative you can use an awesome widget, you can even find some examples on the &quot;[[Change keyboard maps]]&quot; wiki page, or in the [[Obvious]] widget library.

I can also be done by adding a keybind to awful.util.spawn(&quot;setxkbmap &lt;your code&gt;&quot;)

==Usage==
=== How to use this thing? ===
Default binding to open a terminal is &quot;Mod4 + Enter&quot; (where Mod4 is usually the &quot;Windows&quot; key). You can also click on the desktop background with the right button, to open the awesome menu.

From there you can proceed to open ''man awesome'' which has a good guide, including the list of default keybindings.

=== Layouts ===

With the default config, you can cycle through window layouts by pressing mod4+space (mod4+shift+space to go back) or clicking the layout button in the upper right corner of the screen.

See the [[layout]] page for descriptions of what the different layouts do.

=== 怎样重启或者退出awesome？ ===
你可以使用快捷键 &quot;Mod4+Ctrl+r&quot; 或者在菜单中选择 restart 来重启awesome. 也可以在Lua prompt widget中调用 ''awesome.restart()'' ，或者把它传给''awesome-client'':

  $ echo 'awesome.restart()' | awesome-client

也可以发送 '''SIGHUP''' 信号到 awesome 进程。 用''ps'', ''pgrep'' 查找PID， 或者用 ''pkill'':

  $ pkill -HUP awesome

你可以使用快捷键 &quot;Mod4+Shift+q&quot; 或者在菜单中选择quit来退出awesome. 也在Lua prompt widget中调用 ''awesome.quit()'' ，或者把它传给 ''awesome-client''.

  $ echo 'awesome.quit()' | awesome-client

也可以发送 '''SIGINT''' 信号到 awesome 进程。  用''ps'', ''pgrep'' 查找PID， 或者用 ''pkill'':

  $ pkill -INT awesome

=== Where are logs, error messages or something? ===
When hacking your own configuration, something inevitably would go wrong. awesome prints error messages to its ''stderr'' stream. When run with usual ''$ startx'', it'd be printed right in tty. If you use something more complicated (some kind of DM, like kdm or gdm), stderr is usually redirected somewhere else. To see where, run the following command:

 $ ls -l /proc/$(pidof awesome)/fd/2

There's handy way to run awesome and redirect both its standard output and error streams to files:

 exec /usr/bin/awesome &gt;&gt; ~/.cache/awesome/stdout 2&gt;&gt; ~/.cache/awesome/stderr

If you put it into ''.xinitrc'' (for ''startx'') or ''~/.xsession'' ([http://qingy.sourceforge.net/ qingy] uses it, for example), you'll be able to watch (with ''tail -f'') everything right from awesome.

==开发==
=== 如何报告 bugs? ===
首先请测试开发版本看bug是否依然存在. 如果bug类型是与你期待的目的不一致,请说明你想更改的后的情况. 如果bug是段错误,请提交完整的backtrace (使用 gdb).

你可以提交到这里: http://awesome.naquadah.org/bugs/

请尽可能地说明如何再现bug.

=== 是否接受补丁和程序? ===
当然.请发送给 Julien 或者邮件列表. 请查看 [http://awesome.naquadah.org/devel/ development page].

=== 如何跟踪 awesome-branches? ===
用git clone开发版源程序:

  git clone git://git.naquadah.org/awesome.git/
  cd awesome/

如获取分支 'awesome-3':

  git fetch origin awesome-3:awesome-3
  git checkout awesome-3

git-branch 将提示你当前所在的分支.
在一些系统版本中你可以通过按 &lt;tab&gt; 键补全git命令.

在awesome目录中运行下面的命令可以更新 'awesome-3' 分支:

  git fetch origin
  git reset --hard origin/awesome-3

创建补丁:

  git clone git://git.naquadah.org/awesome.git/
  ''edit file''
  git commit ''filename''
  git format-patch origin

将产生类似于下面的文件
  0001-the-title-you-gave-it.patch

[[Category:awesome2]]
[[Category:awesome3]]</text>
      <sha1>e7ugro03lcltopbfo1iup8yia5q5ylo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ (Italiano)</title>
    <ns>0</ns>
    <id>338</id>
    <redirect title="FAQ/it" />
    <revision>
      <id>2739</id>
      <timestamp>2009-05-23T09:37:57Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[FAQ (Italiano)]] to [[FAQ/it]]:&amp;#32;Make this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="20">#REDIRECT [[FAQ/it]]</text>
      <sha1>cdnyywdk6jvu1nm5epwubbg4kkf0hv9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ (Russian)</title>
    <ns>0</ns>
    <id>339</id>
    <redirect title="FAQ/ru" />
    <revision>
      <id>2741</id>
      <timestamp>2009-05-23T09:38:25Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[FAQ (Russian)]] to [[FAQ/ru]]:&amp;#32;Make this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="20">#REDIRECT [[FAQ/ru]]</text>
      <sha1>abnmq1jia3027m2zjaw668l862nypnp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ (français)</title>
    <ns>0</ns>
    <id>335</id>
    <redirect title="FAQ/fr" />
    <revision>
      <id>2733</id>
      <timestamp>2009-05-23T09:35:46Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[FAQ (français)]] to [[FAQ/fr]]:&amp;#32;Make this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="20">#REDIRECT [[FAQ/fr]]</text>
      <sha1>p2kswi6g9n7oeuvzuufzfg6yy2rhnjv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FAQ (french)</title>
    <ns>0</ns>
    <id>3</id>
    <redirect title="FAQ/fr" />
    <revision>
      <id>2896</id>
      <parentid>2673</parentid>
      <timestamp>2009-06-25T14:51:59Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>redirection vers « FAQ/fr », qui contient les mêmes infos + de nombreuses autres</comment>
      <text xml:space="preserve" bytes="19">#REDIRECT[[FAQ/fr]]</text>
      <sha1>tg3aaepby55jrb4i82cbl8v7ycjjky3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Fallback config</title>
    <ns>0</ns>
    <id>570</id>
    <revision>
      <id>4352</id>
      <parentid>4351</parentid>
      <timestamp>2010-07-05T20:06:23Z</timestamp>
      <contributor>
        <username>Boyska</username>
        <id>455</id>
      </contributor>
      <minor/>
      <comment>xephyr link</comment>
      <text xml:space="preserve" bytes="965">When you are changing your rc.lua, it's easy to break something, reload with Win+Ctrl+R and find your awesome session unusable.
Of course, you should have tested it before [[using Xephyr]] but, just in case, I use this hack.

It will try to load my config file: if there are errors, though, it will safely abort and load another file (which we rarely change and _is_ stable).

  cd ~/.config/awesome
  cp rc.lua rc.lua.fallback
  mv rc.lua rc.lua.read

Note that we are now using the current file both for &quot;normal&quot; and fallback session. If you want, you can put a different file as a fallback.

Now, let's create rc.lua

  status, ret = pcall(loadfile, 'rc.lua.real')
  if status == true then
    status, ret = pcall(ret)
  end
  if status == false then
    loadfile('rc.lua.fallback')()
  end

I suggest you putting some difference in your fallback file, so that you can immediately realize that something went wrong; I have a textbox widget displaying &quot;FALLBACK&quot;.</text>
      <sha1>oyzp8wmsqj1ertunje7h399wt5btgps</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Familiar Alt Tab</title>
    <ns>0</ns>
    <id>1195</id>
    <revision>
      <id>7091</id>
      <parentid>7023</parentid>
      <timestamp>2014-10-28T16:36:11Z</timestamp>
      <contributor>
        <username>Jorenheit</username>
        <id>3609</id>
      </contributor>
      <text xml:space="preserve" bytes="5796">== Installation ==

If you, like me, were bothered by the limited window-switching functionality that awesome has to offer by default, this module might be for you. It can be &lt;tt&gt;git clone&lt;/tt&gt;'d directly from [https://github.com/jorenheit/awesome_alttab github]:
    git clone https://github.com/jorenheit/awesome_alttab alttab
Alternatively, the code can be pasted in &lt;tt&gt;~/.config/awesome/alttab/init.lua&lt;/tt&gt;. When the module is available, a keybinding can be added to your keybindings-table in rc.lua:

    alttab = require(&quot;alttab&quot;)

    awful.key({ &quot;Mod1&quot;,           }, &quot;Tab&quot;,                                                      
        function ()                                                                              
           alttab.switch(1, &quot;Alt_L&quot;, &quot;Tab&quot;, &quot;ISO_Left_Tab&quot;)                                             
        end                                                                                      
    ),                                                                                           
                                                                                                 
    awful.key({ &quot;Mod1&quot;, &quot;Shift&quot;   }, &quot;Tab&quot;,                                                      
        function ()                                                                              
           alttab.switch(-1, &quot;Alt_L&quot;, &quot;Tab&quot;, &quot;ISO_Left_Tab&quot;)                                            
        end                                                                                      
    ),

In the above snippet, we pass the keys that we want to function as &quot;Alt&quot; and &quot;Tab&quot;. In this example, I'm using left Alt and Tab. The final parameter is the value that is captured by the keygrabber when Shift+Tab is pressed. When Alt-Tabbing, the arrow-keys can be used to navigate as well.

'''Update:''' it is now possible to break out of alt-tabbing using the Escape key. This will ignore the selected client and return to the previous state. Also, clients that don't have an icon associated with them, failed to preview in previous versions (e.g. &lt;tt&gt;urxvt&lt;/tt&gt;). The updated version contains &lt;tt&gt;noicon.png&lt;/tt&gt; to fix this issue. Be sure to copy this to your alttab-folder as well if you're copy-pasting instead of cloning.

== Tested environments ==
Please add more when appropriate:
* Awesome 3.5.5, built against Lua 5.1.5 (GCC 4.9.0) 

== Features == 
[[Image:awesome_alttab_scrot.png|400px|right]]
The image shows what the functionality might look like once installed, when only the preview-box is enabled. When cycling through your clients, using either alt-(shift)-tab or the arrow keys (while still holding alt), the selected client is illuminated and slightly magnified. After selecting a client, the focus history is updated accordingly, so that you can easily switch back and forth between your two most recent clients. Because this is a common practical use-case of Alt-Tab, a delay is built in to prevent the graphical interface to pop up when releasing Alt within some timeframe. For me, 100ms worked well, so this is the default.

A second mode of operation can be enabled (in place of, or replacing the previews) that applies an opacity effect to the clients themselves. In this mode, all but one client (the currently active one) are rendered somewhat see-through, making the non-opaque window stand out. Like with the preview-box, it's possible to set a delay on this effect to prevent it from being activated when using alt-tab to quickly switch back and forth between two clients.

== Customization == 

* The &lt;tt&gt;alttab.settings&lt;/tt&gt; table contains the following fields, that may be altered to change the Alt-Tab behavior (default values are shown):
   preview_box = true,
   preview_box_bg = &quot;#ddddddaa&quot;,
   preview_box_border = &quot;#22222200&quot;,
   preview_box_fps = 30,
   preview_box_delay = 150,

The above settings all apply to the preview-box, and are pretty self-explanatory. When &lt;tt&gt;preview_box&lt;/tt&gt; is set to false, there won't be any previews at all, but of course the Alt-Tab functionality is still preserved. In addition to the above, the following settings are available:

   client_opacity = false,
   client_opacity_value = 0.5,
   client_opacity_delay = 150,

The opacity-effect is disabled by default, but can be enabled by setting the &lt;tt&gt;client_opacity&lt;/tt&gt; field to &lt;tt&gt;true&lt;/tt&gt;. The alpha-value and delay-time (in milliseconds) can be tweaked to suit your needs/taste.

''Note that you need the `unagi' package to be installed and running on your system (on Debian: &lt;tt&gt;apt-get install unagi&lt;/tt&gt;). You can run it by spawning it from rc.lua, or any other init-script.''

* You might want to edit the illumination/magnification effects when selecting clients, but this required editing the code itself (init.lua). Look for the following lines (in the &lt;tt&gt;draw()&lt;/tt&gt; function):
    local a = 0.8
    local overlay = 0.6
    local fontSize = smallFont
    if c == altTabTable[altTabIndex] then
        a = 0.9
        overlay = 0
        fontSize = bigFont
    end
The `&lt;tt&gt;a&lt;/tt&gt;' value is the scale-factor by which the images are scaled with respect to the box they're drawn in. By default, this is 80%. Selected clients are scaled by 90%, such that it appears as if they're magnified when selected. The `&lt;tt&gt;overlay&lt;/tt&gt;' value is actually the alpha-channel value of a black rectangle that's drawn on top of the images. By setting this to 0 for selected clients, it seems as if they get illuminated.
* The preview-delay can be altered if 100ms isn't working for you. Just alter the timeout value of the &lt;tt&gt;previewDelayTimer&lt;/tt&gt;:
   local previewDelay = 0.1 -- 100ms
   local previewDelayTimer = timer({timeout = previewDelay})

Of course, feel free to mess around with it as much as you like, or even fork!</text>
      <sha1>faaoc16p25xv5kc78px9eaq0mpao52s</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Farhavens fish widget</title>
    <ns>0</ns>
    <id>195</id>
    <revision>
      <id>2788</id>
      <parentid>1751</parentid>
      <timestamp>2009-05-23T11:26:15Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Widgets]]</comment>
      <text xml:space="preserve" bytes="1273">== Farhavens fish widget ==

=== Introduction ===
This widget places a little moving turquoise ASCII fish into your wiboxes, which, once clicked, displays a fortune using naughty. Naturally, you need to include naughty with '''require(&quot;naughty&quot;)''' into your config file and you also need GNU fortune installed.

=== Widget Code ===
Paste the following code somewhere before your wibox definition into your rc.lua

  fish = { }
  fish.widget = widget({ type = &quot;textbox&quot;, align = &quot;right&quot; })
  fish.state = 1
  fish.states = { &quot;&lt;°}))o»«&quot;, &quot;&lt;°)})o&gt;«&quot;, &quot;&lt;°))}o»&lt;&quot; }
  fish.widget:buttons({
      button({ }, 1, function () fish.fortune() end ) })
  
  function fish.fortune()
      local fh = io.popen(&quot;fortune -n 100 -s&quot;)
      local fortune = fh:read(&quot;*all&quot;)
      fh:close()
      naughty.notify({ text = fortune, timeout = 7 })
  end
  function fish.update()
      local t = &quot;&lt;span color=\&quot;#00FFFF\&quot;&gt;&quot;
      t = t .. awful.util.escape(fish.states[fish.state])
      t = t .. &quot;&lt;/span&gt;&quot;
      fish.widget.text = t
      fish.state = (fish.state + 1) % #(fish.states) + 1
  end
  fish.update()
  
  awful.hooks.timer.register(0.5, fish.update)

Then, add '''fish.widget''' to your wibox and restart Awesome. Enjoy the fish :)

[[Category:awesome3]]
[[Category:Widgets]]</text>
      <sha1>9i5l4qspwsd1g52jylp41fcd8spstde</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Farhavens volume widget</title>
    <ns>0</ns>
    <id>162</id>
    <revision>
      <id>5548</id>
      <parentid>5522</parentid>
      <timestamp>2012-07-21T14:43:06Z</timestamp>
      <contributor>
        <username>Farhaven</username>
        <id>144</id>
      </contributor>
      <minor/>
      <comment>/* Farhavens mod */</comment>
      <text xml:space="preserve" bytes="9546">=== Introduction ===

This guide walks you through setting up a volume widget for Awesome 3, very much similar to [[Woffles Volume Widget]]. In fact, originally this was his volume widget, I adapted it to Awesome 3's Lua syntax and gave it a little pepper with Luas string manipulation functions.

The widget works like this:
* You'll have the volume displayed in your status bar, followed by a '''%''' sign if the channel is unmuted and '''M''' if it's muted
* Pressing the left mouse-button on the widget will toggle muting
* Scrolling up or down will change the volume
* (Optional) Your media keys (if you have any) will control the volume as long as you are inside your X session and it is not locked

You'll need the following for this widget to work:

* amixer
* awesome 3 (something &gt;= 3.1)

Note on point 2: It should be fairly simple to adapt this widget to the 3.0 release version, it's only that this exact code will '''not''' work with the stable release and earlier GIT versions.
This widget has been tested and is working on 3.4.10.
=== Preparation ===

The preparation is the same as with [[Woffles Volume Widget]].

=== Adding the widget ===

Add this widget definition to your rc.lua:

  tb_volume = widget({ type = &quot;textbox&quot;, name = &quot;tb_volume&quot;, align = &quot;right&quot; })
  tb_volume:buttons({
  	button({ }, 4, function () volume(&quot;up&quot;, tb_volume) end),
  	button({ }, 5, function () volume(&quot;down&quot;, tb_volume) end),
  	button({ }, 1, function () volume(&quot;mute&quot;, tb_volume) end)
  })
  volume(&quot;update&quot;, tb_volume)

don't forget to add the widget '''tb_volume''' to your widget box like this:

  wi_widgets[s]:widgets({
  	tl_taglist,
  	lb_layout[s],
  	tb_prompt,
  	tl_tasklist,
  	'''tb_volume,'''
  	tb_clock
  	})

=== Bringing the widget to life ===

Now it's time to bring the widget to life, using the following code. Paste it right at the beginning of your rc.lua, below those lines starting with '''require'''. Change the value of '''cardid''' to the ID of your card and the value of '''channel''' to the channel you want to manage.

  cardid  = 0
  channel = &quot;Master&quot;
  function volume (mode, widget)
  	if mode == &quot;update&quot; then
               local fd = io.popen(&quot;amixer -c &quot; .. cardid .. &quot; -- sget &quot; .. channel)
               local status = fd:read(&quot;*all&quot;)
               fd:close()
  		
  		local volume = string.match(status, &quot;(%d?%d?%d)%%&quot;)
  		volume = string.format(&quot;% 3d&quot;, volume)
  
  		status = string.match(status, &quot;%[(o[^%]]*)%]&quot;)
  
  		if string.find(status, &quot;on&quot;, 1, true) then
  			volume = volume .. &quot;%&quot;
  		else
  			volume = volume .. &quot;M&quot;
  		end
  		widget.text = volume
  	elseif mode == &quot;up&quot; then
  		io.popen(&quot;amixer -q -c &quot; .. cardid .. &quot; sset &quot; .. channel .. &quot; 5%+&quot;):read(&quot;*all&quot;)
  		volume(&quot;update&quot;, widget)
  	elseif mode == &quot;down&quot; then
  		io.popen(&quot;amixer -q -c &quot; .. cardid .. &quot; sset &quot; .. channel .. &quot; 5%-&quot;):read(&quot;*all&quot;)
  		volume(&quot;update&quot;, widget)
  	else
  		io.popen(&quot;amixer -c &quot; .. cardid .. &quot; sset &quot; .. channel .. &quot; toggle&quot;):read(&quot;*all&quot;)
  		volume(&quot;update&quot;, widget)
  	end
  end

Finally, we will be adding a timer hook to refresh the volume display every 10 seconds to reflect changes made by, for example, alsamixer:

  awful.hooks.timer.register(10, function () volume(&quot;update&quot;, tb_volume) end)

This line should be pasted at the end of your rc.lua

=== Optional stuff ===

==== Setting keybindings ====

If you have multimedia keys on your keyboard which currently do nothing but look nice, you may want to add these lines to your rc.lua:

  globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioRaiseVolume&quot;,function () volume(&quot;up&quot;, tb_volume) end))
  globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioLowerVolume&quot;,function  () volume(&quot;down&quot;, tb_volume) end))
  globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioMute&quot;,function  () volume(&quot;mute&quot;, tb_volume) end))



Or use 'xev' and see what keycode those buttons have then do something like:
  globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;#176&quot;,function () volume(&quot;up&quot;, tb_volume) end))

==== Calmar's mod ====

Calmar has modded this widget to contain a progressbar instead of a textbox.

An example progressbar for it:

  pb_volume =  widget({ type = &quot;progressbar&quot;, name = &quot;pb_volume&quot;, align = &quot;right&quot; })
  pb_volume.width = 12
  pb_volume.height = 1
  pb_volume.border_padding = 1
  pb_volume.border_width = 1
  pb_volume.ticks_count = 8
  pb_volume.gap = 0
  pb_volume.vertical = true
  
  pb_volume:bar_properties_set(&quot;vol&quot;, 
  { 
    [&quot;bg&quot;] = &quot;#000000&quot;,
    [&quot;fg&quot;] = &quot;green&quot;,
    [&quot;fg_center&quot;] = &quot;yellow&quot;,
    [&quot;fg_end&quot;] = &quot;red&quot;,
    [&quot;fg_off&quot;] = &quot;black&quot;,
    [&quot;border_color&quot;] = &quot;#999933&quot;,
    [&quot;min_value&quot;] = 0,
    [&quot;max_value&quot;] = 100,
    [&quot;reverse&quot;] = false
  })

Note: You need to replace '''every''' occurence of the old widget name (e.g. in the keybindings) with the new name ('''pb_volume''')

Replace the 3 lines in the original volume(...) function to do stuff on the progressbar, rather than tweaking 'text':

  1. volume = volume .. &quot;%&quot;           --replace with (set 'normal' bg color):
  
     widget:bar_properties_set(&quot;vol&quot;, {[&quot;bg&quot;] = &quot;#000000&quot;})
  
  2. volume = volume .. &quot;M&quot;           --replace with (set 'mute' bg color):
  
     widget:bar_properties_set(&quot;vol&quot;, {[&quot;bg&quot;] = &quot;#cc3333&quot;})
  
  3. widget.text = volume             --replace with (just set the value what has to be shown):
  
     widget:bar_data_add(&quot;vol&quot;, volume)

[http://www.calmar.ws/awesome/volume_progressbar.txt final function]

The widget might looks nicer when using 'ticks'. But since the widget is built always homogenuous, you 
need to tweak the number of ticks (maybe even the height of the widget) to get a not shrunken widget.

I have a good result with 7. (with 6 the widget is shrunken too much. With 8 it can't get drawn (the box will still get drawn!)).

Screenshot:

[[Image:Example.png]]

==== Farhavens mod ====
I myself have also modded this widget to display a an ASCII bar instead of the simple number display. The bar looks like this:

  -[||||-----]+

The new code for the volume function would be:

  function volume (mode, widget)
      local cardid  = 0
      local channel = &quot;Master&quot;
      if mode == &quot;update&quot; then
          local status = io.popen(&quot;amixer -c &quot; .. cardid .. &quot; -- sget &quot; .. channel):read(&quot;*all&quot;)
          
          local volume = tonumber(string.match(status, &quot;(%d?%d?%d)%%&quot;))
  
          status = string.match(status, &quot;%[(o[^%]]*)%]&quot;)
  
          local color = &quot;#FF0000&quot;
          if string.find(status, &quot;on&quot;, 1, true) then
               color = &quot;#00FF00&quot;
          end
          status = &quot;&quot;
          for i = 1, math.floor(volume / 10) do
              status = status .. &quot;|&quot;
          end
          for i = math.floor(volume / 10) + 1, 10 do
              status = status .. &quot;-&quot;
          end
          status = &quot;-[&quot; ..status .. &quot;]+&quot;
          widget.text = &quot;&amp;lt;span color=\&quot;&quot; .. color .. &quot;\&quot;&amp;gt;&quot; .. status .. &quot;&amp;lt;/span&amp;gt;|&quot;
      elseif mode == &quot;up&quot; then
          os.execute(&quot;amixer -q -c &quot; .. cardid .. &quot; sset &quot; .. channel .. &quot; 5%+&quot;)
          volume(&quot;update&quot;, widget)
      elseif mode == &quot;down&quot; then
          os.execute(&quot;amixer -q -c &quot; .. cardid .. &quot; sset &quot; .. channel .. &quot; 5%-&quot;)
          volume(&quot;update&quot;, widget)
      else
          os.execute(&quot;amixer -c &quot; .. cardid .. &quot; sset &quot; .. channel .. &quot; toggle&quot;)
          volume(&quot;update&quot;, widget)
      end
  end

==== Pavel's mod ====
It avoids calling amixer twice. Also, the invocation is easier. The widget definition:
 volumecfg = {}
 volumecfg.cardid  = 0
 volumecfg.channel = &quot;Master&quot;
 volumecfg.widget = widget({ type = &quot;textbox&quot;, name = &quot;volumecfg.widget&quot;, align = &quot;right&quot; })
 -- command must start with a space!
 volumecfg.mixercommand = function (command)
        local fd = io.popen(&quot;amixer -c &quot; .. volumecfg.cardid .. command)
        local status = fd:read(&quot;*all&quot;)
        fd:close()
        local volume = string.match(status, &quot;(%d?%d?%d)%%&quot;)
        volume = string.format(&quot;% 3d&quot;, volume)
        status = string.match(status, &quot;%[(o[^%]]*)%]&quot;)
        if string.find(status, &quot;on&quot;, 1, true) then
                volume = volume .. &quot;%&quot;
        else   
                volume = volume .. &quot;M&quot;
        end
        volumecfg.widget.text = volume
 end
 volumecfg.update = function ()
        volumecfg.mixercommand(&quot; sget &quot; .. volumecfg.channel)
 end
 volumecfg.up = function ()
        volumecfg.mixercommand(&quot; sset &quot; .. volumecfg.channel .. &quot; 5%+&quot;)
 end
 volumecfg.down = function ()
        volumecfg.mixercommand(&quot; sset &quot; .. volumecfg.channel .. &quot; 5%-&quot;)
 end
 volumecfg.toggle = function ()
        volumecfg.mixercommand(&quot; sset &quot; .. volumecfg.channel .. &quot; toggle&quot;)
 end
 volumecfg.widget:buttons(awful.util.table.join(
        awful.button({ }, 4, function () volumecfg.up() end),
        awful.button({ }, 5, function () volumecfg.down() end),
        awful.button({ }, 1, function () volumecfg.toggle() end)
 ))
 volumecfg.update()

Add the following to your widget list:
 volumecfg.widget

And try the following key bindings:
  globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioRaiseVolume&quot;,function () volumecfg.up() end))
  globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioLowerVolume&quot;,function  () volumecfg.down() end))
  globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioMute&quot;,function  () volumecfg.toggle() end))

And the following sample hook:
 awful.hooks.timer.register(60, function ()
        volumecfg.update()
 end)
[[Category:Widgets]]

[[Category:awesome3]]</text>
      <sha1>r431igkj8xkgh8k0vuzqz6nl2g1gxbj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Fichiers de configuration d'utilisateurs</title>
    <ns>0</ns>
    <id>409</id>
    <redirect title="User Configuration Files/fr" />
    <revision>
      <id>3048</id>
      <timestamp>2009-06-25T20:36:04Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Fichiers de configuration d'utilisateurs]] to [[User Configuration Files/fr]] over redirect: Fix for [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="41">#REDIRECT [[User Configuration Files/fr]]</text>
      <sha1>o1ezcjozmmv94aiv5e61v7jjwsq1xbv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>File Managers</title>
    <ns>0</ns>
    <id>58</id>
    <revision>
      <id>6168</id>
      <parentid>5674</parentid>
      <timestamp>2013-11-11T04:15:40Z</timestamp>
      <contributor>
        <username>Jaschroe</username>
        <id>3101</id>
      </contributor>
      <comment>Update home page for ROX</comment>
      <text xml:space="preserve" bytes="1796">{{Languages}}

Occasionally, it's just easier to perform certain tasks using a GUI file manager. Both KDE and GNOME provide methods for doing this, but there's no built-in method for doing this in awesome.

Here are some lightweight file managers that don't require all of GNOME or KDE.

* [http://thunar.xfce.org/index.html Thunar] is a part of the Xfce desktop environment.
* [http://pcmanfm.sourceforge.net/ PCManFM] is sometimes dubbed &quot;Thunar with tabs&quot;, a quick and light graphical file manager, with experimental &quot;true&quot; desktop implementation support.
* [http://emelfm2.net/ emelFM2] is a GTK+2 port of the good old original emelFM. Highly configurable, pretty much like its ancestor.
* [http://rox.sourceforge.net/desktop/ ROX] is a small and fast file manager which can optionally manage the desktop background and panels.
* [http://www.ibiblio.org/mc/ mc] GNU midnight commander, console based, but the mouse works too to some degree.
* [http://vifm.sourceforge.net Vifm] Vifm is a ncurses based file manager with vi like keybindings. If you use vi(m), vifm gives you complete keyboard control over your files without having to learn a new set of commands.
* [http://roland65.free.fr/xfe/ Xfe] is small and very fast file manager and only requires the FOX library to be fully functional.
* [https://savannah.nongnu.org/projects/ranger/ Ranger] Console based, multicolumn filemanager with vim-bindings.
* [http://en.wikipedia.org/wiki/Gentoo_%28file_manager%29 Gentoo] Gentoo is a free file manager for Linux and other Unix-like computer systems created by Emil Brink. It has a very simple but effective ui and it's fast. Gentoo is written in C using the GTK+ toolkit
* [https://code.google.com/p/sunflower-fm/ Sunflower] Small and highly customizable twin-panel file manager using GTK2.</text>
      <sha1>6pckub1vj12qi96o15m7s1s862y6qgk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>File Managers/fr</title>
    <ns>0</ns>
    <id>423</id>
    <revision>
      <id>3340</id>
      <parentid>3211</parentid>
      <timestamp>2009-07-15T18:38:59Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use DISPLAYTITLE instead of Title</comment>
      <text xml:space="preserve" bytes="1558">{{DISPLAYTITLE:Gestionnaires de fichiers}}
{{Languages|File Managers}}

Parfois, il est tout simplement plus pratique d’effectuer certaines tâches en utilisant un gestionnaire de fichiers avec une interface graphique. KDE et Gnome fournissent des méthodes pour réaliser ces actions, mais il n’y a pas de méthode équivalente dans awesome.

Voici quelques gestionnaires de fichiers qui ne nécessitent ni Gnome ni KDE :

* [http://thunar.xfce.org/index.html Thunar] fait partie de l’environnement de bureau XFCE.
* [http://pcmanfm.sourceforge.net/ PCManFM] est parfois appelé « Thunar avec onglets » : c’est un gestionnaire de fichiers rapide et léger avec un « vrai » support de bureau expérimental.
* [http://emelfm2.net/ emelFM2] est un portage GTK+2 du bon vieux emelFM. Hautement configurable, comme son ancêtre.
* [http://roscidus.com/desktop ROX] est un gestionnaire de fichiers petit et rapide qui peut également gérer le papier peint du bureau et les tableaux de bord.
* [http://www.ibiblio.org/mc/ mc] GNU midnight commander : en console, mais la souris a un certain rôle.
* [http://vifm.sourceforge.net Vifm] Vifm est un gestionnaire de fichiers fondé sur ''ncurses'' avec des raccourcis claviers à la ''vi''. Si vous utilisez ''vi(m)'', Vifm vous donne un contrôle clavier complet sur vos fichiers sans avoir à apprendre de nouvelles commandes.
* [http://roland65.free.fr/xfe/ Xfe] est un gestionnaire de fichiers petit et très rapide qui ne nécessite que la bibliothèque FOX pour être pleinement opérationnel.</text>
      <sha1>phdejrnp0ni4zrgiw1h92y8eeastne3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>File Managers/ru</title>
    <ns>0</ns>
    <id>466</id>
    <revision>
      <id>6849</id>
      <parentid>6727</parentid>
      <timestamp>2014-06-29T06:44:28Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>change link</comment>
      <text xml:space="preserve" bytes="2931">{{DISPLAYTITLE: Файловые менеджеры}}
{{Languages|File Managers}}

Иногда проще выполнять некоторые операции с файлами, используя файловые менеджеры с GUI, которые есть в KDE и GNOME, но отсутствуют в Awesome.

Вот список легковесных файловых менеджеров, не требующих наличия GNOME или KDE.

* [http://thunar.xfce.org/index.html Thunar] является частью окружения рабочего стола Xfce.
* [http://pcmanfm.sourceforge.net/ PCManFM] иногда называют &quot;Thunar с вкладками&quot;, это быстрый и лёгкий файловый менеджер с экспериментальной поддержкой управления рабочим столом.
* [http://emelfm2.net/ emelFM2] - порт на GTK+2 старого доброго emelFM. Как и предшественник, содержит множество настроек.
* [http://rox.sourceforge.net/desktop/ROX-Filer] - маленький и быстрый файловый менеджер, который помимо всего прочего может управлять фоном рабочего стола и панелями.
* [http://www.ibiblio.org/mc/ mc] GNU midnight commander, работает в консоли, но отчасти поддерживает мышь.
* [http://vifm.sourceforge.net Vifm] Vifm - это основанный на ncurses файловый менеджер с привязками клавиш в стиле vi. Если Вы поклонник vi(m), vifm даст Вам полный контроль над файлами без необходимости изучать новые сочетания клавиш.
* [http://roland65.free.fr/xfe/ Xfe] - маленький и очень быстрый файловый менеджер, требующий для работы только библиотеку FOX.
* [https://savannah.nongnu.org/projects/ranger/ Ranger] Работает в консоли, много панельный файловый менедежр с управлением в стиле Vim.
* [http://en.wikipedia.org/wiki/Gentoo_%28file_manager%29 Gentoo] Gentoo является свободным файловым менеджером для Linux и других UNIX-подобных систем созданный Emil Brink. Он имеет очень простой, но весьма эффективный интерфейс, а также очень быстрый. Gentoo написан на С с использованием GTK+ toolkit
* [https://code.google.com/p/sunflower-fm/ Sunflower] Маленький и гибко настраиваемый двухпанельный файловый менеджер использующий GTK2.</text>
      <sha1>mcw10cgwx66cz1bk3hroxcpry6kqugs</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Flaw</title>
    <ns>0</ns>
    <id>673</id>
    <revision>
      <id>6702</id>
      <parentid>5408</parentid>
      <timestamp>2014-06-04T13:52:50Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1893">{{Languages}}

Flaw is a LUA object oriented library providing a thin abstraction layer above awesome widgets. It is aimed at being simple and resources efficient. flaw provides the following concepts.

;gadgets
:To add functionality to awesome widgets, flaw defines gadget objects, which are a wrapper around a widget. All gadgets have properties, events, a refresh mechanism and a data provider (see below). Gadgets can wrap text boxes, image boxes, graphs or progress bars. Flaw provides many gadgets for common system information (like CPU, memory or network activity).

;provider
:Flaw tries to minimise system access and data refresh, so data fetching is dedicated to provider objects. Since some gadgets can share information, providers can be shared by gadgets. Gadgets can update their view at will but providers refresh only when necessary (ie. when the gadget with the shortest refresh rate demands it). At last, providers can also gather non-cyclic information like mouse events.

;events
:Events are a way for the user to modify the gadget behaviour or properties when some conditions are met. An event is composed of a trigger, which computes the condition, and an action. Event triggers are tested by the providers each time when data is refreshed. Both the condition and the action are provided by the user.

== Caution ==
Comparatively to [[Obvious|Obvious]], [[Vicious|Vicious]] and other widget libraries, Flaw was developped by a single person until now, and so is rarely (at best) used or tested. It is only available from its Git repository and should always run with quite recent versions of awesome.

== Getting Flaw ==
Flaw is hosted on https://github.com/dsoulayrol/flaw. It comes with (quite a big) documentation, which is available at http://david.soulayrol.name/en/projects/flaw. Note that Flaw depends on lua-filesystem.

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>r8dqp98b5p3xwzpiwbn8m3guntp3im2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Flaw/ru</title>
    <ns>0</ns>
    <id>1097</id>
    <revision>
      <id>6704</id>
      <timestamp>2014-06-04T15:03:10Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Flaw (translating page)</comment>
      <text xml:space="preserve" bytes="3500">{{Languages|Flaw}}

Flaw это объектно-ориентированная Lua библиотека, обеспечивающая небольшую абстракцию над виджетами Awesome. Она направлена на простоту и эффективность в ресурсах. Flaw обеспечивается следующими концепциями.

;gadgets
:Чтобы добавить функциональность в виджеты Awesome, Flaw определяет объекты gadget, которые являются оберткой виджета. Все gadget имеют свойства(properties), события(events), механизм обновления и поставщик(provider) данных(см. ниже). Gadget может служить оболочкой для text boxes, image boxes, graphs или progress bars. Flaw обеспечивает множество gadget для общей информационной системы (такие как CPU, память или сетевая активность).

;provider
:Flaw старается минимизировать доступ к системе и обновления данных, поэтому получение данных передано провайдеру объектов(provider objects). Так как некоторые gadget могут обмениваться информацией, провайдеры могут иметь к ним доступ. Gadget могут обновлять их внешний вид по желанию, но провайдеры обновляются только при необходимости (т.е. когда gadget с наименьшей частотой обновления требует этого). В завершение, провайдеры могут получать нецикличную информацию, например события мыши.

;events
:События являются одним из пользовательских способов для модификации поведения или свойств gadget, при соблюдении некоторых условий. Событие состоит из триггера, который вычисляет условие и действие. Триггеры событий проверяются провайдерами каждый раз, при обновлении данных. И условие, и действие определяются пользователем.

== Предупреждение ==
По сравнению с [[Obvious/ru|Obvious]], [[Vicious/ru|Vicious]] и другими библиотеками виджетов, Flaw до сих пор разрабатывается одним человеком, и лишь изредка(в лучшем случае) тестируется. Эта библиотека доступна на его Git репозитории и всегда работает на последних версиях Awesome.

== Установка Flaw ==
Flaw располагается по адресу https://github.com/dsoulayrol/flaw. Она поставляется с (довольно большой) документацией, которая доступна на  http://david.soulayrol.name/en/projects/flaw. Имейте в виду, что Flaw зависит от lua-filesystem.

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>rdr9bd5dh6dqg9ypl7cikvjnybnmsg6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FullScreens</title>
    <ns>0</ns>
    <id>730</id>
    <revision>
      <id>6742</id>
      <parentid>5060</parentid>
      <timestamp>2014-06-09T13:26:22Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2116">{{Languages}}

The thing that annoyed me for some time was that my colleagues, using gnome, could resize their clients/windows to span both screens on our dual screen setup at work. So after some thinking and help from the awesome channel I wrote a lua function to do that with a client. 

= The function =
  function fullscreens(c)
      awful.client.floating.toggle(c)
      if awful.client.floating.get(c) then
          local clientX = screen[1].workarea.x
          local clientY = screen[1].workarea.y
          local clientWidth = 0
          -- look at http://www.rpm.org/api/4.4.2.2/llimits_8h-source.html
          local clientHeight = 2147483640
          for s = 1, screen.count() do
              clientHeight = math.min(clientHeight, screen[s].workarea.height)
              clientWidth = clientWidth + screen[s].workarea.width
          end
          local t = c:geometry({x = clientX, y = clientY, width = clientWidth, height = clientHeight})
      else
          --apply the rules to this client so he can return to the right tag if there is a rule for that.
          awful.rules.apply(c)
      end
      -- focus our client
      client.focus = c
  end

This function will:
* Toggle the floating property on the provided client as parameter.
* If the floating property becomes true it will resize the client on all screens.
* If the floating property becomes false it will restore the client's default size and tag.

= Some notes on the function =
On some machines the most left screen(from where the geometry coordinates should start is not screen[1] so
  local clientX = screen[1].workarea.x
  local clientY = screen[1].workarea.y
should be changed to 
  local clientX = screen[other_index].workarea.x
  local clientY = screen[other_index].workarea.y

= Function usage =
In my configuration Mod + f is bound to '''fullscreen''', so Mod + Shift + f seems like a nice key combination for '''fullscreens'''. To use that put this line where you define your '''clientkeys'''

  clientkeys = awful.util.table.join(
      ...
      awful.key({ modkey, &quot;Shift&quot; }, &quot;f&quot;,        fullscreens),
      ...
  )</text>
      <sha1>259lpsfmhctv4zwbfwz0i4gdenrqpnd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>FullScreens/ru</title>
    <ns>0</ns>
    <id>1110</id>
    <revision>
      <id>6744</id>
      <timestamp>2014-06-09T13:45:12Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода FullScreens (translating page)</comment>
      <text xml:space="preserve" bytes="2920">{{Languages|FullScreens}}

Дело в том, что меня раздражало то, что мои коллеги, использующие Gnome, могут растягивать приложения/окна чтобы захватить оба экрана. После некоторого размышления и помощи через Awesome IRC канал, я написал Lua функцию, которая позволяет растягивать приложение на оба экрана. 

= Функция =
  function fullscreens(c)
      awful.client.floating.toggle(c)
      if awful.client.floating.get(c) then
          local clientX = screen[1].workarea.x
          local clientY = screen[1].workarea.y
          local clientWidth = 0
          -- look at http://www.rpm.org/api/4.4.2.2/llimits_8h-source.html
          local clientHeight = 2147483640
          for s = 1, screen.count() do
              clientHeight = math.min(clientHeight, screen[s].workarea.height)
              clientWidth = clientWidth + screen[s].workarea.width
          end
          local t = c:geometry({x = clientX, y = clientY, width = clientWidth, height = clientHeight})
      else
          --apply the rules to this client so he can return to the right tag if there is a rule for that.
          awful.rules.apply(c)
      end
      -- focus our client
      client.focus = c
  end

Эта функция позволяет:
* Переключать плавающий режим на требуемом клиенте в качестве параметра.
* Если floating property установлено равным true функция будет изменять размер клиента на всех экранах.
* Если floating property установлено равным false, то будет восстановлен стандартный размер и тег для клиента.

= Некоторые замечание =
На некоторых машинах, самый левый экран (откуда начинаются геометрические координаты), это не screen[1] поэтому:
  local clientX = screen[1].workarea.x
  local clientY = screen[1].workarea.y
необходимо заменить на
  local clientX = screen[other_index].workarea.x
  local clientY = screen[other_index].workarea.y

= Использование функции =
В моем файле конфигурации Mod + f привязан к режиму '''fullscreen''', поэтому Mod + Shift + f похоже будет являться хорошей комбинацией для '''fullscreens'''. Для ее использования поместите эту строку, в разделе '''clientkeys'''

  clientkeys = awful.util.table.join(
      ...
      awful.key({ modkey, &quot;Shift&quot; }, &quot;f&quot;,        fullscreens),
      ...
  )</text>
      <sha1>7n46qrbsejjpmntiv5w6wolw6epfl7c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Getting+started</title>
    <ns>0</ns>
    <id>426</id>
    <redirect title="Getting started" />
    <revision>
      <id>3163</id>
      <timestamp>2009-06-27T09:54:11Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>moved [[Getting+started]] to [[Getting started]]</comment>
      <text xml:space="preserve" bytes="29">#REDIRECT [[Getting started]]</text>
      <sha1>hyxdsc69mgmn5h6sz4f5m6zz07i29p1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Getting started</title>
    <ns>0</ns>
    <id>425</id>
    <revision>
      <id>5953</id>
      <parentid>5952</parentid>
      <timestamp>2013-04-19T08:45:15Z</timestamp>
      <contributor>
        <username>Surfdemon</username>
        <id>2998</id>
      </contributor>
      <comment>/* Keyboard */</comment>
      <text xml:space="preserve" bytes="6178">{{Languages|Getting started}}

First, you should have [[Building awesome|built]] awesome 3. Most of the information in this guide still remain available for awesome 2.3, since the basic concepts haven’t changed.

== Concepts ==

Before even using awesome, you should know a few terms that might not be usual.

; Client : a simple window.

; Tag
: A tag can be seen as a workspace. But if you look more closely, you see that you can show
: a client on multiple tags. It's also possible to display more than one tag at the same time.

; Master windows
: The master windows are usually the ones requiring most attention. This concept comes from dwm, from which awesome got some ideas.
: The other windows are just called non-master.

; Floating window
: Usually, windows don't overlap each other. Since some applications don't work well in this mode, it's possible to make clients floating.
: Floating clients can be resized and moved freely as in non-floating window manager.

; Layout
: A layout is a way of organizing windows in a view. awesome offers the following layouts:
:*'''colums''' - master windows are displayed in the left column (or the right one: there are two layouts) and the other windows are in multiple columns.
:*'''rows''' - the same, with rows instead of columns.
:*'''magnified''' - the master window (only one in this layout) is drawn in the middle of the screen, the other ones are stacked under it in columns.
:*'''maximized''' - the master window uses all available place and the other ones are hidden.
:*'''spiral''' - the master window stays in the left half of the screen, the next on uses the half of the other half, the third on half of the remaining half, and so on clockwise.
:*'''zig-zag''' - as above, except windows are drawn from right to bottom, then right, instead of clockwise. It's easier than it sounds, just try it.
:*'''floating''' - windows can be freely moved and resized, and they can overlap each other.

== Launching awesome ==

* If you’re using a login manager as KDM or GDM, simply choose awesome in the session selection menu.
* If you start X system yourself, put this in your ~/.xinitrc:
 #! /bin/sh
 exec awesome

== Using awesome ==

=== Home screen ===
Once you’ve launched awesome, you have a screen which shows the awesome logo, and a statusbar on top, like this one below (colors might be different, and some elements could be somewhere else):
[[Image:Bar.png]]

This bar includes:
* an awesome logo.
* a list of available tags, with the currently selected tag emphasized.
* a list of clients in the current view, which is empty for now, since we haven’t any clients open yet.
* a logo of the current layout in use (colums, master windows on the left)
* the date (or UNIX timestamp in default configuration)

=== Basic mappings ===

All actions in awesome are done with a mouse or with key bindings using a main modificator. In the default config, this modificator is Mod4, meaning the “Super” key, on which usually shows a windows logo, an apple or a penguin. Some keyboards don’t have this key, so you’ll have to change the configuration as explained below. This modificator key will be called “Mod” from here on.

Here is a list of essential commands. There are so many more, and they are details in the [[Man pages|man pages]] for awesome(1), that you should read (&lt;code&gt;man 1 awesome&lt;/code&gt;).

==== Keyboard ====

; Mod + &lt;return&gt;          : Launch a terminal
; Mod + r                 : Display a prompt in the bar to run a program. You have acces to an history (↑) and completion (↹).
; Mod + shift + c         : Close the selected window.
; Mod + j, k              : Select the next, previous window.
; Mod + shift + j,k       : Move the selected window by swapping it with the next, previous one.
; Mod + Ctrl + Space        : Toggle the floating attribute of the window.
; Mod + left, right       : Display the previous, next tag.
; Mod + Ctrl + j          : Change focus to next screen (using multiple monitors).
; Mod + o                 : Move window to next screen (using multiple monitors).
; Mod + shift + space     : Change the layout (using ⇧ (Shift), doing so in the reverse order). To fully understand their caracteristics, try with many windows.
; Mod + shift + h,l       : Increase, lower the number of master windows (only useful in some layouts).
; Mod + Ctrl + h,l        : Increase, lower the number of columns for non-master windows (only useful in some layouts).
; Mod + Ctrl + r          : Relaunch awesome: allows you to reload the configuration after you modified it.
; Mod + shift + q         : Quit awesome

==== Mouse ====

; Right click in an empty region             : Open a menu
; Click on a window name in the list : Focus and display this window.
; Mod + drag a window                : Move the window. Freely if floating, swapping it with other ones if not.
; Mod + drag with right button       : Resize a floating window, or the master zone in some layouts.
; Click on a tag name in the list    : Display this tag.
; Scroll on the tag list             : Display the previous or next tag.
; Mod + click on a tag name          : Put the selected window in this tag.

== Configure awesome ==

=== Behaviour ===

Awesome 3's [[Awesome 3 configuration|configuration file]] is named rc.lua, and is located in ~/.config/awesome/. At first, you don’t have any personal config file, and the default one is used: in /etc/xdg/awesome/.

So, to configure awesome, begin with copying the system file into your directory:
 $ cp /etc/xdg/awesome/rc.lua ~/.config/awesome/rc.lua

Then, you can edit it: the comments are made to help you quickly understand how to tweak awesome (including keybinding).

=== Theming ===

Awesome's [[Beautiful|theme config file]] is loaded by your rc.lua config file:
 theme_path = &quot;/usr/share/awesome/themes/default&quot;

You can copy this file, e.g. into ~/.config/awesome/themes, then load it instead of the default one (relative path from you own directory):
 theme_path = &quot;.config/awesome/themes/default&quot;

Again, this theme file is well commented, so you should be able to quickly understand how to set it up.

[[Category:awesome3]]</text>
      <sha1>kqx5j2rv8tyb2imn7sehmb10640q2hb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Getting started/fr</title>
    <ns>0</ns>
    <id>148</id>
    <revision>
      <id>3855</id>
      <parentid>3334</parentid>
      <timestamp>2009-12-06T09:11:05Z</timestamp>
      <contributor>
        <username>Nim65s</username>
        <id>309</id>
      </contributor>
      <comment>Le rc.conf utilise maintenant les keycodes, donc plus besoin de bidouiller à cause du layout fr.</comment>
      <text xml:space="preserve" bytes="7633">{{DISPLAYTITLE:Débuter avec awesome}}
{{Languages|Getting started}}

Pour commencer, vous devez avoir [[Building awesome/fr|installé]] awesome 3. L'essentiel des informations de ce guide sont toutefois valables pour awesome 2.3, les concepts de base n'ayant pas changé.

==Concepts==

Avant de commencer à utiliser awesome, il faut d'abord préciser quelques termes qui ne sont pas forcément habituels.

; Client : Une fenêtre, tout simplement.

; Onglet
: Un onglet peut être vu en première approche comme un bureau virtuel.
: En fait, il est possible d'associer plusieurs onglets à une fenêtre, de sorte qu'elle sera visible dans la vue correspondant à chacun de ces onglets.
: De plus, il est possible d'afficher à l'écran les fenêtres d'un onglet (qui se comporte alors comme un bureau virtuel) ou de plusieurs !

; Fenêtres maîtres
: La ou les fenêtres maîtres sont normalement celles qui requièrent le plus d'attention. Ce concept provient de dwm, dont awesome s'inspire.
: Les autres fenêtres sont dites non maîtres, tout simplement.

; Fenêtre flottante
: En général, les fenêtres sont disposées de façon à ne pas se chevaucher. Certains logiciels ne sont pas adaptés à cela, et il est possible de les faire apparaître au-dessus de la mosaïque des autres fenêtres, et de les redimensionner et de les déplacer librement.

; Disposition
: Une disposition est une méthode d'organisation des fenêtres d'une vue. awesome propose les organisations suivantes :
:*'''en colonnes''' : les fenêtres maîtres sont placées dans la colonne de gauche (ou de droite, il s'agit de deux dispositions différentes) et les autres fenêtres dans d'autres colonnes de nombre variable, au choix de l'utilisateur ;
:*'''en lignes''' : pareil, mais avec des lignes à la place des colonnes ;
:*'''loupe''' : la fenêtre maître (il ne peut pas y en avoir deux dans ce mode) est placée au milieu de l'écran, et les autres sont empilées en colonne par-dessous ;
:*'''maximisée''' : la fenêtre maître occupe toute la place disponible et les autres sont cachées ;
:*'''en spirale''' : la fenêtre maître occupe la moitié gauche de l'écran, la suivante occupe la moitié de la moitié restante, la troisième occupe la moitié de la moitié de la moitié restante, et ainsi de suite en tournant.
:*'''en zig-zag''' : comme pour la disposition en spirale, sauf que les fenêtres sont placées à droite, puis en-dessous, puis à droite, au lieu de tourner. Attendez d'essayer avec plein de fenêtre, pour comprendre.
:*'''flottante''' : les fenêtres peuvent être librement déplacées et redimentionnées, et peuvent se chevaucher.

==Lancer awesome==

* Si vous utilisez un gestionnaire de connexion comme KDM ou GDM, choisissez simplement awesome dans le menu de choix de session.
* Si vous démarrez votre serveur X à la main, mettez ceci dans votre ~/.xinitrc :
 #! /bin/sh
 exec awesome

==Utiliser awesome==

===L'écran d'accueil===

Une fois que vous avez lancé awesome, vous arrivez sur un écran dont le fond présente le logo d'awesome, et qui comporte, en haut, une barre de statut à peu près comme celle-ci (les couleurs seront certainement différentes des miennes, et les différents éléments ne seront pas à la même place) :
[[Image:Bar.png]]

Cette barre contient :
* un logo awesome,
* une liste des onglets disponibles, dont l'onglet actuellement affiché est mis en valeur,
* la liste des fenêtres dans la vue courante, qui est pour le moment vide, puisque nous n'avons encore ouvert aucune fenêtre,
* le logo de la disposition actuellement utilisée (en colonnes, fenêtres maîtres à gauche),
* la date (ou le timestamp Unix, dans la configuration par défaut…).

===Manipulations de base===

Toutes les actions d'awesome se font avec la souris ou avec des combinaisons de touches qui utilisent un modificateur principal. Dans la configuration par défaut, il s'agit de Mod4, autrement dit la touche Super, qui porte souvent une fenêtre, un pomme ou un manchot. Certains claviers ne disposent pas de cette touche, et il faut alors changer la configuration (cf. plus bas). Je me référerai à cette touche sous le nom de Mod.

Voici une liste des commandes essentielles. Il y en a bien d'autres, qui sont détaillées dans les [[Man pages/fr|manuels]] d'awesome(1), que je vous invite à lire (&lt;code&gt;man 1 awesome&lt;/code&gt;).

====Au clavier====

; Mod + ↵                 : Lance un émulateur de terminal.
; Mod + r                 : Affiche dans la barre une invite pour lancer un programme. Vous avez droit à un historique (↑) et à une auto-complétion (↹).
; Mod + ⇧ + c             : Ferme la fenêtre sélectionnée.
; Mod + j, k              : Sélectionne la fenêtre suivante, précédente.
; Mod + ⇧ + j, k          : Déplace la fenêtre sélectionné en l'échangeant avec la suivante, la précédente.
; Mod + Contrôle + Espace : Rend la fenêtre flottante, ou fixe si elle est déjà flottante.
; Mod + ←, →              : Affiche l'onglet précédent, suivant.
; Mod + (⇧ +) Espace      : Change de disposition (avec ⇧ (Maj), cela change dans l'autre sens). Pour bien comprendre leurs caractéristiques, essayez-les avec de nombreuses fenêtres.
; Mod + ⇧ + h, l          : Augmente, diminue le nombre de fenêtres maîtres (seulement dans certaines dispositions).
; Mod + Contrôle + h, l   : Augmente, diminue le nombre de colonnes pour les fenêtres non maîtres (seulement dans certaines dispositions).
; Mod + Contrôle + r      : Relance awesome : cela permet de recharger la configuration après l'avoir modifiée.
; Mod + ⇧ + q             : Quitte awesome

====À la souris====

; Clic droit dans le vide                : Lance un émulateur de terminal.
; Clic sur le nom d'une fenêtre dans la liste : Affiche la fenêtre en question.
; Mod + tirer une fenêtre                : Déplace la fenêtre. Librement si elle est flottante, en l'échangeant avec d'autres si elle est fixe.
; Mod + tirer du bouton droit            : Redimensionne une fenêtre flottante, ou la zone maître dans certaines dispositions.
; Clic sur le nom d'un onglet dans la liste : Affiche l'onglet en question.
; Roulette sur la liste des onglets      : Affiche l'onglet précédent ou suivant.
; Mod + clic sur le nom d'un onglet         : Place la fenêtre sélectionnée dans l'onglet en question.

==Configurer awesome==

===Comportement===

Le [[Awesome 3 configuration/fr|fichier de configuration]] d'awesome 3 se nomme rc.lua, et se trouve dans le répertoire ~/.config/awesome/. Au départ, vous n'avez pas de fichier de configuration personnel, et c'est celui du système qui est utilisé, dans /etc/xdg/awesome/.

Donc, pour configurer awesome, commencez par copier le fichier du système dans votre répertoire personnel :
 $ cp /etc/xdg/awesome/rc.lua ~/.config/awesome/rc.lua

Vous pouvez ensuite l'éditer : c'est assez bien commenté pour comprendre rapidement comment effectuer les réglages de base (notamment les combinaisons de touches).

===Apparence===

Le [[Beautiful/fr|fichier de configuration de l'apparence]] d'awesome est chargé par le fichier de configuration rc.lua :
 theme_path = &quot;/usr/share/awesome/themes/default&quot;

Vous pouvez copier ce fichier, par exemple dans ~/.config/awesome/themes, puis le charger à la place de celui du système (les chemins relatifs partent de votre répertoire personnel) :
 theme_path = &quot;.config/awesome/themes/default&quot;

Là encore, le fichier de thème est assez bien commenté, et vous pourrez donc rapidement comprendre comment le régler.

[[Category:awesome3]]</text>
      <sha1>6w6llio1dfjcfjuniqn6f4p2ryo0edg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ghost1227 volume widget for oss</title>
    <ns>0</ns>
    <id>225</id>
    <revision>
      <id>1931</id>
      <timestamp>2008-12-11T03:18:48Z</timestamp>
      <contributor>
        <username>Ghost1227</username>
        <id>212</id>
      </contributor>
      <text xml:space="preserve" bytes="3794">=== Introduction ===

This volume widget for Awesome 3 is based heavily on [[Farhavens volume widget]]. In fact, the only real difference is that mine is built for people using OSS instead of ALSA.

The widget works like this:
* You'll have the volume displayed in your status bar, shown as the volume level followed by a '''%''' sign if the channel is unmuted or the word '''MUTE''' if it's muted.
* Pressing the left mouse-button on the widget will toggle muting
* Scrolling up or down will change the volume
* (Optional) Your media keys (if you have any) will control the volume as long as you are inside your X session and it is not locked

You'll need the following for this widget to work:

* ossmix
* awesome 3 (a GIT version from after the stable Release)
* [http://ossvol.sourceforge.net ossvol] (optional)
Note on point 3: Highly recommended - since ossmix doesn't support mute, you'll need this to make muting possible... besides, I wrote it!

=== Adding the widget ===

Add this widget definition to your rc.lua:

  volwidget = widget({ type = 'textbox', name = 'volwidget' })
  volwidget:buttons({
        button({ }, 4, function () volume(&quot;up&quot;, volwidget) end),
        button({ }, 5, function () volume(&quot;down&quot;, volwidget) end),
        button({ }, 1, function () volume(&quot;mute&quot;, volwidget) end)
  })
  volume(&quot;update&quot;, volwidget)

don't forget to add the widget '''volwidget''' to your widget box like this:

  mybottomwibox[s].widgets = {
        myiconbox,
        mpdwidget,
        '''volwidget,'''
        netwidget,
        mytextbox
  }

=== Bringing the widget to life ===

Now it's time to bring the widget to life, using the following code. Paste it right at the beginning of your rc.lua, below those lines starting with '''require'''. Change the value of '''cardid''' to the ID of your card and the value of '''channel''' to the channel you want to manage.

  channel = &quot;vol&quot;
  function volume (mode, widget)
 	if mode == &quot;update&quot; then
              local fd = io.popen(&quot;ossmix &quot; .. channel)
              local volume = fd:read(&quot;*all&quot;):match(&quot;(%d+)&quot;)
              fd:close()
                
                volume = tonumber(volume)
                
 		if volume == 0 then
 			volume = '&lt;span color=&quot;white&quot;&gt;VOL: &lt;/span&gt;&lt;span color=&quot;#C00000&quot;&gt;MUTE&lt;/span&gt;'
 		else
 			volume = '&lt;span color=&quot;white&quot;&gt;VOL: &lt;/span&gt;' .. volume .. '%'
 		end
 		widget.text = volume
 	elseif mode == &quot;up&quot; then
 		awful.util.spawn(&quot;ossmix &quot; .. channel .. &quot; +5&quot;)
 		--If you are using my ossvol script replace the previous line with the following one
 		--awful.util.spawn(&quot;ossvol -i 5&quot;)
 		volume(&quot;update&quot;, widget)
 	elseif mode == &quot;down&quot; then
 		awful.util.spawn(&quot;ossmix &quot; .. channel .. &quot; -- -5&quot;)
 		--If you are using my ossvol script replace the previous line with the following one
 		--awful.util.spawn(&quot;ossvol -d 5&quot;)
 		volume(&quot;update&quot;, widget)
 	else
 		--The mute option is useless without ossvol, ossmix does not navitely support muting
 		awful.util.spawn(&quot;ossvol -t&quot;)
 		volume(&quot;update&quot;, widget)
 	end
  end

Finally, we will be adding a timer hook to refresh the volume display every 10 seconds to reflect changes made by, for example, alsamixer:

  awful.hooks.timer.register(10, function () volume(&quot;update&quot;, volwidget) end)

This line should be pasted at the end of your rc.lua

=== Optional stuff ===

==== Setting keybindings ====

If you have multimedia keys on your keyboard which currently do nothing but look nice, you may want to add these lines to your rc.lua:

  keybinding({ }, &quot;XF86AudioRaiseVolume&quot;, function () volume(&quot;up&quot;, volwidget) end):add()
  keybinding({ }, &quot;XF86AudioLowerVolume&quot;, function () volume(&quot;down&quot;, volwidget) end):add()
  keybinding({ }, &quot;XF86AudioMute&quot;, function () volume(&quot;mute&quot;, volwidget) end):add()

[[Category:Widgets]]

[[Category:awesome3]]</text>
      <sha1>8gglue87k69r6fv89urh7uobfc6ct0e</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gigamo Battery Widget</title>
    <ns>0</ns>
    <id>193</id>
    <revision>
      <id>7315</id>
      <parentid>6070</parentid>
      <timestamp>2015-03-14T11:20:57Z</timestamp>
      <contributor>
        <username>Ksamak</username>
        <id>4291</id>
      </contributor>
      <text xml:space="preserve" bytes="7090">A simple battery widget using &lt;tt&gt;/sys/class/power_supply&lt;/tt&gt;.
It also uses naughty for notification when battery gets low.

Widget creation:

  battery_widget = wibox.widget.textbox()
  battery_widget:set_align(&quot;right&quot;)

The function:

  function batteryInfo(adapter)
      spacer = &quot; &quot;
      local fcur = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/charge_now&quot;)    
      local fcap = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/charge_full&quot;)
      local fsta = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/status&quot;)
      local cur = fcur:read()
      local cap = fcap:read()
      local sta = fsta:read()
      local battery = math.floor(cur * 100 / cap)
      if sta:match(&quot;Charging&quot;) then
          dir = &quot;^&quot;
          battery = &quot;A/C (&quot;..battery..&quot;)&quot;
      elseif sta:match(&quot;Discharging&quot;) then
          dir = &quot;v&quot;
          if tonumber(battery) &gt; 25 and tonumber(battery) &lt; 75 then
              battery = battery
          elseif tonumber(battery) &lt; 25 then
              if tonumber(battery) &lt; 10 then
                  naughty.notify({ title      = &quot;Battery Warning&quot;
                                 , text       = &quot;Battery low!&quot;..spacer..battery..&quot;%&quot;..spacer..&quot;left!&quot;
                                 , timeout    = 5
                                 , position   = &quot;top_right&quot;
                                 , fg         = beautiful.fg_focus
                                 , bg         = beautiful.bg_focus
                                 })
              end
              battery = battery
          else
              battery = battery
          end
      else
          dir = &quot;=&quot;
          battery = &quot;A/C&quot;
      end
      battery_widget:set_markup(spacer..&quot;Bat:&quot;..spacer..dir..battery..dir..spacer)
      fcur:close()
      fcap:close()
      fsta:close()
  end

Then, call the function with a timer, like this:

  battery_timer = timer({timeout = 20})
  battery_timer:connect_signal(&quot;timeout&quot;, function()
      batteryInfo(&quot;BAT1&quot;)
  end)
  battery_timer:start()

Change the 20 to the time you want, or BAT1 to BAT0 if that's what you use.

=== Addendum ===

I can second this widget as working great for me. Checking the AC status is slightly different for me though. I had to do:

  local fsta = io.open(&quot;/sys/class/power_supply/AC/online&quot;)

And check it with:

  if sta:match(&quot;1&quot;) then
    ...
  elseif sta:match(&quot;0&quot;) then
    ...

Also you can add nice colours to the battery indicator using:

  battery = &quot;&amp;lt;span color='orange'&amp;gt;&quot; .. battery .. &quot;&amp;lt;/span&amp;gt;&quot;
== Simple modular version for 3.4 ==

I've got Awesome 3.4 and had to change a few things. I also made the code simpler and more modular. Since most of the time my taskbar is hidden, I made a shortcut for a battery notification.

Creation: 
  battery_widget = widget({ type = &quot;textbox&quot; })

and add &quot;battery_widget,&quot; in :   
  mywibox[s].widgets = { 
     -- already present stuff
 }

Timer:
  battery_timer = timer({timeout = 20})
  battery_timer:add_signal(&quot;timeout&quot;, function()  batteryCheck(&quot;BAT0&quot;) end)
  battery_timer:start()

Functions :

 function batteryInfo(adapter)
    local fcur = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/charge_now&quot;)    
    local fcap = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/charge_full&quot;)
    local fsta = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/status&quot;)
    if fcur and fcap and fsta then
         local cur = fcur:read()
         local cap = fcap:read()
         local sta = fsta:read()
         local battery = math.floor(cur * 100 / cap)
         if sta:match(&quot;Charging&quot;) then
             dir = &quot;^&quot;
         elseif sta:match(&quot;Discharging&quot;) then
             dir = &quot;v&quot;
         else
             dir = &quot;&quot;
         end
        fcur:close()
        fcap:close()
        fsta:close()
        return {battery,dir}
    end
end

 function batteryShow(adapter)
     local batInfos =  batteryInfo(adapter)
     if batInfos then
         local battery = batInfos[1]
         local dir = batInfos[2]
         infos = &quot; &quot; .. dir .. battery .. &quot;% &quot; 
     else
        infos = &quot;absente&quot;
     end
       naughty.notify({title = &quot;Batterie&quot;,text = infos})
end

 function batteryCheck(adapter)
     local batInfos = batteryInfo(adapter)
     if batInfos then
         local battery = batInfos[1]
         local dir = batInfos[2]
         if dir:match(&quot;v&quot;) and tonumber(battery) &lt; 10 then
                naughty.notify({ preset = naughty.config.presets.critical,
                                 title = &quot;Batterie Low&quot;,
                                 text = &quot; &quot;.. battery .. &quot;% left&quot;,
                                 timeout = 30,
                                 font = &quot;Liberation 11&quot;, })
        end
        infos = &quot; &quot; .. dir .. battery .. &quot;% &quot;
    else
        infos = &quot;A/C&quot;
    end
    battery_widget.text = infos
 end

And the shortcut: (if you don't use keydoc, drop the last string argument)

    awful.key({modkey,           }, &quot;b&quot;, function ()  batteryShow(&quot;BAT0&quot;) end,&quot;Infos batterie&quot;),

== Simple modular version for 3.4 with display of remaining time ==
This version requires the &quot;acpi&quot; program, with regex based on v1.6 , aside of sysfs.
If you find that acpi's output has changed, you can tweak the line with io.open() to fit your needs.

add &quot;battery_widget,&quot; in :
  mywibox[s].widgets = { 
     -- already present stuff
 }

 -- declaration of widget
 battery_widget = widget({ type = &quot;textbox&quot; })

Timer:
 -- timer declaration
  battery_timer = timer({timeout = 20})
  battery_timer:add_signal(&quot;timeout&quot;, function()  batteryCheck(&quot;BAT0&quot;) end)
  battery_timer:start()

function declarations
 -- function declaration
 function batteryInfo(adapter)
    local handle = io.popen(&quot;acpi | cut -d ' ' -f 4-5 | cut -d ':' -f -2&quot;)
    local battery = handle:read(&quot;*a&quot;)
    handle:close()
    local fsta = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/status&quot;)
    local sta = fsta:read()
    fsta:close()
    local fcur = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/charge_now&quot;)
    local cur = fcur:read()
    fcur:close()
    local fcap = io.open(&quot;/sys/class/power_supply/&quot;..adapter..&quot;/charge_full&quot;)
    local cap = fcap:read()
    fcap:close()
    local batt_level = math.floor(cur * 100 / cap)
    if sta:match(&quot;Charging&quot;) then
        dir = &quot;^&quot;
    elseif sta:match(&quot;Discharging&quot;) then
        dir = &quot;v&quot;
    else
        dir = &quot;&quot;
    end
    if dir:match(&quot;v&quot;) and tonumber(batt_level) &lt; 10 then
           naughty.notify({ preset = naughty.config.presets.critical,
                            title = &quot;Batterie Low&quot;,
                            text = &quot; &quot;.. batt_level .. &quot;% left&quot;,
                            timeout = 15,
                            font = &quot;Liberation 11&quot;, })
    end
    return {battery,dir}
 end
 
 function batteryCheck(adapter)
     local batInfos = batteryInfo(adapter)
     if batInfos then
         local battery = batInfos[1]
         local dir = batInfos[2]
        infos = &quot; &quot; .. dir .. battery .. &quot; &quot;
    else
        infos = &quot;A/C&quot;
    end
    battery_widget.text = infos
 end



Note: this has to be improved (hopefully soon) to support several batteries.


[[Category:Widgets]]

[[Category:awesome3]]</text>
      <sha1>4wdd2xs1ogv0tpduegs6chd3i9tt1k9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gigamo Wifi Widget</title>
    <ns>0</ns>
    <id>194</id>
    <revision>
      <id>6365</id>
      <parentid>5679</parentid>
      <timestamp>2014-04-02T11:57:37Z</timestamp>
      <contributor>
        <username>-?!-</username>
        <id>3271</id>
      </contributor>
      <text xml:space="preserve" bytes="3130">A simple wifi widget using &quot;/sys/class/net&quot;.

Widget creation:
  
  wifiwidget = widget({type = &quot;textbox&quot;, name = &quot;wifiwidget&quot;, align = &quot;right&quot; })

The function:
  
  function wifiInfo(adapter)
      spacer = &quot; &quot;
      local f = io.open(&quot;/sys/class/net/&quot;..adapter..&quot;/wireless/link&quot;)
      local wifiStrength = f:read()
      if wifiStrength == &quot;0&quot; then
          wifiStrength = &quot;Network Down&quot;
      else
          wifiStrength = &quot;Wifi:&quot;..spacer..wifiStrength..&quot;%&quot;
      end
      wifiwidget.text = spacer..wifiStrength..spacer
      f:close()
  end

Then, call the function in a hook, like this:

  awful.hooks.timer.register(5, function()
      wifiInfo(&quot;wlan0&quot;)
  end)

Change the 5 to the time you want, or wlan0 to whichever adapter you use.

== Newer Kernel Versions ==

In newer kernel versions it seems that ''/sys/class/net/wlan0/wireless/link'' doesn't exist anymore.  Here's an alternate version based on ''/proc/net/wireless''.

Create widget as in example above:
  wifiwidget = widget({type = &quot;textbox&quot;, name = &quot;wifiwidget&quot;, align = &quot;right&quot; })

Altered wifiInfo-function:

  function wifiInfo()
      spacer = &quot; &quot;
      local wifiStrength = execute_command(&quot;awk 'NR==3 {print \$3 \&quot;%\&quot;}''' /proc/net/wireless | sed 's/\\\.//g'&quot;)
      wifiwidget.text = &quot;Wifi:&quot;..spacer..wifiStrength..spacer
  end

And the awful update hook as mentioned before:
  awful.hooks.timer.register(5, function()
      wifiInfo()
  end)

== Newer Kernel Versions and Awesome 3.5==
This version is based on the above, but has some edits. There is possibly one configuration option, which is in.
  awk 'NR==3 {printf \&quot;%.1f%%\\n\&quot;,($3/70)*100}' /proc/net/wireless
The 70 represents the maximum signal level available. This actual maximum may be different depending on your device. Run
  iwconfig wlan0
Where you replace wlan0 with your device (in my case this is wlp3s0, but wlan0 is much more common). In the result you should see &quot;Link Quality=xx/yy Signal level=-zz dBm&quot; Now yy is the maximum link quality and should replace the number 70 in the code.

  -- Wifi signal
  wifi_signal_widget = wibox.widget.textbox(&quot;?%&quot;)
  -- wifi_icon = wibox.widget.imagebox()
  function wifiInfo()
      spacer = &quot; &quot;
      local wifiStrength = awful.util.pread(&quot;awk 'NR==3 {printf \&quot;%.1f%%\\n\&quot;,($3/70)*100}' /proc/net/wireless&quot;)
      if wifiStrength == &quot;&quot; then
          -- wifi_icon:set_image(beautiful.wireless_down)
          wifi_signal_widget:set_text(&quot;&quot;)
      else
          -- wifi_icon:set_image(beautiful.wireless)
          wifi_signal_widget:set_text(spacer .. wifiStrength)
      end
  end
  wifiInfo()
  
  wifi_timer = timer({timeout=2})
  wifi_timer:connect_signal(&quot;timeout&quot;,wifiInfo)
  wifi_timer:start()

Dont forget to add your widget to your wibox.
=== widget behaviour ===
The widgets as shown above shows the link quality as a percentage. If there is no connection, nothing is shown to indicate that the wifi is disconnected. If you have no internet connection, but still got wifi the percentage is still shown. 

A stub is present for showing an image when connected and when disconnected.
[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>eeoeg6q88mjx9lr01s2nvpozzbp8ya5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gigamos Theme</title>
    <ns>0</ns>
    <id>64</id>
    <revision>
      <id>4633</id>
      <parentid>2404</parentid>
      <timestamp>2011-01-05T18:53:05Z</timestamp>
      <contributor>
        <username>UGin</username>
        <id>566</id>
      </contributor>
      <comment>IMHO screenshot of Mac OS isn't really up-to-date screenshot of awesome config</comment>
      <text xml:space="preserve" bytes="1372">  ----------------------------
  -- Gigamo's awesome theme --
  ----------------------------
  
  font                    = DejaVu Sans Mono 8
  
  bg_normal               = #000000AA
  bg_focus                = #1C1C1CAA
  bg_urgent               = #3579A8
  
  fg_normal               = #C4C4C4
  fg_focus                = #3579A8
  fg_urgent               = #EFEFEF
  
  border_width            = 1
  border_normal           = #4c4c4c66
  border_focus            = #3579A866
  border_marked           = #FF000066
  
  taglist_squares_sel     = /usr/share/awesome/themes/default/taglist/squarefw.png
  taglist_squares_unsel   = /usr/share/awesome/themes/default/taglist/squarew.png
  
  tasklist_floating_icon  = /usr/share/awesome/themes/default/tasklist/floatingw.png
  
  menu_submenu_icon       = /home/gig/.config/awesome/icons/submenu.png
  menu_height             = 15
  menu_width              = 100
  
  taglist_squares         = true
  
  titlebar_close_button   = true
  
  wallpaper_cmd           = awsetbg /home/gig/walls/diagonals.jpg
  
  awesome_icon            = /usr/share/awesome/icons/awesome16.png

'''Note:''' Images or wallpapers used in my config can also be found on github.


rc.lua can be located [http://github.com/gigamo/awesome-configs/tree/master here].

All configurations require awesome-git.


[[Category:Themes]]

[[Category:awesome3]]</text>
      <sha1>ove862xbze0gtl60uz1xqy4mhvmjjd7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gizmoguy's super-easy acpi battery widget</title>
    <ns>0</ns>
    <id>857</id>
    <revision>
      <id>6182</id>
      <parentid>5581</parentid>
      <timestamp>2013-12-07T22:35:58Z</timestamp>
      <contributor>
        <username>Ey3ball</username>
        <id>3120</id>
      </contributor>
      <text xml:space="preserve" bytes="1722">Just hacked this together as no other battery widget did what I wanted and was nice and simple. You will need [http://sourceforge.net/projects/acpiclient/ acpiclient] for this to work.

&lt;pre&gt;
-- Create an ACPI widget                                                        
batterywidget = widget({ type = &quot;textbox&quot; })                                    
batterywidget.text = &quot; | Battery | &quot;                                            
batterywidgettimer = timer({ timeout = 5 })                                     
batterywidgettimer:add_signal(&quot;timeout&quot;,                                        
  function()                                                                    
    fh = assert(io.popen(&quot;acpi | cut -d, -f 2,3 -&quot;, &quot;r&quot;))                       
    batterywidget.text = &quot; |&quot; .. fh:read(&quot;*l&quot;) .. &quot; | &quot;                         
    fh:close()                                                                  
  end                                                                           
)                                                                               
batterywidgettimer:start()
&lt;/pre&gt;

Basically all this does is pipe 'acpi' through a 'cut' to clean it up a bit, every 5 seconds.

Remember to add to your wibox. No guarantee that this will keep working in the future.

----

Awesome 3.5 :

&lt;pre&gt;
batterywidget = wibox.widget.textbox()    
batterywidget:set_text(&quot; | Battery | &quot;)    
batterywidgettimer = timer({ timeout = 5 })    
batterywidgettimer:connect_signal(&quot;timeout&quot;,    
  function()    
    fh = assert(io.popen(&quot;acpi | cut -d, -f 2,3 -&quot;, &quot;r&quot;))    
    batterywidget:set_text(&quot; |&quot; .. fh:read(&quot;*l&quot;) .. &quot; | &quot;)    
    fh:close()    
  end    
)    
batterywidgettimer:start()
&lt;/pre&gt;</text>
      <sha1>kra8nlbdxqz97j7040ln3iplgjz51t1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Global Keybindings</title>
    <ns>0</ns>
    <id>726</id>
    <revision>
      <id>7093</id>
      <parentid>5030</parentid>
      <timestamp>2014-10-30T07:48:31Z</timestamp>
      <contributor>
        <username>Lysergia</username>
        <id>3822</id>
      </contributor>
      <minor/>
      <comment>Add link to list of keysyms</comment>
      <text xml:space="preserve" bytes="692">The basic syntax for creating a global keybinding in awesome is:
  globalkeys = awful.util.table.join(globalkeys, awful.key({ &quot;modifier&quot; }, &quot;keycode&quot;,function () someLuaCodeHere() end))

Where &quot;keycode&quot; can be a named key, such as &quot;XF86AudioRaiseVolume&quot;, &quot;#123&quot; (X keycode), &quot;5&quot;, and modifier can be &quot;Ctrl&quot; or &quot;Mod1&quot;-&quot;Mod4&quot;. Capitals matter. 

Replace someLuaCodehere() with the function you wish to call on keypress.

Example:
  globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioRaiseVolume&quot;,function () volume(&quot;up&quot;, tb_volume) end))

A list of keycodes is available on [http://wiki.linuxquestions.org/wiki/List_of_Keysyms_Recognised_by_Xmodmap the linkquestions wiki].</text>
      <sha1>j1vzazv7c48v9g8j8llq9ojrk2l0qdo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Glossy theme</title>
    <ns>0</ns>
    <id>639</id>
    <revision>
      <id>4692</id>
      <parentid>4687</parentid>
      <timestamp>2011-01-21T02:48:29Z</timestamp>
      <contributor>
        <username>Tj</username>
        <id>575</id>
      </contributor>
      <text xml:space="preserve" bytes="250">[[Image:Glossy.png|thumb|Screenshot]]

Clean, light theme that is designed to be used with Glossy GTK+ theme. Includes full support for [[Delightful]] widgets.

Download information at http://solitudo.net/software/awesome/themes/

[[Category:Themes]]</text>
      <sha1>6sgyc0y8upmpgmnj6ykfpbj46jqo3uo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gmail Widget</title>
    <ns>0</ns>
    <id>6</id>
    <revision>
      <id>1271</id>
      <timestamp>2008-10-16T14:52:56Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="2302">{|cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; style=&quot;margin: 0em&quot; width=&quot;100%&quot;
|- style=&quot;background: #aea&quot;
| This widget is written for awesome 2.
|}

The following script will check an atom feed for your gmail account and output a command that can be piped to awesome-client to set the contents of a text box. For example, if you have 1 unread message, the script will output. The first argument to the script will be taken as the name of the widget you want the text to appear in.

'''Requires:'''
*awesome-git
*python
*python-feedparser

'''Usage'''
''(the second line will be piped to awesome-client)''''':'''
 # checkgmail.py mywidgetname
 0 widget_tell mywidgetname 1

'''Python script:'''
 #!/usr/bin/env python
 
 import urllib
 import feedparser
 import sys
 
 _url = &quot;https://mail.google.com/gmail/feed/atom&quot;
 
 _pwd = &quot;password&quot;
 _username = &quot;username&quot;
 _widgetName = &quot;emailbox&quot;
 
 class GmailRSSOpener(urllib.FancyURLopener):
 	def prompt_user_passwd(self, host, realm):
 		return (_username, _pwd)
 
 
 def auth():
 	opener = GmailRSSOpener()
 	f = opener.open(_url)
 	feed = f.read()
 	return feed
 
 def getUnreadMsgCount(feed):
     atom = feedparser.parse(feed)
     newmails = len(atom.entries)
     return newmails
 
 if __name__ == &quot;__main__&quot;:
     if len(sys.argv) &gt; 1:
         _widgetName = sys.argv[1]
     feed = auth()
     print &quot;0 widget_tell %s %d&quot; % (_widgetName, getUnreadMsgCount(feed))

In order to use this script to check your email regularly, you need a shell script like the following:
 #!/bin/bash
 # sleep for 5 seconds before beginning in case awesome needs more time to set up
 sleep 5
 while true; do
     echo `checkgmail.py mywidget`
     sleep 120
 done | awesome-client

It might be useful, if you set a longer interval between checking messages, to set up your widget so that right clicking it immediately checks for new messages. And you can set left click to open gmail in your browser.
 #In .awesomerc statusbar section
 textbox emailbox {
     text = &quot;N/A&quot;
     mouse {
        button = &quot;1&quot;
        command = &quot;spawn&quot;
        arg = &quot;firefox www.gmail.com&quot;
     }
     mouse {
        button = &quot;3&quot;
        command = &quot;spawn&quot;
        arg = &quot;echo `checkgmail.py emailbox` | awesome-client&quot;
     }
 }


[[Category:Widgets]]
[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>4j28ayw8j6knye2fh3t8nji97gn25ov</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gmail Widget-2</title>
    <ns>0</ns>
    <id>122</id>
    <revision>
      <id>1272</id>
      <timestamp>2008-10-16T14:53:19Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="10257">{|cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; style=&quot;margin: 0em&quot; width=&quot;100%&quot;
|- style=&quot;background: #aea&quot;
| The two scripts below are alternative approaches to [[Gmail_Widget|Gmail statusbar widget]] for Awesome-2.3. They do not require python feed parsers or other such programs.
|}
&lt;p&gt;&lt;b&gt;Requires:&lt;/b&gt;
&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;'''wget''', found in almost all distros.
&lt;/li&gt;&lt;li&gt;'''ca-certificates''' for security. If you can't get the package or don't want to, then comment out the wget command line and use the one above it, which disables security checks.
&lt;/li&gt;&lt;li&gt;'''/dev/shm''', a tmpfs ram filesystem found in most distros, or you can change the file strings to another location.
&lt;/li&gt;&lt;/ul&gt;

&lt;p&gt;&lt;b&gt;Usage:&lt;/b&gt;
&lt;/p&gt;
See the comments at the top of each script. You can run multiple instances of the scripts to check multiple accounts and have all alerts go to the same textbox. Just stagger the start as shown in the comments. You can mix the regular and &quot;nag&quot; versions - they are compatible. Both versions sit in the background and will not complain if there is no internet connection, which is useful if you run it at startup on a notebook or other box that is not always connected. They will start working once a connection is established. The regular version tries to connect every minute until it connects and then reverts to whatever interval you put on the command line. The &quot;nag&quot; version only tries at the command line interval.

You stop the alert by left-clicking on the text box, or you can set up a keyboard shortcut create the file.

&lt;p&gt;&lt;b&gt;Optional Extras:&lt;/b&gt;
&lt;/p&gt;
If you want audible alerts, then install a program like '''beep''' and uncomment the line in the alert section. Note that beep does not work on the EeePC, so try a 
program like '''tones''' which is part of the '''siggen''' package. You could also modify the scripts to play an audio file or operate a solenoid-controlled fog horn, or
whatever you want. 

It is fairly easy to modify the scripts to work with '''dzen2''' or '''zenity''' if you want.

&lt;p&gt;&lt;b&gt;Awesome-Gmail-Nag:&lt;/b&gt;
&lt;/p&gt;
The &quot;nag&quot; version assumes that you are very well disciplined and read all new mail immediately. If you don't, the &quot;nag&quot; version will alert you each time it checks. This
version simply checks the first digit of the unread message count and alerts you if that digit is not zero.

&lt;pre&gt;#!/bin/sh
# awesome-gmail-nag for awesome-2.3 by ljcohen 04 July 2008
# lines like the one below are test code - uncomment for debugging
## test commands ## any comments about test commands
#
# You need the following in your .awesomerc section &quot;statusbar mystatusbar&quot;
# textbox gmail {
#     text_align = &quot;center&quot;  mouse { button = &quot;1&quot; command = &quot;spawn&quot; arg = &quot;exec touch /dev/shm/gmail-ack-$USER&quot; }
#               }
# You can run multiple account checks in the same textbox. Just offset them in your
# .xinitrc or .xprofile like this (see usage below):
# /usr/bin/awesome-gmail-nag firstaccount password 6 &amp; # start first account 
# ( sleep 3m ; /usr/bin/awesome-gmail-nag nextaccount password 6 &amp; ) &amp; # start next account
#
############ code starts here ###########
 if [ $# -ne 3 ]; then # 
    echo Usage: $(basename $0) username password interval-in-minutes
    exit 1
 fi
#
 until [ -S ~/.awesome_ctl.0 ] ; do  # wait until awesome starts (if started in .xinitrc for example)
   sleep 2s
 done
###### real stuff starts here ############
 GMUSER=$1
 PASSWD=$2
 INTERVAL=$3
 CFILE=/dev/shm/gmail-ack-$USER	# file exists only when alert acknowledged
 GURL=&quot;https://mail.google.com/mail/feed/atom&quot;  # feed url
#  
 while [ -S ~/.awesome_ctl.0 ] ; do  # exit if awesome is not running
  # use line below if package ca-certificates is not installed - MAY BE SECURITY RISK!
  # MCOUNT=$(wget -qO- --no-check-certificate --http-user=$GMUSER --http-password=$PASSWD $GURL | grep fullcount)
  MCOUNT=$(wget -qO- --http-user=$GMUSER --http-password=$PASSWD $GURL | grep fullcount)
  ## echo $MCOUNT ## looks like &lt;fullcount&gt;36&lt;/fullcount&gt;
  MCOUNT=`expr substr &quot;$MCOUNT&quot; 12 1` # just get first digit
  ## echo Count=$MCOUNT ##
  if [ $MCOUNT -ne 0 2&gt;/dev/null ] ; then # you got mail!
     rm -f $CFILE		  # loose it (false acknowledgement)
     	while [ ! -f $CFILE ] ; do # flash the statusbar textbox
	     echo 0 widget_tell mystatusbar gmail text &quot; [*******] &quot; | awesome-client
	     # beep -f 1000
	     sleep 2
	     echo 0 widget_tell mystatusbar gmail text &quot; [$GMUSER] &quot; | awesome-client
	     sleep 2
        done
      rm -f $CFILE # get rid of alert acknowledgement file
  fi
  ##  date ## for checking sleep interval
  # line below clears textbox
  echo 0 widget_tell mystatusbar gmail text &quot;&quot; | awesome-client
  sleep $INTERVAL&quot;m&quot;  # wait for next check
 done
#
 exit 0
&lt;/pre&gt;

&lt;p&gt;&lt;b&gt;Awesome-Gmail:&lt;/b&gt;
&lt;/p&gt;
The regular version is for people like me, who do not always read new emails as they arrive, and often have many unread emails in the box. This version creates a file
in your home directory for each email account you use. The file contains the id number (explained in the script comments) of the newest message. It is read on startup
and only written to when a new message arrives. The script only alerts you if the first email has a higher id then the one stored. If the message count is zero, the id
variable and file are reset to zero.

If you are using a box with an SSD and are paranoid about writes, than delete the sections that refer to $IFILE. The script stores the working variable in memory, so the
only downside is that you will get an alert each time the program starts (normally at reboot) when the default id is zero. All other files are stored in /dev/shm, which
is a ram file system.

A warning: I do not fully understand the id, but I think it is a form of a time stamp. A new email seems to &quot;always&quot; be a higher number than the one before, though they
are not sequential. It is possible that at some point the portion of the id that I use may rollover to a lower value sequence. If that happens you will have new mail 
and no alerts, which you will notice. Just stop the script, delete the ~/.gmail-lid-&quot;your-account&quot; file and restart the program. I have been using this script for weeks
and not had any problems, but you never know.

&lt;pre&gt;#!/bin/sh
# awesome-gmail for awesome-2.3 by ljcohen 04 July 2008
# lines like the one below are test code - uncomment for debugging
## test commands ## any comments about test commands
#
# You need the following in your .awesomerc section &quot;statusbar mystatusbar&quot;
# textbox gmail {
#     text_align = &quot;center&quot;  mouse { button = &quot;1&quot; command = &quot;spawn&quot; arg = &quot;exec touch /dev/shm/gmail-ack-$USER&quot; }
#               }
# You can run multiple account checks in the same textbox. Just offset them in your
# .xinitrc or .xprofile like this (see usage below):
# /usr/bin/awesome-gmail firstaccount password 6 &amp; # start first account 
# ( sleep 3m ; /usr/bin/awesome-gmail nextaccount password 6 &amp; ) &amp; # start next account
#
############ code starts here ###########
 if [ $# -ne 3 ]; then # 
    echo Usage: $(basename $0) username password interval-in-minutes
    exit 1
 fi
#
 until [ -S ~/.awesome_ctl.0 ] ; do  # wait until awesome starts (if started in .xinitrc for example)
   sleep 2s
 done
# 
############### real stuff starts here #################
 GMUSER=$1
 PASSWD=$2
 INTERVAL=$3
# NOTE - /dev/shm is temporary ram file system. files disappear at reboot 
 CFILE=/dev/shm/gmail-ack-$USER	# file exists only when alert acknowledged
 GFILE=/dev/shm/gmail-$GMUSER	# working copy of latest feed contents
 IFILE=~/.gmail-lid-$GMUSER	# contains last id for after reboot/restart
 LASTID=0			# default last id
 GURL=&quot;https://mail.google.com/mail/feed/atom&quot;  # feed url
#    
 if [ -f $IFILE ] ; then	# check for saved count file
     LASTID=$(cat $IFILE)	# and retrive last id 
  else
     echo 0 &gt;$IFILE		# otherwise create one with id of 0 
 fi
#
 while [ -S ~/.awesome_ctl.0 ] ; do  # exit if awesome is not running
 GOGET=1
 until [ $GOGET -eq 0 ] ; do # wait for connection
  # use line below if package ca-certificates is not installed - MAY BE SECURITY RISK!
  # MCOUNT=$(wget -qO- --no-check-certificate --http-user=$GMUSER --http-password=$PASSWD $GURL | grep fullcount)
  wget -qO $GFILE --http-user=$GMUSER --http-password=$PASSWD $GURL
  GOGET=$?
  ## echo goget=$GOGET ##
  if [ $GOGET -eq 1 ] ; then
     echo 0 widget_tell mystatusbar gmail text &quot;&quot; | awesome-client
     sleep 1m
    else
     GOGET=0
  fi 
  done  
  MCOUNT=$(cat $GFILE | grep fullcount)
  ## echo $MCOUNT ## looks like &lt;fullcount&gt;36&lt;/fullcount&gt;
  MCOUNT=${MCOUNT#&lt;*&gt;} # strips &lt;fullcount&gt;
  MCOUNT=${MCOUNT%&lt;*&gt;} # strips &lt;/fullcount&gt; and leaves just number of emails
  ## echo Count=$MCOUNT ##
  if [ $MCOUNT -ne 0 ] ; then # there is an id, so process it
     ID=$(cat $GFILE | grep &quot;&lt;id&gt;&quot;)
     # each ID looks like &lt;id&gt;tag:gmail.google.com,2004:1274193124735397341&lt;/id&gt;
     # the string may contain many, we just take the first one (newest always first)
     ID=`expr substr &quot;$ID&quot; 31 19` 
     # ID now looks like 1274193124735397341
     ## echo lastid=$LASTID ; echo now-id=$ID ##
   else # there are no unread emails at all
     ID=0 ; LASTID=0
       if [ `cat $IFILE` -ne 0 ] ; then 
          echo 0 &gt;$IFILE  # clear the saved id
       fi
  fi  
#
  if [ $ID -gt $LASTID ] ; then # a new email is on top
     LASTID=$ID			# update pointer
     echo $LASTID &gt;$IFILE	# and update file
     rm -f $CFILE		  # loose (false) acknowledgement file
     	while [ ! -f $CFILE ] ; do # flash the statusbar textbox
	     echo 0 widget_tell mystatusbar gmail text &quot; [*******] &quot; | awesome-client
	     # beep -f 1000
	     sleep 2
	     echo 0 widget_tell mystatusbar gmail text &quot; [$GMUSER] &quot; | awesome-client
	     sleep 2
        done
     rm -f $CFILE # get rid of alert acknowledgement file
  fi
  ##  date ## for checking sleep interval
# line below shows account checked, number of unread emails and time of last check
#  echo 0 widget_tell mystatusbar gmail text &quot; [$GMUSER($MCOUNT)@`date +\&quot;%H:%M\&quot;`] &quot; | awesome-client
  echo 0 widget_tell mystatusbar gmail text &quot; [$GMUSER-$MCOUNT] &quot; | awesome-client
  sleep $INTERVAL&quot;m&quot;  # wait for next check
 done
#
 exit 0
&lt;/pre&gt;

--[[User:Krell46|Krell46]] 16:44, 6 July 2008 (UTC)


[[Category:Widgets]]
[[Category:awesome2]]</text>
      <sha1>3qgr9fh9yaw0a0hb98tlye2ajib3ipb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Goblin theme</title>
    <ns>0</ns>
    <id>133</id>
    <revision>
      <id>2782</id>
      <parentid>1274</parentid>
      <timestamp>2009-05-23T11:21:40Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Themes]]</comment>
      <text xml:space="preserve" bytes="690">&lt;pre&gt;
---------------------------
-- goblin awesome theme --
---------------------------

font          = sans 8

bg_normal     = #222222
bg_focus      = #23ad2c
bg_urgent     = #ff0000

fg_normal     = #aaaaaa
fg_focus      = #ffffff
fg_urgent     = #ffffff

border_width  = 3
border_normal = #222266
border_focus  = #23ad2c
border_marked = #91231c

# You can use your own command to
# set your wallpaper
wallpaper_cmd = feh --bg-scale /home/matt/.config/awesome/wallpapers/awesome-3D-wallpaper-1280x1024.png

# You can add as many variables as
# you wish and access them by using
# beautiful.variable in your rc.lua
#bg_widget    = #cc0000
&lt;/pre&gt;
[[Category:awesome2]]
[[Category:Themes]]</text>
      <sha1>jhrtiph0r2u7n8qo4ppk6uevlciyiq4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Google Translate</title>
    <ns>0</ns>
    <id>594</id>
    <revision>
      <id>6631</id>
      <parentid>6630</parentid>
      <timestamp>2014-05-23T16:50:21Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>correct tag</comment>
      <text xml:space="preserve" bytes="2546">{{Languages}}

First, you will need a translator-script. I've found two versions.
First version taken from [http://ubuntuforums.org/showpost.php?p=6870143&amp;postcount=3 here].
&lt;pre&gt;#!/usr/bin/env python
from urllib2 import urlopen
from urllib import urlencode
import sys

# The google translate API can be found here: 
# http://code.google.com/apis/ajaxlanguage/documentation/#Examples

lang1=sys.argv[1]
lang2=sys.argv[2]
langpair='%s|%s'%(lang1,lang2)
text=' '.join(sys.argv[3:])
base_url='http://ajax.googleapis.com/ajax/services/language/translate?'
params=urlencode( (('v',1.0),
                   ('q',text),
                   ('langpair',langpair),) )
url=base_url+params
content=urlopen(url).read()
start_idx=content.find('&quot;translatedText&quot;:&quot;')+18
translation=content[start_idx:]
end_idx=translation.find('&quot;}, &quot;')
translation=translation[:end_idx]
print translation&lt;/pre&gt;

Idea of second version from [http://www.commandlinefu.com/commands/view/5034/google-translate here]:
&lt;pre&gt;wget -qO- &quot;http://ajax.googleapis.com/ajax/services/language/translate?v=1.0&amp;q=$1&amp;langpair=$2|${3:-en}&quot; | sed 's/.*&quot;translatedText&quot;:&quot;\([^&quot;]*\)&quot;.*}/\1\n/'&lt;/pre&gt;

Save one of them to ''any/dir/google-translate'' and make executable.

You should add ''function aw_translate'' to your ''rc.lua''.

&lt;pre&gt;function aw_translate()
    local val = nil
    awful.prompt.run({ text=val and tostring(val),
        selectall = true,
        fg_cursor = black,
        bg_cursor = orange,
        prompt = &quot;&lt;span color='#00A5AB'&gt;Translate:&lt;/span&gt; &quot;}, mypromptbox.widget,
        function(expr)
            -- if you use the second script, you will need &quot;any/dir/google-translate&quot; .. expr .. &quot; en hu&quot;
            -- &quot;en hu&quot;: &quot;source language&quot; &quot;target language&quot;, you may want to change this
            local f = io.popen(&quot;any/dir/google-translate en hu &quot; .. expr)
            if f then
                val = f:read(&quot;*line&quot;)
                f:close()
            else
                val = &quot;&lt; error &gt;&quot;
            end
            notify_keychain = naughty.notify({
                text = expr .. ' &lt;span color=&quot;white&quot;&gt;' .. val .. &quot;&lt;/span&gt;&quot;,
                timeout = 0,
                position = &quot;bottom_right&quot;
            })
            root.keys(awful.util.table.join(
                keychain[&quot;awesome&quot;],
                awful.key({},&quot;Escape&quot;,function ()
                    reset_keychain()
                end)
            ))
        end,
        nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/translate&quot;)
end&lt;/pre&gt;

After this you can use ''aw_translate()'' (eg. with keybinding).</text>
      <sha1>i10q6brmn3p810e6n4vmfevi80q051q</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Google Translate/ru</title>
    <ns>0</ns>
    <id>1080</id>
    <revision>
      <id>6796</id>
      <parentid>6795</parentid>
      <timestamp>2014-06-14T10:24:22Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>/* Google.Translate */ добавление требований к скрипту</comment>
      <text xml:space="preserve" bytes="3790">{{Languages|Google Translate}}
{{DISPLAYTITLE:Переводчик Google}}

== Актуальная версия ==

===Яндекс.Перевод===

Создайте файл в папке с вашими скриптами ''yatranslate'':

&lt;pre&gt;
#!/bin/bash
wget -qO- http://translate.yandex.ru/tr.json/translate --post-data=&quot;srv=tr-text&amp;lang=en-ru&amp;text=$1&quot; | sed 's/&quot;//g'
&lt;/pre&gt;

Не забудьте дать права на выполнение chmod +x translate.

===Google.Translate===
Пользователь SLEDopit выложил на сайте [http://unixforum.org/index.php?showtopic=137076 UnixForum] выложил рабочий скрипт для перевода текста через Google. Я его чуть чуть модифицировал, чтобы он мог принимать значения в виде переданных аргументов, а не считывал строку из консоли. Сохраните скрипт в папке с вашими скриптами и дайте ему права на выполнение ''chmod +x gtranslate''
&lt;pre&gt;
#!/bin/bash

if [ -z &quot;$1&quot; ]
then 
        echo &quot;Exiting&quot;
fi

text=&quot;$1&quot;

l_source=&quot;auto&quot;
l_target=&quot;ru&quot;

result=$(curl -s -i --user-agent &quot;&quot; -d &quot;sl=$source&quot; -d &quot;tl=$target&quot; --data-urlencode &quot;text=$text&quot; https://translate.google.ru)
encoding=$(awk '/Content-Type: .* charset=/ {sub(/^.*charset=[&quot;'\'']?/,&quot;&quot;); sub(/[ &quot;'\''].*$/,&quot;&quot;); print}' &lt;&lt;&lt;&quot;$result&quot;)
iconv -f $encoding &lt;&lt;&lt;&quot;$result&quot; |  awk 'BEGIN {RS=&quot;&lt;/div&gt;&quot;};/&lt;span[^&gt;]* id=[&quot;'\'']?result_box[&quot;'\'']?/' | html2text -utf8 | sed 's/&lt;[^&gt;]*&gt;//g'

exit
&lt;/pre&gt;

Для работы скрипта нужно установить html2text и curl

==Настройка Awesome==

После создания скрипта, добавьте функцию aw_translate() в ваш rc.lua:
&lt;pre&gt;
function aw_translate()
    local val = nil
    awful.prompt.run({ text=val and tostring(val),
        selectall = true,
        fg_cursor = black,
        bg_cursor = orange,
        prompt = &quot;&lt;span color='#00A5AB'&gt;Translate:&lt;/span&gt; &quot;}, mypromptbox[mouse.screen].widget,
        function(expr)            
            local f = io.popen(&quot;/dir/gtranslate /&quot;&quot; .. expr .. &quot;/&quot;&quot;)
            --или замените предыдущую строку, на следующую,если хотите использовать перевод от яндекса
            --local f = io.popen(&quot;/dir/yatranslate /&quot;&quot; .. expr .. &quot;/&quot;&quot;)
            if f then
                val = f:read(&quot;*line&quot;)
                f:close()
            else
                val = &quot;&lt; error &gt;&quot;
            end
            notify_keychain = naughty.notify({
                text = expr .. ' &lt;span color=&quot;white&quot;&gt;' .. val .. &quot;&lt;/span&gt;&quot;,
                timeout = 0,
                position = &quot;bottom_right&quot;
            })
            root.keys(awful.util.table.join(
                keychain[&quot;awesome&quot;],
                awful.key({},&quot;Escape&quot;,function ()
                    reset_keychain()
                end)
            ))
        end,
        nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/translate&quot;)
end
&lt;/pre&gt;
Не забудьте прописать верный путь до вашего скрипта.

Для запуска всего этого дела,добавьте в секцию globalkeys в вашем rc.lua
  awful.key({modkey, &quot;Shift&quot;}, &quot;t&quot;, function ()aw_translate() end),  --запятая в конце обязательна!

При нажатии Mod+Shift+t появится promptbox, в котором вы можете ввести текст для перевода. После нажатия Enter, отправляется запрос, по окончании перевода, вы увидите уведомление naughty.</text>
      <sha1>0jt33v6dk7f7ds1ekzh4d3dkwrs59nd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Google reader widget</title>
    <ns>0</ns>
    <id>559</id>
    <revision>
      <id>5239</id>
      <parentid>5236</parentid>
      <timestamp>2012-01-09T00:46:19Z</timestamp>
      <contributor>
        <username>Nickbp</username>
        <id>764</id>
      </contributor>
      <comment>/* greader.py */</comment>
      <text xml:space="preserve" bytes="1940">== Using curl ==

These several lines give you the count of unread item of your [http://www.google.hu/reader google reader] account.

 function hook_google_reader(username, password)
    f = io.popen('curl --connect-timeout 1 -fsn &quot;https://www.google.com/accounts/ClientLogin?service=reader&amp;Email=' .. username .. '&amp;Passwd=' .. password .. '&quot;')
    if not f then return 0 end
    cookie = f:read(&quot;*line&quot;)
    f:close()
    command = 'curl --connect-timeout 1 -s -X GET http://www.google.com/reader/api/0/unread-count?all=true --header &quot;Cookie: ' .. cookie .. '&quot;'
    f = io.popen(command)
    if (not f) then return 0 end
    line = f:read(&quot;*line&quot;)
    i,j = string.find(line,'reading%-list&lt;/string&gt;&lt;number name=&quot;count&quot;&gt;%d+&lt;/number&gt;')
    line = string.sub(line,i,j)
    return string.gsub(line,&quot;%D&quot;,&quot;&quot;)
 end

== greader.py ==

[https://github.com/nickbp/misc-utils/blob/master/greader.py greader.py] is a script which uses a separate [http://www.mavetju.org/unix/netrc.php .netrc] for storing the username/password (like the vicious GMail widget) and which caches the login token to reduce updates to a single http query.

Create ~/.netrc if necessary, then add a line like this to it:

 machine www.google.com login ''you@gmail.com'' password ''yourpassword''

It's recommended that you use a [https://www.google.com/accounts/b/0/IssuedAuthSubTokens?hl=en generated password]. Also, make sure to ''chmod 600 ~/.netrc''.

Then put something like this in your rc.lua:

 rsswidget = widget({type = &quot;textbox&quot; })
 function update_reader()
   rsswidget.text = awful.util.pread(&quot;python &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/greader.py&quot;)
 end
 awful.hooks.timer.register(300, update_reader)
 update_reader()

Or as a vicious widget:

 rsswidget = widget({type = &quot;textbox&quot; })
 function update_reader()
   return awful.util.pread(&quot;python &quot; .. awful.util.getdir(&quot;config&quot;) .. &quot;/greader.py&quot;)
 end
 vicious.register(rsswidget, update_reader, &quot;$1&quot;, 300)</text>
      <sha1>rq367k0m9qoy93lynhbck47xf046el4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gradient</title>
    <ns>0</ns>
    <id>207</id>
    <revision>
      <id>7332</id>
      <parentid>6476</parentid>
      <timestamp>2015-06-23T19:51:46Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Fix for lua 5.3 where integers and floats are different. Thanks to Thomas Constants for reporting this.</comment>
      <text xml:space="preserve" bytes="3653">{{Languages}}

== Introduction ==
Our eyes can process graphical data much faster then numerical. The following two functions allow you to convert numerical data into a hexadecimal colorgradient given three variables {min, val, max} with the relation: min &lt;= val &lt;= max. The actual color gradient looks like this:
[[Image:Gradient.png]]

== Gradient ==
The following function converts a value between min, max into a hexadecimal color.
&lt;pre&gt;
function gradient(min, max, val)
  if (val &gt; max) then val = max end
  if (val &lt; min) then val = min end

  local v = val - min
  local d = (max - min) * 0.5
  local red, green

  if (v &lt;= d) then
    red = math.floor((255 * v) / d + 0.5)
    green = 255
  else
    red = 255
    green = math.floor(255 - (255 * (v-d)) / (max - min - d) + 0.5)
  end

  return string.format(&quot;#%02x%02x00&quot;, red, green)
end
&lt;/pre&gt;


=== Example ===
The following example shows my cores temperature and usage in a color gradient using [[Wicked]].
&lt;pre&gt;
-- {{{ CPU USAGE
cputextwidget = widget({
	type = 'textbox',
	name = 'cputextwidget',
	align = 'right'
})

wicked.register(cputextwidget, 'cpu', function(widget, args)
	cpuinfo = title(&quot;CPU&quot;)
	cpuinfo = color(cpuinfo..'['..args[2]..'% '..cputemp(0)..'°C]  ', gradient(0, 100, tonumber(args[2])))
	cpuinfo = color(cpuinfo..'['..args[3]..'% '..cputemp(1)..'°C]  ', gradient(0, 100, tonumber(args[3])))
	cpuinfo = color(cpuinfo..'['..args[4]..'% '..cputemp(2)..'°C]  ', gradient(0, 100, tonumber(args[4])))
	cpuinfo = color(cpuinfo..'['..args[5]..'% '..cputemp(3)..'°C]  ', gradient(0, 100, tonumber(args[5])))
	return cpuinfo
end, 1, nil, 2)
-- }}}
&lt;/pre&gt;

== Gradient2 ==
The following function is not limited to a gradient from green to red.
It works the same way as the original gradient, but you can specify your own start color and stop color.

&lt;pre&gt;
function gradient(color, to_color, min, max, value)
    local function color2dec(c)
        return tonumber(c:sub(2,3),16), tonumber(c:sub(4,5),16), tonumber(c:sub(6,7),16)
    end

    local factor = 0
    if (value &gt;= max ) then 
        factor = 1  
    elseif (value &gt; min ) then 
        factor = (value - min) / (max - min)
    end 

    local red, green, blue = color2dec(color) 
    local to_red, to_green, to_blue = color2dec(to_color) 

    red   = red   + math.floor(0.5 + (factor * (to_red   - red)))
    green = green + math.floor(0.5 + (factor * (to_green - green)))
    blue  = blue  + math.floor(0.5 + (factor * (to_blue  - blue)))

    -- dec2color
    return string.format(&quot;#%02x%02x%02x&quot;, red, green, blue)
end
&lt;/pre&gt;

=== Example ===
Here we calculate in the interactive lua interpreter the color in the middle of white and black. (which is obvious grey)
&lt;pre&gt;
&gt; = print(gradient(&quot;#000000&quot;,&quot;#ffffff&quot;,0,100,50))
#7f7f7f
&lt;/pre&gt;


This is a sophisticated example for [[vicious]]. It shows all your cpu cores in the form cpu1%/cpu2%/cpuX%.
If the usage of one core rise above 50%, the gradient function begin to highlight it.
The chosen color are optimised for the default theme. Adapt it to your needs.
&lt;pre&gt;
local cpuwidget = widget({ type = &quot;textbox&quot; })

vicious.register(cpuwidget, vicious.widgets.cpu,
function (widget, args)
  local text
  -- list only real cpu cores
  for i=1,#args do
    -- alerts, if system is stressed
    if args[i] &gt; 50 then
      -- from light green to light red
      local color = gradient(&quot;#AECF96&quot;,&quot;#FF5656&quot;,50,100,args[i])
      args[i] = string.format(&quot;&lt;span color='%s'&gt;%s&lt;/span&gt;&quot;, color, args[i])
    end

    -- append to list
    if i &gt; 2 then text = text..&quot;/&quot;..args[i]..&quot;%&quot;
    else text = args[i]..&quot;%&quot; end
  end

  return text
end )
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>gtvcwwkv2ruabzwx348dbxfo0elyd4k</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gradient/ru</title>
    <ns>0</ns>
    <id>1043</id>
    <revision>
      <id>6479</id>
      <timestamp>2014-05-08T08:56:40Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{Languages|Gradient}}  == Введение == Наши глаза воспринимают графическую информацию намного быстрее, чем ...&quot;</comment>
      <text xml:space="preserve" bytes="4615">{{Languages|Gradient}}

== Введение ==
Наши глаза воспринимают графическую информацию намного быстрее, чем цифровую. Следующие две функции позволяют вам конвертировать цифровые данне в шестнадцатеричный цветовой графдиент, функции получают 3 значения {min, val, max} с отношением : min &lt;= val &lt;= max. Актуальный цветовой градиент выглядит так:
[[Image:Gradient.png]]

== Градиент ==
Следующая функция преобразует значение между min и max в шестнадцатиричное значение цвета.
&lt;pre&gt;
function gradient(min, max, val)
  if (val &gt; max) then val = max end
  if (val &lt; min) then val = min end

  local v = val - min
  local d = (max - min) * 0.5
  local red, green

  if (v &lt;= d) then
    red = (255 * v) / d
    green = 255
  else
    red = 255
    green = 255 - (255 * (v-d)) / (max - min - d)
  end

  return string.format(&quot;#%02x%02x00&quot;, red, green)
end
&lt;/pre&gt;


=== Пример ===
Следующий пример показывает температуру ядра процессора в цветовом градиенте, используя библиотеку [[Wicked]].
&lt;pre&gt;
-- {{{ CPU USAGE
cputextwidget = widget({
	type = 'textbox',
	name = 'cputextwidget',
	align = 'right'
})

wicked.register(cputextwidget, 'cpu', function(widget, args)
	cpuinfo = title(&quot;CPU&quot;)
	cpuinfo = color(cpuinfo..'['..args[2]..'% '..cputemp(0)..'°C]  ', gradient(0, 100, tonumber(args[2])))
	cpuinfo = color(cpuinfo..'['..args[3]..'% '..cputemp(1)..'°C]  ', gradient(0, 100, tonumber(args[3])))
	cpuinfo = color(cpuinfo..'['..args[4]..'% '..cputemp(2)..'°C]  ', gradient(0, 100, tonumber(args[4])))
	cpuinfo = color(cpuinfo..'['..args[5]..'% '..cputemp(3)..'°C]  ', gradient(0, 100, tonumber(args[5])))
	return cpuinfo
end, 1, nil, 2)
-- }}}
&lt;/pre&gt;

== Градиент 2 ==
Следующая функция не ограничивается градиентом от зеленого до красного. Ана работает также как и обычный градиент, но вы можете определить начальный и конечный цвета.

&lt;pre&gt;
function gradient(color, to_color, min, max, value)
    local function color2dec(c)
        return tonumber(c:sub(2,3),16), tonumber(c:sub(4,5),16), tonumber(c:sub(6,7),16)
    end

    local factor = 0
    if (value &gt;= max ) then 
        factor = 1  
    elseif (value &gt; min ) then 
        factor = (value - min) / (max - min)
    end 

    local red, green, blue = color2dec(color) 
    local to_red, to_green, to_blue = color2dec(to_color) 

    red   = red   + (factor * (to_red   - red))
    green = green + (factor * (to_green - green))
    blue  = blue  + (factor * (to_blue  - blue))

    -- dec2color
    return string.format(&quot;#%02x%02x%02x&quot;, red, green, blue)
end
&lt;/pre&gt;

=== Пример ===
Здесь мы расчитываем цвет между белым и черным. (Т.е. получаем градации серого)
&lt;pre&gt;
&gt; = print(gradient(&quot;#000000&quot;,&quot;#ffffff&quot;,0,100,50))
#7f7f7f
&lt;/pre&gt;


Этот сложный пример взят из библиотеки [[vicious/ru]]. Он показывает все ядра вашего процессора cpu1%/cpu2%/cpuX%.
Если использование ядра выше 50%, функция градиента начинает подсвечивать его. Выбранные цвета оптимизированны для темы по умолчанию. Если нужно, отредактируйти под свои нужды.
&lt;pre&gt;
local cpuwidget = widget({ type = &quot;textbox&quot; })

vicious.register(cpuwidget, vicious.widgets.cpu,
function (widget, args)
  local text
  -- список только реально существующих ядер(без виртуальных)
  for i=1,#args do
    -- Предупреждение, если система перегружена
    if args[i] &gt; 50 then
      -- от светло зеленого до светло красного
      local color = gradient(&quot;#AECF96&quot;,&quot;#FF5656&quot;,50,100,args[i])
      args[i] = string.format(&quot;&lt;span color='%s'&gt;%s&lt;/span&gt;&quot;, color, args[i])
    end

    -- Добавляем в список
    if i &gt; 2 then text = text..&quot;/&quot;..args[i]..&quot;%&quot;
    else text = args[i]..&quot;%&quot; end
  end

  return text
end )
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>oeh3f0zv2cqlqmhsuml44c8o946k36v</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Gratuit's volume widget</title>
    <ns>0</ns>
    <id>690</id>
    <revision>
      <id>5364</id>
      <parentid>5027</parentid>
      <timestamp>2012-03-01T15:36:06Z</timestamp>
      <contributor>
        <username>Gratuit</username>
        <id>652</id>
      </contributor>
      <text xml:space="preserve" bytes="2657">Simple volume widget written for Awesome 3.4.10 using the Vicious library 2.0.3.
You can place this in your rc.lua. You will need to customize to your preferences(i.e. colors and size and frequency of updating)

    --Create Volume Progressbar
    -- Initialize widget
    volwidget = awful.widget.progressbar()
    -- Progressbar properties
    volwidget:set_width(8)
    volwidget:set_height(22)
    volwidget:set_vertical(true)
    volwidget:set_background_color(&quot;#232323&quot;)
    volwidget:set_border_color(nil)
    volwidget:set_color(&quot;#606060&quot;)
    volwidget:set_gradient_colors({ &quot;#606060&quot;, &quot;blue&quot; })
    --Register widget
    vicious.register(volwidget, vicious.widgets.volume, &quot;$1&quot;, 0.2, &quot;Master&quot;)
    --Mouse bindings
    volwidget.widget:buttons(awful.util.table.join(
        awful.button({ }, 4, function () awful.util.spawn_with_shell(&quot;amixer -c 0 set Master 1+ unmute&quot;) end),
        awful.button({ }, 5, function () awful.util.spawn_with_shell(&quot;amixer -c 0 set Master 1-&quot;) end)
    ))

If you want a box to appear around the widget when muted, then change the register widget line to:

    --Register widget
    vicious.register(volwidget, vicious.widgets.volume,
            function(widget, args)
                if args[2] == &quot;♩&quot; then
                    volwidget:set_border_color(&quot;#990000&quot;)
                else
                    volwidget:set_border_color(nil)
                end
                return args[1]
            end
            , 0.2, &quot;Master&quot;)


Then place it in your wiibox:

Find the section that looks like this and add the line indicated:
   mywibox[s].widgets = {
        {
            mylauncher,
            mytaglist[s],
            mypromptbox[s],
            layout = awful.widget.layout.horizontal.leftright
        },
        mylayoutbox[s],
        mytextclock,
        volwidget.widget,                                   --Add this line.
        s == 1 and mysystray or nil,
        mytasklist[s],
        layout = awful.widget.layout.horizontal.rightleft
    }
If 'Master' dosn't work for you try this(also Mute/Unmute with left click):
   --Register widget
   vicious.register(volwidget, vicious.widgets.volume, &quot;$1&quot;, 0.2, 'PCM')
   --Mouse bindings
   volwidget.widget:buttons(awful.util.table.join(
       awful.button({ }, 4, function () awful.util.spawn_with_shell(&quot;amixer -c 0 set PCM 2+ unmute &gt; /dev/null&quot;) end),
       awful.button({ }, 5, function () awful.util.spawn_with_shell(&quot;amixer -c 0 set PCM 2- &gt; /dev/null&quot;) end),
       awful.button({ }, 1, function () awful.util.spawn_with_shell(&quot;amixer set 'Master Front' `amixer get 'Master Front' | grep off &gt; /dev/null &amp;&amp; echo un`mute&quot;) end)
   ))</text>
      <sha1>aczq583ikmh3y96nra03s5zt2rdaxpj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>HelpPopup</title>
    <ns>0</ns>
    <id>1127</id>
    <revision>
      <id>7000</id>
      <parentid>6854</parentid>
      <timestamp>2014-09-08T16:50:03Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>add dynamic launcher</comment>
      <text xml:space="preserve" bytes="4574">{{Languages}}
{{DISPLAYTITLE:Help Popup}}

==Introduction==
Some time ago, began to catch myself thinking, that I do not remember certain keys for some program. When you remember basic, it still did not go, but at the same ''vim'' their more then 100, that you will agree, is almost impossible to remember.

So, I think that would not prevent what some help on hotkeys applications. Now, you can see result.

This module allows typing keybinding show notify with help, it does not matter the console or graphic application. Еhe module will define the name of application and will show for it the help.

However, there is limitation, if in console you are stopped one of programms (Ctrl+Z), the script sometimes strays, have not been able to solve ((. 

But at the same time have succeeded in, if such a'' mc'' open file for editing ''vim'' or ''nano'' and exist suited help file, then it will be displayed by him.

It looks like the following:
[[File:Vimhelp.png|300px|thumb|right|Hint for Vim]]
[[File:Iceweaselhelp.png|300px|thumb|right|Hint for Iceweasel]]

==Setting Up==
https://github.com/FaiverBES/Awesome-help

That module work in Awesome 3.4 and 3.5
Clone repository:
&lt;pre&gt;
git clone https://github.com/FaiverBES/Awesome-help.git ~/.config/awesome/help
&lt;/pre&gt;

Add in top of your ''rc.lua'':
&lt;pre&gt;
require (&quot;help/help&quot;)
&lt;/pre&gt;

If you are using either terminal than ''Xterm, UXTerm, Rxvt, URxvt, Konsole'', then add its class to value ''termClass'' in ''help.lua''. For get class of client, you can type in console, and click on them:
&lt;pre&gt;
xprop | grep CLASS
&lt;/pre&gt;
Class is the second value in quotes.

Now, module will be able to look which program is running in the terminal, and if it has a help file, display it.

If your language different from the English, change value ''lang'' to your own language. And  add same folder in ''data''.

In order that it was possible to hide the notification message add in ''rc.lua'' the following code::
&lt;pre&gt;
local help_nofify = nil
function notifyHide(mynotification)    --destroy notification by id
        if mynotification ~= nil then 
                naughty.destroy(mynotification)
                return nil
        else
                return true
        end
end
&lt;/pre&gt;

Now just add a module call. To do this, in your rc.lua ''clientkey'' section, add the following code:
&lt;pre&gt;
 awful.key({ modkey,}, &quot;z&quot;, function (c) 
                              if notifyHide(help_notify) then
                                help_notify = help.getClientName(c)
                              else
                                help_notify = nil
                               end 
                             end) ,
awful.key({ modkey, &quot;Shift&quot;}, &quot;z&quot;, function ()
                                     if notifyHide(help_notify) then
                                       help_notify = help.displayHelp(&quot;Awesome&quot;)
                                     else
                                       help_notify = nil
                                     end 
                                   end)
&lt;/pre&gt;
Now when you press'' Mod4 + z'' will be the application definition and display prompts for it (if any). And when you'' Mod4 + Shift + z'' will see help for Awesome. By pressing these keys as a notification will be hidden, or you can click on it.

In addition, I can offer more to create a menu and place it for example in ''systray'', so that you can manually call any help (eg, you can add a help file on regular expressions, or shell commands, etc.).
&lt;pre&gt;
helpLauncher = awful.widget.launcher({ image=beautiful.help_icon,  --create theme.help_icon in your theme.lua
                                     menu = help.helpMenuGenerate() })
&lt;/pre&gt;
Then add the widgets section of your ''helpLauncher''.

==Help files==
Files with the help located in the ''data'' directory and have the same name as the application. If it's not exitst, you give message with it name (note, name of application are case-sensitive). So, you can create help file for your application.

The syntax is very simple:
&lt;pre&gt;
== - section title
'' - allocated positions
&lt;/pre&gt;
The names of the sections following keys and their descriptions by a dash (-). Note that the keys are not used dash.

Note: don't using symbol of another(not English) languages (left side of string, before -), because their size 2byte and there is an incorrect alignment.

==Contact==
If you have some problem, [mailto:evg.bichan@yandex.ru write me]  about it, with subject &quot;Awesome module help&quot;. Also I will be glad if you send your files of helps, for filling base. ))</text>
      <sha1>jf63771lzi0d3jugegv43cvxmzv2cic</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>HelpPopup/ru</title>
    <ns>0</ns>
    <id>1126</id>
    <revision>
      <id>6999</id>
      <parentid>6855</parentid>
      <timestamp>2014-09-08T16:48:12Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>add dynamic launcher</comment>
      <text xml:space="preserve" bytes="8159">{{Languages|HelpPopup}}
{{DISPLAYTITLE:Справочная информация}}

==Введение==
Некоторое время назад, после того как плотно перешел на Awesome на ноутбуке, все чаще стал ловить себя на мысли, что не помню те или иные клавиши для нужной мне программы. Когда помнишь основные, это еще куда не шло, но в том же vim их более 100, что согласитесь, запомнить почти нереально. 

Поэтому подумав, решил, что не помешала бы какая нибудь помощь по горячим клавишам приложений. И вот результат перед вами.
Данный модуль позволяет набрав комбинацию клавиш вызывать подсказку именно для открытой сейчас программы, не важно консольная она или графическая. 

Правда есть ограничение, если в консоли одна из программ остановлена (Ctrl+Z), то скрипт иногда сбивается, решить пока не удалось ((. 

Но в то же время удалось добиться того, что если например в ''mc'' открыть файл на редактирование в ''vim'' или ''nano'' и есть соответствующий файл подсказок, то он будет отображен именно он. Файл с подсказкой должен существовать.
Выглядит это примерно следующим образом:
[[File:Vimhelp.png|300px|thumb|right|Подсказка для Vim]]
[[File:Iceweaselhelp.png|300px|thumb|right|Подсказка для Iceweasel]]

==Установка==
Модуль работает в 3.4 и 3.5

Клонируйте репозиторий:
&lt;pre&gt;
git clone https://github.com/FaiverBES/Awesome-help.git ~/.config/awesome/help
&lt;/pre&gt;

Затем в вашем ''rc.lua'' добавьте в начале файла:
&lt;pre&gt;
require (&quot;help/help&quot;)
&lt;/pre&gt;

Если используемый вами терминал отличается от ''Xterm, UXTerm, Rxvt, URxvt, Konsole'', то добавьте его класс в список терминалов в файле ''help.lua'' в переменную ''termClass''. Для получения класса терминала выполните команду:
&lt;pre&gt;
xprop | grep CLASS
&lt;/pre&gt;
Класс это второе значение в кавычках.

После этого модуль сможет искать какая именно программа запущена в терминале, и если для нее существует файл подсказки, выводить ее.

Поменяйте переменную ''lang'' в файле help.lua на 'ru', чтобы данные брались из соответствующего каталога.

Для того чтобы можно было скрывать уведомление добавьте в ''rc.lua'' следующий код:
&lt;pre&gt;
local help_nofify = nil
function notifyHide(mynotification)    --функция удаляет уведомление по переданному идентификатору 
        if mynotification ~= nil then 
                naughty.destroy(mynotification)
                return nil
        else
                return true
        end
end
&lt;/pre&gt;

Теперь осталось только добавить вызов модуля. Для этого в вашем rc.lua в секцию clientkey добавьте следующий код:
&lt;pre&gt;
 awful.key({ modkey,}, &quot;z&quot;, function (c) 
                              if notifyHide(help_notify) then
                                help_notify = help.getClientName(c)
                              else
                                help_notify = nil
                               end 
                             end) ,
awful.key({ modkey, &quot;Shift&quot;}, &quot;z&quot;, function ()
                                     if notifyHide(help_notify) then
                                       help_notify = help.displayHelp(&quot;Awesome&quot;)
                                     else
                                       help_notify = nil
                                     end 
                                   end)
&lt;/pre&gt;
Теперь при нажатии клавиш ''Mod4+z'' будет производиться определение приложения, и отображение подсказки для него(если существует). А при нажатии ''Mod4+Shift+z'' будет выводится подсказка для Awesome. При повторном нажатии этих же клавиш уведомление будет скрыто, или можете щелкнуть по нему мышкой.

Также можно на панель добавить виджет, который будет автоматически сканировать папку (в зависимости от выбранного языка) с файлами подсказок и выводить его в виде меню:
&lt;pre&gt;
helpLauncher = awful.widget.launcher({ image=beautiful.help_icon,  --не забудьте добавить путь до иконки в theme.lua
                                     menu = help.helpMenuGenerate() })
&lt;/pre&gt;
А затем в секцию ваших виджетов добавьте helpLauncher.

==Файлы подсказок==
Файлы с подсказками находятся в каталоге data и имеют то же название что и приложение. Если файл не найден, то будет выведено сообщение об этом, и вы сможете его создать(обращайте внимание на написание, название регистрозависимо).

Синтаксис очень простой:
&lt;pre&gt;
== - название разделов
'' - выделяемые позиции
&lt;/pre&gt;
После названий разделов следуют клавиши и их описания через тире ( - ). Обратите внимание, чтобы в клавишах не использовалось тире.
&lt;strike&gt;Также следует избегать символов : &lt; &gt; &amp; - эти символы используются в разметке и поэтому их использование может привести к ошибкам, заменяйте их комбинациями клавиш, например Shift+7.&lt;/strike&gt; 

Старайтесь также избегать использования русских символов в левой части (где клавиши), так как они имеют размер 2Байта, и происходит некорректный центровка.

Все приведенные файлы помощи, являются демонстрационными, редактируйте их по своему усмотрению.

==Планы ==
*Сделать подсказки на весь экран (пока не удалось добиться хорошего результата, из за того, что сбивается разметка).
*Добавить возможность установки максимальной ширины колонки
*Вынести настройки цветов и шрифтов отдельно

==Обратная связь==
Если у вас что то не работает, не стесняйтесь  [mailto:evg.bichan@yandex.ru пишите мне] с темой &quot;Awesome module help&quot;. Также буду рад, если пришлете ваши файлы подсказок, для наполнения базы. ))</text>
      <sha1>iuto8s7yl3jjeav13n1j7hm5zynggny</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Hidetray</title>
    <ns>0</ns>
    <id>1302</id>
    <revision>
      <id>7321</id>
      <parentid>7320</parentid>
      <timestamp>2015-04-28T21:55:55Z</timestamp>
      <contributor>
        <username>Seniorivn</username>
        <id>4288</id>
      </contributor>
      <comment>/* Customization */</comment>
      <text xml:space="preserve" bytes="1594">{{Languages}}

{{VersionSpecific
| goodversions = 3.5
}}
=== Description ===

If you don't like tray look, or you use a lot of tray items and it too big in your panel you can use this . It allows you to show/hide your tray when your panel under the mouse/or not or by the keybinding and when tray updates.

=== Howto ===

* Clone https://github.com/seniorivn/awesome-hidetray

* Require the module in '''rc.lua''':

    local hidetray = require(&quot;hidetray&quot;)

* Get table of hidden trays and add them where you want, attach any widget or panel to show tray when this panel or widget under the mouse
    tray = hidetray()
    for s = 1, screen.count() do
        hidetray:attach({ wibox = mywibox[s], screen = s})
        right_layout:add(tray[s])
    end
* You can show tray on start for а few seconds
  hidetray:show(1)
  hidetray.hidetimer:start()
* Add shortcut
   awful.key({ modkey,           }, &quot;/&quot;,      function () 
    hidetray:show(mouse.screen) 
    hidetray.hidetimer:start()
  end),

* Don't forget to remove the default system tray from your panel. You should delete this line:

    if s == 1 then right_layout:add(wibox.widget.systray()) end

=== Customization ===
* by default args is 

    local number = args.number or screen.count()
    local backgr = args.background or wconst
    local gettimerscreen = args.focusscreen or function() return mouse.screen end
    hidetray.traybufer = args.traybufer or awfwibox({ x = -55, y = -55})
    hidetray.hidetimer = timer({ timeout = args.timeout or 5 })

* you can change it if you want

[[Category:Widgets]]

[[Category:Awesome3.5]]</text>
      <sha1>5h1x0dxs7orozdgf7r7qx4g3pfdzahf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Hints</title>
    <ns>0</ns>
    <id>352</id>
    <revision>
      <id>7392</id>
      <parentid>6716</parentid>
      <timestamp>2015-11-17T14:24:32Z</timestamp>
      <contributor>
        <username>Barlik</username>
        <id>4310</id>
      </contributor>
      <text xml:space="preserve" bytes="750">{{Languages}}

Window hints for Awesome. After pressing keybinding, letters will pop up on each window and you can select a window to focus by pressing the corresponding letter.

==Instalation==

You can get it here: https://github.com/guotsuan/hints

Put hints.lua in the awesome config directory (~/.config/awesome)

Load hints module (in rc.lua):

  local hints = require(&quot;hints&quot;)

Initialize (in rc.lua, must be after beautiful.init()):

  hints.init()

Add a keybinding to run hints.focus() (in rc.lua in globalkeys declaration):

  awful.key({ modkey }, &quot;j&quot;, function () hints.focus() end),

==Usage==

Now, when you press modkey + j, letters will pop up on each window and you can select a window to focus by pressing the corresponding letter.</text>
      <sha1>eocny9yh3gb90c21f0fs2dh6tezmbcg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Hints/ru</title>
    <ns>0</ns>
    <id>1103</id>
    <revision>
      <id>6718</id>
      <timestamp>2014-06-06T18:03:33Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Hints (translating page)</comment>
      <text xml:space="preserve" bytes="959">{{Languages|Hints}}

Оконные подсказки для Awesome.

== Установка Hints ==

Вы можете скачать модуль здесь: https://github.com/zackpete/hints

Поместите файл hints.lua в каталог с конфигами awesome (~/.config/awesome)
Загрузите модуль hints в rc.lua:
   require(&quot;hints&quot;)

Инициализируйте его в rc.lua, разместив после beautiful.init():
   hints.init()

Добавьте клавиатурное сочетание для запуска hints.focus() (в rc.lua секция globalkeys):

   awful.key({ modkey }, &quot;j&quot;, function () hints.focus() end),

== Использование ==

Когда вы нажимаете modkey + j, над каждым окном появляется подсказка в виде буквы, и вы можете выбрать окно нажав соответствующую букву.</text>
      <sha1>5hpbfv7258ijgg5bi9n1yvmwxtv6auy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>How to add awesome to gdm3</title>
    <ns>0</ns>
    <id>1235</id>
    <revision>
      <id>7129</id>
      <parentid>7128</parentid>
      <timestamp>2014-12-05T00:41:27Z</timestamp>
      <contributor>
        <username>MohsenPahlevanzadeh</username>
        <id>4089</id>
      </contributor>
      <text xml:space="preserve" bytes="245">When you use gdm3 , May be you don't see awesome in WMs of gdm, for adding awesome to this list it's enough to do :
 gsettings set org.gnome.desktop.session session-name awesome

Above line store for defualt session and list your awesome in WMs.</text>
      <sha1>bjeecwnc84atzh5c29zu5qu6bd3f404</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>How to take ScreenShot with PrntScr key</title>
    <ns>0</ns>
    <id>1237</id>
    <revision>
      <id>7136</id>
      <parentid>7135</parentid>
      <timestamp>2014-12-11T18:49:56Z</timestamp>
      <contributor>
        <username>MohsenPahlevanzadeh</username>
        <id>4089</id>
      </contributor>
      <text xml:space="preserve" bytes="453">At first, you need to add the following code to your rc.lua:
 awful.key({ }, &quot;Print&quot;, function () awful.util.spawn(&quot;scrot -e 'mv $f ~/screenshots/ 2&gt;/dev/null'&quot;) end),

Above code define command scrot to take screenShot, when you restart your aweseome, After pressing PrntScr key , You find at your screenshots directory with the following format:
 2014-12-11-211641_1366x768_scrot.png

DONT FORGET TO CREATE screenshots DIRECTORY:

 mkdir ~/screenshots</text>
      <sha1>8y8rlhupca70jhlrh0n5k5sheuj461w</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>IM tips</title>
    <ns>0</ns>
    <id>515</id>
    <revision>
      <id>6559</id>
      <parentid>6052</parentid>
      <timestamp>2014-05-19T09:36:52Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="4006">{{Languages}}
This page shows some examples on how to configure awesome for use with certain IM clients.

== CenterIM ==

[http://www.centerim.org/index.php/Main_Page CenterIM] is a terminal based IM program supporting a bunch of protocols.
== Finch ==

A terminal based IM program alternative to Pidgin. It uses existing Pidgin configuration files and the libpurple library. This comes in especially handy if you're migrating from a different window manager environment and have Pidgin already configured. 

[http://tuxarena.blogspot.com/2010/09/guide-to-using-finch-terminal-based.html Great guide to get you started.]

== Pidgin ==
By default Pidgin doesn't set urgent hints on its windows when new message arrives. But it could be enabled via standard plug-in: go to '''Tools -&gt; Plugins''' ''(or press Ctrl-U)'' '''-&gt; Message Notification -&gt;''' and check '''Set window manager &quot;URGENT&quot; hint''' combobox.


== Gajim ==
Recent versions of Gajim have a very useful feature for use with tiling window managers; it can keep the roster and chats in a single window (much like Tkabber does). To enable this feature go to: ''Preferences -&gt; General -&gt; Window behaviour'' and select: ''Single window for everything''.

If for some reason you want to separate the roster from your chat windows here are some tips to get you started. First one being to dedicate a whole tag to Gajim - even though it supports tabbed windows when you open service discovery, have some file transfers, check user info etc. it can clutter your screen fast.

=== Tag settings ===
Once you dedicate a tag to Gajim you can setup a custom ''mwfact'' (master width factor) for it in the tag creation loop, to reserve a narrow space for your roster. I ([[User:anrxc]]) have a resolution of 1280x800 and find ''0.13'' to be a good value for the ''tile'' layout (where 'N' is the tag number):

  awful.tag.setproperty(tags[s][N], &quot;mwfact&quot;, 0.13)

=== Rules ===
The above tag property works best if you use ''setslave'', so that the chat and other windows don't hijack this narrow space you reserved for your roster. If you decided to dedicate a tag to Gajim you also need a rule that will automatically move all your Gajim windows to that tag. We can solve both of these usability problems in the ''awful.rules.rules'' table (where 'S' is the screen number and 'N' the tag number):

  { rule       = { class = &quot;Gajim.py&quot; },
    properties = { tag   = tags[S][N] },
    callback   = awful.client.setslave },


== Psi and qutIM ==
=== Tag settings ===
I ([[User:DsTr]]) use these tag settings (where 'N' is the tag number):

  awful.tag.setncol(2, tags[s][N])
  awful.tag.setnmaster (1, tags[s][N])
  awful.tag.setmwfact (0.2, tags[s][N])

Rules:

  { rule = { class = &quot;psi&quot; },
      properties = { tag = tags[s][N] } },
  { rule = { class = &quot;Qutim&quot; },
      properties = { tag = tags[s][N] } },

=== Manage signal/hook ===
  if c.class == &quot;psi&quot; and not c.name:find(&quot;Psi&quot;) then
    awful.client.setslave(c)
  end
  
  if c.class == &quot;Qutim&quot; and not c.role:find(&quot;contactlist&quot;) then
    awful.client.setslave(c)
  end

On lastest versions of awesome3 can use &quot;new&quot; signal

=== Additional rule ===

An alternative to using the 'manage' signal is to add a second rule below the ones above:

&lt;pre&gt;
{ rule_any = { class = { &quot;psi&quot;, &quot;Psi&quot; } }, except = { instance = &quot;main&quot; },
  callback = awful.client.setslave },
&lt;/pre&gt;

This makes all Psi windows slaves, except the contact list.  This may be slightly more efficient, since the code in the 'manage' signal is run more frequently than the rules are checked.

== Freetalk ==

For [http://www.gnu.org/software/freetalk/ freetalk] one can use a hook like this (requires wmctrl and freetalk windows title to contain &quot;freetalk&quot;):

 (add-hook! ft-message-receive-hook 
     (lambda (time from nickname message)
         (system &quot;for w in $(wmctrl -l|grep freetalk|awk '{print $4}'); do wmctrl -r $w -b add,demands_attention; done&quot;)))

P.S. Still wondering if there's a better solution.

[[Category:Awesome3]]</text>
      <sha1>4w7xn34x7hqv1h1l5e1hpxmjul88tdz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>IM tips/ru</title>
    <ns>0</ns>
    <id>1061</id>
    <revision>
      <id>6562</id>
      <parentid>6561</parentid>
      <timestamp>2014-05-19T16:46:02Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Настройка тегов */ разделил на разделы(divide for section)</comment>
      <text xml:space="preserve" bytes="9747">{{DISPLAYTITLE:Советы по использованию месенджеров}}
{{Languages|IM tips}}
This page shows some examples on how to configure awesome for use with certain IM clients.

== CenterIM ==

[http://www.centerim.org/index.php/Main_Page CenterIM] терминально ориентированная программа IM поддерживающая кучу протоколов.

== Finch ==

Терминальный месенджер, являющийся альтернативой Pidgin. Он использует существующие файлы конфигурации Pidgin и библиотеку libpurple. Это особенно удобно, если вы переходите с других оконных менеджеров и/или имеете уже настроенный Pidgin. 

[http://tuxarena.blogspot.com/2010/09/guide-to-using-finch-terminal-based.html Великолепное руководство для начинающих.]

== Pidgin ==

Настройка Pidgin была опубликована [http://help.ubuntu.ru/wiki/awesome#pidgin_%D0%B2_awesome пользователем Сперанский] 

В Awesome работа с этим распространенным мессенджером станет удивительно приятной и удобной! Для этого нам нужно:

  1. Настроить схему отображения клиентов на выбранном тэге;
  2. Назначить Pidgn выбранный тэг по умолчанию;
  3. Присвоить окнам чатов статус slave по умолчанию (что позволит списку контактов оставаться всегда в мастер-зоне).

=== Настройка тегов ===

Для начала определимся со схемами, небольшая часть раздела layouts:
  layouts =
  {
    awful.layout.suit.floating,
    awful.layout.suit.tile,  -- в данном случае нас интересует именно эта схема
    ...
  }
В нашем примере закрепляем за Pidgin тег 4: 

  -- {{{ Tags
  -- Define a tag table which hold all screen tags.
  tags = {
  names = {&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;,},
  layout = {layouts[2], layouts[2], layouts[4], &lt;b&gt;layouts[2]&lt;/b&gt;, layouts[4], layouts[2]}
  }
  for s = 1, screen.count() do
      -- Each screen has its own tag table.
      tags[s] = awful.tag(tags.names, s, tags.layout)
      awful.tag.setncol(2, tags[s][4])                         -- эта и следующая строчка нужна для Pidgin
      awful.tag.setproperty(tags[s][4], &quot;mwfact&quot;, 0.20)        -- здесь мы устанавливаем ширину списка контактов в 20% от ширины экрана
  end

=== Правила ===
В правилах (rule) для поиска конкретного приложения или его свойств, вы можете использовать вместе свойства class и role, который можно узнать запустив: 
  xprop | grep -i class
  xprop | grep -i role
Более подробно о настройке правил(rule) вы можете ознакомиться на странице [[Understanding_Rules/ru|Разбираем правила(rules)]]

Для окна списка контактов Pidgin свойство role имеет значение buddy_list, для окон чатов- conversation. Добавляя приведенный ниже код в ваш rc.lua, вы определяете открытие окна списка контактов в тэге 4, и открытие окна чата в тэге 4 и пометкой его как slave, что будет переносить его сразу в стэк-зону. 
    { rule = { class = &quot;Pidgin&quot;, role = &quot;buddy_list&quot;},
      properties = { tag = tags[1][4] } },
    { rule = { class = &quot;Pidgin&quot;, role = &quot;conversation&quot;},
      properties = { tag = tags[1][4]}, callback = awful.client.setslave },

=== Уведомления на ярлыке тега ===
По умолчанию в Pidgin не устанавлены уровни срочности (urgent hints) в его окнах при появлении новых сообщений. Но вы можете включить эту возможность используя стандратный плагин: перейдите в '''Средства -&gt; Модули''' ''(или нажмите Ctrl-U)'' '''-&gt; Уведомления о сообщениях -&gt;'''и в его настройках включите '''Установить подсказку СРОЧНО в оконном менеджере'''.
У меня в системе ярлык тега при поступлении сообщения подсвечивается красным цветом.

== Gajim ==
В последних версиях Gajim появилось много полезных возможностей для использования в тайлинговых оконных менеджерах; он может держать список контактов и чаты в одном окне (как это сдлеано в Tkabber). Для включения этой функции перейдите: ''Preferences -&gt; General -&gt; Window behaviour'' и выберите: ''Single window for everything''.

Если по какой то причине, вы хотите разделить список контактов и чат, далее приведены несколько советов с которых можно начать. Во первых вам лучше будет выделить весь тег для Gajim - хотя он и поддерживает табулированные окна, когда вы открвате сервис поиска, передачи файлов, вывода информации о пользователя и т.д. они могут довольно быстро загромоздить весь экран.

=== Настройки тегов ===
Однажды выделив тег для Gajim вы можете настроить пользовательский ''mwfact'' (мастер фактор ширины) в цикле создания тегов, чтобы зарезервировать узкое пространство для списка контактов. Я ([[User:anrxc]]) имею разрешение 1280x800 и вычислил, что ''0.13'' является оптимальным значением для схемы ''tile'' (где 'N' это номер тега):

  awful.tag.setproperty(tags[s][N], &quot;mwfact&quot;, 0.13)

=== Правила(rules) ===
Свойства тегов работают отлично, если вы укажите ''setslave'', поэтому чат и другие окна не смогут захватить пространство предназначенное для списка контактов. Если вы решите выделить тег для Gajim вам также будет необходимы правила которые будут автоматически перемещать все окна Gajim на этот тег. Мы можем решить эту проблему используя таблицу в ''awful.rules.rules'' (где 'S' это номер экрана и 'N' номер тега):

  { rule       = { class = &quot;Gajim.py&quot; },
    properties = { tag   = tags[S][N] },
    callback   = awful.client.setslave },


== Psi и qutIM ==
=== Настройки тегов ===
Я ([[User:DsTr]]) использую следующие настройки тегов (где 'N' это номер тега):

  awful.tag.setncol(2, tags[s][N])
  awful.tag.setnmaster (1, tags[s][N])
  awful.tag.setmwfact (0.2, tags[s][N])

Правила:

  { rule = { class = &quot;psi&quot; },
      properties = { tag = tags[s][N] } },
  { rule = { class = &quot;Qutim&quot; },
      properties = { tag = tags[s][N] } },

=== Управление signal/hook ===
  if c.class == &quot;psi&quot; and not c.name:find(&quot;Psi&quot;) then
    awful.client.setslave(c)
  end
  
  if c.class == &quot;Qutim&quot; and not c.role:find(&quot;contactlist&quot;) then
    awful.client.setslave(c)
  end

В последих версиях awesome3 можно использовать &quot;новые&quot; сигналы

=== Дополнительные rule ===

В качестве альтернативы испльзования 'manage' signal добавьте второе правило после описанного выше:

&lt;pre&gt;
{ rule_any = { class = { &quot;psi&quot;, &quot;Psi&quot; } }, except = { instance = &quot;main&quot; },
  callback = awful.client.setslave },
&lt;/pre&gt;

Это сделает все окна Psi вторичными, исключая список контактов. Это может быть намного более эффективно, так как код с 'manage' signal запускается намного чаще чем проверяются правила.

== Freetalk ==

Для [http://www.gnu.org/software/freetalk/ freetalk] можно использовать хук, как это (требуется название окон wmctrl и freetalk для содержания &quot;freetalk&quot;):

 (add-hook! ft-message-receive-hook 
     (lambda (time from nickname message)
         (system &quot;for w in $(wmctrl -l|grep freetalk|awk '{print $4}'); do wmctrl -r $w -b add,demands_attention; done&quot;)))

P.S. Тем не менее, интересно, существует ли лучшее решение.

[[Category:Awesome3]]</text>
      <sha1>1626ry0ayibl0853sjuf4q1lm5bo90b</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Identica Prompt</title>
    <ns>0</ns>
    <id>487</id>
    <revision>
      <id>6646</id>
      <parentid>4067</parentid>
      <timestamp>2014-05-24T17:30:17Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2508">{{Languages}}

It is possible to tweet or dent directly from a prompt box.
Insert next line in the key bindings section near &quot;-- Prompt&quot;&lt;br&gt;
&lt;code&gt;
   key({ modkey }, &quot;F5&quot;,
        function ()
            awful.prompt.run({ prompt = &quot;Post Dent: &quot; },
            mypromptbox[mouse.screen],
            function (expr)
                awful.util.spawn(&quot;curl -u user:pass -d status=\&quot;&quot;..awful.util.escape(expr)..&quot;\&quot; -d source=awesomewm -k https://identi.ca/api/statuses/update.xml&quot;
            end)
   end),
&lt;/code&gt;

If you have several accounts:
&lt;code&gt;
    awful.key({ modkey }, &quot;t&quot;,
         function ()
            awful.prompt.run({ prompt = &quot;Tweet as: &quot; },
              mypromptbox[mouse.screen].widget,
              function (username)
                awful.prompt.run({ prompt = &quot;Tweet as &quot; .. username .. &quot;: &quot; },
                  mypromptbox[mouse.screen].widget,
                  function(tweet)
                    awful.util.spawn(
                      &quot;curl -u &quot; ..
                      username ..
                      &quot;:YourPasswordHere -d status=\&quot;&quot; ..
                      awful.util.escape(tweet) ..
                      &quot;\&quot; -d source=awesomewm -k https://twitter.com/statuses/update.xml&quot;)
                  end)
              end,
              function(cmd, cur_pos, ncomp)
                return awful.completion.generic(cmd, cur_pos, ncomp, { &quot;Account1&quot;, &quot;Account2&quot; })
              end)
          end),
&lt;/code&gt;

For Twitpic (requires ImageMagick):
&lt;code&gt;
    awful.key({ modkey, &quot;Shift&quot; }, &quot;t&quot;,
         function ()
           if(os.execute(&quot;import /tmp/twitpic.png&quot;) == 0) then
             awful.prompt.run({ prompt = &quot;Tweet a pic as: &quot; },
               mypromptbox[mouse.screen].widget,
               function (username)
                 awful.prompt.run({ prompt = &quot;Tweet a pic as &quot; .. username .. &quot;: &quot; },
                   mypromptbox[mouse.screen].widget,
                   function(tweet)
                     awful.util.spawn(
                       &quot;curl -F media=@/tmp/twitpic.png -F username=&quot; ..
                       username ..
                       &quot; -F password=YourPasswordHere -F message=\&quot;&quot; ..
                       awful.util.escape(tweet) ..
                       &quot;\&quot; http://twitpic.com/api/uploadAndPost&quot;)
                   end)
               end,
               function(cmd, cur_pos, ncomp)
                 return awful.completion.generic(cmd, cur_pos, ncomp, { &quot;Account1&quot;, &quot;Account2&quot; })
               end)
           end
         end),
&lt;/code&gt;</text>
      <sha1>a63w8qb65fyguwnfx89gcqcucerp6kg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Identica Prompt/ru</title>
    <ns>0</ns>
    <id>1083</id>
    <revision>
      <id>6648</id>
      <timestamp>2014-05-24T18:23:20Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Identica Prompt (translating page)</comment>
      <text xml:space="preserve" bytes="2703">{{Languages|Identica Prompt}}

С помощью этой статьи вы сможете отрпавлять твиты непосредственно из promptbox.
Вставьте следующие строки в секцию клавиатурных сочетаний &quot;-- Prompt&quot;&lt;br&gt;
&lt;code&gt;
   key({ modkey }, &quot;F5&quot;,
        function ()
            awful.prompt.run({ prompt = &quot;Post Dent: &quot; },
            mypromptbox[mouse.screen],
            function (expr)
                awful.util.spawn(&quot;curl -u user:pass -d status=\&quot;&quot;..awful.util.escape(expr)..&quot;\&quot; -d source=awesomewm -k https://identi.ca/api/statuses/update.xml&quot;
            end)
   end),
&lt;/code&gt;

Если у вас несколько аккаунтов:
&lt;code&gt;
    awful.key({ modkey }, &quot;t&quot;,
         function ()
            awful.prompt.run({ prompt = &quot;Tweet as: &quot; },
              mypromptbox[mouse.screen].widget,
              function (username)
                awful.prompt.run({ prompt = &quot;Tweet as &quot; .. username .. &quot;: &quot; },
                  mypromptbox[mouse.screen].widget,
                  function(tweet)
                    awful.util.spawn(
                      &quot;curl -u &quot; ..
                      username ..
                      &quot;:YourPasswordHere -d status=\&quot;&quot; ..
                      awful.util.escape(tweet) ..
                      &quot;\&quot; -d source=awesomewm -k https://twitter.com/statuses/update.xml&quot;)
                  end)
              end,
              function(cmd, cur_pos, ncomp)
                return awful.completion.generic(cmd, cur_pos, ncomp, { &quot;Account1&quot;, &quot;Account2&quot; })
              end)
          end),
&lt;/code&gt;

Для Twitpic (требуется ImageMagick):
&lt;code&gt;
    awful.key({ modkey, &quot;Shift&quot; }, &quot;t&quot;,
         function ()
           if(os.execute(&quot;import /tmp/twitpic.png&quot;) == 0) then
             awful.prompt.run({ prompt = &quot;Tweet a pic as: &quot; },
               mypromptbox[mouse.screen].widget,
               function (username)
                 awful.prompt.run({ prompt = &quot;Tweet a pic as &quot; .. username .. &quot;: &quot; },
                   mypromptbox[mouse.screen].widget,
                   function(tweet)
                     awful.util.spawn(
                       &quot;curl -F media=@/tmp/twitpic.png -F username=&quot; ..
                       username ..
                       &quot; -F password=YourPasswordHere -F message=\&quot;&quot; ..
                       awful.util.escape(tweet) ..
                       &quot;\&quot; http://twitpic.com/api/uploadAndPost&quot;)
                   end)
               end,
               function(cmd, cur_pos, ncomp)
                 return awful.completion.generic(cmd, cur_pos, ncomp, { &quot;Account1&quot;, &quot;Account2&quot; })
               end)
           end
         end),
&lt;/code&gt;</text>
      <sha1>rgizcfztjik2bvucavag68a4z5k0z4h</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Installer awesome</title>
    <ns>0</ns>
    <id>407</id>
    <redirect title="Building awesome/fr" />
    <revision>
      <id>3039</id>
      <timestamp>2009-06-25T20:25:16Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Installer awesome]] to [[Building awesome/fr]] over redirect: Fix for [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="33">#REDIRECT [[Building awesome/fr]]</text>
      <sha1>go63lt8zb14mw3qkcmxaw07e0d1hk12</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Integrating widgets into awesome</title>
    <ns>0</ns>
    <id>349</id>
    <revision>
      <id>2796</id>
      <timestamp>2009-05-24T18:12:34Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding an english translation of [[Einfache_Widgets_integrieren]] done by farhaven</comment>
      <text xml:space="preserve" bytes="2800">{{Languages}}

This tutorial is a short introduction into text widgets for Awesome 2.3.x
A little understanding of bash scripting helps a lot here.

[[Image:Awesome_statusbar_awesomewiki.jpg]]

== Preparing a textbox ==

First, we add the new textbox to your ~/.awesomerc:

 screen 0
 {
    general
    {
        ...
    }
    ...
    statusbar mystatusbar
    {
        taglist mytaglist
        {
            ...
        }
        ### THE TEXTBOX STARTS HERE ###
        textbox mytextbox
        {
            align = &quot;right&quot;
            text_align = &quot;right&quot;
            width = &quot;120&quot;
            text = &quot;foobar&quot;
        }
    }
 }

The 'width' parameter should be tweaked to fit the text contained by the box.
If you just want a static textbox which doesn't change its content, you are done now.
If you want the content to change from time to time, read on.

== Dynamic data ==

If you want the content of your textbox to change, you can remove the 'text' property from
the textbox above, as it will be set by an external shellscript.

For setting the content of a textbox to the output of some program, usually a command like
the following is used:

 echo &lt;screen&gt; widget_tell &lt;statusbar&gt; &lt;textbox name&gt; text `&lt;program&gt;` | awesome-client

&lt;screen&gt; is to be replaced by the screen the widget is on, starting with 0
&lt;statusbar&gt; is to be replaced by the name of the statusbar the widget is on, in our example the name is 'mystatusbar'
&lt;textbox name&gt; is to be replaced by the textbox name, which is 'mytextbox' in the example
&lt;program&gt; is to be replaced by the program to read from, the following example will use 'date +%H:%M:%S' for that

Now create the file ~/.awesome/widgets with the following content:

 #!/bin/bash
 while true
 do
    echo 0 widget_tell mystatusbar mytextbox text &quot;[`date +%H:%M:%S`]&quot; | awesome-client
    sleep 1
 done

This will update the time displayed by the widget every second ad infinitum.

Now make the file executable:

 chmod +x ~/.awesome/widgets

And add it to your ~/.xsession or ~/.xinitrc:

 ~/.awesome/widgets &amp;
 exec awesome

If you then log out and back in, the time should be shown in a new widget on your status bar.

== Integrating graph widgets ==
This is an example to show the current RAM usage in the status bar:

 graph mem {
    width = &quot;40&quot;
    data mem_used {
        scale = false
        max = 512
        draw_style = bottom
    }
 }

Replace the '512' in that example with the actual size of your RAM in megabytes.

Now open up ~/.awesome/widgets and add the following line to the loop before the sleep statement:

 echo 0 widget_tell mystatusbar mem data mem_used `free -m | tail -n 2 | head -n 1 | awk '{print $3}'` | awesome-client

After a logging out and back in, the RAM usage should be shown in your status bar.

[[Category:awesome2]]</text>
      <sha1>55f6y2hjyzjn3ef1j5frym02fbk78f7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Integrating widgets into awesome/de</title>
    <ns>0</ns>
    <id>91</id>
    <revision>
      <id>2799</id>
      <parentid>2797</parentid>
      <timestamp>2009-05-24T18:13:55Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Add [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="2209">{{Languages|Integrating_widgets_into_awesome}}

Dieses kleine Tutorial soll näherlegen wie man kleine Textwidgets in die Statusbar von awesome 2.3 einbindet. Ein wenig verständnis für Bashscripte sollte vorhanden sein.

[[Image:Awesome_statusbar_awesomewiki.jpg]]

== Eine textbox vorbereiten ==

Zuerst wird in die .awesomerc eine Sektion für die neue Textbox angelegt.

 screen 0
 {
     general
     {
     ...
     }
     ...
     statusbar mystatusbar
     {
         taglist mytaglist
         {
         ...
         }
         ### HIER BEGINNT DIE TEXTBOX ###
         textbox uhrzeit
         {
             align = &quot;right&quot;
             text_align = &quot;right&quot;
             width = &quot;120&quot;
         }
     }

Die breite sollte angepasst werden sobald Daten in der textbox vorhanden sind.

== Die Daten durch ein Bashscript ausgeben lassen ==

Der normale Weg Daten in eine textbox zu bekommen ist folgendes Kommando:

 echo &lt;screen&gt; widget_tell &lt;statusbar&gt; &lt;textbox name&gt; text `&lt;befehl&gt;` | awesome-client

Legen wir nun das Bashscript ~/.awesome/widgets mit folgendem Inhalt an:

 #!/bin/bash
 while true
     do
         echo 0 widget_tell mystatusbar uhrzeit text `date | awk '{print &quot;[&quot;$4&quot;]&quot;}'` | awesome-client
         sleep 1
     done

Der Befehl in den ` ` ist natürlich nur ein Beispiel. Anderen Leuten fällt da bestimmt besseres ein.

Machen wir nun die Datei ausführbar mit

 chmod +x ~/.awesome/widgets

und tragen unser Script in die .xinit / .xsession ein:

 ~/.awesome/widgets &amp;
 exec awesome

Nach einem Neustart von awesome sollte in dem neuen Widget die Uhrzeit zu sehen sein.

== Graphen einbinden ==

Dies ist ein Beispiel um den RAM Verbrauch in der Statusleiste anzuzeigen:

 graph mem {
     width = &quot;40&quot;
     data mem_used {
         scale = false
         max = 512           # &lt;--- Das hier natürlich auf die Größe des Arbeitsspeicher einstellen
         draw_style = bottom
     }    
 }

Eingebunden wird das ganze wie oben beschrieben über ein kleines Bashscript. Folgende Zeile übergibt den RAM Verbrauch an das Widget:

 echo 0 widget_tell mystatusbar mem data mem_used `free -m | tail -n 2 | head -n 1 | awk '{print $3}'` | awesome-client

[[Category:awesome2]]</text>
      <sha1>kpvrilhq5lv4ftlkt8pgswl2yea1eu2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>IoGA theme</title>
    <ns>0</ns>
    <id>212</id>
    <revision>
      <id>2777</id>
      <parentid>1625</parentid>
      <timestamp>2009-05-23T11:20:48Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Themes]]</comment>
      <text xml:space="preserve" bytes="1119">[[Image:IoGA_scr_1.png|thumb|Screenshot]]

Slightly modified default theme. I've only changed bg_focus for a blue, and a font to a terminus, so i have a single font both at status bar and at Urxvt.

 font          = terminus 8
 bg_normal     = #222222
 bg_focus      = #3465a4
 bg_urgent     = #ff0000
 fg_normal     = #aaaaaa
 fg_focus      = #ffffff
 fg_urgent     = #ffffff
 border_width  = 1
 border_normal = #555555
 border_focus  = #535d6c
 border_marked = #91231c
 wallpaper_cmd = awsetbg /home/ioga/awesome/default-background.png

.Xdefaults:

 Rxvt*font: xft:terminus:size=12
 Rxvt*scrollBar_right: True
 Rxvt*scrollBar:False
 Rxvt*saveLines: 8192
 Rxvt*background: #000000
 Rxvt*foreground: #a8a8a8
 Rxvt*termName: xterm
 *color0:      #000000
 *color1:      #9e1828
 *color2:      #aece92
 *color3:      #968a38
 *color4:      #0000a8
 *color5:      #963c59
 *color6:      #418179
 *color7:      #bebebe
 *color8:      #666666
 *color9:      #cf6171
 *color10:     #c5f779
 *color11:     #fff796
 *color12:     #4186be
 *color13:     #cf9ebe
 *color14:     #71bebe
 *color15:     #ffffff

[[Category:Themes]]</text>
      <sha1>enrc6i6ry4o4rca8o8qgq9l8ph1pxwf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Irssi tips</title>
    <ns>0</ns>
    <id>128</id>
    <revision>
      <id>6556</id>
      <parentid>5533</parentid>
      <timestamp>2014-05-19T07:38:02Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2159">{{Languages}}

Using IRSSI with Awesome

== Urgent Signals ==
You can have the awesome window manager identify if somebody sent you a message on IRC using the urgency settings, by doing the following:

'''In irssi:'''
&lt;pre&gt;
/set bell_beeps ON
/set beep_msg_level MSGS NOTICES INVITES DCC DCCMSGS HILIGHT
&lt;/pre&gt;

'''Permanent irssi configuration:'''
&lt;pre&gt;
# settings
#   fe-common/core
bell_beeps = &quot;yes&quot;;
beep_msg_level = &quot;MSGS NOTICES INVITES DCC DCCMSGS HILIGHT&quot;;
&lt;/pre&gt;


'''In .Xdefaults for terminal emulators:'''
&lt;pre&gt;
! rxvt-unicode
URxvt.urgentOnBell:  true

! xterm
XTerm*bellIsUrgent:  true
&lt;/pre&gt;


'''In GNU screen:'''
Make sure ''audible bell'' is enabled (C-a C-g to check). Permanent setting for .screenrc:
&lt;pre&gt;
vbell off  # no visual bell
&lt;/pre&gt;


== Notifications ==
The following irssi script uses libnotify (via the `notify-send` command) to alert user of highlighted messages. On Debian, and Ubuntu you need to install the `libnotify-bin` package.

[http://code.google.com/p/irssi-libnotify/source/browse/notify.pl Libnotify Script for Irssi].


== Genjix's scripts ==

Here's my setup for anyone interested.

Channel List:
&lt;pre&gt;$ cd ~/.irssi/scripts/autorun
$ wget http://anti.teamidiot.de/static/nei/*/Code/Irssi/adv_windowlist.pl&lt;/pre&gt;

Hide statusbar:
&lt;pre&gt;
$ /statusbar window disable
$ /save
&lt;/pre&gt;

Install irssi-scripts, and do:
&lt;pre&gt;
$ cd .irssi/scripts/autorun/
# colourised nicknames
$ ln -s /usr/share/irssi/scripts/nickcolor.pl .
# mouse scrollwheel support
$ ln -s /usr/share/irssi/scripts/mouse.pl .
&lt;/pre&gt;

Add this to .irssi config to ignore nickserv window:
&lt;pre&gt;
autosendcmd = &quot;/msg nickserv identify blaablaa; /window goto nickserv; /wc&quot;;
&lt;/pre&gt;

To run irssi, I do:
&lt;pre&gt;$ screen -mdS i irssi&lt;/pre&gt;
[http://quadpoint.org/articles/irssi#learning_screen Then whenever I wish to check irc], I can run screen -r and type C-a d to detach from the session. Closing the terminal without exiting is fine. screen is a handy utility where you can make seperate sessions to log into, each with their own windows. So here we make 1 session called irssi, with 1 window that has irssi loaded.

Show running sessions with screen -ls</text>
      <sha1>sadzt9vn02zkm779owrknjnw9w40qqj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Irssi tips/ru</title>
    <ns>0</ns>
    <id>1060</id>
    <revision>
      <id>6558</id>
      <timestamp>2014-05-19T08:03:16Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода irssi tips (translating page)</comment>
      <text xml:space="preserve" bytes="3993">{{Languages|Irssi tips}}
{{DISPLAYTITLE:Советы IRSSI}}

== Что такое irssi ==

Irssi — IRC-клиент для Linux и других UNIX-подобных систем. Посредством плагинов возможна работа по XMPP, SILC и ICB протоколам. Irssi богат функционально: развитая система ведения логов позволяет держать отдельно логфайлы для каждой IRC-сети, есть поддержка тем и возможность модифицировать установленные по умолчанию «горячие» клавиши, поддержка скриптов на Perl, и плагина «Irssi-proxy».

Использование IRSSI в Awesome

== Сигналы срочности ==
Вы можеете заставить оконный менеджер Awesome распознавать, если кто то прислал вам сообщение в IRC, используя для этого настройки срочности, сделав следующим образом:

'''В консоли irssi:'''
&lt;pre&gt;
/set bell_beeps ON
/set beep_msg_level MSGS NOTICES INVITES DCC DCCMSGS HILIGHT
&lt;/pre&gt;

'''Постоянная настройка в irssi:'''
&lt;pre&gt;
# settings
#   fe-common/core
bell_beeps = &quot;yes&quot;;
beep_msg_level = &quot;MSGS NOTICES INVITES DCC DCCMSGS HILIGHT&quot;;
&lt;/pre&gt;


'''В .Xdefaults для эмулятора терминала:'''
&lt;pre&gt;
! rxvt-unicode
URxvt.urgentOnBell:  true

! xterm
XTerm*bellIsUrgent:  true
&lt;/pre&gt;


'''В screen GNU:'''
Убедитесь, что ''audible bell'' работает (C-a C-g для проверки). Добавьте настройки в .screenrc:
&lt;pre&gt;
vbell off  # no visual bell
&lt;/pre&gt;


== Уведомления ==
Следующий скрипт irssi использует libnotify (с помощью команды `notify-send`) для предупреждения пользователя о полученном сообщении. В Debian, и Ubuntu вам дополнительно необходимо установить пакет `libnotify-bin`.

[http://code.google.com/p/irssi-libnotify/source/browse/notify.pl Libnotify Script for Irssi].


== Скрипты Genjix ==

Здесь приведены мои настройки, если кому то они будут интересны, я буду рад.

Список каналов:
&lt;pre&gt;$ cd ~/.irssi/scripts/autorun
$ wget http://anti.teamidiot.de/static/nei/*/Code/Irssi/adv_windowlist.pl&lt;/pre&gt;

Скрыаем statusbar:
&lt;pre&gt;
$ /statusbar window disable
$ /save
&lt;/pre&gt;

Устанавливаем irssi-scripts, и делаем:
&lt;pre&gt;
$ cd .irssi/scripts/autorun/
# разукрашиваем nicknames
$ ln -s /usr/share/irssi/scripts/nickcolor.pl .
# поддержка колеса мыши
$ ln -s /usr/share/irssi/scripts/mouse.pl .
&lt;/pre&gt;

Добавляем в настройки .irssi игнорирование окна nickserv:
&lt;pre&gt;
autosendcmd = &quot;/msg nickserv identify blaablaa; /window goto nickserv; /wc&quot;;
&lt;/pre&gt;

Для запуска irssi я использую:
&lt;pre&gt;$ screen -mdS i irssi&lt;/pre&gt;
[http://quadpoint.org/articles/irssi#learning_screen Теперь, когда я хочу проверить irc], я могу запустить screen -r и нажав C-a d отключиться от сессии. Закрытие терминала не приводит к выходу из программы. screen это удобная утилита, где вы можете сделать раздельные сессии входа, каждая из которых будет иметь собственное окно. Поэтому мы делаем 1 сессию под названием irssi, с одним окном в котором загружен irssi.

Показать текущие сеансы можно так:
  screen -ls</text>
      <sha1>tl6f4kajddd007bai92rl3sjumqfcap</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Jaenbon's MPD widget</title>
    <ns>0</ns>
    <id>309</id>
    <revision>
      <id>4963</id>
      <parentid>4198</parentid>
      <timestamp>2011-07-27T12:01:01Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <minor/>
      <comment>moved [[MPD]] to [[Jaenbon's MPD widget]]:&amp;#32;Taking the MPD page for a more general article.</comment>
      <text xml:space="preserve" bytes="3348">This script shows the current title in a scrolling textbox and the current time.
You'll need '''mpc''', of course

The lua configuration : 

 mpd_text_box = widget({ type = &quot;textbox&quot;, align = &quot;right&quot; })
 mpd_text_box.text = &quot;&quot;
 mpd_time_box = widget({ type = &quot;textbox&quot;, align = &quot;right&quot; })
 mpd_time_box.text = &quot;&quot;
 
 mpd_text_max_size = 30
 mpd_text = &quot;&quot;
 
 function mpd_text_rotate()
     if string.len(mpd_text) &gt;= mpd_text_max_size then
         mpd_text = string.gsub(mpd_text, '^(.)(.+)$', '%2%1')
         mpd_text_box.text = string.sub(mpd_text, 1, mpd_text_max_size)..&quot;...&quot;
     else
         mpd_text_box.text = mpd_text
     end
 end
 
 awful.hooks.timer.register(0.4, function()
     mpd_text_rotate()
 end)

The bash script, to launch on startup (e.g. in .xinitrc)
 #!/bin/bash
 
 aw_song_var=&quot;mpd_text&quot;
 aw_song_box=&quot;mpd_text_box&quot;
 aw_time_var=&quot;mpd_time_box.text&quot;
 aw_time_box=&quot;mpd_time_box&quot;
 aw_song_width=180
 aw_time_width=70
 
 function set_width {
     echo &quot;${aw_song_box}.width = $aw_song_width&quot; | awesome-client
     #echo &quot;${aw_time_box}.width = $aw_time_width&quot; | awesome-client
 }
     
 function clean {
     echo &quot;${aw_song_box}.width = 0&quot; | awesome-client
     update_aw_text &quot;&quot;
     echo &quot;${aw_time_box}.width = 0&quot; | awesome-client
     update_aw_time &quot;&quot;
 }
 
 function get_current {
     current=`mpc --format &quot;[%artist% - %title%]&quot; | head -n 1`
     if &lt;nowiki&gt;[[ -z $current ]]&lt;/nowiki&gt;; then
         current=`mpc --format &quot;[%file%]&quot; | head -n 1 | sed -r -e 's=^.*/([^/]*)$=\1=' -e 's/(.+)\..+/\1/'`
     fi
     echo $current | sed -e &quot;s/'/\\\'/g&quot; -e 's/&quot;/\\\&quot;/g' | sed 's/&amp;/&amp;amp\;/g'
 }
 
 function get_time {
     mpc | sed 1d | grep '\[.*\]' | sed 's/^.* \([0-9:/]\+\) .*/\1/'
 }
 
 function get_status {
     mpc | sed 1d | grep '\[.*\]' | sed -r 's/^\[(.+)\].*$/\1/'
 }
 
 function update_aw_text {
     echo &quot;$aw_song_var = '$@'&quot; | awesome-client
 }
 
 function update_aw_time {
     echo &quot;$aw_time_var = '$@'&quot; | awesome-client
 }
 
 function ctr_c {
     echo &quot;You want me to stop...&quot;
     the_response=&quot;youjustfailed&quot;
 }
 
 if &lt;nowiki&gt;[[ &quot;$1&quot; == &quot;-c&quot; ]]&lt;/nowiki&gt;; then
     #clean
     clean
     exit 0
 fi
 
 # Capture the keyboardinterrupt
 # Ugly, I know
 trap ctr_c INT
 
 the_response=`echo NDIK | base64 -d`
 
 set_width
 old_song=&quot;&quot;
 old_status=&quot;&quot;
 while &lt;nowiki&gt;[[ &quot;42&quot; -eq &quot;$the_response&quot; ]]&lt;/nowiki&gt;; do 
     if &lt;nowiki&gt;[[ -n `pgrep mpd` ]]&lt;/nowiki&gt;; then
         status=`get_status`
         current=`get_current`
         ze_time=`get_time`
         if &lt;nowiki&gt;[[ &quot;$status&quot; == &quot;playing&quot; ]]&lt;/nowiki&gt; ; then
             if &lt;nowiki&gt;[[ &quot;$old_song&quot; != &quot;$current&quot; || &quot;$status&quot; != &quot;$old_status&quot; ]]&lt;/nowiki&gt;; then
                 old_song=$current
                 old_status=$status
                 update_aw_text &quot; [&gt;] $current &quot;
                 set_width
             fi
             update_aw_time &quot; $ze_time &quot;
         elif &lt;nowiki&gt;[[ &quot;$status&quot; == &quot;paused&quot; ]]&lt;/nowiki&gt; ; then
             if &lt;nowiki&gt;[[ &quot;$old_song&quot; != &quot;$current&quot; || &quot;$status&quot; != &quot;$old_status&quot; ]]&lt;/nowiki&gt;; then
                 old_song=$current
                 old_status=$status
                 update_aw_text &quot; [~] $current &quot;
                 set_width
             fi
         else
             update_aw_text &quot; [#] Stopped &quot;
         fi
     else
         clean
     fi
 
     sleep 1
 done
 clean

[[Category:Awesome3]]</text>
      <sha1>dgyp8d5cxfecrx266oom4c8nwkhoj8w</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>KAworu FreeBSD ACPI Widget</title>
    <ns>0</ns>
    <id>169</id>
    <revision>
      <id>2862</id>
      <parentid>2861</parentid>
      <timestamp>2009-06-23T16:36:15Z</timestamp>
      <contributor>
        <username>KAworu</username>
        <id>148</id>
      </contributor>
      <minor/>
      <comment>/* creating the ACPI Widget */</comment>
      <text xml:space="preserve" bytes="1817">FreeBSD provide a nice tool to get various system information: sysctl(8)

= FreeBSD ACPI interface for Lua =

System information under FreeBSD can be read using sysctl(8). I did write a sysctl(3) interface for lua, you can get it [http://hg.kaworu.ch/lua-sysctl here].

== UPDATE: ==
thanks to Renato Botelho, lua-sysctl is now in the FreeBSD port system :D

  cd /usr/ports/devel/lua-sysctl &amp;&amp; make install clean

= How to Use =

== sysctl.get(key) ==
returns two values. first returned value is the sysctl(3) value,
second value is the format of returned value
* &quot;I&quot; int 
* &quot;UI&quot; unsigned int 
* &quot;IK&quot; int, in (kelv * 10) (used to get temperature)
* &quot;L&quot; long
* &quot;UL&quot; unsigned long
* &quot;Q&quot; quad_t
* &quot;A&quot; char *
* &quot;T,dev_t&quot; dev_t
* &quot;S,clockinfo&quot; struct clockinfo
* &quot;S,loadavg&quot; struct loadavg
* &quot;S,timeval&quot; struct timeval
* &quot;S,vmtotal&quot; struct vmtotal

== sysctl.set(key, newval) ==
set the sysctl's key to newval. return nothin' and throw lua 
error if any problem occur.
  
== sysctl.IK2celsius(kelv) ==
convert a sysctl's IK value into celsius and return it. 
  
== sysctl.IK2farenheit(kelv) ==
convert a sysctl's IK value into farenheit and return it.

= creating the ACPI Widget =
You need to load the library (in your rc.lua file). For example, if you have ~/.config/awesome/lib/sysctl/core.so and ~/.config/awesome/lib/sysctl.lua:
 package.cpath = package.cpath .. ';' .. awful.util.getdir(&quot;config&quot;) .. '/lib/?.so'
 require(&quot;lib/sysctl&quot;)
If you installed lua-sysctl via the port system, you don't need to tweak the package.cpath, and can require(&quot;sysctl&quot;)

And voilà! You can use sysctl.get() etc. to query sysctl and get any system information.

== Example ==
You can check my config [[User_Configuration_Files#kAworu | here]] for a complete example of use, and other user's config.

Have fun!

[[Category:awesome3]]</text>
      <sha1>b74hekz446zqv39gsq1gvtyueastp3v</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>KAworu MPD Widget</title>
    <ns>0</ns>
    <id>168</id>
    <revision>
      <id>3814</id>
      <parentid>2790</parentid>
      <timestamp>2009-11-18T16:07:05Z</timestamp>
      <contributor>
        <username>Visti</username>
        <id>393</id>
      </contributor>
      <comment>/* Install Luasocket */</comment>
      <text xml:space="preserve" bytes="2631">We will create a MPD widget using a MPD client written in Lua (that doesn't use mpc/netcat/telnet).

= Install Luasocket =
First, you'll need to install [http://www.tecgraf.puc-rio.br/~diego/professional/luasocket/ luasocket].

FreeBSD users:

&lt;code&gt;cd /usr/ports/net/luasocket &amp;&amp; make install clean&lt;/code&gt;

Gentoo users, you can add the akoya overlay (from geekounet). This overlay has a lot of nice other awesome related ebuilds (like wicked for example):

&lt;code&gt;layman -a akoya&lt;/code&gt;

Then emerge luasocket (NOTE: it's a ~arch ebuild, you'll need to keyword it if you have a stable profile, see the Gentoo documentation).

Debian users, as root :

&lt;code&gt;apt-get install liblua5.1-socket2&lt;/code&gt;

Arch users either, as root :

&lt;code&gt;pacman -S luasocket&lt;/code&gt;

or, as user :

&lt;code&gt;yaourt -S luasocket&lt;/code&gt;

* add here your distro package for luasocket :)

= The MPD lua Library =
Save the lua MPD lib (lib/mpd.lua) to $HOME/.config/awesome/lib/mpd.lua, you can get it [http://hg.kaworu.ch/lua-mpd here]

= How to use =

Now we can bind key and get MPD infos. All changes are now in your main configuration file ($HOME/.config/awesome/rc.lua).
First, require the mpd.lua file:

&lt;code&gt;require(&quot;lib/mpd&quot;)&lt;/code&gt;

Then you can get infos from MPD and display them in a widget. Here a quick demo:
 mpc = mpd.new() -- will use default values, localhost:6600 without password
 mpc:send(&quot;status&quot;) -- get the MPD status. You can send any mpd message, and it will return a table with key:value given by mpd
 mpc:stop() -- stop MPD. shortcut for mpc:send(&quot;play&quot;)
 mpc:next() -- next song, shortcut for mpc:send(&quot;next&quot;)
 mpc:toogle_repeat()
 mpc:toggle_play()
 -- etc. see mpd.lua or config.
== handy lua code ==
I'm using a table to handle more than one MPD server:
 mpds = {
   add      = function (self, c) table.insert(self.list, c) end,
   current  = function (self) return self.list[self.current_idx] end,
   next     = function (self) self.current_idx = math.fmod(self.current_idx, #self.list) + 1; self.last_songid = nil end,
   previous = function (self) self.current_idx = math.fmod(self.current_idx, #self.list) - 1; self.last_songid = nil end,
   -- private stuff
   list        = { mpd.new() }, -- one (local) server by default
   current_idx = 1
 }

Then, you can add MPD server:
 mpds:add(mpd.new { hostname=&quot;bla&quot; })

Switch the current MPD server:
 mpds:next()
 mpds:previous()

And use mpds:current() in your key bindings and widgets.

= Full example =
see my config [[User_Configuration_Files#kAworu | here]] for a complete example of use. Check also other users config files.

[[Category:awesome3]]
[[Category:Widgets]]</text>
      <sha1>jvwglsc0572v85mhistsfs8ms3k3fwk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>KDE and awesome</title>
    <ns>0</ns>
    <id>313</id>
    <revision>
      <id>7098</id>
      <parentid>7087</parentid>
      <timestamp>2014-11-02T19:13:45Z</timestamp>
      <contributor>
        <username>Dethnull</username>
        <id>3859</id>
      </contributor>
      <minor/>
      <comment>/* Option 1: .desktop files */  Added location of ksmserver folder for Gentoo users.</comment>
      <text xml:space="preserve" bytes="2648">{{Languages}}

==Replace KWin==
===Option 1: .desktop files===
Place the following in $(KDE prefix)/ksmserver/windowmanagers/awesome.desktop (the folder will probably contain openbox.desktop or metacity.desktop as well).

Note: on KDE3, $(KDE Prefix) usually is /usr/share/apps/.

Note: on KDE4, $(KDE Prefix) usually is /usr/share/kde4/apps/.

Note: for Gentoo, you'll find the ksmserver folder in /usr/share/apps/ksmserver

Note: on KDE Frameworks 5, $(KDE Prefix) usually is /usr/share/.

&lt;pre&gt;
[Desktop Entry]
Encoding=UTF-8
Name=Awesome
Comment=Highly configurable framework window manager
Type=XSession
Exec=awesome
TryExec=awesome
&lt;/pre&gt;
Now, you should be able to choose &quot;awesome&quot; as window manager in '''System Settings-&gt;Default Applications-&gt;Window Manager'''

===Option 2: Environment variables===
====Per user====
KDE has the KDEWM environment variable that allows you to specify an alternative window manager to use.
Just create a new script called something like:

~/.kde/env/set_window_manager.sh 

containing
&lt;pre&gt;
export KDEWM=awesome
&lt;/pre&gt;
and make it executable
chmod +x ~/.kde/env/set_window_manager.sh

Note: on KDE Frameworks 5 that variable is read from plasma-workspace's environment, so put it into ~/.config/plasma-workspace/env/set_window_manager.sh.

====Globally====
I made a script in /etc/X11/Xsession.d/98mine containing just:
&lt;pre&gt;
export KDEWM=awesome
&lt;/pre&gt;
But this is not recommended since it sets this variable for all users of the system (which is only me on my laptop).

I made some [http://koch.ro/blog/index.php?/archives/115-Found-my-desktop-for-live.html screenshots].

==Disable Plasma==
Copy /usr/share/autostart/plasma-desktop.desktop to ~/.config/autostart/ and add Hidden=true at the end.

Note: on Plasma 5 that is /etc/xdg/autostart/plasmashell.desktop.

====Disable KRunner====
Copy /usr/share/autostart/krunner.desktop to ~/.config/autostart/ and add Hidden=true at the end.

Note: on Plasma 5 that is located in /etc/xdg/autostart/.

==Fix Systray== 
Tray icons of some KDE applications won't show up in awesome's systray because they use the KDE status notifier. If you disable this service (System Settings &gt; Startup and Shutdown &gt; Service Manager &gt; uncheck &quot;Status Notifier Manager&quot;) all the icons should appear. Tip taken from [https://code.google.com/p/tint2/wiki/FAQ#Why_don't_some_systray_icons_appear_when_you_run_tint2_in_a Tint2 Wiki].

Note: on Plasma 5 also take a look to http://blog.martin-graesslin.com/blog/2014/06/where-are-my-systray-icons/

==Logout / Shutdown / Lock ==

Install [http://kshutdown.sourceforge.net/ kshutdown], also available as package in many distribution.</text>
      <sha1>tvdcv9mdo6uwu16qss4pbs0t6l19uvm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>KDE and awesome/fr</title>
    <ns>0</ns>
    <id>436</id>
    <revision>
      <id>3359</id>
      <parentid>3250</parentid>
      <timestamp>2009-07-15T19:06:54Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>DISPLAYTGITLE instead of Templaet:Title</comment>
      <text xml:space="preserve" bytes="1130">{{DISPLAYTITLE:Mettre en place awesome avec KDE}}
{{Languages|KDE and awesome}}

Tout d’abord, quelques [http://koch.ro/blog/index.php?/archives/115-Found-my-desktop-for-live.html captures d’écran] du résultat attendu.

== Mise en place ==
KDE dispose d’une variable d’environnement KDEWM qui vous permet de spécifier un gestionnaire de fenêtres alternatif à utiliser. Apparemment, la marche à suivre est la suivante :

Créez un script, par exemple '''~/.kde/env/set_window_manager.sh''', contenant :
 export KDEWM=awesome 
et rendez-le exécutable :
chmod +x ~/.kde/env/set_window_manager.sh

Vous pouvez également créer un script '''/etc/X11/Xsession.d/98mon-script''' contenant simplement :
 export KDEWM=awesome
mais ce n’est pas recommandé puisque cela change la variable pour tous les utilisateurs du système.

== Pour aller plus loin ==
* Pour désactiver Plasma, il suffit de supprimer, déplacer, ou renommer '''/usr/share/autostart/plasma.desktop'''
* Pour l’invite de connexion et de déconnexion, installez [http://kshutdown.sourceforge.net/ kshutdown], également disponible en paquet Debian.</text>
      <sha1>rwtjkergl694c7i5862w8eaf1ww8a73</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>KDE and awesome/ru</title>
    <ns>0</ns>
    <id>457</id>
    <revision>
      <id>7155</id>
      <parentid>6768</parentid>
      <timestamp>2014-12-15T06:48:13Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>added last changes</comment>
      <text xml:space="preserve" bytes="4005">{{DISPLAYTITLE:KDE и Awesome}}
{{Template:Languages|KDE and awesome}}

==Заменяем KWin==
===Вариант 1: файлы .desktop===
Поместите следующий код в $(KDE prefix)/ksmserver/windowmanagers/awesome.desktop (папка скорее всего уже содержит openbox.desktop или metacity.desktop).

Note: В KDE3, $(KDE Prefix) обычно в /usr/share/apps/.
Note: В KDE4, $(KDE Prefix) обычно в /usr/share/kde4/apps/.

Note: В Gentoo, вы найдете папку ksmserver в /usr/share/apps/ksmserver

Note: В KDE Frameworks 5, $(KDE Prefix) обычно в /usr/share/. 
&lt;pre&gt;
[Desktop Entry]
Encoding=UTF-8
Name=Awesome
Comment=Highly configurable framework window manager
Type=XSession
Exec=awesome
TryExec=awesome
&lt;/pre&gt;
Теперь у вас должна появится возможность выбирать &quot;awesome&quot; в качестве window manager в '''Параметры системы-&gt;Приложения по умолчанию-&gt;Диспечер окон'''

===Вариант 2: Переменные окружения===
====Пользовательский способ====
В KDE существует переменная окружения KDEWM, позволяющая указать альтернативный оконный менеджер. 

Создайте новый скрипт и разместите его следующим образом:

~/.kde/env/set_window_manager.sh 

содержащий
&lt;pre&gt;
export KDEWM=awesome
&lt;/pre&gt;
и сделайте его исполнимым
&lt;pre&gt;chmod +x ~/.kde/env/set_window_manager.sh&lt;/pre&gt;

Note: В KDE Frameworks 5 данная перменная считывается из рабочего окружения plasma, поэтому, поместите ее в  ~/.config/plasma-workspace/env/set_window_manager.sh.

====Глобальный способ====
Я создал скрипт /etc/X11/Xsession.d/98mine содержащий только:
&lt;pre&gt;
export KDEWM=awesome
&lt;/pre&gt;
Но этот способ не рекомендуется, т.к. здесь эта переменная устанавливается для всех пользователей системы (только если вы один используете систему, например на ноутбуке).

Я сделал несколько [http://koch.ro/blog/index.php?/archives/115-Found-my-desktop-for-live.html скриншотов].

==Отключаем Plasma==
Скопируйте /usr/share/autostart/plasma-desktop.desktop в ~/.config/autostart/ и добавьте Hidden=true в его конец.

Note: В Plasma 5 он находится в /etc/xdg/autostart/plasmashell.desktop.

==Отключаем KRunner==
Скопируйте /usr/share/autostart/krunner.desktop в ~/.config/autostart/ и добавьте Hidden=true в его конец.

Note: В Plasma 5 он находится в /etc/xdg/autostart/.

== Fix Systray == 
Иконки трея некоторых приложений KDE не хочет отображаться в системном трее awesome, т.к. они используют область уведомлений KDE. Если вы отключите этот сервис (Параметры системы &gt; Запуск и завершений &gt; Управление службами &gt; снимите галочку с &quot;Status Notifier Manager&quot;) должны появиться все иконки. Совет взят из  [https://code.google.com/p/tint2/wiki/FAQ#Why_don't_some_systray_icons_appear_when_you_run_tint2_in_a Tint2 Wiki].

Note: Для Plasma 5 также загляните на [http://blog.martin-graesslin.com/blog/2014/06/where-are-my-systray-icons/ Systray Icons]

==Logout / Shutdown / Lock ==

Установите [http://kshutdown.sourceforge.net/ kshutdown], также он доступен в виде пакетов для многих дистрибутивов.</text>
      <sha1>ccomjuk2wx8ie0nggzu13l13lm0j2v7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keeping multitags persistent</title>
    <ns>0</ns>
    <id>674</id>
    <revision>
      <id>6607</id>
      <parentid>4840</parentid>
      <timestamp>2014-05-22T16:51:36Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2699">{{Languages}}

== Summary ==

This configuration snipper/lua code will enable persistent multitags, for example :

* type F1 to go to tag 1 ;

* type Ctrl+F2 to add tag 2 to your view (you'll have clients of tags 1 and 2);

* type F3 to switch to tag 3 (you'll have only clients from tag 3);

* now, type F1 to go back to tag 1 : with this code, you'll be back to having tags 1 and 2, until you press Ctrl+F2 to remove tag 2.

== Disclaimers ==

* I use Fx keys to access tags, adjust if you want to keep the default (Mod4+numbers) or anything else.

* This is my first lua code, so there may be more elegant ways of writing it.

* If you restart awesome, everything will be forgotten (which is actually a good way of resetting if it gets lost, which it shouldn't but well...).

* It only works if you switch with keyboard, not with mouse. That may be considered a feature ;)

== The code ==

&lt;pre&gt;
-- Bind all key numbers to F keys.
-- Keep a (semi-)persistant mapping of active multitags
-- This should map on the top row of your keyboard, usually F1 to F9.
extra_tags = {}
for i = 1, keynumber do
    extra_tags[i] = {}
    globalkeys = awful.util.table.join(globalkeys,
        awful.key({ }, &quot;F&quot; .. i,
                  function ()
		     local screen = mouse.screen
		     local curtag = tags[screen][i]
		     if curtag then
			awful.tag.viewonly(curtag)
		     end
		     for tag,v in pairs(extra_tags[i]) do 
			if v then
			   awful.tag.viewtoggle(tags[screen][tag])
			end
		     end
                  end),
        awful.key({ &quot;Control&quot; }, &quot;F&quot; .. i,
                  function ()
		     local screen = mouse.screen
		     local curtag = awful.tag.getidx(awful.tag.selected(screen))
		     local selected = awful.tag.selectedlist(screen)
		     local found = false
		     for i_,v in ipairs(selected) do 
			v = awful.tag.getidx(v)
			if v == i then
			   found = true
			   break
			end
		     end
		     if found then
			extra_tags[curtag][i] = false
		     else
			extra_tags[curtag][i] = true
		     end
		     if tags[screen][i] then
			awful.tag.viewtoggle(tags[screen][i])
		     end
                  end),
        awful.key({ &quot;Shift&quot; }, &quot;F&quot; .. i,
                  function ()
                      if client.focus and tags[client.focus.screen][i] then
                          awful.client.movetotag(tags[client.focus.screen][i])
                      end
                  end),
        awful.key({ &quot;Control&quot;, &quot;Shift&quot; }, &quot;F&quot; .. i,
                  function ()
                      if client.focus and tags[client.focus.screen][i] then
                          awful.client.toggletag(tags[client.focus.screen][i])
                      end
                  end))
end
&lt;/pre&gt;</text>
      <sha1>koasq1pjr8gieede7x4ncz4hpu2a2f6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keeping multitags persistent/ru</title>
    <ns>0</ns>
    <id>1073</id>
    <revision>
      <id>6610</id>
      <timestamp>2014-05-22T17:44:19Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Keeping multitags persistent (translate page)</comment>
      <text xml:space="preserve" bytes="3591">{{Languages|Keeping multitags persistent}}
{{DISPLAYTITLE:Сохранение мультитегового состояния}}

== Описание ==

Эта конфигурация lua кода позволяет сохранять мультитеговое состояние, например:

* Нажмите F1 для перехода на тег 1 ;

* Нажмите Ctrl+F2 чтобы объединить просмотр тега 1 и 2 (у вас будут отображены клиенты с обоих тегов), как при нажатии Mod+Ctrl+№;

* Нажмите F3 для переключения на тег 3 (будут отображены клиенты только для тега 3);

* теперь, нажав F1 вы вернетесь на тег 1: с помощью этого кода, вы вернетесь и снова будете видеть теги 1 и 2, до тех пор, пока не нажмете Ctrl+F2 чтобы удалить тег 2.

== Особенности ==

* Я использую клавиши Fx для переключения по тегам, если вы хотите сохранить значения по умолчанию (Mod4+numbers) отредактируйт код.

* Это мой первый код на lua, поэтому наверно можно было найти более элегантный  способ написать это.

* После перезапуска awesome, все настройки забываются.

* Код будет работать только при переключении с клавиатуры, мышь не поддерживается в коде. Это можно считать особенностью ;)

== Код ==

&lt;pre&gt;
-- Bind all key numbers to F keys.
-- Keep a (semi-)persistant mapping of active multitags
-- This should map on the top row of your keyboard, usually F1 to F9.
extra_tags = {}
for i = 1, keynumber do
    extra_tags[i] = {}
    globalkeys = awful.util.table.join(globalkeys,
        awful.key({ }, &quot;F&quot; .. i,
                  function ()
		     local screen = mouse.screen
		     local curtag = tags[screen][i]
		     if curtag then
			awful.tag.viewonly(curtag)
		     end
		     for tag,v in pairs(extra_tags[i]) do 
			if v then
			   awful.tag.viewtoggle(tags[screen][tag])
			end
		     end
                  end),
        awful.key({ &quot;Control&quot; }, &quot;F&quot; .. i,
                  function ()
		     local screen = mouse.screen
		     local curtag = awful.tag.getidx(awful.tag.selected(screen))
		     local selected = awful.tag.selectedlist(screen)
		     local found = false
		     for i_,v in ipairs(selected) do 
			v = awful.tag.getidx(v)
			if v == i then
			   found = true
			   break
			end
		     end
		     if found then
			extra_tags[curtag][i] = false
		     else
			extra_tags[curtag][i] = true
		     end
		     if tags[screen][i] then
			awful.tag.viewtoggle(tags[screen][i])
		     end
                  end),
        awful.key({ &quot;Shift&quot; }, &quot;F&quot; .. i,
                  function ()
                      if client.focus and tags[client.focus.screen][i] then
                          awful.client.movetotag(tags[client.focus.screen][i])
                      end
                  end),
        awful.key({ &quot;Control&quot;, &quot;Shift&quot; }, &quot;F&quot; .. i,
                  function ()
                      if client.focus and tags[client.focus.screen][i] then
                          awful.client.toggletag(tags[client.focus.screen][i])
                      end
                  end))
end
&lt;/pre&gt;</text>
      <sha1>db06y8leme84m3yf9ye7817qm8fv5zm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keybindings and numeric pad</title>
    <ns>0</ns>
    <id>942</id>
    <revision>
      <id>6472</id>
      <parentid>5993</parentid>
      <timestamp>2014-05-08T05:00:21Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="4022">{{Languages}}

== Introduction ==

The numeric pad is seldom used, and useful key bindings can easily be defined if you have '''9 tags''' and '''9 keys'''. This page goes through an example on how to use the numeric pad to &quot;go to tags&quot; and &quot;show personalized menus&quot;, but you can go to the [[Keybindings_and_numeric_pad#Having_all_together_in_few_lines_of_code.21.21 | '''final section''']] if you are already familiar with '''awesome''' and want to see the result.

== Show a particular tag ==

Showing (''moving to'') a particular tag can be achieved associating the key (''KP_End'') with the tag:

 awful.key({ }, &quot;KP_End&quot;, function () awful.tag.viewonly(tags[mouse.screen][1]) end),

Pressing keypad '''1''' (with the symbol ''end'') shows tag number 1.

== Go to a tag and show the menu corresponding to that tag  ==

One of the first actions when configuring awesome has to do with the naming of the tags. For example:

 tags = {}
 for s = 1, screen.count() do
     -- Each screen has its own tag table.
     tags[s] = awful.tag({ &quot;File&quot;, &quot;Mail&quot;, &quot;Off&quot;, &quot;FF&quot;, &quot;Sys&quot;, &quot;Oci&quot;, &quot;Chro&quot;, &quot;Net&quot;, &quot;Aw&quot; }, s, layouts[1])
 end

The naming is normally related with the activities you are going to be doing in this particular tag; activities often related with a sub-section of the main menu. For example, in the main menu you may have a sub-menu with these items:

 Menu_File = {
 	{&quot;&amp;1_vifm&quot;, &quot;urxvtc -e vifm&quot;},
 	{&quot;&amp;2_Muntar usb&quot;, &quot;urxvtc -e /usr/local/bin/Munta.sh usb&quot; }
 }

This sub-menu with the activities related to &quot;files&quot; can be easily transformed into a menu of its own:

 M_File = awful.menu (
 	{items = Menu_File}
 )

All right. Let's go to the tag and show the menu associated to the tag with '''Shift'''-'''KP_End''':

 awful.key({ &quot;Shift&quot; }, &quot;KP_End&quot;, function () 
 	awful.tag.viewonly(tags[mouse.screen][1])
 	M_File:show({keygrabber=true}) 
 end),

You may have noticed that each item in the menu is numbered and preceded with an ampersand (''&amp;''). If frequent items are positioned higher in the menu, pressing '''Shift'''-'''KP_End''' and '''1''' will give  the most used item in the tag (''workspace'').

== Show the menu when you are not in the tag ==

There may be situations where you want the menu associated to another tag. Let's associate this menu to the '''ctrl''' key:

 awful.key({ &quot;Control&quot; }, &quot;KP_End&quot;, function () 
 	M_File:show({keygrabber=true}) 
 end)

== Having all together in few lines of code!! ==

Other window managers can more or less easily have multiple menus and &quot;go to workspace and show the menu associated to the workspace&quot;, What is '''awesome''' is that you can define this in a few lines of code thanks to the use of the '''Lua''' language:

 -- Define the keys and the menus in a lua table
 Numeric_Pad = { &quot;KP_End&quot;, &quot;KP_Down&quot;, &quot;KP_Next&quot;, &quot;KP_Left&quot;, &quot;KP_Begin&quot;, &quot;KP_Right&quot;, &quot;KP_Home&quot;, &quot;KP_Up&quot;, &quot;KP_Prior&quot; }
 Menu_Table  = { M_File, M_Mail, M_Office, M_Fox, M_Sys, M_Oci, M_Chrome, M_Xarxa, M_Awesome }
 
 -- Associate each tag (1 to 9) with each key (Numeric_Pad) to each menu (Menu_Table)
 for i = 1, 9 do
     globalkeys = awful.util.table.join(globalkeys,
 	-- Got to tag with numeric pad  
 	awful.key({ }, Numeric_Pad[i], function () awful.tag.viewonly(tags[mouse.screen][i]) end),
 	-- Go to tag and show menu with shift and numeric pad 
 	awful.key({ &quot;Shift&quot; }, Numeric_Pad[i], function () 
 		awful.tag.viewonly(tags[mouse.screen][i])
 		Menu_Table[i]:show({keygrabber=true}) 
 	end),
 	-- Show menu with control and numeric pad
 	awful.key({ &quot;Control&quot; }, Numeric_Pad[i], function () 
 		Menu_Table[i]:show({keygrabber=true}) 
 	end)
 	)
 end

Voilà! 


(note: ''let us know if this can be easily achieved with other window managers to give them recognition'').
* [http://www.fvwm.org/ Fvwm] can do this magic with Perl preprocessing. See [http://www.fvwmforums.org/phpBB3/viewtopic.php?f=33&amp;t=2970&amp;p=14171#p14171 this post]

== See also ==

* Full [https://github.com/mimosinnet/Awesome/blob/master/rc.lua rc.lua] working configuration using this example in GitHub.</text>
      <sha1>rmz88w98ciob9y8n0e696akjwrftebg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keybindings and numeric pad/ru</title>
    <ns>0</ns>
    <id>1042</id>
    <revision>
      <id>6475</id>
      <parentid>6474</parentid>
      <timestamp>2014-05-08T06:36:43Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <text xml:space="preserve" bytes="6071">{{Languages|Keybindings and numeric pad}}
{{DISPLAYTITLE:Клавиатурные сочетания и цифровая клавиатура}}

== Введение ==

Цифровая клавиатура используется редко, и вы можете легко определеить ее использование, если у вас есть '''9 тегов''' и '''9 ключей'''. 
The numeric pad is seldom used, and useful key bindings can easily be defined if you have '''9 tags''' and '''9 keys'''. На этой странице описываются примеры использования цифоровой клавиатуры для &quot;переключения тегов&quot; и &quot;отображения персонализированного меню&quot;, но если вы уже знакомы с awesome можете перейти в [[Keybindings_and_numeric_pad/ru#Собираем все в единый код | '''итоговый раздел''']] в конец страницы и посмотреть конкретый результат. 

== Переключение на конкретный тег ==

Показан способ переключения на конкретный тег, связывющий клавишу ''KP_End'' с тегом:

 awful.key({ }, &quot;KP_End&quot;, function () awful.tag.viewonly(tags[mouse.screen][1]) end),

Нажатие клавиши '''1''' (с символом ''end'') отобразит тег с номером 1.

== Переход к тегу и отображение меню соотвестующее этому тегу  ==

Обычно, одним из первых действия, при конфигурировании Awesome, является присваивание тегам собственных названий. Например:

 tags = {}
 for s = 1, screen.count() do
     -- Each screen has its own tag table.
     tags[s] = awful.tag({ &quot;File&quot;, &quot;Mail&quot;, &quot;Off&quot;, &quot;FF&quot;, &quot;Sys&quot;, &quot;Oci&quot;, &quot;Chro&quot;, &quot;Net&quot;, &quot;Aw&quot; }, s, layouts[1])
 end

Название тега обычно связывается с действиями которые будут в нем производиться; действия часто связанные с подразделом главного меню. Например, в главном меню  вы можете иметь подменю со следующими элементами:

 Menu_File = {
 	{&quot;&amp;1_vifm&quot;, &quot;urxvtc -e vifm&quot;},
 	{&quot;&amp;2_Muntar usb&quot;, &quot;urxvtc -e /usr/local/bin/Munta.sh usb&quot; }
 }

Это подменю сязанное с действиям с файлами, может быть легко преобразованно в свое собственное меню:

 M_File = awful.menu (
 	{items = Menu_File}
 )

Хорошо. Давайте настрим переход на ныжный тег и отображение ассоциированного с ним меню используя '''Shift'''-'''KP_End''':

 awful.key({ &quot;Shift&quot; }, &quot;KP_End&quot;, function () 
 	awful.tag.viewonly(tags[mouse.screen][1])
 	M_File:show({keygrabber=true}) 
 end),

Вы возмжно уже обратили внимание на то, что каждый элемент меню пронумерован и ему предшествует амперсанд (''&amp;''). Если часто используемые элементы располагаются выше в меню, нажатие '''Shift'''-'''KP_End''' и '''1''' выдаст наиболее используемые элементы в теге.

== Отображение меню без перключения на тег ==

Иногда может возникнуть ситуация, когда вам потребуется отобразиться связанное с тегом меню, без переключения на него. Давайте свяжем его с клавишей  '''ctrl''':

 awful.key({ &quot;Control&quot; }, &quot;KP_End&quot;, function () 
 	M_File:show({keygrabber=true}) 
 end)

== Собираем все в единый код ==

Другие оконные менеджеры могут более или менне легко иметь множественные меню и &quot;переключаться на рабочее пространство и отображать связанное с ним меню&quot;. В '''awesome''' вы тоже можете сделать это написав лишь несколько строк кода на '''Lua''':

 -- Определяем клавиши и меню в таблице lua
 Numeric_Pad = { &quot;KP_End&quot;, &quot;KP_Down&quot;, &quot;KP_Next&quot;, &quot;KP_Left&quot;, &quot;KP_Begin&quot;, &quot;KP_Right&quot;, &quot;KP_Home&quot;, &quot;KP_Up&quot;, &quot;KP_Prior&quot; }
 Menu_Table  = { M_File, M_Mail, M_Office, M_Fox, M_Sys, M_Oci, M_Chrome, M_Xarxa, M_Awesome }
 
 -- Ассоциируем каждый тег(от 1 до 9) с сооветсвующей клавишей на цифровой клавиатуре, а также с меню (Menu_Table)
 for i = 1, 9 do
     globalkeys = awful.util.table.join(globalkeys,
 	-- Переключаемся на тег использую цифровую клавиатуру
 	awful.key({ }, Numeric_Pad[i], function () awful.tag.viewonly(tags[mouse.screen][i]) end),
 	-- переключается на тег и отображаем меню дополнительно нажав ''Shift'' 
 	awful.key({ &quot;Shift&quot; }, Numeric_Pad[i], function () 
 		awful.tag.viewonly(tags[mouse.screen][i])
 		Menu_Table[i]:show({keygrabber=true}) 
 	end),
 	-- Отображение меню конкретного тега, без переключения на него нажимая Contol+клавиша цифровой клавиатуры
 	awful.key({ &quot;Control&quot; }, Numeric_Pad[i], function () 
 		Menu_Table[i]:show({keygrabber=true}) 
 	end)
 	)
 end

Готово! 

== Смотрите также ==

* Полная [https://github.com/mimosinnet/Awesome/blob/master/rc.lua rc.lua] рабочая конфигурация использующая этот пример на GitHub.</text>
      <sha1>mmhid4fi422334lfhstaw7hzxywliqe</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keyboard layouts with kbdd</title>
    <ns>0</ns>
    <id>604</id>
    <revision>
      <id>6223</id>
      <parentid>6222</parentid>
      <timestamp>2014-01-16T09:51:26Z</timestamp>
      <contributor>
        <username>Umod.47</username>
        <id>3156</id>
      </contributor>
      <minor/>
      <comment>/* Awesome 3 and kbdd */</comment>
      <text xml:space="preserve" bytes="6671">= Awesome 3 and kbdd =

'''[http://github.com/qnikst/kbdd/ kbdd]''' stands for ''&lt;u&gt;k&lt;/u&gt;ey&lt;u&gt;b&lt;/u&gt;oar&lt;u&gt;d&lt;/u&gt; &lt;u&gt;d&lt;/u&gt;aemon''. It is a simple daemon, which is designed to be run in X11 session and remember keyboard layouts on a per-window basis. That's very useful if don't want to switch layouts back and forth, while typing in terminals (probably mostly in English layouts) and some kind of chat (Greek, for example). Another useful thing about it is D-Bus notification support (optional) — it can emit signals on layout change, thus making it possible to create a indicator widget.

First, head over to '''''kbdd''''' homepage and install latest version (chances to find it in repos are low). [http://gentoo.org/ Gentoo] users are advised to use [http://code.google.com/p/rion-overlay/ ''rion'' overlay].

Make sure you've configured your Xorg server properly, ''kbdd'' uses its settings. Run kbdd executable and behold its unbelievable greatness in layout remembering!

Next thing is to create Awesome widget:

&lt;pre&gt;
-- Keyboard layout widget
kbdwidget = widget({type = &quot;textbox&quot;, name = &quot;kbdwidget&quot;})
kbdwidget.border_width = 1
kbdwidget.border_color = beautiful.fg_normal
kbdwidget.text = &quot; Eng &quot;
&lt;/pre&gt;

Awesome 3.5+ version:
&lt;pre&gt;
-- Keyboard layout widget
kbdwidget = wibox.widget.textbox(&quot; Eng &quot;)
kbdwidget.border_width = 1
kbdwidget.border_color = beautiful.fg_normal
kbdwidget:set_text(&quot; Eng &quot;)
&lt;/pre&gt;

…place it where you want and make it listen to D-Bus events:

&lt;pre&gt;
dbus.request_name(&quot;session&quot;, &quot;ru.gentoo.kbdd&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='ru.gentoo.kbdd',member='layoutChanged'&quot;)
dbus.add_signal(&quot;ru.gentoo.kbdd&quot;, function(...)
    local data = {...}
    local layout = data[2]
    lts = {[0] = &quot;Eng&quot;, [1] = &quot;Рус&quot;}
    kbdwidget.text = &quot; &quot;..lts[layout]..&quot; &quot;
    end
)
&lt;/pre&gt;

Awesome 3.5+ version:
&lt;pre&gt;
kbdstrings = {[0] = &quot; Eng &quot;, 
              [1] = &quot; Рус &quot;}

dbus.request_name(&quot;session&quot;, &quot;ru.gentoo.kbdd&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='ru.gentoo.kbdd',member='layoutChanged'&quot;)
dbus.connect_signal(&quot;ru.gentoo.kbdd&quot;, function(...)
    local data = {...}
    local layout = data[2]
    kbdwidget:set_markup(kbdstrings[layout])
    end
)
&lt;/pre&gt;

In this example the first layout (numbered &quot;0&quot;) is English and therefore indicated as &quot;Eng&quot;, and the second one is Russian (&quot;1&quot;, &quot;Рус&quot;). Adjust it as you need: you could play with background and foreground colours, display images instead of boring letters and so on.

That's simplest example. See [http://github.com/qnikst/kbdd/wiki '''''kbdd''' wiki''] and manpage for details regarding D-Bus methods and other features.

== Advanced layout managing and prettier widget ==
Here's much more complex example of kbdd-powered widget with background images and layout selection menu written by [https://plus.google.com/u/0/108851120880764769721/posts Mellon].
 * Left mouse click switches two most recent layouts.
 * Middle click switches to next layout.
 * Right click opens menu.
Widget state is changed by ''kbdd'' D-BUS signals, layouts are switched by calling ''kbdd'' D-BUS methods.
Code is subject to changes, so look into example here and make sure you've checked most recent version at GoogleCode.

[[File:Mellon_kbdd.png]]

[http://code.google.com/p/qmellon/source/browse/home/.config/awesome/kbd.lua kbd.lua]
&lt;pre&gt;
-- {{{ Variable definitions
kbd_dbus_sw_cmd = &quot;qdbus ru.gentoo.KbddService /ru/gentoo/KbddService  ru.gentoo.kbdd.set_layout &quot;
-- kbd_dbus_sw_cmd = &quot;dbus-send --dest=ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.set_layout uint32:&quot;
kbd_dbus_prev_cmd = &quot;qdbus ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.prev_layout&quot;
-- kbd_dbus_prev_cmd = &quot;dbus-send --dest=ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.prev_layout&quot;
kbd_dbus_next_cmd = &quot;qdbus ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.next_layout&quot;
-- kbd_dbus_next_cmd = &quot;dbus-send --dest=ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.next_layout&quot;
kbd_img_path = &quot;/usr/share/icons/kbflags/&quot;
-- }}}

-- {{{ Keyboard layout widgets
--- Create the menu
kbdmenu =awful.menu({ items = {  { &quot;English&quot;, kbd_dbus_sw_cmd .. &quot;0&quot;,  kbd_img_path .. &quot;us.png&quot; },
	{ &quot;Русский&quot;, kbd_dbus_sw_cmd .. &quot;1&quot;, kbd_img_path .. &quot;ru.png&quot; },
	{ &quot;Hebrew&quot;, kbd_dbus_sw_cmd .. &quot;2&quot;, kbd_img_path .. &quot;il.png&quot; },
	{ &quot;Deutsch&quot;, kbd_dbus_sw_cmd .. &quot;3&quot;, kbd_img_path .. &quot;de.png&quot; }
	}
})

-- Create simple text widget
kbdwidget = widget({type = &quot;textbox&quot;, name = &quot;kbdwidget&quot;})
-- kbdwidget.border_width = 1
-- kbdwidget.border_color = beautiful.fg_normal
kbdwidget.align=&quot;center&quot;
kbdwidget.text = &quot;&lt;b&gt;Eng&lt;/b&gt;&quot;
kbdwidget.bg_image = image (kbd_img_path .. &quot;us.png&quot;)
kbdwidget.bg_align = &quot;center&quot;
kbdwidget.bg_resize = true
awful.widget.layout.margins[kbdwidget] = { left = 0, right = 10 }
kbdwidget:buttons(awful.util.table.join(
	awful.button({ }, 1, function() os.execute(kbd_dbus_prev_cmd) end),
	awful.button({ }, 2, function() os.execute(kbd_dbus_next_cmd) end),
	awful.button({ }, 3, function() kbdmenu:toggle () end)
))
-- }}}

-- {{{ Signals
dbus.request_name(&quot;session&quot;, &quot;ru.gentoo.kbdd&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='ru.gentoo.kbdd',member='layoutChanged'&quot;)
dbus.add_signal(&quot;ru.gentoo.kbdd&quot;, function(...)
	local data = {...}
	local layout = data[2]
	lts = {[0] = &quot;Eng&quot;, [1] = &quot;Рус&quot;, [2] = &quot;Heb&quot;, [3] = &quot;Deu&quot;}
	lts_img = {[0] = kbd_img_path .. &quot;us.png&quot;, [1] = kbd_img_path .. &quot;ru.png&quot;, [2] = kbd_img_path .. &quot;il.png&quot;, [3] = kbd_img_path .. &quot;de.png&quot; }
	kbdwidget.text = &quot;&lt;b&gt;&quot;..lts[layout]..&quot;&lt;/b&gt;&quot;
	kbdwidget.bg_image = image(lts_img[layout])
	end)
-- }}}
&lt;/pre&gt;
[http://code.google.com/p/qmellon/source/browse/home/.config/awesome/rc.lua#115 rc.lua]
&lt;pre&gt;
-- {{{ Load user widgets
dofile(awful.util.getdir(&quot;config&quot;) .. &quot;/kbd.lua&quot;)
-- }}}

    -- Add widgets to the wibox - order matters
    mywibox[s].widgets = {
--     ...
        s == 1 and kbdwidget or nil,
--     ...
    }

-- My keybindings
globalkeys = awful.util.table.join(globalkeys,
    awful.key({ modkey, &quot;Mod1&quot;    }, &quot;1&quot;,     function () os.execute(kbd_dbus_sw_cmd .. &quot;0&quot;) end),
    awful.key({ modkey, &quot;Mod1&quot;    }, &quot;2&quot;,     function () os.execute(kbd_dbus_sw_cmd .. &quot;1&quot;) end),
    awful.key({ modkey, &quot;Mod1&quot;    }, &quot;3&quot;,     function () os.execute(kbd_dbus_sw_cmd .. &quot;2&quot;) end),
    awful.key({ modkey, &quot;Mod1&quot;    }, &quot;4&quot;,     function () os.execute(kbd_dbus_sw_cmd .. &quot;3&quot;) end),
    awful.key({  &quot;Control&quot;  }, &quot;ISO_Level3_Shift&quot;,     function () os.execute(kbd_dbus_prev_cmd) end)
)
&lt;/pre&gt;

Icons used are [http://kde-look.org/content/show.php/translatoid?content=97511 translatoid's] (translator plasmoid using google translator).

[[Category:awesome3]]
[[Category:Widgets]]</text>
      <sha1>pj2lqicvkovdcd6rdbmyw76c7k6xg0q</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keyboard layouts with kbdd/ru</title>
    <ns>0</ns>
    <id>1046</id>
    <revision>
      <id>6499</id>
      <timestamp>2014-05-12T14:27:58Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{Languages|Keyboard layouts with kbdd}} {{DISPLAYTITLE:Раскладка клавиатуры с kbdd}}  = Awesome 3 и kbdd =  '''[http://github.com/qnikst/kbdd/ kbdd]''' ...&quot;</comment>
      <text xml:space="preserve" bytes="8963">{{Languages|Keyboard layouts with kbdd}}
{{DISPLAYTITLE:Раскладка клавиатуры с kbdd}}

= Awesome 3 и kbdd =

'''[http://github.com/qnikst/kbdd/ kbdd]''' выступает в качестве ''&lt;u&gt;к&lt;/u&gt;лав&lt;u&gt;иа&lt;/u&gt;тур&lt;u&gt;ного&lt;/u&gt; &lt;u&gt;д&lt;/u&gt;емона''. Это простой демон, который предназначен для запуска в сессии X11  и запоминании клавиатурной схемы для каждого окна. Это очень удобно, если вы не хотите постоянно переключаться туда-сюда, когда печатаете в терминале (обычно на английской раскладке) или в каком то чате (на русском например). Еще одной полезной вещью данного демона является поддержка уведомлений D-Bus(опционально) - что позволяет иму выдавать сигналы об изменении раскладки, что делает возможным создание на его основе виджета.

Во первых, посетите домашнюю страницу '''''kbdd''''' и установите последнюю версию (по словам автора шансы найти его в репозитории очень низки, но у меня в Debian, он нашелся легко #apt-get install kbdd). [http://gentoo.org/ Gentoo] пользователя рекомендуется использовать [http://code.google.com/p/rion-overlay/ ''rion'' overlay].

Убедитесь, что вы верно настроили ваш сервер Xorg, и ''kbdd'' использует его настройки (чтобы не мучаться с настройками, можно сначала запустить Х, а затем уже в секции автозапуска файла rc.lua запусить kbdd). Затем запустите kbdd.

Следующий код позволит вам создать виджет для Awesome:

Awesome &lt;3.5
&lt;pre&gt;
-- Виджет переключателя клавиатуры
kbdwidget = widget({type = &quot;textbox&quot;, name = &quot;kbdwidget&quot;})
kbdwidget.border_width = 1
kbdwidget.border_color = beautiful.fg_normal
kbdwidget.text = &quot; Eng &quot;
&lt;/pre&gt;

Awesome 3.5+ version:
&lt;pre&gt;
-- Виджет переключения клавиатуры
kbdwidget = wibox.widget.textbox(&quot; Eng &quot;)
kbdwidget.border_width = 1
kbdwidget.border_color = beautiful.fg_normal
kbdwidget:set_text(&quot; Eng &quot;)
&lt;/pre&gt;

…следующий код разместите где угодно(можно даже после инициализации виджета), он прослушивает уведомления D-Bus (для не gentoo систем ничего менять не нужно):

&lt;pre&gt;
dbus.request_name(&quot;session&quot;, &quot;ru.gentoo.kbdd&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='ru.gentoo.kbdd',member='layoutChanged'&quot;)
dbus.add_signal(&quot;ru.gentoo.kbdd&quot;, function(...)
    local data = {...}
    local layout = data[2]
    lts = {[0] = &quot;Eng&quot;, [1] = &quot;Рус&quot;}
    kbdwidget.text = &quot; &quot;..lts[layout]..&quot; &quot;
    end
)
&lt;/pre&gt;

Awesome 3.5+ version:
&lt;pre&gt;
kbdstrings = {[0] = &quot; Eng &quot;, 
              [1] = &quot; Рус &quot;}

dbus.request_name(&quot;session&quot;, &quot;ru.gentoo.kbdd&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='ru.gentoo.kbdd',member='layoutChanged'&quot;)
dbus.connect_signal(&quot;ru.gentoo.kbdd&quot;, function(...)
    local data = {...}
    local layout = data[2]
    kbdwidget:set_markup(kbdstrings[layout])
    end
)
&lt;/pre&gt;

В этом примере первой раскладкой (пронумерованна &quot;0&quot;) является Английская, и обознчаена как &quot;Eng&quot;, а вторая Русская (&quot;1&quot;, &quot;Рус&quot;). Отредактируйте его как вам угодно, меняйте фон, добавляйте изображение вместо текста и т.д.

Это простейший пример. Смотрите [http://github.com/qnikst/kbdd/wiki '''''kbdd''' wiki''] и управляйте в деталях прослушивание и управление D-Bus.

== Расширение раскладок и оформления ==

Здесь описан более сложный пример использования kbdd-производного виджета с фоновым изображением и меню выбора раскладки написанная [https://plus.google.com/u/0/108851120880764769721/posts Mellon].
 * Левая кнопка мыши переключает между двумя наиболее частыми раскладками.
 * Средняя кнопка переключает на следущую раскладку.
 * Правая клавиша открывает меню.
Виджет изменяет состояние в соотвествии с сигналами ''kbdd'' через D-BUSs, раскладки меняются вызовом метода ''kbdd'' D-BUS.
Код может изменяться, поэтому смотрите пример здесь и убедитесь, что он соответсвует последней версии на GoogleCode.

[[File:Mellon_kbdd.png]]

Файл [http://code.google.com/p/qmellon/source/browse/home/.config/awesome/kbd.lua kbd.lua]
&lt;pre&gt;
-- {{{ Определение переменных
kbd_dbus_sw_cmd = &quot;qdbus ru.gentoo.KbddService /ru/gentoo/KbddService  ru.gentoo.kbdd.set_layout &quot;
-- kbd_dbus_sw_cmd = &quot;dbus-send --dest=ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.set_layout uint32:&quot;
kbd_dbus_prev_cmd = &quot;qdbus ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.prev_layout&quot;
-- kbd_dbus_prev_cmd = &quot;dbus-send --dest=ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.prev_layout&quot;
kbd_dbus_next_cmd = &quot;qdbus ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.next_layout&quot;
-- kbd_dbus_next_cmd = &quot;dbus-send --dest=ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.next_layout&quot;
kbd_img_path = &quot;/usr/share/icons/kbflags/&quot;
-- }}}

-- {{{ виджет раскладки клавиатуры
--- Создаем меню
kbdmenu =awful.menu({ items = {  { &quot;English&quot;, kbd_dbus_sw_cmd .. &quot;0&quot;,  kbd_img_path .. &quot;us.png&quot; },
	{ &quot;Русский&quot;, kbd_dbus_sw_cmd .. &quot;1&quot;, kbd_img_path .. &quot;ru.png&quot; },
	{ &quot;Hebrew&quot;, kbd_dbus_sw_cmd .. &quot;2&quot;, kbd_img_path .. &quot;il.png&quot; },
	{ &quot;Deutsch&quot;, kbd_dbus_sw_cmd .. &quot;3&quot;, kbd_img_path .. &quot;de.png&quot; }
	}
})

-- Создаем простой текстовый виджет
kbdwidget = widget({type = &quot;textbox&quot;, name = &quot;kbdwidget&quot;})
-- kbdwidget.border_width = 1
-- kbdwidget.border_color = beautiful.fg_normal
kbdwidget.align=&quot;center&quot;
kbdwidget.text = &quot;&lt;b&gt;Eng&lt;/b&gt;&quot;
kbdwidget.bg_image = image (kbd_img_path .. &quot;us.png&quot;)
kbdwidget.bg_align = &quot;center&quot;
kbdwidget.bg_resize = true
awful.widget.layout.margins[kbdwidget] = { left = 0, right = 10 }
kbdwidget:buttons(awful.util.table.join(
	awful.button({ }, 1, function() os.execute(kbd_dbus_prev_cmd) end),
	awful.button({ }, 2, function() os.execute(kbd_dbus_next_cmd) end),
	awful.button({ }, 3, function() kbdmenu:toggle () end)
))
-- }}}

-- {{{ Signals
dbus.request_name(&quot;session&quot;, &quot;ru.gentoo.kbdd&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='ru.gentoo.kbdd',member='layoutChanged'&quot;)
dbus.add_signal(&quot;ru.gentoo.kbdd&quot;, function(...)
	local data = {...}
	local layout = data[2]
	lts = {[0] = &quot;Eng&quot;, [1] = &quot;Рус&quot;, [2] = &quot;Heb&quot;, [3] = &quot;Deu&quot;}
	lts_img = {[0] = kbd_img_path .. &quot;us.png&quot;, [1] = kbd_img_path .. &quot;ru.png&quot;, [2] = kbd_img_path .. &quot;il.png&quot;, [3] = kbd_img_path .. &quot;de.png&quot; }
	kbdwidget.text = &quot;&lt;b&gt;&quot;..lts[layout]..&quot;&lt;/b&gt;&quot;
	kbdwidget.bg_image = image(lts_img[layout])
	end)
-- }}}
&lt;/pre&gt;

Файл [http://code.google.com/p/qmellon/source/browse/home/.config/awesome/rc.lua#115 rc.lua]
&lt;pre&gt;
-- {{{ Load user widgets
dofile(awful.util.getdir(&quot;config&quot;) .. &quot;/kbd.lua&quot;)
-- }}}

    -- Add widgets to the wibox - order matters
    mywibox[s].widgets = {
--     ...
        s == 1 and kbdwidget or nil,
--     ...
    }

-- My keybindings
globalkeys = awful.util.table.join(globalkeys,
    awful.key({ modkey, &quot;Mod1&quot;    }, &quot;1&quot;,     function () os.execute(kbd_dbus_sw_cmd .. &quot;0&quot;) end),
    awful.key({ modkey, &quot;Mod1&quot;    }, &quot;2&quot;,     function () os.execute(kbd_dbus_sw_cmd .. &quot;1&quot;) end),
    awful.key({ modkey, &quot;Mod1&quot;    }, &quot;3&quot;,     function () os.execute(kbd_dbus_sw_cmd .. &quot;2&quot;) end),
    awful.key({ modkey, &quot;Mod1&quot;    }, &quot;4&quot;,     function () os.execute(kbd_dbus_sw_cmd .. &quot;3&quot;) end),
    awful.key({  &quot;Control&quot;  }, &quot;ISO_Level3_Shift&quot;,     function () os.execute(kbd_dbus_prev_cmd) end)
)
&lt;/pre&gt;

Иконки использовались из [http://kde-look.org/content/show.php/translatoid?content=97511 translatoid's] (translator plasmoid using google translator).

[[Category:awesome3]]
[[Category:Widgets]]</text>
      <sha1>1tzo7wggj3g8wd4hdctmdy2l2pjr3h9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keychains</title>
    <ns>0</ns>
    <id>874</id>
    <revision>
      <id>6708</id>
      <parentid>5937</parentid>
      <timestamp>2014-06-04T15:49:58Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1434">{{Languages}}

A simple keychain module which allows to use keychains in awesome window
manager. You can do the following:

If you press 'winkey+c', a notify will popup and you can press
    'g' to open your gmail
    'a' to open awesome web page
    'w' to open awesome wiki

How can do this? The answer is simple:

 require(&quot;keychains&quot;)
 
 -- don't forget to initailize your 'globalkeys' table
 
 keychains.init(globalkeys,your_desired_options)
 
 keychains.add({winkey},&quot;c&quot;,&quot;Web pages&quot;, desired_icon, {
        g   =   {
            func    =   function()
                open_url(&quot;https://mail.google.com/mail/u/0/#search/l%3Aunread&quot;)
            end,
            info    =   &quot;Gmail - unread emails&quot;
        },
        a   =   {
            func    =   function()
                open_url(&quot;http://awesome.naquadah.org/&quot;)
            end,
            info    =   &quot;awesome web page&quot;
        },
        w   =   {
            func    =   function()
                open_url(&quot;http://awesome.naquadah.org/wiki/Main_Page&quot;)
            end,
            info    =   &quot;awesome wiki&quot;
        }
 })

The last parameter of ''keychains.add()'' can be a function too which generates similar table above - so you can create dynamic lists depends on your needs.

After all ''keychains.add()'' should call ''start()'' to activite:

    keychains.start()

You can install from here [https://github.com/uzsolt/keychains], more informations see README!</text>
      <sha1>9urqr9e071i2h64e40slqtbx2ko94xq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keychains/ru</title>
    <ns>0</ns>
    <id>1099</id>
    <revision>
      <id>6710</id>
      <timestamp>2014-06-04T16:06:56Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Keychains (translating page)</comment>
      <text xml:space="preserve" bytes="2102">{{Languages|Keychains}}

Простейший модуль связки клавиш, позволяющий использовать связку клавиш в оконном менеджере Awesome. Вы можете сделать следующее:

Если вы нажмете 'winkey+c', появится всплывающее уведомление и вы можете нажать
    'g' to open your gmail
    'a' to open awesome web page
    'w' to open awesome wiki

Как можно это сделать? Ответ прост:
&lt;pre&gt;
 require(&quot;keychains&quot;)
 
 -- не забудьте инициализировать вашу таблицу 'globalkeys'
 
 keychains.init(globalkeys,your_desired_options)
 
 keychains.add({winkey},&quot;c&quot;,&quot;Web pages&quot;, desired_icon, {
        g   =   {
            func    =   function()
                open_url(&quot;https://mail.google.com/mail/u/0/#search/l%3Aunread&quot;)
            end,
            info    =   &quot;Gmail - unread emails&quot;
        },
        a   =   {
            func    =   function()
                open_url(&quot;http://awesome.naquadah.org/&quot;)
            end,
            info    =   &quot;awesome web page&quot;
        },
        w   =   {
            func    =   function()
                open_url(&quot;http://awesome.naquadah.org/wiki/Main_Page&quot;)
            end,
            info    =   &quot;awesome wiki&quot;
        }
 })
&lt;/pre&gt;

Последний параметр ''keychains.add()'' может также являться функцией которая создает таблицу подобную описанной выше - поэтому вы можете создавать динамический список в зависимости от ваших потребностей.

После этого ''keychains.add()'' должен вызвать ''start()'' для активации:

    keychains.start()

Вы можете установить модуль со [https://github.com/uzsolt/keychains страницы на Github]. 
Для получения дополнительной информации прочтите README!</text>
      <sha1>k2q4aplm8aezptwmxsfa3221oiuxfa0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Keycodes</title>
    <ns>0</ns>
    <id>1242</id>
    <revision>
      <id>7202</id>
      <parentid>7201</parentid>
      <timestamp>2014-12-21T16:27:53Z</timestamp>
      <contributor>
        <username>MohsenPahlevanzadeh</username>
        <id>4089</id>
      </contributor>
      <comment>/* Set key map */</comment>
      <text xml:space="preserve" bytes="6830">[[File:keyboard.jpg|500px|300px]]

You can find everything about keyboard, keycode,keybind and so on,&lt;br /&gt;
Edward Moy wrote a nice documentation on keycode and you can download from [[http://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf here.]]

Sure, you need to keycode and bind to your functions or etc. LQ wiki has a complete refrence to keycode [http://wiki.linuxquestions.org/wiki/List_of_Keysyms_Recognised_by_Xmodmap here].

But every programmer need to hack some key or some reacts again pressing each key or combining keys, For helping to users, GNU/Linux has some commands:&lt;br&gt;
[http://linux.die.net/man/1/showkey showkey(1)]&lt;br&gt;
[http://linux.die.net/man/1/dumpkeys dumpkeys(1)]&lt;br&gt;
[http://linux.die.net/man/1/setxkbmap setxkbdmap(1)]&lt;br&gt;
[http://linux.die.net/man/1/xmodmap xmodmap(1)]&lt;br&gt;


== showkey command ==
Do you remember DOS programming? Scan codes? At first check 0 then check code? 

  root@debian:/home/mohsen# showkey --scancodes
 kb mode was ?UNKNOWN?
 [ if you are trying this under X, it might not work
 since the X server is also reading /dev/console ]
 press any key (program terminates 10s after last keypress)...  
 0x9c 
 30x04 0x84 
 0x36 
 0xb6 
 0x36 
 :0x27 0xa7 
 0xb6 
 0x36 
 !0x02 0x82 0xb6 
 0x36 
 #0x04 
 0x84 0xb6 
 0x1d 
 ^Ccaught signal 2, cleaning up...

When you use : 

  root@debian:/home/mohsen# showkey --keycodes
 kb mode was ?UNKNOWN?
 [ if you are trying this under X, it might not work
 since the X server is also reading /dev/console ] 
 press any key (program terminates 10s after last keypress)...
 keycode  28 release
 1keycode   2 press
 keycode   2 release
 keycode  28 press
 keycode  28 release
 2keycode   3 press
 keycode   3 release
 3keycode   4 press

== dumpkeys command ==
dumpkeys is a powerfull and useful command, when you run it without parameters, it return 7673 line:

 root@debian:/home/mohsen# dumpkeys |wc -l
 7673

The part of output of this command:

  keycode   4 = three           
   shift	keycode   4 = numbersign      
   shift	altgr	keycode   4 = numbersign      
   shift	control	keycode   4 = numbersign      
   shift	altgr	control	keycode   4 = numbersign      
   alt	keycode   4 = Meta_three      
   shift	alt	keycode   4 = Meta_numbersign 
   altgr	alt	keycode   4 = Meta_three      
   shift	altgr	alt	keycode   4 = Meta_numbersign 
   control	alt	keycode   4 = Meta_three      
   shift	control	alt	keycode   4 = Meta_numbersign 
   altgr	control	alt	keycode   4 = Meta_three      
   shift	altgr	control	alt	keycode   4 = Meta_numbersign 
   shift	shiftl	keycode   4 = numbersign      
   shift	altgr	shiftl	keycode   4 = numbersign      
   shift	control	shiftl	keycode   4 = numbersign      
   shift	altgr	control	shiftl	keycode   4 = numbersign      
	  
And another output of this command:

 compose '/' 'o' to U+00f8
 compose '`' 'U' to U+00d9
 compose '`' 'u' to U+00f9
 compose '\'' 'U' to U+00da
 compose '\'' 'u' to U+00fa
 compose '^' 'U' to U+00db
 compose '^' 'u' to U+00fb
 compose '&quot;' 'U' to U+00dc
 compose '&quot;' 'u' to U+00fc 
 compose '\'' 'Y' to U+00dd
 compose '\'' 'y' to U+00fd
 compose 'T' 'H' to U+00de
 compose 't' 'h' to U+00fe

Another output of this command:

 0x0016	Control_v
 0x0017	Control_w
 0x0018	Control_x
 0x0019	Control_y
 0x001a	Control_z
 0x001b	Escape
 0x001c	Control_backslash
 0x001d	Control_bracketright
 0x001e	Control_asciicircum
 0x001f	Control_underscore
 0x0020	space
 0x0021	exclam
 0x0022	quotedbl
 0x0023	numbersign 
 0x0024	dollar
 0x0025	percent
 0x0026	ampersand
 0x0027	apostrophe
 0x0028	parenleft
 0x0029	parenright


When you want to fidn out which key support by kernel , you can use:
 &lt;nowiki&gt;
 root@debian:/home/mohsen# dumpkeys -i
 keycode range supported by kernel:           1 - 255
 max number of actions bindable to a key:         256
 number of keymaps in actual use:                 128
 of which 121 dynamically allocated
 ranges of action codes supported by kernel:
 	 0x0000 - 0x00ff
	 0x0100 - 0x01ff
	 0x0200 - 0x0213
	 0x0300 - 0x0313
	 0x0400 - 0x0405
	 0x0500 - 0x05ff
	 0x0600 - 0x0603
	 0x0700 - 0x0708
	 0x0800 - 0x08ff
	 0x0900 - 0x0919
	 0x0a00 - 0x0a08
	 0x0b00 - 0x0bff
	 0x0c00 - 0x0c08
	 0x0d00 - 0x0dff
 	 0x0e00 - 0x0e0a
 number of function keys supported by kernel: 256
 max nr of compose definitions: 256
 nr of compose definitions in actual use: 68
 &lt;/nowiki&gt;

&lt;code&gt;dumpkeys -l&lt;/code&gt; vs &lt;code&gt;dummpkeys&lt;/code&gt; without parameters! Yes, without parameters returns more than 7000 lines output, and with &lt;code&gt;-l&lt;/code&gt; option return more than 800 lines output.What's your idea? Yes, &lt;code&gt;dumpkeys -l&lt;/code&gt; eliminated some useless output.

== setxkbdmap command ==
You can divide its duties into two sections:
* Get result
* Set key map

=== Get result ===

&lt;code&gt;setxkbdmap&lt;/code&gt; command can give you useful information about keyboard. Practical:
 &lt;nowiki&gt;
 root@debian:/home/mohsen# setxkbmap -query
 rules:      evdev
 model:      inspiron
 layout:     us
 &lt;/nowiki&gt;

suppose you want to retrive current layout from &lt;code&gt;setxkbdmap&lt;/code&gt; command, You can do it:

 setxkbmap -query |grep layout |awk -F: {'lay=$2;sub(/^[ \t\r\n]+/, &quot;&quot;, lay);sub(/[ \t\r\n]+$/, &quot;&quot;, lay);print lay'}

Along with &lt;code&gt;-query&lt;/code&gt; option, You can use the &lt;codde&gt;-print&lt;/code&gt; option for getting X information:
 &lt;nowiki&gt;
root@debian:/home/mohsen# setxkbmap -print
xkb_keymap {
	xkb_keycodes  { include &quot;evdev+aliases(qwerty)&quot;	};
	xkb_types     { include &quot;complete&quot;	};
	xkb_compat    { include &quot;complete&quot;	};
	xkb_symbols   { include &quot;pc+us+inet(evdev)&quot;	};
	xkb_geometry  { include &quot;pc(pc104)&quot;	};
};
 &lt;/nowiki&gt;
=== Set key map ===
You can set you keyboard layout with &lt;code&gt;setxkbdmap&lt;/code&gt; command , For example:

 setxkbdmap us ##Switch to English language
 setxkbdmap ir ##Switch to Persian language
 setxkbmap ru  ## Switch to Russian language
 setxkbmap jp ##Switch to Japanese language

However you can set many parameters with &lt;code&gt;setxkbdmap&lt;/code&gt; foor your language, if you want, please hack &lt;code&gt;man 1 setxkbdmap&lt;/code&gt;

== xmodmap command ==
Sure, You're familar with modifier keys:&lt;br&gt;
&lt;code&gt;⇧ Shift&lt;/code&gt; Shift key&lt;br&gt;
&lt;code&gt;Ctrl&lt;/code&gt;(&lt;b&gt;C&lt;/b&gt;on&lt;b&gt;tr&lt;/b&gt;o&lt;b&gt;l&lt;/b&gt;) &lt;br&gt;
&lt;code&gt;Alt&lt;/code&gt;(&lt;b&gt;Alt&lt;/b&gt;ernate) – also labelled&lt;code&gt; ⌥ Option&lt;/code&gt; on Apple Macintosh keyboards  &lt;br&gt;
&lt;code&gt;AltGr&lt;/code&gt;(&lt;b&gt;Alt&lt;/b&gt;ernate &lt;b&gt;Gr&lt;/b&gt;aphic) &lt;br&gt;
&lt;code&gt;&amp;#9830;&lt;/code&gt;– Meta key, found on MIT, Symbolics, and Sun Microsystems keyboards&lt;br&gt;
&lt;code&gt;Windows Log&lt;/code&gt; found on Windows keyboards (However if you read other documentation, you prevent other name such as super key in Gnome documentations.)&lt;br&gt;
&lt;code&gt;⌘ command&lt;/code&gt;– Command key, found on Apple Macintosh keyboards. On older keyboards marked with the Apple logo. &lt;br&gt;
&lt;code&gt;Fn&lt;/code&gt;(&lt;b&gt;F&lt;/b&gt;unctio&lt;b&gt;n&lt;/b&gt;) – present on small-layout keyboard, usually on notebooks. &lt;br&gt;</text>
      <sha1>33it8zug3dw4jd26xu9h7ayipns7hv0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Klaus Dieter volume widget FreeBSD</title>
    <ns>0</ns>
    <id>272</id>
    <revision>
      <id>2701</id>
      <parentid>2233</parentid>
      <timestamp>2009-05-23T07:37:38Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Awesome3 category again</comment>
      <text xml:space="preserve" bytes="2079">This is my volume changer widget - it does not do muting yet but its easy to implement.
Also it updates the progress bar as soon as the user scrolls on the bar.
To make the popup work you need naughty.


  volumewidget = widget({ type = &quot;progressbar&quot;, name = &quot;volumewidget&quot;,  align = &quot;right&quot; })
  volumewidget.width = 40
  volumewidget.height = 0.40
  volumewidget.ticks_count = 100 
  
  volumewidget.gap = 1
  volumewidget.border_padding = 1
  volumewidget.border_width = 0
  volumewidget.ticks_gap = 0
  volumewidget.vertical = false
  volumewidget:bar_properties_set('vol', {
    bg = 'black',
    fg = 'blue4',
    fg_off = 'red',
    reverse = false,
    min_value = 0,
    max_value = 100
  })
  
  local mixer = nil
  
  function remove_mixer()
    if mixer ~= nil then
      naughty.destroy(mixer)
      mixer = nil
    end
  end
  
  function add_mixer()
    local mix = awful.util.pread(&quot;mixer |sed -e 's/Mixer//' -e 's/currently //'&quot;);
  
    remove_mixer()
  
    mixer = naughty.notify({
      text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;',&quot;monospace&quot;, mix),
      timeout = 0, hover_timeout = 0.5,
      width = 220
    })
  end
 
  volumewidget.mouse_enter = function()
    add_mixer(0)
  end
  volumewidget.mouse_leave = remove_mixer
  
  
  volumewidget:buttons({
  
    button({ }, 5, function()
      os.execute(&quot;mixer vol -5:-5 pcm -5:-5&quot;)
      volval = volval - 5
      volumewidget:bar_data_add(&quot;vol&quot;, volval)
  end),
    button({ }, 4, function()
      os.execute(&quot;mixer vol +5:+5 pcm +5:+5&quot;)
      volval = volval + 5
      volumewidget:bar_data_add(&quot;vol&quot;, volval)
  end),
  
  })
  
  --{{{ batt hook
  local function get_vol()
  local vol =   awful.util.pread(&quot;/usr/sbin/mixer vol|/usr/bin/awk '{print $7}'|/usr/bin/cut -d: -f1&quot;)
  local pcm = awful.util.pread(&quot;/usr/sbin/mixer pcm|awk '{print $7}'|cut -d: -f1&quot;) 
  local val = math.floor( (vol + pcm ) / 2 )
  volumewidget:bar_data_add(&quot;vol&quot;, val )
  volval = val
  --   dtextbox.text =  tostring(pcm)
  end
  
  awful.hooks.timer.register(30, function() get_vol() end)

[[Category:Awesome3]]</text>
      <sha1>575gpey70e0ljrovsdcjyq7nnkaxnhv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Kooky IRC Client</title>
    <ns>0</ns>
    <id>282</id>
    <revision>
      <id>4238</id>
      <parentid>2717</parentid>
      <timestamp>2010-04-27T15:06:20Z</timestamp>
      <contributor>
        <username>Garoth</username>
        <id>129</id>
      </contributor>
      <text xml:space="preserve" bytes="4064">== Function code ==
This code is based on http://www.endoneight.com/29_lua-irc-bot .
You will need the lua socket library http://www.tecgraf.puc-rio.br/~diego/professional/luasocket/

  local socket = require(&quot;socket&quot;)
  local io = io
  local string = string
 
  module(&quot;irc&quot;)
  local connection
  local host
  local port
  local channel
  local nickname
  local messages = {
        ptr = 0, 
        size = -1
  }
 
  function initialize(settings)
        host = settings.host
        port = settings.port
        nickname = settings.nickname
        channel = settings.channel
        connection = socket.tcp()
        connection:settimeout(1)
  end
 
  function connect()
        if connection == nil then
                connection = socket.tcp()
                connection:settimeout(1)
        end
        connection:connect(host, port)
        send(&quot;NICK &quot;..nickname)
        send(&quot;USER Awesome 0 * :awesome-git&quot;)
  end
 
 function disconnect()
        if connection ~= nil then
                connection:close()
        end
        connection = nil
  end
 
  function read()
        local buffer, err
        local prefix, cmd, param, param1, param2
        local user, userhost
        err = nil
        if connection ~= nil then
                while not err do
                        buffer, err = connection:receive(&quot;*l&quot;)
                        if not err then
                                if string.sub(buffer,1,4) == &quot;PING&quot; then
                                        send(string.gsub(buffer,&quot;PING&quot;,&quot;PONG&quot;,1))
                                else
                                        prefix, cmd, param = string.match(buffer, &quot;^:([^ ]+) ([^ ]+)(.*)$&quot;)
                                        if param ~= nil then
                                                param = string.sub(param,2)
                                                param1, param2 = string.match(param,&quot;^([^:]+) :(.*)$&quot;)
                                                if cmd == &quot;PRIVMSG&quot; then
                                                        user, userhost = string.match(prefix,&quot;^([^!]+)!(.*)$&quot;)
                                                        messages.size = messages.size + 1
                                                        messages[messages.size] = {}
                                                        messages[messages.size].nick = user
                                                        messages[messages.size].message = param2
                                                end
                                        end
                                end
                        end
                end
        end
        return buffer, err
  end
 
  function send(data)
        if connection ~= nil then
                connection:send(data..&quot;\r\n&quot;)
        end
  end
 
  function message()
        local ptr = messages.ptr
        if ptr &gt; messages.size then 
                return nil 
        end
        local message = messages[ptr]
        messages[ptr] = nil
        messages.ptr = ptr + 1
        return message
  end
 
  function messages_size()
        return messages.size
  end
 
== Usage ==

To use the module in awesome just require it in your rc.lua and set the host, port and the nickname of your client in a table


  require(&quot;irc&quot;)
 
  irc.settings = {}
  irc.settings.host = &quot;irc.oftc.net&quot;
  irc.settings.port = 6667
  irc.settings.nickname = &quot;awesome&quot;
 
  irc.initialize(irc.settings)
  irc.connect()
 
  awful.hooks.timer.register(10, function ()
        if irc.messages_size() &gt; 0 then
                msg = irc.message()
                if msg ~= nil then
                        irc.popup = naughty.notify({ 
                                title = &quot;IRC&quot;,
                                text = msg.nick..&quot;: &quot;..msg.message, 
                                hover_timeout = 3, 
                                timeout = 10
                        })
                end
         end
  end)
 
  awful.hooks.timer.register(1, function ()
        irc.read()
  end)


Have Fun!

[[Category:Awesome3]]</text>
      <sha1>f9cnme80ff182lm3zpcdpdmtzvvqc58</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Kooky geo</title>
    <ns>0</ns>
    <id>292</id>
    <revision>
      <id>2718</id>
      <parentid>2381</parentid>
      <timestamp>2009-05-23T08:06:05Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>This also goes into [[Category:Awesome3]]</comment>
      <text xml:space="preserve" bytes="2804">This little script lets you calculate the distance (in meter) between two locations.
[http://www.markurashi.de/dotfiles/awesome/2009-02-25_19:56:49.png  Screenshot ]

== Function code ==
You will need the lua socket library http://www.tecgraf.puc-rio.br/~diego/professional/luasocket/

  local http = require(&quot;socket.http&quot;)
  local print = print
  local math = math
  local string = string
  local tonumber = tonumber
  local sin = math.sin
  local cos = math.cos
  local asin = math.asin
  local sqrt = math.sqrt
  local min = math.min
  local abs = math.abs
  local pi = math.pi
  
  module(&quot;geo&quot;)
  local googleKey
  
  function distance(from, to)
   local distance = 0
   local radius = 6367000
   local radian = pi / 180
   local deltaLatitude = sin(radian * (from.latitude - to.latitude) /2)
   local deltaLongitude = sin(radian * (from.longitude - to.longitude) / 2)
   
   local circleDistance = 2 * asin(min(1, sqrt(deltaLatitude * deltaLatitude + 
      cos(radian * from.latitude) * cos(radian * to.latitude) * deltaLongitude * deltaLongitude)))
   distance = abs(radius * circleDistance)
   return distance
  end
  
  function point(address)
   local point = {}
   point.accuracy = 0
   point.latitude = 0.0
   point.longitude = 0.0
   address = string.gsub(address, &quot;([^A-Za-z0-9_])&quot;, function(c)
    return string.format(&quot;%%%02x&quot;, string.byte(c))
    end)
   local request = &quot;http://maps.google.com/maps/geo?output=csv&amp;q=&quot;..address..&quot;&amp;key=&quot;
   if googleKey then
    request = request..googleKey
   end
  
   local c, err, h = http.request(request)
   if c then
    err, point.accuracy, point.latitude, point.longitude = c:match(&quot;(.*),(.*),(.*),(.*)&quot;)
   end
   
   point.accuracy = tonumber(point.accuracy)
   point.latitude = tonumber(point.latitude)
   point.longitude = tonumber(point.longitude)
  
   return point
  end


== Usage ==
After that you can set your own location in your rc.lua

  require(&quot;geo&quot;)
  
  location = geo.point(&quot;Your Street and City&quot;)

And bind a key so you have a prompt where you can enter any location you wanna move or something and the script will show you the distance and any other nessary information about the location

  table.insert(globalkeys, key({ modkey }, &quot;F6&quot;, function ()
    awful.prompt.run({ prompt = &quot;Address: &quot; },
      promptbox[mouse.screen],
      function(h)
        local point = geo.point(h)
        naughty.notify({ 
          title = h,
          text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace 6&quot;,
            &quot;Latitude: &quot;..point.latitude..&quot;\n&quot;..
            &quot;Longitude: &quot;..point.longitude..&quot;\n&quot;..
            &quot;Accuracy: &quot;..point.accuracy..&quot;\n&quot;..
            &quot;Distance: &quot;..geo.distance(location, point)..&quot;m&quot;), 
          hover_timeout = 3, 
          timeout = 10,
        })
  end)
  end))

[[Category:Awesome3]]</text>
      <sha1>3ndw6t2490ltzyiznmw6upc0755l2dj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Kooky wikipedia completion</title>
    <ns>0</ns>
    <id>286</id>
    <revision>
      <id>6658</id>
      <parentid>2707</parentid>
      <timestamp>2014-05-25T17:52:49Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2190">{{Languages}}

== Function code ==
You will need the lua socket library http://www.tecgraf.puc-rio.br/~diego/professional/luasocket/ and the lua json library http://json.luaforge.net/

  local json = require(&quot;json&quot;)
  local http = require(&quot;socket.http&quot;)
  local table = table
  local io = io
  local os = os
  local print = print
  
  function wikipedia(command, cur_pos, ncomp)
    local wstart = 1
    local wend = 1
    local words = {}
    local cword_index = 0
    local cword_start = 0
    local cword_end = 0
    local i = 1
  
    if cur_pos ~= #command + 1 and command:sub(cur_pos, cur_pos) ~= &quot; &quot; then
      return command, cur_pos
    elseif #command == 0 then
      return command, cur_pos
    end
  
    while wend &lt;= #command do
      wend = command:find(&quot; &quot;, wstart)
      if not wend then wend = #command + 1 end
      table.insert(words, command:sub(wstart, wend - 1))
      if cur_pos &gt;= wstart and cur_pos &lt;= wend + 1 then
         cword_start = wstart
         cword_end = wend
         cword_index = i
      end
      wstart = wend + 1
      i = i + 1
    end
    local c, err, h = http.request(&quot;http://de.wikipedia.org/w/api.php?action=opensearch&amp;search=&quot;..words[cword_index]..&quot;&amp;format=json&quot;)
    local output = {}
    i = 0
    if c then
      c = json.decode(c)
      for i=2, table.getn(c[2]) do
        local entry = c[2][i]
        if not entry then break end
        table.insert(output, entry)
      end
    else
      print(err)
    end
  
    if #output == 0 then
      return command, cur_pos
    end
    while ncomp &gt; #output do
      ncomp = ncomp - #output
    end
  
    local str = command:sub(1, cword_start - 1) .. output[ncomp] .. command:sub(cword_end)
    cur_pos = cword_end + #output[ncomp] + 1
  
    return str, cur_pos
  end

== Usage ==

  key({ modkey }, &quot;F7&quot;,
        function ()
            awful.prompt.run({ prompt = &quot;Search: &quot; },
            mypromptbox[mouse.screen],
            function(h)
              awful.util.spawn(browser .. &quot; 'http://de.wikipedia.org/w/index.php?title=Spezial:Suche&amp;amp;search=&quot; .. h..&quot;'&quot;)
            end, wikipedia,
            awful.util.getdir(&quot;cache&quot;) .. &quot;/history&quot;)
        end),

[[Category:Awesome3]]</text>
      <sha1>8oz2cvoe1kpvt9n8cuwfdmbtfhrp1n1</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Kooky wikipedia completion/ru</title>
    <ns>0</ns>
    <id>1087</id>
    <revision>
      <id>6660</id>
      <timestamp>2014-05-25T17:59:46Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевоада Kooky wikipedia completion (translating page)</comment>
      <text xml:space="preserve" bytes="2335">{{Languages|Kooky wikipedia completion}}
{{DISPLAYTITLE:Автозавершение для Wikipedia}}

== Код функции ==
Вам потребуется библиотеки [http://www.tecgraf.puc-rio.br/~diego/professional/luasocket/ lua socket] и [http://json.luaforge.net/ lua json] 

  local json = require(&quot;json&quot;)
  local http = require(&quot;socket.http&quot;)
  local table = table
  local io = io
  local os = os
  local print = print
  
  function wikipedia(command, cur_pos, ncomp)
    local wstart = 1
    local wend = 1
    local words = {}
    local cword_index = 0
    local cword_start = 0
    local cword_end = 0
    local i = 1
  
    if cur_pos ~= #command + 1 and command:sub(cur_pos, cur_pos) ~= &quot; &quot; then
      return command, cur_pos
    elseif #command == 0 then
      return command, cur_pos
    end
  
    while wend &lt;= #command do
      wend = command:find(&quot; &quot;, wstart)
      if not wend then wend = #command + 1 end
      table.insert(words, command:sub(wstart, wend - 1))
      if cur_pos &gt;= wstart and cur_pos &lt;= wend + 1 then
         cword_start = wstart
         cword_end = wend
         cword_index = i
      end
      wstart = wend + 1
      i = i + 1
    end
    local c, err, h = http.request(&quot;http://ru.wikipedia.org/w/api.php?action=opensearch&amp;search=&quot;..words[cword_index]..&quot;&amp;format=json&quot;)
    local output = {}
    i = 0
    if c then
      c = json.decode(c)
      for i=2, table.getn(c[2]) do
        local entry = c[2][i]
        if not entry then break end
        table.insert(output, entry)
      end
    else
      print(err)
    end
  
    if #output == 0 then
      return command, cur_pos
    end
    while ncomp &gt; #output do
      ncomp = ncomp - #output
    end
  
    local str = command:sub(1, cword_start - 1) .. output[ncomp] .. command:sub(cword_end)
    cur_pos = cword_end + #output[ncomp] + 1
  
    return str, cur_pos
  end

== Использование ==

  key({ modkey }, &quot;F7&quot;,
        function ()
            awful.prompt.run({ prompt = &quot;Wiki поиск: &quot; },
            mypromptbox[mouse.screen],
            function(h)
              awful.util.spawn(browser .. &quot; 'http://ru.wikipedia.org/w/index.php?title=Spezial:Suche&amp;amp;search=&quot; .. h..&quot;'&quot;)
            end, wikipedia,
            awful.util.getdir(&quot;cache&quot;) .. &quot;/history&quot;)
        end),

[[Category:Awesome3]]</text>
      <sha1>40ogkp3qk8196x4zv25qg7f89g1huqu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Kooky xkcd</title>
    <ns>0</ns>
    <id>283</id>
    <revision>
      <id>2719</id>
      <parentid>2302</parentid>
      <timestamp>2009-05-23T08:06:33Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Uhm, yeah, goes into [[Category:Awesome3]]</comment>
      <text xml:space="preserve" bytes="1473">= Kooky's xkcd =
Just a little script to download a random xkcd comic that can be displayed in a naughty popup

== Function code ==
You will need the lua socket library http://www.tecgraf.puc-rio.br/~diego/professional/luasocket/

  local http = require(&quot;socket.http&quot;)
  local ltn12 = require(&quot;ltn12&quot;)
  local io = io
  local string = string
  module(&quot;xkcd&quot;)
  local tempfile
  function initialize(filename)
    tempfile = filename
  end
  function comic()
    local body
    local code
    local header
    local sStart
    local sEnd
    local img
    body, code, header = http.request(&quot;http://dynamic.xkcd.com/comic/random/&quot;)
    sStart, sEnd = string.find(body, &quot;&lt;img src=[\&quot;'](.-)[\&quot;']&quot;)
    if sEnd ~= nil then
      img = string.match(body, &quot;&lt;img src=[\&quot;'](.-)[\&quot;']&quot;, sEnd)
    else
      img = string.match(body, &quot;&lt;img src=[\&quot;'](.-)[\&quot;']&quot;)
    end
    http.request{ 
      url = img, 
      sink = ltn12.sink.file(io.open(tempfile, &quot;wb&quot;))
    }
  end

== Usage ==

To use the module in awesome just require it in your rc.lua and set the filename where it should save the image

  require(&quot;xkcd&quot;)
  xkcd.settings = {}
  xkcd.settings.filename = os.getenv(&quot;HOME&quot;)..&quot;/.config/awesome/xkcd.png&quot;
  xkcd.initialize(xkcd.settings.filename)
  xkcd.comic()
  naughty.notify({ 
    title = &quot;xkcd&quot;,
    text = &quot;Random xkcd comic&quot;, 
    hover_timeout = 3, 
    timeout = 10,
    ontop = false,
    icon = xkcd.settings.filename, 
    icon_size = 256
  })

[[Category:Awesome3]]</text>
      <sha1>2wioofkf8nb39w2v1jqqmsix99eq7xm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Lain</title>
    <ns>0</ns>
    <id>960</id>
    <revision>
      <id>7465</id>
      <parentid>6441</parentid>
      <timestamp>2016-04-01T09:32:49Z</timestamp>
      <contributor>
        <username>Luke bonham</username>
        <id>2753</id>
      </contributor>
      <text xml:space="preserve" bytes="661">{{Languages|Lain}}

Successor of [https://github.com/vain/awesome-vain awesome-vain], this module provides new layouts (useless gaps included), widgets and utilities, in order to improve Awesome usability and configurability.

== Why another widgets (sub)module? ==

To add new widget types, like: synchronous/asynchronous script-feed widgets, IMAP mail checker, Taskwarrior prompt, OpenWeatherMap current weather and forecast, ThinkPad batteries.

And also to introduce utilities like: notifications, presets, dynamic tagging, on-the-fly useless gaps resize.

== Installation &amp; documentation ==

[https://github.com/copycat-killer/lain/wiki wiki git submodule]</text>
      <sha1>cf995lpc0w7gdx2l7ws5aoxlxprfvbx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Lain/ru</title>
    <ns>0</ns>
    <id>1032</id>
    <revision>
      <id>6780</id>
      <parentid>6778</parentid>
      <timestamp>2014-06-12T16:16:12Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>добавлена ссылка на оригинальную страницу</comment>
      <text xml:space="preserve" bytes="29773">{{Template:Languages|Lain}}

Оригинальная ссылка на [https://github.com/copycat-killer/lain Lain]

Является наследником [[Vain/ru|Vain]]. Данный модуль добавляет новые layouts (включая useless gaps), виджеты и утилиты, повышающие удобство и настраиваемость Awesome.

'''Разработано для версии Awesome 3.5'''

Lain является модульным, как и Vicious, разрабатываемый сообществом, как и Obvious, работающий со скриптами, как и Bashets, творческий, как Vain.

== Какие еще есть подмодули виджетов? ==

Добавлены новые типы виджетов, такие как: IMAP mail checker, Taskwarrior prompt, Yahoo! Weather, ThinkPad batteries и прочие.

Также добавлены различные стили для: уведомлений, предустановок, динамичности и облегчающие создание заметок.

== Зависимости ==

{|
! Название пакета
! Требуется для
! Причина выбора
|-
| alsa-utils
| alsa, alsabar
| /
|-
| curl
| виджеты доступа к ресурсам сети
| LuaSocket не является внутренней библиотекой, и все еще не доступна для 5.2+. LuaSSL устарел.
|-
| imagemagick
| album arts для уведомления mpd
| Cairo не осуществляет качественной фильтрации.
|-
|}

== Установка и документация ==

[https://github.com/copycat-killer/lain/wiki wiki git submodule] - оригинальная документация на английском.

Данный набор модулей постоянно развивается и совершенствуется. Добавляются новые виджеты и т.д. Поэтому '''периодически проверяете обновления'''.

===Arch Linux===
Lain доступен через [https://aur.archlinux.org/packages/lain-git/ AUR]

===Прочие дистрибутивы===
&lt;pre&gt;
git clone https://github.com/copycat-killer/lain.git ~/.config/awesome/lain
&lt;/pre&gt;

==Использование==

Для начала необходимо добавить в ваш rc.lua:
&lt;pre&gt;
local lain = require(&quot;lain&quot;)
&lt;/pre&gt;

А затем изучите и добавьте подмодули, которые вам нужны.

==Layout==

В настоящее время существует 8 схем (layout):
&lt;pre&gt;
lain/layout
.
|-- termfair
|-- centerfair
|-- cascade
|-- cascadetile
|-- centerwork
|-- uselessfair
|-- uselesspiral
`-- uselesstile
&lt;/pre&gt;
Для их использования просто добавьте нужные вам в таблицу layouts в rc.lua:
&lt;pre&gt;
lain/layout
layouts =
{
    ...
    lain.layout.termfair,
    lain.layout.uselesstile,
    ...
}
&lt;/pre&gt;
Или установите какой либо на определенный тег:
&lt;pre&gt;
awful.layout.set(lain.layout.uselessfair, tags[1][7])
&lt;/pre&gt;
===Список виджетов===

====termfair====

Я очень много работаю в терминале. Стандартные тайлинговые алгоритмы обычно разворачивают окно на весь экран, так, что вы получаете терминал с количеством столбцов около 200 или даже более. Это слишком много. Вы пробовали читать страницы руководства(manpage) в терминале такого размера?

Данный layout ограничивает размер каждого окна. Каждое окно будет иметь одинаковую ширину, но может изменяться по высоте. Кроме того, окна выровнены по левому краю. Основная рабочая схема следующая (число над экраном это число открытых окон, число в клетке, это фиксированный номер клиента):
&lt;pre&gt;
     (1)                (2)                (3)
+---+---+---+      +---+---+---+      +---+---+---+
|   |   |   |      |   |   |   |      |   |   |   |
| 1 |   |   |  -&gt;  | 2 | 1 |   |  -&gt;  | 3 | 2 | 1 |  -&gt;
|   |   |   |      |   |   |   |      |   |   |   |
+---+---+---+      +---+---+---+      +---+---+---+

     (4)                (5)                (6)
+---+---+---+      +---+---+---+      +---+---+---+
| 4 |   |   |      | 5 | 4 |   |      | 6 | 5 | 4 |
+---+---+---+  -&gt;  +---+---+---+  -&gt;  +---+---+---+
| 3 | 2 | 1 |      | 3 | 2 | 1 |      | 3 | 2 | 1 |
+---+---+---+      +---+---+---+      +---+---+---+
&lt;/pre&gt;
Первый клиент будет размещен в левом столбце. При открытии нового окна, это новое окно будет размещено в левом столбце, а предыдущее, первое окно будет перемещено в средний столбец. После заполнения ряда, новый ряд будет создан над ним.

Стандартное число строк и столбцов берется из значений ''nmaster'' и ''ncol'' из awful.tag, но вы можете установить собственные значения.

Например, для установки в termfair 3х столбцов и как минимум 1 строки исползуйте:
&lt;pre&gt;
lain.layout.termfair.nmaster = 3
lain.layout.termfair.ncol = 1
&lt;/pre&gt;

====centerfair====
Похож на '''termfair''', но с фиксированным числом вертикальных столбцов. Перввые 3 клиента располагаются по центру, пока не достигнут значения столбцов из ''nmaster'', затем окна начинают stacked как вторичные, до достижения числа ''ncol'' на колонку.
&lt;pre&gt;
        (1)                (2)                (3)
   +---+---+---+      +-+---+---+-+      +---+---+---+
   |   |   |   |      | |   |   | |      |   |   |   |
   |   | 1 |   |  -&gt;  | | 1 | 2 | | -&gt;   | 1 | 2 | 3 |  -&gt;
   |   |   |   |      | |   |   | |      |   |   |   |
   +---+---+---+      +-+---+---+-+      +---+---+---+

        (4)                (5)
   +---+---+---+      +---+---+---+
   |   |   | 3 |      |   | 2 | 4 |
   + 1 + 2 +---+  -&gt;  + 1 +---+---+
   |   |   | 4 |      |   | 3 | 5 |
   +---+---+---+      +---+---+---+
&lt;/pre&gt;
Как и в схеме termfair, стандартное число столбцов и строк берется из значений ''nmaster'' и ''ncol'' values из awful.tag, но вы можете установить эти значения сами.

Например:
&lt;pre&gt;
lain.layout.centerfair.nmaster = 3
lain.layout.centerfair.ncol = 1
&lt;/pre&gt;

====cascade====
Размещает все окна в теге каскадом.

Вы можете управлять смещением изменяя значения двух переменных:
&lt;pre&gt;

lain.layout.cascade.cascade_offset_x = 64
lain.layout.cascade.cascade_offset_y = 16
&lt;/pre&gt;
Следующий пример резервирует место под 5 окон:
&lt;pre&gt;
lain.layout.cascade.nmaster = 5
&lt;/pre&gt;
До тех пор пока не будет создано 5 окон, их размеры не будут изменяться.

====cascadetile====
Похожа на схему awful.layout.suit.tile, однако клиенты во вторичных колонках размещаются каскадом, а не tiled.

Размер левого столбца может быть настроен, в противном случае будет контролироваться ''mwfact'' тега. Новые окна будут открываться в другом столбце справа. Новые окна в них будут открываться поверх старых окон.

Будут ли вторичные столбцы размещены поверх (on top) или нет, контролируется значением ncol. Значение 1 означает &quot;перекрытие вторичных столбцов&quot;, а любое другое значение будет означать &quot;не перекрывать окна&quot;.

Пример использования:
&lt;pre&gt;
lain.layout.cascadetile.cascade_offset_x = 2
lain.layout.cascadetile.cascade_offset_y = 32
lain.layout.cascadetile.extra_padding = 5
lain.layout.cascadetile.nmaster = 5
lain.layout.ncol = 1
&lt;/pre&gt;
extra_padding уменьшает размер главного окна, если активно &quot;перекрытие вторичных столбцов&quot;. Это позволяет видеть, если ли какие либо окна во вторичном столбце.

Устанавливайте cascade_offset_x на очень маленькое значение или даже 0, чтобы не терять место.

====centerwork====

Вы начинаете с одним окном, расположенным по центру горизонтально:
&lt;pre&gt;
+--------------------------+
|       +----------+       |
|       |          |       |
|       |          |       |
|       |          |       |
|       |   MAIN   |       |
|       |          |       |
|       |          |       |
|       |          |       |
|       |          |       |
|       +----------+       |
+--------------------------+
&lt;/pre&gt;

Это главное рабочее окно. Большую часть работы вы делаете здесь. Иногда, вы можете открывать дополнительные окна. Они будут располагаться в следующих четырех слотах:
&lt;pre&gt;
+--------------------------+
| +---+ +----------+ +---+ |
| |   | |          | |   | |
| | 0 | |          | | 1 | |
| |   | |          | |   | |
| +---+ |   MAIN   | +---+ |
| +---+ |          | +---+ |
| |   | |          | |   | |
| | 2 | |          | | 3 | |
| |   | |          | |   | |
| +---+ +----------+ +---+ |
+--------------------------+
&lt;/pre&gt;
Да, число &quot;четыре&quot; фиксировано. В общей сложности, вы можете открыть пять окон с этой схемой. Дополнительные окна не поддерживаются и им устанавливается плавающий режим(floating). '''Это сделано намерено.'''

Вы можете определить порядок четырех дополнительных окон. Это стандартная конфигурация:
&lt;pre&gt;
lain.layout.centerwork.top_left = 0
lain.layout.centerwork.top_right = 1
lain.layout.centerwork.bottom_left = 2
lain.layout.centerwork.bottom_right = 3
&lt;/pre&gt;
Это означает: Нижний левый слот будет присвоен третьему окну (не считаю главного окна). Предположим, вы хотите, чтобы ваши окна располагались в следующем порядке:
&lt;pre&gt;
+--------------------------+
| +---+ +----------+ +---+ |
| |   | |          | |   | |
| | 3 | |          | | 0 | |
| |   | |          | |   | |
| +---+ |   MAIN   | +---+ |
| +---+ |          | +---+ |
| |   | |          | |   | |
| | 2 | |          | | 1 | |
| |   | |          | |   | |
| +---+ +----------+ +---+ |
+--------------------------+
&lt;/pre&gt;
Для этого вам потребуется использовать следующие настройки:
&lt;pre&gt;
lain.layout.centerwork.top_left = 3
lain.layout.centerwork.top_right = 0
lain.layout.centerwork.bottom_left = 2
lain.layout.centerwork.bottom_right = 1
&lt;/pre&gt;
''Примечание:'' Если вы используете стандартую конфигурацию Awesome, навигация в этой схеме может быть весьма запутанной. Как перейти из главного окна на нижнее левое окно? Это зависит от порядка в котором эти окна были открыты! Таким образом, я предлагаю вам использовать функцию  &lt;code&gt;awful.client.focus.bydirection()&lt;/code&gt;:
&lt;pre&gt;
globalkeys = awful.util.table.join(
    ...
    awful.key({ modkey }, &quot;j&quot;,
        function()
            awful.client.focus.bydirection(&quot;down&quot;)
            if client.focus then client.focus:raise() end
        end),
    awful.key({ modkey }, &quot;k&quot;,
        function()
            awful.client.focus.bydirection(&quot;up&quot;)
            if client.focus then client.focus:raise() end
        end),
    awful.key({ modkey }, &quot;h&quot;,
        function()
            awful.client.focus.bydirection(&quot;left&quot;)
            if client.focus then client.focus:raise() end
        end),
    awful.key({ modkey }, &quot;l&quot;,
        function()
            awful.client.focus.bydirection(&quot;right&quot;)
            if client.focus then client.focus:raise() end
        end),
    ...
)
&lt;/pre&gt;

====uselessfair, uselesspiral &amp; uselesstile====
Они дублируют стоковые схемы fair, spiral и tile. Однако с добавлением  &quot;useless gaps&quot; (смотрите ниже).

====Промежутки между окнами====

&quot;Useless gaps&quot; это промежуток между окнами. Они &quot;бесполезны&quot; потому что не имеют специального назначения, несмотря на улучшение обзора. Я обнаружил, что проще обнаружить границы окон, если они располагаются немного раздельно. 

Схема ''uselessfair'' например, выглядит следующим образом:
&lt;pre&gt;
+================+
#                #
#  +---+  +---+  #
#  | 1 |  |   |  #
#  +---+  |   |  #
#         | 3 |  #
#  +---+  |   |  #
#  | 2 |  |   |  #
#  +---+  +---+  #
#                #
+================+
&lt;/pre&gt;
Все мои схемы поддерживают &quot;useless gaps&quot;. Для настройки ширины разрывов, вам необходимо расширить вашу тему beautiful. Она должна содержать пункт под названием useless_gap_width в таблице темы. Если этот параметр отсутсвует, ширина по умолчиню становится равной 0.
&lt;pre&gt;
theme.useless_gap_width = &quot;5&quot;
&lt;/pre&gt;

===Иконки===
Они расположены в lain/icons/layout.

Для их использования, добавьте следующие строки в ваш ''theme.lua'':
&lt;pre&gt;
theme.lain_icons         = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/lain/icons/layout/default/&quot;
theme.layout_termfair    = theme.lain_icons .. &quot;termfairw.png&quot;
theme.layout_cascade     = theme.lain_icons .. &quot;cascadew.png&quot;
theme.layout_cascadetile = theme.lain_icons .. &quot;cascadetilew.png&quot;
theme.layout_centerwork  = theme.lain_icons .. &quot;centerworkw.png&quot;
&lt;/pre&gt;
Благодарим Nicolas Estibals за создание иконок для схем для стандартной темы.

Вы можете использовать их как шаблон для ваших собственных версий.

==Виджеты==

===Основы использования ===

Каждый виджет выводится функцией.

Для некоторых виджетов, функции возвращают ''wibox.widget.textbox'', для других возвращаемым значением будут таблицы используемые для уведомления или обновления значени.

Каждый виджет может принимать другие таблицы или список переменных в качестве аргументов.

Если виджет принимает таблицу, вы должны определить переменную функцию вызывающую в ней настройки, для осуществления ваших настроек.

Для разметки textbox, вызовите widget:set_markup(...) в настройках.

Вы можете вызвать ''set_markup'' с предопределенными аргументами, смотрите соответствующие разделы для получения подробностей.

Виджеты являются объектами textbox, поэтому вы можете управлять ими, так же как и другими виджетами ''wibox.widget.textbox''.

Ниже приведен пример:
&lt;pre&gt;
mycpu = lain.widgets.cpu({
    timeout = 4,
    settings = function()
        widget:set_markup(&quot;Cpu &quot; .. cpu_now.usage)
    end
})
&lt;/pre&gt;
Если вы хотите увидеть более сложные приложения, смотрите на сайте [https://github.com/copycat-killer/awesome-copycats awesome-copycats].

===Список виджетов===
Ниже приведен список виджетов, входящих в состав Lain.

*[https://github.com/copycat-killer/lain/wiki/alsa alsa] - Отображает и контролирует громкость alsa с помощью textbox
*[https://github.com/copycat-killer/lain/wiki/alsabar alsabar] - Отображает и контролирует громкость alsa с прогрессбаром; поддерживает подсказки, уведомления и изменения цветов при включении/выключение звука.
*[https://github.com/copycat-killer/lain/wiki/base base] - Это простой виджет-шаблон. В своей основе, все что он делает исполняет входящие команды, и выводит вывод в его textbox.
*[https://github.com/copycat-killer/lain/wiki/bat bat] - Отображает textbox оставшееся время и процент мощности батареи ноутбука. Выводит уведомление при низком или критическом заряде батареи.
*[https://github.com/copycat-killer/lain/wiki/borderbox borderbox] - Создает тонкий wibox в позиции относительно другого wibox. Это позволяет создать &quot;границы&quot; для вашего wiboxes.
*[https://github.com/copycat-killer/lain/wiki/calendar calendar] - Прикрепляет календарь в виде уведомления к виджету.
*[https://github.com/copycat-killer/lain/wiki/cpu cpu] - Отображает в textbox средний процент использования процессора.
*[https://github.com/copycat-killer/lain/wiki/fs fs] - Отображает использование диска для данного раздела. Выводит уведомление при переполнении раздела или малом количестве места.
*[https://github.com/copycat-killer/lain/wiki/imap imap] - Отображает количество писем в textbox с полученных по IMAP.
*[https://github.com/copycat-killer/lain/wiki/maildir maildir] - Отображает статус maildirs в textbox.
*[https://github.com/copycat-killer/lain/wiki/mem mem] - Отображает использование памяти (в MiB) в textbox.
*[https://github.com/copycat-killer/lain/wiki/mpd mpd] - Отображает статус MPD в textbox.
*[https://github.com/copycat-killer/lain/wiki/net net] - Мониторит сетевой интерфейс и отображает текущий трафик в textbox. 
*[https://github.com/copycat-killer/lain/wiki/sysload sysload] - Отображает текущую загрузку системы.
*[https://github.com/copycat-killer/lain/wiki/temp temp] - Отображает температуру ядра в textbox.
*[https://github.com/copycat-killer/lain/wiki/yawn yawn] - отображает краткую и компактную погоду из YAhoo.

Вклад пользователей
*[https://github.com/copycat-killer/lain/wiki/task task] - Прикрепляет уведомление taskwarrior к виджету и позволяет добавить возможность добавить/найти задачу через promptbox.
*[https://github.com/copycat-killer/lain/wiki/tpbat tpbat] - Виджет батареи, который работает с ноутбуками Lenovo ThinkPad с исползованием tp_smapi.
*[https://github.com/copycat-killer/lain/wiki/ccurr ccurr] - Отображает в textbox текущих цен для Bitcoin/USD и Dogecoin/USD.
You will need dkjson library. A simple way of installing is to download the dksjon.lua file and place it in your ~/.config/awesome directory.
*[https://github.com/copycat-killer/lain/wiki/redshift redshift] - Redshift это приложение, которое позволяет регулировать цветовую температуру экрана на основе видимого положения солнца в местонахождении пользователя.

==Утилиты==

===markup===

Облегчает разметку! Для начала необходимо настроить использование:
&lt;pre&gt;
local markup = lain.util.markup
&lt;/pre&gt;
затем вы можете вызывать его функции:
&lt;pre&gt;
 +-- markup
 |
 |`-- bold()        Set bold.
 |`-- italic()      Set italicized text.
 |`-- strike()      Set strikethrough text.
 |`-- underline()   Set underlined text.
 |`-- monospace()   Set monospaced text.
 |`-- big()         Set bigger text.
 |`-- small()       Set smaller text.
 |`-- font()        Set the font of the text.
 |
 |`--+ bg
 |   |
 |   |`-- color()   Set background color.
 |   |`-- focus()   Set focus  background color.
 |   |`-- normal()  Set normal background color.
 |    `-- urgent()  Set urgent background color.
 |
 |`--+ fg
 |   |
 |   |`-- color()   Set foreground color.
 |   |`-- focus()   Set focus  foreground color.
 |   |`-- normal()  Set normal foreground color.
 |    `-- urgent()  Set urgent foreground color.
 |
 |`-- focus()       Set both foreground and background focus  colors.
 |`-- normal()      Set both foreground and background normal colors.
  `-- urgent()      Set both foreground and background urgent colors.
&lt;/pre&gt;
Все они принимают один аргумент, которым является текст предназначенный для разметки, за исключением ''font'', ''fg.color'' и ''bg.color'':
&lt;pre&gt;
markup.font(font, text)
markup.fg.color(text, color)
markup.bg.color(text, color)
&lt;/pre&gt;
''focus'', ''normal'' и ''urgent'' использует переменные ''beautiful''.

===dynamic tagging===

Позволяет:
* Добавлять новые теги;
* Переименовать существующие теги;
* Перемещать существующие теги;
* Удалять существующие теги.

Если вы удаляете тег, любые установленные для него правила(rule) ломаются, поэтому будьте осторожны.

Используйте с клавиатурными привязками, например:
&lt;pre&gt;
awful.key({ modkey, &quot;Shift&quot; }, &quot;n&quot;, function () lain.util.add_tag(mypromptbox) end),
awful.key({ modkey, &quot;Shift&quot; }, &quot;r&quot;, function () lain.util.rename_tag(mypromptbox) end),
awful.key({ modkey, &quot;Shift&quot; }, &quot;Left&quot;, function () lain.util.move_tag(1) end),  -- move to next tag
awful.key({ modkey, &quot;Shift&quot; }, &quot;Right&quot;, function () lain.util.move_tag(-1) end), -- move to previous tag
awful.key({ modkey, &quot;Shift&quot; }, &quot;d&quot;, function () lain.util.remove_tag() end),
&lt;/pre&gt;
Помните, что эти функции не будут нормально работать с темой [https://github.com/copycat-killer/awesome-copycats Copland] или любыми другими конфигурациями, которые уже используют модули динамических тегов, такие как [https://github.com/copycat-killer/awesome-copycats/tree/master/eminent Eminent] ([[Eminent/ru|русская перевод Eminent]]).

===useless_gaps_resize===

Изменение ''beautiful.useless_gaps_width'' на лету. Функция принимает целочисленный аргумент, который является числом пикселей и добавляет/удаляет разрывы(gaps).

Вы можете использовать его со следующими клавиатурными сочетаниями:
&lt;pre&gt;
-- On the fly useless gaps change
awful.key({ altkey, &quot;Control&quot; }, &quot;+&quot;, function () lain.util.useless_gaps_resize(1) end),
awful.key({ altkey, &quot;Control&quot; }, &quot;-&quot;, function () lain.util.useless_gaps_resize(-1) end),
&lt;/pre&gt;
где ''altkey=Mod1'', или вы можете использовать по вашему выбору:
&lt;pre&gt;
mywidget:buttons(awful.util.table.join (
      awful.button({}, 4, function() lain.util.useless_gaps_resize(-1) end),
      awful.button({}, 5, function() lain.util.useless_gaps_resize(1) end)
      end)
))
&lt;/pre&gt;
Используя код приведенный выше, вы можете создав виджет mywidget, навести на него мышь и прокруткой колеса изменять размеры &quot;useless gaps&quot;.

===tag_view_nonempty===

Эта функция позволяет переходить на следующий/предыдущий не пустой тег. Она принимает два аргумента:

* direction: 1 для следующего не пустого тега, -1 для предыдущего.
* sc: Экран на котором находится список тегов(taglist). По умолчанию равен mouse.screen или 1. Это необязательный аргумент.

Вы можете использовать ее используя клавиши:
&lt;pre&gt;
-- Non-empty tag browsing
awful.key({ altkey }, &quot;Left&quot;, function () lain.util.tag_view_nonempty(-1) end),
awful.key({ altkey }, &quot;Right&quot;, function () lain.util.tag_view_nonempty(1) end),
&lt;/pre&gt;
Где ''altkey = &quot;Mod1&quot;''.

===menu_clients_current_tags===

Эта функция подобна awful.menu.clients(), но отображает клиентов только для текущего тега. Используйте следующим образом: 
&lt;pre&gt;
awful.key({ &quot;Mod1&quot; }, &quot;Tab&quot;,
function()
    awful.menu.menu_keys.down = { &quot;Down&quot;, &quot;Alt_L&quot;, &quot;Tab&quot;, &quot;j&quot; }
    awful.menu.menu_keys.up = { &quot;Up&quot;, &quot;k&quot; }
    lain.util.menu_clients_current_tags({ width = 350 }, { keygrabber = true })
end),
&lt;/pre&gt;

===magnify_client===
Устанавливает клиенту плавающий режим(floating) и изменяет его размеры так же, как это сделано в схеме &quot;magnifier&quot;. Размещает клиент на &quot;текущем&quot; экране (зависит от положения мыши). Это позволяет вам увеличить любой клиент, независимо от используемой схемы. Используйте функцию клавиатурной привязки клиента следующим образом: 
&lt;pre&gt;
clientkeys = awful.util.table.join(
    ...
    awful.key({ modkey, &quot;Control&quot; }, &quot;m&quot;, lain.util.magnify_client),
    ...
)
&lt;/pre&gt;
Если вы хотите &quot;de-magnify&quot; клиента, просто наберите команду еще раз.

===niceborder_{focus, unfocus}===

По умолчанию ваш rc.lua содержит что то, похожее на:
&lt;pre&gt;
client.connect_signal(&quot;focus&quot;, function(c) c.border_color = beautiful.border_focus end)
client.connect_signal(&quot;unfocus&quot;, function(c) c.border_color = beautiful.border_normal end)
&lt;/pre&gt;
Вы можете изменить этот код на:
&lt;pre&gt;
client.connect_signal(&quot;focus&quot;, lain.util.niceborder_focus(c))
client.connect_signal(&quot;unfocus&quot;, lain.util.niceborder_unfocus(c))
&lt;/pre&gt;
Теперь, при фокусировке или потере фокуса клиентом, Awesome будет искать его значение nice в /proc/&lt;pid&gt;/stat. Если значение меньше 0, это окно классифицируется как имеющее &quot;high priority&quot;; если оно больше 0, окно классифицируется как имеющее &quot;low priority&quot;. Если оно равно 0, ничего особенного не происходит.

Это требует определить дополнительные цвета в theme.lua. Вот те, которые использую я: 
&lt;pre&gt;
theme.border_focus_highprio  = &quot;#FF0000&quot;
theme.border_normal_highprio = &quot;#A03333&quot;

theme.border_focus_lowprio   = &quot;#3333FF&quot;
theme.border_normal_lowprio  = &quot;#333366&quot;
&lt;/pre&gt;

[[Category:Awesome3.5]]</text>
      <sha1>purwvom6tlk0g1ypskamm540p01gxqv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Lan network widget</title>
    <ns>0</ns>
    <id>961</id>
    <revision>
      <id>6126</id>
      <parentid>6123</parentid>
      <timestamp>2013-09-28T18:39:33Z</timestamp>
      <contributor>
        <username>Jasuramme</username>
        <id>3076</id>
      </contributor>
      <text xml:space="preserve" bytes="3200">[[File:Not_connected.jpg|thumb|right| ]]
[[File:connected.png|thumb|right|That how widget button will look like]]
This is a simple lan network plugin for statusbar. On click it will toggle your lan connection. It is pulling information from /sys/class/net/&quot;..adapter..&quot;/operstate to get current status of connection. That happens every 30 seconds. After you change lan state it will check it much more often for a wile. That could be a good idea to make widget which receives signal for system, that network state is changed. Anyway. That's it

=Installation=

==rc.lua==
===The widget===
Add the following code into your personal ''rc.lua'' file:
&lt;pre&gt;
 --all settings are made in next 3 lines
lan_enable_net_path=&quot;/home/user/bin/net.sh&quot;
lan_disable_net_path=&quot;/home/user/bin/anet.sh&quot;
lan_interface=&quot;eth0&quot;
 

lan_short_timer = timer({timeout = 1})
 lan_short_timer:connect_signal(&quot;timeout&quot;, function()
	if lan_connected == lan_need_state
		then
		lan_short_timer:stop();
		end
     laninfo(lan_interface)
 end)
--lan_timer:start()

function laninfo(adapter)
     local f = io.open(&quot;/sys/class/net/&quot;..adapter..&quot;/operstate&quot;)
     local isconnected = f:read()
     if isconnected == &quot;down&quot; then
	lanwidget.tooltip:set_text(&quot;network is not connected&quot;)
	lanwidget:set_markup('&lt;span color=&quot;red&quot;&gt;X&lt;/span&gt; ')
	lan_connected=0
     else
	lanwidget.tooltip:set_text(&quot;network is connected&quot;)
	lanwidget:set_markup('&lt;span color=&quot;white&quot;&gt;+&lt;/span&gt; ')
	lan_connected=1
     end
end

lanwidget = wibox.widget.textbox()
lanwidget.set_align(&quot;right&quot;)
lanwidget.tooltip = awful.tooltip ({ objects = { lanwidget } })
lanwidget_lan=0
lanenable = terminal .. &quot; -e &quot; .. lan_enable_net_path
landisable = terminal .. &quot; -e &quot; .. lan_disable_net_path

lanwidget:buttons (awful.util.table.join (
	awful.button ({}, 1, function()
		lan_short_timer:start();
		if lan_connected==0
			then
			awful.util.spawn (lanenable)
			lan_need_state=1;
			else
			lan_need_sate=0;
			awful.util.spawn (landisable)
			end
		laninfo(lan_interface)
	end),
	awful.button ({}, 3, function()
		awful.util.spawn (editor ..&quot; &quot;.. lan_enable_net_path)
		awful.util.spawn (editor ..&quot; &quot;.. lan_disable_net_path)
	end)
))

laninfo(lan_interface)

 lan_timer = timer({timeout = 10})
 lan_timer:connect_signal(&quot;timeout&quot;, function()
     laninfo(lan_interface)
 end)
lan_timer:start()
&lt;/pre&gt;
Then add '''alsawidget.bar''' to your wibox layout(s).
&lt;pre&gt;
right_layout:add(lanwidget)
&lt;/pre&gt;
===Setting up system===
You must have shell scripts in place to use this widget. I used:
my /home/user/bin/net.sh contains
&lt;pre&gt;
ip addr add 188.227.110.45/255.255.255.0 dev enp2s0
ip route add default via 188.227.110.1
echo &quot;nameserver 85.235.193.2&quot; &gt;&gt; /etc/resolv.conf
ip link set dev enp2s0 up
ip addr add 188.227.110.45/255.255.255.0 dev enp2s0
ip route add default via 188.227.110.1
echo &quot;nameserver 85.235.193.2&quot; &gt;&gt; /etc/resolv.conf
ip link set dev enp2s0 up
&lt;/pre&gt;
my /home/user/bin/anet.sh contains
&lt;pre&gt;
ip link set dev enp2s0 down
&lt;/pre&gt;
But to make your scripts work from user account, you have to change your permissions for ip utility or shell script.
&lt;pre&gt;
chown root:users doit
chmod u=rxs,g=x,o= doit
&lt;/pre&gt;
=Notes=
* None at the moment.

[[Category:Widgets]]</text>
      <sha1>pxpn93ttcc2u0ilxs4p0vbyznv7mu3j</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Launch In Terminal Keyword</title>
    <ns>0</ns>
    <id>517</id>
    <revision>
      <id>6642</id>
      <parentid>5317</parentid>
      <timestamp>2014-05-24T16:19:32Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1551">{{Languages}}

This is a modified run command that accepts and intial &quot;:&quot; keyword to indicate launching commands in a terminal.

For instance, &quot;:mc&quot; would open a terminal and run mc.

Or my favorite &quot;:aptitude&quot;.

This is all done in the ~/.config/awesome/rc.lua

This is the key definition that you would add to your globalkeys:
&lt;pre&gt; 
awful.key({ modkey,           }, &quot;r&quot;, 
              function () awful.prompt.run({prompt=&quot;Run:&quot;},
                                           mypromptbox[mouse.screen].widget,
                                           check_for_terminal,
                                           clean_for_completion,
                                           awful.util.getdir(&quot;cache&quot;) .. &quot;/history&quot;) end)
&lt;/pre&gt;

These are the functions it needs.  I just added them to the bottom of my rc.lua and that seems to work just fine:
&lt;pre&gt;
-- {{{ functions to help launch run commands in a terminal using &quot;:&quot; keyword 
function check_for_terminal (command)
   if command:sub(1,1) == &quot;:&quot; then
      command = terminal .. ' -e &quot;' .. command:sub(2) .. '&quot;'
   end
   awful.util.spawn(command)
end
   
function clean_for_completion (command, cur_pos, ncomp, shell)
   local term = false
   if command:sub(1,1) == &quot;:&quot; then
      term = true
      command = command:sub(2)
      cur_pos = cur_pos - 1
   end
   command, cur_pos =  awful.completion.shell(command, cur_pos,ncomp,shell)
   if term == true then
      command = ':' .. command
      cur_pos = cur_pos + 1
   end
   return command, cur_pos
end
-- }}}
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>h6w711audr9xphp2hw7rpioaucebxzc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Launch In Terminal Keyword/ru</title>
    <ns>0</ns>
    <id>1082</id>
    <revision>
      <id>6645</id>
      <parentid>6644</parentid>
      <timestamp>2014-05-24T16:42:14Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="1922">{{Languages|Launch In Terminal Keyword}}
{{DISPLAYTITLE:Ключевое слово для запуска в терминале}}

Это модификация команд запуска, которая позволяет использовать &quot;:&quot; для указания запуска введенной команды в терминале.

Например, &quot;:mc&quot; откроет терминал и запустит mc.

Или мой любимый &quot;:aptitude&quot;.

Все это можно реализовать в ~/.config/awesome/rc.lua

Замените клавиатурное сочетания в секции globalkeys на следующее:
&lt;pre&gt; 
awful.key({ modkey,           }, &quot;r&quot;, 
              function () awful.prompt.run({prompt=&quot;Run:&quot;},
                                           mypromptbox[mouse.screen].widget,
                                           check_for_terminal,
                                           clean_for_completion,
                                           awful.util.getdir(&quot;cache&quot;) .. &quot;/history&quot;) end),
&lt;/pre&gt;

Дополнительно потребуется функция для обработки. Добавьте ее в начале файла rc.lua:
&lt;pre&gt;
-- {{{ functions to help launch run commands in a terminal using &quot;:&quot; keyword 
function check_for_terminal (command)
   if command:sub(1,1) == &quot;:&quot; then
      command = terminal .. ' -e &quot;' .. command:sub(2) .. '&quot;'
   end
   awful.util.spawn(command)
end
   
function clean_for_completion (command, cur_pos, ncomp, shell)
   local term = false
   if command:sub(1,1) == &quot;:&quot; then
      term = true
      command = command:sub(2)
      cur_pos = cur_pos - 1
   end
   command, cur_pos =  awful.completion.shell(command, cur_pos,ncomp,shell)
   if term == true then
      command = ':' .. command
      cur_pos = cur_pos + 1
   end
   return command, cur_pos
end
-- }}}
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>m3ieza9epu2zpnpb8bueqtfsekdfm5r</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Launcher auto-hiding</title>
    <ns>0</ns>
    <id>729</id>
    <revision>
      <id>5051</id>
      <parentid>5050</parentid>
      <timestamp>2011-09-26T18:04:12Z</timestamp>
      <contributor>
        <username>Uzsolt</username>
        <id>13</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="2214">If you use launchers you may want if an application started, its launcher will be hide, so you can't start the application twice with a &quot;random mouse click&quot;.

I'm using a lua-table to store my launchers.

Concretely I've two launchers, ''launchers[&quot;Qbittorrent&quot;]'' and ''launchers[&quot;Chromium&quot;]''. The keys are the client's class name (because of simplicity).

So, here is the codes.

This function checks the clients and launchers. If there is a client from a launcher, the launcher will unset (nil).
 function get_launchers_table()
    tmp_launchers = awful.util.table.clone(launchers)
    local clients = client.get(0)
    for _,client in pairs(clients) do
        if (launchers[client.class]~=nil) then
            tmp_launchers[client.class] = nil
        end
    end
    local ret = {}
    local x,y
    for x,y in pairs(tmp_launchers) do
        if (y~=nil) then
            table.insert(ret,x)
        end
    end
    return ret
 end
 

This is a simple util: checks if ''what'' is in ''table''.
 function in_table(table,what)
    local item
    for _,item in pairs(table) do
        if (what==item) then
            return true 
        end 
    end 
    return false
 end 

Checks if table ''t1'' has same elements as table ''t2''.
 function table_equal(t1,t2)
    if (t1==nil) then
        return false
    end
    if ( #t1 ~= #t2 ) then
        return false
    end
    local item
    for _,item in pairs(t1) do
        if (not in_table(t2,item)) then
            return false
        end
    end
    return true
 end

Set the ''wiboxes[&quot;bottom_right&quot;]'' wibox's widgets. If the client list does not change (previous value stored in ''launchers_to_wibox''.

 launchers_to_wibox = {}
 function set_wibox_widgets()
    local tmp = get_launchers_table()
    if (table_equal(tmp,launchers_to_wibox)) then
        return
    end
    wiboxes[&quot;bottom_right&quot;].widgets = {}
    local x
    local nr = 0
    for _,x in pairs(tmp) do
        nr = nr+1
        wiboxes[&quot;bottom_right&quot;].widgets[nr] = launchers[x]
    end
    wiboxes[&quot;bottom_right&quot;].widgets.layout = awful.widget.layout.horizontal.rightleft
    launchers_to_wibox = tmp
 end

You can add a ''timer'' object with function ''set_wibox_widgets''.

Enjoy!</text>
      <sha1>q21207zms9zvrlql7jdmr0396pm4zxd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Launcher auto-hiding/ru</title>
    <ns>0</ns>
    <id>1031</id>
    <revision>
      <id>6419</id>
      <timestamp>2014-05-02T13:04:25Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{Languages|Launcher auto-hiding}} {{DISPLAYTITLE: Автоматичиское скрытие launcher'а}}  Если вы используете кнопки запуска(...&quot;</comment>
      <text xml:space="preserve" bytes="3027">{{Languages|Launcher auto-hiding}}
{{DISPLAYTITLE: Автоматичиское скрытие launcher'а}}

Если вы используете кнопки запуска(launchers), у вас может появиться желание скрыть ее, при запуске приложения, чтобы нельзя было случайно запустить приложение повторно.

Предлагаю использовать вам таблицу (lua-table) для хранения ваших лаунчеров.

Итак, у меня есть два лаунчера ''launchers[&quot;Qbittorrent&quot;]'' и ''launchers[&quot;Chromium&quot;]''. Клавиши с названиями клиентских классов (для простоты).

Итак, вот код.

Эта функция проверяет запущенные приложения и их launchers. Если приложение запущено через кнопку запуска(launcher), launcher будет скрыт.
 function get_launchers_table()
    tmp_launchers = awful.util.table.clone(launchers)
    local clients = client.get(0)
    for _,client in pairs(clients) do
        if (launchers[client.class]~=nil) then
            tmp_launchers[client.class] = nil
        end
    end
    local ret = {}
    local x,y
    for x,y in pairs(tmp_launchers) do
        if (y~=nil) then
            table.insert(ret,x)
        end
    end
    return ret
 end
 

Эта простая утилита, проверяет что хранится в таблице (''table'').
 function in_table(table,what)
    local item
    for _,item in pairs(table) do
        if (what==item) then
            return true 
        end 
    end 
    return false
 end 

Проверяем таблицу ''t1'' и сравниваем ее с элементами в таблице ''t2''.
 function table_equal(t1,t2)
    if (t1==nil) then
        return false
    end
    if ( #t1 ~= #t2 ) then
        return false
    end
    local item
    for _,item in pairs(t1) do
        if (not in_table(t2,item)) then
            return false
        end
    end
    return true
 end

Устанавливаем ''wiboxes[&quot;bottom_right&quot;]'' виджеты wibox. Если список запущенных приложений не изменялся (предыдущие значения хранятся в ''launchers_to_wibox'').

 launchers_to_wibox = {}
 function set_wibox_widgets()
    local tmp = get_launchers_table()
    if (table_equal(tmp,launchers_to_wibox)) then
        return
    end
    wiboxes[&quot;bottom_right&quot;].widgets = {}
    local x
    local nr = 0
    for _,x in pairs(tmp) do
        nr = nr+1
        wiboxes[&quot;bottom_right&quot;].widgets[nr] = launchers[x]
    end
    wiboxes[&quot;bottom_right&quot;].widgets.layout = awful.widget.layout.horizontal.rightleft
    launchers_to_wibox = tmp
 end

Также вы можете добавить объект ''timer'' с функцией ''set_wibox_widgets''.

Наслаждайтесь!</text>
      <sha1>bq26f3k6mx3szz816xug2w6rp4znnow</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Layout</title>
    <ns>0</ns>
    <id>587</id>
    <revision>
      <id>6785</id>
      <parentid>5330</parentid>
      <timestamp>2014-06-12T16:28:02Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2419">{{Languages}}

: A layout is a way of organizing windows in a view. awesome offers the following layouts:
:*'''colums''' - master windows are displayed in the left column (or the right one: there are two layouts) and the other windows are in multiple columns.
:*'''rows''' - the same, with rows instead of columns.
:*'''magnified''' - the master window (only one in this layout) is drawn in the middle of the screen, the other ones are stacked under it in columns.
:*'''maximized''' - the master window uses all available place and the other ones are hidden.
:*'''spiral''' - the master window stays in the left half of the screen, the next on uses the half of the other half, the third on half of the remaining half, and so on clockwise.
:*'''zig-zag''' - as above, except windows are drawn from right to bottom, then right, instead of clockwise. It's easier than it sounds, just try it.
:*'''floating''' - windows can be freely moved and resized, and they can overlap each other.


To follow layout information in 'tile' views I have found it useful to change rc.lua in following way
&lt;code&gt;
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;h&quot;,     function () awful.tag.incnmaster( 1)
                                              naughty.notify({ title = 'Master', text = tostring(awful.tag.getnmaster()), timeout = 1 }) end),
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;l&quot;,     function () awful.tag.incnmaster(-1)
                                              naughty.notify({ title = 'Master', text = tostring(awful.tag.getnmaster()), timeout = 1 }) end),
 awful.key({ modkey, &quot;Control&quot; }, &quot;h&quot;,     function () awful.tag.incncol( 1)
                                              naughty.notify({ title = 'Columns', text = tostring(awful.tag.getncol()), timeout = 1 }) end),
 awful.key({ modkey, &quot;Control&quot; }, &quot;l&quot;,     function () awful.tag.incncol(-1)
                                              naughty.notify({ title = 'Columns', text = tostring(awful.tag.getncol()), timeout = 1 }) end),

 awful.key({ modkey,           }, &quot;space&quot;, function () awful.layout.inc(layouts,  1)
                                              naughty.notify({ title = 'Layout', text = awful.layout.getname(), timeout = 1 }) end),
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;space&quot;, function () awful.layout.inc(layouts, -1)
                                              naughty.notify({ title = 'Layout', text = awful.layout.getname(), timeout = 1 }) end),
&lt;/code&gt;</text>
      <sha1>qcv8ynqbueue72e4pixvft43fcwvvpv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Layout/ru</title>
    <ns>0</ns>
    <id>1119</id>
    <revision>
      <id>6791</id>
      <parentid>6790</parentid>
      <timestamp>2014-06-14T06:15:03Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>/* floating */ добавление переключение приложения в плавающий режим</comment>
      <text xml:space="preserve" bytes="20735">{{Languages|Layout}}
{{DISPLAYTITLE:Layout - схемы}}

==Общие положения==

'''layout''' - это способ организации окон/клиентов на экране. Т.е. как именно и где именно будут располагаться окна, в каком порядке они будут открываться.
Иконка текущей схемы находится (по умолчанию) в правом верхнем углу, и при переключении схемы она меняется.

Если вы изучите файл rc.lua, то можете обнаружить там секцию layout, которая выглядит следующим образом (нумерация не присутствует, я ее добавил для удобства дальнейшей настройки):
&lt;pre&gt;
layouts =
{
    awful.layout.suit.floating,         --1
    awful.layout.suit.tile,             --2
    awful.layout.suit.tile.left,        --3
    awful.layout.suit.tile.bottom,      --4
    awful.layout.suit.tile.top,         --5
    awful.layout.suit.fair,             --6
    awful.layout.suit.fair.horizontal,  --7
    awful.layout.suit.spiral,           --8
    awful.layout.suit.spiral.dwindle,   --9
    awful.layout.suit.max,              --10
    awful.layout.suit.max.fullscreen,   --11
    awful.layout.suit.magnifier         --12
}
&lt;/pre&gt;

Это схемы предусмотренные в Awesome по умолчанию. Если какие то из этих схем вам не потребуются, вы можете их удалить или закомментировать, и тогда Awesome не будет их использовать:
&lt;pre&gt;
-- awful.layout.suit.spiral,  
&lt;/pre&gt;

Для переключения схемы в текущем теге используются клавиши '''modkey+space''' для переключения на следующую схему и '''modkey+Shift+space''' для переключения на предыдущую схему. Обычно в качестве клавиши modkey используется Win клавиша. 

На первых порах для запоминания схем предлагаю вам использовать уведомления, отображающие название текущей схемы. Для этого в файле ''rc.lua'' найдите секцию ''Standart program'' и замените в ней:
&lt;pre&gt; 
awful.key({ modkey,           }, &quot;space&quot;, function () awful.layout.inc(layouts,  1) end),
awful.key({ modkey, &quot;Shift&quot;   }, &quot;space&quot;, function () awful.layout.inc(layouts, -1) end),
&lt;/pre&gt;
на следующий код:
&lt;pre&gt;
awful.key({ modkey,           }, &quot;space&quot;, function () awful.layout.inc(layouts,  1)
                                              naughty.notify({ title = 'Layout', text = awful.layout.getname(), timeout = 3 }) end),
awful.key({ modkey, &quot;Shift&quot;   }, &quot;space&quot;, function () awful.layout.inc(layouts, -1)
                                              naughty.notify({ title = 'Layout', text = awful.layout.getname(), timeout = 3 }) end),
&lt;/pre&gt;

''Вообще, для изучения клавиш управления вашим Awesome, для начала ознакомьтесь с [[/Awesome_3.x/ru|manpages]].''

==Описание схем==
===floating===
Окна в этом режиме окна могут свободно перемещаться и изменять свои размеры, и верхнее окно перекрывает нижние. Чем то этот режим похож на поведение окон в других DE(Gnome,KDE). 

Этот режим используется для всех тегов в Awesome со стандартными настройками (из коробки).

Для перемещения окон по экрану необходимо нажать клавишу modkey(Win) и зажав левую кнопку мыши, перемещать окно по экрану. При нажатии modkey и правой кнопки мыши вы можете изменять размеры окна. 

Кстати, в любой другой схеме, для того чтобы сделать перевести приложение в floating режим нужно нажать
&lt;pre&gt;
Modkey+Control+Space
&lt;/pre&gt;

Для переключения между клиентами вы можете использовать следующие клавиши:
&lt;pre&gt;
Modkey + j Следующий клиент.
Modkey + k Предыдущий клиент.
Modkey+Tab Переключение между предыдущим и текущим клиентов.
&lt;/pre&gt;

===tile===

Поведение окон отображено на следующей схеме. Где цифра в скобках показывает количество открытых окон, а цифра в клетке положение окна в порядке открытия.
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----+-----+      +-----+-----+
|           |      |     |     |      |     |  2  |
|     1     |  -&gt;  |  2  |  1  |  -&gt;  |  3  +-----+  -&gt;
|           |      |     |     |      |     |  1  |
+-----------+      +-----+-----+      +-----+-----+

     (4)                (5)                (6)
+-----+-----+      +-----+-----+      +-----+-----+
|     |     |      |     |     |      |     |  5  |
|     |  3  |      |     |  4  |      |     +-----+
|     |     |      |     +-----+      |     |  4  |
|     +-----+      |     |     |      |     +-----+
|     |     |      |     |  3  |      |  6  |  3  |
|  4  |  2  |   -&gt; |  5  +-----+  -&gt;  |     +-----+
|     |     |      |     |     |      |     |  2  |
|     +-----+      |     |  2  |      |     +-----+
|     |     |      |     +-----+      |     |  1  |
|     |  1  |      |     |     |      +-----+-----+
|     |     |      |     |  1  |      
+-----+-----+      +-----+-----+      
&lt;/pre&gt;

Здесь нужно пояснить, что вся схема делится на 2 части:
* &quot;master&quot; зона,в данном случае она находится в левой части
* &quot;slave&quot;  зона (стек или вторичная зона), в данном случае она расположена в правой части

Для управления клиентами в мастер и стек зоне используйте следующие клавиши:
&lt;pre&gt;
Modkey + Shift + h Увеличить число окон в master зоне на 1.
Modkey + Shift + l Уменьшить число окон в master зоне на 1.

Modkey + Control + h Увеличить число колонок для slave зоны на 1.
Modkey + Control + l Уменьшить число колонок для slave зоны на 1.
&lt;/pre&gt;
Поэкспериментируйте с этими клавишами, чтобы получить удобные для вас значения.

===tile.left===
Схема расположения окон в данном layout:
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----+-----+      +-----+-----+
|           |      |     |     |      |  2  |     |
|     1     |  -&gt;  |  1  |  2  |  -&gt;  +-----+  3  |  -&gt;
|           |      |     |     |      |  1  |     |
+-----------+      +-----+-----+      +-----+-----+

     (4)                (5)                (6)
+-----+-----+      +-----+-----+      +-----+-----+
|     |     |      |     |     |      |  5  |     |
|  3  |     |      |  4  |     |      +-----+     |
|     |     |      +-----+     |      |  4  |     |
+-----+     |      |     |     |      +-----+     |
|     |     |      |  3  |     |      |  3  |  6  |
|  2  |  4  |   -&gt; +-----+  5  |  -&gt;  +-----+     |
|     |     |      |     |     |      |  2  |     |
+-----|     |      |  2  |     |      +-----+     |
|     |     |      +-----+     |      |  1  |     |
|  1  |     |      |     |     |      +-----+-----+
|     |     |      |  1  |     |      
+-----+-----+      +-----+-----+      
&lt;/pre&gt;
Здесь &quot;master&quot; зона расположена справа, а &quot;slave&quot; слева.
Если размер какой либо из зон вас не устраивает, то можно их увеличить/уменьшить:
&lt;pre&gt;
Modkey + h Уменьшить главную зону на 5%.
Modkey + l Увеличить главную зона на 5%.
&lt;/pre&gt;

===tile.bottom===
Схема расположения окон в данном layout:
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----------+      +-----------+
|           |      |     2     |      |     3     |
|     1     |  -&gt;  +-----------+  -&gt;  +-----+-----+  -&gt;
|           |      |     1     |      |  2  |  1  |
+-----------+      +-----------+      +-----+-----+

     (4)                (5)                 (6)
+-----------+      +-----------+      +--------------+
|     4     |      |     5     |      |      6       |
+---+---+---+  -&gt;  +--+--+--+--+  -&gt;  +--+--+--+--+--+
| 3 | 2 | 1 |      | 4| 3| 2| 1|      | 5| 4| 3| 2| 1|
+---+---+---+      +--+--+--+--+      +--+--+--+--+--+
&lt;/pre&gt;

Здесь &quot;master&quot; зона располагается сверху, а &quot;slave&quot; соответственно снизу.

Иногда вы открываете новое окно, а старое при этом смещается в стек зону, что не всегда удобно, в этом случае, можно клиенты поменять местами:
&lt;pre&gt;
Modkey + Shift + j Поменять текущий и следующий за ним клиенты местами.
Modkey + Shift + k Поменять текущий и предыдущий клиенты местами.
&lt;/pre&gt;
Еще можно зажав ''Modkey'' перетащить мышкой нужный клиент в мастер зону, в этом случае, они поменяются местами.

===tile.top===
Схема расположения окон в данном layout:
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----------+      +-----+-----+
|           |      |     1     |      |  2  |  1  |
|     1     |  -&gt;  +-----------+  -&gt;  +-----+-----+  -&gt;
|           |      |     2     |      |     3     |
+-----------+      +-----------+      +-----------+

     (4)                (5)                 (6)
+---+---+---+      +--+--+--+--+      +--+--+--+--+--+
| 3 | 2 | 1 |      | 4| 3| 2| 1|      | 5| 4| 3| 2| 1|
+---+---+---+  -&gt;  +--+--+--+--+  -&gt;  +--+--+--+--+--+
|     4     |      |     5     |      |       6      |
+-----------+      +-----------+      +--+--+--+--+--+
&lt;/pre&gt;

В данном случае мастер зона расположена внизу, а стек зона сверху.
И чтобы поменять любой выделенный клиент и находящийся в мастер зоне, можно использовать:
&lt;pre&gt;
Modkey + Control + Return Поменять текущий и главный клиенты местами.
&lt;/pre&gt;

===fair===
Схема расположения окон в данном layout:
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----+-----+      +-----+-----+
|           |      |     |     |      |  3  |     |
|     1     |  -&gt;  |  2  |  1  |  -&gt;  +-----+  1  |  -&gt;
|           |      |     |     |      |  2  |     |
+-----------+      +-----+-----+      +-----+-----+

     (4)                (5)                (6)
+-----+-----+      +-----+-----+      +-----+-----+
|  4  |  2  |      |  5  |     |      |  6  |  3  |
|     |     |      +-----+  2  |      +-----+-----+
+-----+-----+  -&gt;  |  4  + ----|  -&gt;  |  5  |  2  |
|     |     |      +-----+     |      +-----+-----+
|  3  |  1  |      |  3  |  1  |      |  4  |  1  |
+-----+-----+      +-----+-----+      +-----+-----+
&lt;/pre&gt;

===fair.horizontal===
Схема расположения окон в данном layout:
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----------+      +-----+-----+
|           |      |     2     |      |  3  |  2  |
|     1     |  -&gt;  +-----------+  -&gt;  +-----------+  -&gt;
|           |      |     1     |      |     1     |
+-----------+      +-----------+      +-----+-----+

     (4)                (5)                 (6)
+-----+-----+      +---+---+---+      +---+---+---+
|  4  |  3  |      | 5 | 4 | 3 |      | 6 | 5 | 4 |
+-----+-----+  -&gt;  +---+-+-+---+  -&gt;  +---+---+---+
|  2  |  1  |      |  2  |  1  |      | 3 | 2 | 1 |
+-----+-----+      +--+--+--+--+      +---+---+---+
&lt;/pre&gt;

===spiral===
Схема расположения окон в данном layout:
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----+-----+      +-----+-----+
|           |      |     |     |      |     |  2  |
|     1     |  -&gt;  |  2  |  1  |  -&gt;  |  3  +-----+  -&gt;
|           |      |     |     |      |     |  1  |
+-----------+      +-----+-----+      +-----+-----+

       (4)                    (5)                 (6)
+-------+-------+      +-------+-------+      +-------+-------+
|       |       |      |       |       |      |       |       |
|       |   3   |      |       |   4   |      |       |   5   |
|       |       |      |       |       |      |       |       |
|   4   +---+---+   -&gt; |   5   +---+---+  -&gt;  |   6   +-+-+---|
|       |   |   |      |       | 1 |   |      |       |2|1|   |
|       | 1 | 2 |      |       +---+ 3 |      |       +-+-+ 4 |
|       |   |   |      |       | 2 |   |      |       | 3 |   |
+-------+---+---+      +-------+---+---+      +-------+---+---+
&lt;/pre&gt;

===spiral.dwindle===
Схема расположения окон в данном layout:
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----+-----+      +-----+-----+
|           |      |     |     |      |     |  2  |
|     1     |  -&gt;  |  2  |  1  |  -&gt;  |  3  +-----+  -&gt;
|           |      |     |     |      |     |  1  |
+-----------+      +-----+-----+      +-----+-----+

       (4)                    (5)                 (6)
+-------+-------+      +-------+-------+      +-------+-------+
|       |       |      |       |       |      |       |       |
|       |   3   |      |       |   4   |      |       |   5   |
|       |       |      |       |       |      |       |       |
|   4   +---+---+   -&gt; |   5   +---+---+  -&gt;  |   6   +---+---|
|       |   |   |      |       |   | 2 |      |       |   | 3 |
|       | 2 | 1 |      |       | 3 +---+      |       | 4 +-+-+
|       |   |   |      |       |   | 1 |      |       |   |2|1|
+-------+---+---+      +-------+---+---+      +-------+---+-+-+
&lt;/pre&gt;

===max===
В этой схеме окна занимают весь экран, за исключением панели.

===max.fullscreen===
В этой схеме окно занимает полностью весь экран, включая панели. Идеально подходит для просмотра видео.

===magnifier===

В этой схема 1 окно находится в мастер зоне (по центру экрана), все остальные располагаются под ним, расположенные стопкой.
&lt;pre&gt;
     (1)                (2)                (3)
+-----------+      +-----------+      +-----------+
|           |      |1  +---+   |      |2  +---+   |
|     1     |  -&gt;  |   | 2 |   |  -&gt;  +---| 3 |---+  -&gt;
|           |      |   +---+   |      |1  +---+   |
+-----------+      +-----------+      +-----------+

         (4)                        (5)               
+---------+---------+      +---------+---------+
|                   |      |                   |
|  3                |      |4                  |
|    +---------+    |      +---+-----------+---+
+----|         |----+      |   |           |   |
|    |    4    |    |      |3  |           |   |
|  2 |         |    |   -&gt; +---|     1     |---+
|    |         |    |      |   |           |   |
+----|         |----+      |2  |           |   |
|    +---------+    |      +---+-----------+---+
|  1                |      |                   |
|                   |      |1                  |
+---------+---------+      +-------------------+
&lt;/pre&gt;

==Настройка layout==
Первое время пока вы будете изучать и подбирать схемы для себя, какой либо настройки не требуется. Но со временем, вы захотите, чтобы например, на 1м теге открывалась определенная схема, например для терминалов, а на 2м, открывался браузер, раскрытый во весь экран. Конечно можно каждый раз переключать схемы, но можно избежать муторной и повторяющейся настройки. Ведь мы используем Awesome, не для того, чтобы каждый раз повторять одни и те же действия, а чтобы нам '''действительно''' было удобно использовать систему. 

Итак, открываем наш ''rc.lua'', находим там секцию ''Tags'', она начинается со строки &lt;code&gt;tags = {}&lt;/code&gt;.
&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
tags = {}
for s = 1, screen.count() do
    tags[s] = awful.tag({1,2,3,4,5,6,7,8,9}, s, layout[1])
end
&lt;/pre&gt;
Код приведенный выше используется по умолчанию в Awesome 3.4. Здесь мы можем видеть, что для '''всех''' тегов будет использоваться схема layout[1]. Смотртим в таблицу layout выше и видим, что по умолчанию для всех тегов будет использоваться схема awful.layout.suit.floating. Теперь для привязки схемы к конкретному тегу, нам нужно модифицировать код следующим образом:
&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
tags = {
    names = { &quot;Main&quot;, &quot;www&quot;, 3, 4, 5, 6, 7, 8, 9 },
    layout={ layouts[2], layouts[10], layouts[10], layouts[10], layouts[1], layouts[2], layouts[1],
			layouts[1], layouts[11]
           }
	}
&lt;/pre&gt;
Обратите внимание, количество значений в таблице ''name{}'', должно соответствовать количеству значений в таблице ''layout{}''. 
Итак, для первого тега, который мы назвали &quot;Main&quot; в данном случае мы будем использовать layout[2] - awful.layout.suit.tile
Для тега &quot;www&quot; мы используем layout[10] - awful.layout.suit.max, т.е. браузер у нас будет открываться на весь экран, за исключением панели. И так далее.

==Расширение стандартных схем==

После некоторого времени использования Awesome, иногда возникает некая неудовлетворенность существующими схемами(layout), для решения этой проблемы пользователи создали 2 библиотеки для их расширения.

* [[Vain/ru|Vain]] - изначально разрабатывался для Awesome 3.4, чуть позднее был портирован на 3.5 (разрабатывался одним пользователем под себя).

* [[Lain/ru|Lain]] - когда вышел Awesome 3.5, создатель Vain остался на старой версии и не стал портировать свою библиотеку на новую версию, конечно, со временем, это было сделано, но, сообщество решило на его основе сделать свою, новую и поддерживаемую версию, так была создана библиотека Lain. На сегодняшний день в нее добавлены виджеты и различные утилиты. Но работает она только на Awesome 3.5.</text>
      <sha1>5u6lqpfo994k35yww2lgso4pxedy8ue</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Libreoffice Multi-monitor</title>
    <ns>0</ns>
    <id>1005</id>
    <revision>
      <id>7317</id>
      <parentid>7316</parentid>
      <timestamp>2015-04-13T15:52:38Z</timestamp>
      <contributor>
        <username>Getzze</username>
        <id>4292</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="3976">{{Languages}}

== Scrolling problem ==

When using multiple monitors, scrolling in Libreoffice on one screen can cause Awesome to switch tags in the other screen.  There was a fix added to Openoffice and Libreoffice, but you need to edit an xml settings file to enable it.  With Libreoffice, there should be a per-user settings file at:

 ~/.config/libreoffice/4/user/registrymodifications.xcu

Add the following entry to the end of that file before the &lt;nowiki&gt;&lt;/oor:items&gt;&lt;/nowiki&gt; tag.

 &lt;nowiki&gt;&lt;item oor:path=&quot;/org.openoffice.VCL/Settings/org.openoffice.VCL:ConfigurableSettings['WM']&quot;&gt;&lt;prop oor:name=&quot;ShouldSwitchWorkspace&quot; oor:op=&quot;fuse&quot; oor:type=&quot;xs:string&quot;&gt;&lt;value&gt;false&lt;/value&gt;&lt;/prop&gt;&lt;/item&gt;&lt;/nowiki&gt;

With that added, scrolling in Libreoffice shouldn't affect the other screen.

== Presentation on second screen ==

There is a bug with Libreoffice Impress (as of version 4.3) presentation mode (https://bugs.documentfoundation.org/show_bug.cgi?id=57742), so that the fullscreen presentation window is not sent to the second screen, but remains in the first screen, hidden under the presentation console.
Using awful.rules and [https://github.com/Elv13/tyrannical tyrannical], the presentation window can be detected and sent to the second screen:

    awful.rules.rules = {
        {   rule_any = { class = { &quot;openoffice&quot;,    &quot;soffice&quot;, &quot;Soffice&quot;, &quot;LibreOffice&quot;,
                &quot;libreoffice-writer&quot;,  &quot;libreoffice-base&quot;,  &quot;libreoffice-impress&quot;, &quot;libreoffice-calc&quot;, &quot;libreoffice-draw&quot;, &quot;libreoffice-math&quot;, &quot;libreoffice-startcenter&quot;  }},
            callback = function(c)
                    awful.client.property.set(c, &quot;overwrite_class&quot;, &quot;libreoffice&quot;)
                end
        },
        {   rule = { name = &quot;LibreOffice 4.3&quot;, class = &quot;Soffice&quot;, type = &quot;normal&quot;},
            callback = function(c)
                    awful.client.property.set(c, &quot;overwrite_class&quot;, &quot;libreoffice-fullscreen&quot;)
                end,
            properties = { 
                screen = 2,
                skip_taskbar = true,
                maximized = true,
                focusable = true}
        }
    }
    tyrannical.tags = {
        {
            name         = &quot;libreoffice&quot;,
            screen       = 1, 
            no_focus_stealing_out = true,
            class        = { &quot;libreoffice&quot; }   
        } ,
        {
            name         = &quot;presentation&quot;,
            screen       = 2,
            force_screen = true,
            selected     = true,
            volatile     = true,
            no_focus_stealing_out = true,
            class        = { &quot;libreoffice-fullscreen&quot;}
        }
    }

The `callback` option in the awful.rules serves to differentiate the presentation window from the other Libreoffice windows. For LibreOffice 4.3, the presentation window is defined with the class &quot;Soffice&quot;, name &quot;LibreOffice 4.3&quot; and type &quot;normal&quot;. This may change in other versions, use xprop to get the presentation window properties.

In Awesome 3.5.6, there is a bug when changing the screen of a fullscreen (or maximized) window, so the window size is not recalculated to fit the new screen dimensions. To solve this, add the following code to your `rc.lua`:

    -- Patch change screen for fullscreen
    local function client_reload_max(c)
        local c = c or client.focus
        if not c then return end
        if c.maximized then
            c.maximized = false
            c.maximized = true
        else
            if c.maximized_horizontal then
                c.maximized_horizontal = false
                c.maximized_horizontal = true
            end
            if c.maximized_vertical then
                c.maximized_vertical = false
                c.maximized_vertical = true
            end
        end
        if c.fullscreen then
            c.fullscreen = false
            c.fullscreen = true
        end
    end
    -- Connect change screen signal to a resize function
    client.connect_signal(&quot;property::screen&quot;, client_reload_max)</text>
      <sha1>50ieg4eoi91y9q1f83q9awr1qphdviv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Libreoffice Multi-monitor/ru</title>
    <ns>0</ns>
    <id>1112</id>
    <revision>
      <id>6751</id>
      <timestamp>2014-06-09T16:27:03Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Libreoffice Multi-monitor (translating page)</comment>
      <text xml:space="preserve" bytes="1322">{{Languages|Libreoffice Multi-monitor}}
{{DISPLAYTITLE:Корректная работа LibreOffice с несколькими мониторми}}

== Libreoffice Multi-monitor ==

При использовании нескольких мониторов, прокрутка в Libreoffice на одном экране, может привести к смене тега в Awesome на другом экране. Эта ошибка была исправлена в Openoffice и Libreoffice, но необходимо отредактировать настройки в xml файле для включения этих исправление. Для Libreoffice, файл настроек находится в каталоге пользователя:

 ~/.config/libreoffice/4/user/registrymodifications.xcu

Добавьте следующую запись в конец этого файла перед тегом&lt;nowiki&gt;&lt;/oor:items&gt;&lt;/nowiki&gt;.

 &lt;nowiki&gt;&lt;item oor:path=&quot;/org.openoffice.VCL/Settings/org.openoffice.VCL:ConfigurableSettings['WM']&quot;&gt;&lt;prop oor:name=&quot;ShouldSwitchWorkspace&quot; oor:op=&quot;fuse&quot; oor:type=&quot;xs:string&quot;&gt;&lt;value&gt;false&lt;/value&gt;&lt;/prop&gt;&lt;/item&gt;&lt;/nowiki&gt;

После добавления этих строк, прокрутка в Libreoffice не должна влиять на другой экран.</text>
      <sha1>9fepiqjovwmnd4tpwb8hbch17ez7ejh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Linux CPU Governor Widget</title>
    <ns>0</ns>
    <id>303</id>
    <redirect title="CPU Governor/Freq. Widget for Linux (Pure Lua)" />
    <revision>
      <id>2453</id>
      <parentid>2450</parentid>
      <timestamp>2009-03-17T10:39:35Z</timestamp>
      <contributor>
        <username>Redirect fixer</username>
        <id>245</id>
      </contributor>
      <comment>[[CPU Governor/Freq Widget for Linux (Pure Lua)]] has been moved, it is now a redirect to [[CPU Governor/Freq. Widget for Linux (Pure Lua)]]</comment>
      <text xml:space="preserve" bytes="60">#REDIRECT [[CPU Governor/Freq. Widget for Linux (Pure Lua)]]</text>
      <sha1>khy2a8fjx6mply2c0o4idwya6r7py8z</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Lua prompt improvements</title>
    <ns>0</ns>
    <id>268</id>
    <revision>
      <id>6661</id>
      <parentid>4457</parentid>
      <timestamp>2014-05-26T03:15:45Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="3648">{{Languages}}

The default Lua prompt (Mod+F4) can be a bit awkward to use. These two hacks allow adding both auto-completion and better evaluation support.

== Completion ==
(by [[User:Espenhw|espenhw]])

This isn't very useful, maybe, but it's kinda cool that it is even possible!

Use this function as the completion_callback argument to ''awful.prompt.run''.

&lt;pre&gt;
function lua_completion (line, cur_pos, ncomp)
   -- Only complete at the end of the line, for now
   if cur_pos ~= #line + 1 then
      return line, cur_pos
   end

   -- We're really interested in the part following the last (, [, comma or space
   local lastsep = #line - (line:reverse():find('[[(, ]') or #line)
   local lastidentifier
   if lastsep ~= 0 then
      lastidentifier = line:sub(lastsep + 2)
   else
      lastidentifier = line
   end

   local environment = _G

   -- String up to last dot is our current environment
   local lastdot = #lastidentifier - (lastidentifier:reverse():find('.', 1, true) or #lastidentifier)
   if lastdot ~= 0 then
      -- We have an environment; for each component in it, descend into it
      for env in lastidentifier:sub(1, lastdot):gmatch('([^.]+)') do
         if not environment[env] then
            -- Oops, no such subenvironment, bail out
            return line, cur_pos
         end
         environment = environment[env]
      end
   end

   local tocomplete = lastidentifier:sub(lastdot + 1)
   if tocomplete:sub(1, 1) == '.' then
      tocomplete = tocomplete:sub(2)
   end

   local completions = {}
   for k, v in pairs(environment) do
      if type(k) == &quot;string&quot; and k:sub(1, #tocomplete) == tocomplete then
         table.insert(completions, k)
      end
   end

   if #completions == 0 then
      return line, cur_pos
   end
   
   while ncomp &gt; #completions do
      ncomp = ncomp - #completions
   end

   local str = &quot;&quot;
   if lastdot + lastsep ~= 0 then
      str = line:sub(1, lastsep + lastdot + 1)
   end
   str = str .. completions[ncomp]
   cur_pos = #str + 1
   return str, cur_pos
end
&lt;/pre&gt;


== Evaluation ==
(by [[User:MattJ|MattJ]])

This eval function improves the default ''awful.util.eval'' for the Lua prompt to show the result of an execution, either return value(s) or an error. It also executes the code in the same context as your rc.lua, meaning you can access widgets and variables created there.

To use, simply add this function to your rc.lua, above where the Lua prompt is created. Change ''awful.util.eval'' on the prompt line to ''usefuleval''.

&lt;pre&gt;
function usefuleval(s)
	local f, err = loadstring(&quot;return &quot;..s);
	if not f then
		f, err = loadstring(s);
	end
	
	if f then
		setfenv(f, _G);
		local ret = { pcall(f) };
		if ret[1] then
			-- Ok
			table.remove(ret, 1)
			local highest_index = #ret;
			for k, v in pairs(ret) do
				if type(k) == &quot;number&quot; and k &gt; highest_index then
					highest_index = k;
				end
				ret[k] = select(2, pcall(tostring, ret[k])) or &quot;&lt;no value&gt;&quot;;
			end
			-- Fill in the gaps
			for i = 1, highest_index do
				if not ret[i] then
					ret[i] = &quot;nil&quot;
				end
			end
			if highest_index &gt; 0 then
				mypromptbox[mouse.screen].text = awful.util.escape(&quot;Result&quot;..(highest_index &gt; 1 and &quot;s&quot; or &quot;&quot;)..&quot;: &quot;..tostring(table.concat(ret, &quot;, &quot;)));
			else
				mypromptbox[mouse.screen].text = &quot;Result: Nothing&quot;;
			end
		else
			err = ret[2];
		end
	end
	if err then
		mypromptbox[mouse.screen].text = awful.util.escape(&quot;Error: &quot;..tostring(err));
	end
end
&lt;/pre&gt;

Note by Proc: &lt;br /&gt;
&lt;code&gt;
mypromptbox[mouse.screen].text = XXX
&lt;/code&gt;
didn't work for me so I changed it to
&lt;code&gt;
naughty.notify({ XXX , screen = mouse.screen })


[[Category:Awesome3]]</text>
      <sha1>7dfyaxti0m70swzd0rl1m3tzgt5u73x</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Lua prompt improvements/ru</title>
    <ns>0</ns>
    <id>1088</id>
    <revision>
      <id>6663</id>
      <timestamp>2014-05-26T04:01:19Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Lua prompt improvements (translating page)</comment>
      <text xml:space="preserve" bytes="5312">{{Languages|Lua prompt improvements}}
{{DISPLAYTITLE:Улучшение строки запуска кода Lua}}

Строка запуска Lua по уполчанию (Mod+x) может быть не очень удобна в использовании. Здесь приведены два хака, позволяющие добавить автозавершение и улучшенние функции evaluation.

== Заключение ==
(Сделано [[User:Espenhw|espenhw]])

Это не очень полезно, может быть, но это круто что это возможно!

Функция должна быть размещено до секции prompt файла rc.lua

&lt;pre&gt;
function lua_completion (line, cur_pos, ncomp)
   -- Only complete at the end of the line, for now
   if cur_pos ~= #line + 1 then
      return line, cur_pos
   end

   -- We're really interested in the part following the last (, [, comma or space
   local lastsep = #line - (line:reverse():find('[[(, ]') or #line)
   local lastidentifier
   if lastsep ~= 0 then
      lastidentifier = line:sub(lastsep + 2)
   else
      lastidentifier = line
   end

   local environment = _G

   -- String up to last dot is our current environment
   local lastdot = #lastidentifier - (lastidentifier:reverse():find('.', 1, true) or #lastidentifier)
   if lastdot ~= 0 then
      -- We have an environment; for each component in it, descend into it
      for env in lastidentifier:sub(1, lastdot):gmatch('([^.]+)') do
         if not environment[env] then
            -- Oops, no such subenvironment, bail out
            return line, cur_pos
         end
         environment = environment[env]
      end
   end

   local tocomplete = lastidentifier:sub(lastdot + 1)
   if tocomplete:sub(1, 1) == '.' then
      tocomplete = tocomplete:sub(2)
   end

   local completions = {}
   for k, v in pairs(environment) do
      if type(k) == &quot;string&quot; and k:sub(1, #tocomplete) == tocomplete then
         table.insert(completions, k)
      end
   end

   if #completions == 0 then
      return line, cur_pos
   end
   
   while ncomp &gt; #completions do
      ncomp = ncomp - #completions
   end

   local str = &quot;&quot;
   if lastdot + lastsep ~= 0 then
      str = line:sub(1, lastsep + lastdot + 1)
   end
   str = str .. completions[ncomp]
   cur_pos = #str + 1
   return str, cur_pos
end
&lt;/pre&gt;

Используйте эту функцию как аргумент completion_callback для ''awful.prompt.run''. 
Для использования функции измените вызов awful.prompt.run:
&lt;pre&gt;
  awful.key({modkey},&quot;x&quot;,
    function ()
      awful.prompt.run({prompt = &quot;Run Lua code:&quot;,
        mypromptbox[mouse.screen].widget,
        awful.util.eval,
        lua_completion,
        awful.util.getdir(&quot;cache&quot;)..&quot;history_eval&quot;)
     end)
  )
&lt;/pre&gt;

== Улучшение качества ==
(by [[User:MattJ|MattJ]])

Эта функция usefuleval улучшает стандартную ''awful.util.eval'' для Lua prompt, чтобы отобразить результат выполнения, либо возваращает значение(я) или код ошибки. Этот код также выполняется в том же контексте, что и ваш rc.lua, что означает, что вы можете получить доступ к виджетам и переменным созданным в этом файле.

Для использования, просто добавьте эту функцию в ваш rc.lua, выше места создания Lua prompt. 

&lt;pre&gt;
function usefuleval(s)
	local f, err = loadstring(&quot;return &quot;..s);
	if not f then
		f, err = loadstring(s);
	end
	
	if f then
		setfenv(f, _G);
		local ret = { pcall(f) };
		if ret[1] then
			-- Ok
			table.remove(ret, 1)
			local highest_index = #ret;
			for k, v in pairs(ret) do
				if type(k) == &quot;number&quot; and k &gt; highest_index then
					highest_index = k;
				end
				ret[k] = select(2, pcall(tostring, ret[k])) or &quot;&lt;no value&gt;&quot;;
			end
			-- Fill in the gaps
			for i = 1, highest_index do
				if not ret[i] then
					ret[i] = &quot;nil&quot;
				end
			end
			if highest_index &gt; 0 then
				mypromptbox[mouse.screen].text = awful.util.escape(&quot;Result&quot;..(highest_index &gt; 1 and &quot;s&quot; or &quot;&quot;)..&quot;: &quot;..tostring(table.concat(ret, &quot;, &quot;)));
			else
				mypromptbox[mouse.screen].text = &quot;Result: Nothing&quot;;
			end
		else
			err = ret[2];
		end
	end
	if err then
		mypromptbox[mouse.screen].text = awful.util.escape(&quot;Error: &quot;..tostring(err));
	end
end
&lt;/pre&gt;

Затем измените вызов функции ''awful.util.eval'' в строке на вызов функции ''usefuleval'' в prompt.
Для использования функции измените вызов awful.prompt.run:
&lt;pre&gt;
  awful.key({modkey},&quot;x&quot;,
    function ()
      awful.prompt.run({prompt = &quot;Run Lua code:&quot;,
        mypromptbox[mouse.screen].widget,
        usefuleval, nil,
        awful.util.getdir(&quot;cache&quot;)..&quot;history_eval&quot;)
     end)
  )
&lt;/pre&gt;

Примечание от Proc: &lt;br /&gt;
&lt;code&gt;
mypromptbox[mouse.screen].text = XXX
&lt;/code&gt;
у меня не работает, поэтому я изменил его на
&lt;code&gt;
naughty.notify({ XXX , screen = mouse.screen })


[[Category:Awesome3]]</text>
      <sha1>862v912sut6548spc4xv7ez4euopf80</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MPD</title>
    <ns>0</ns>
    <id>710</id>
    <redirect title="MPD Widgets" />
    <revision>
      <id>4970</id>
      <parentid>4964</parentid>
      <timestamp>2011-07-27T13:35:48Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <comment>Redirected page to [[MPD Widgets]]</comment>
      <text xml:space="preserve" bytes="25">#REDIRECT [[MPD Widgets]]</text>
      <sha1>cyrvbuesqolgxusxath7bbe0txdt9tp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MPD Widgets</title>
    <ns>0</ns>
    <id>715</id>
    <revision>
      <id>5193</id>
      <parentid>5110</parentid>
      <timestamp>2011-12-07T20:36:36Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="2928">This page provides a basic overview of existing widgets for MPD (Music Player Daemon). Each widget comes with a short description, last update date, a screenshot and a link to the main article.

== User contributed widgets ==

=== [[Awesompd_widget| Awesompd]] ===

''Last update: 07.12.2011''

[[Image:mpd_widgets_awesompd.png|right|thumb|Awesompd plays a Jamendo stream and displays notification]]

Awesompd is a mature and highly-functional MPD widget. It provides interaction with MPD server through '''mpc'''. Main features:

* playback control, scrolling text, notifications, changing servers, album covers display

* Jamendo support: music search, Top 100, changeable stream format (MP3 or OGG)

=== [[KAworu_MPD_Widget|kAworu MPD Widget]] ===

''Last update: 10.04.2010''

[[Image:mpd_widgets_kaworu.png|right|thumb|kAworu MPD Widget on the wibox]]

This is more like a framework for creating MPD widgets. It uses '''luasocket''' library to communicate with MPD server and provides basic requests to the server that you can use in building your MPD widget.

* Depends only on luasocket (doesn't use mpc/netcat/telnet). 

* May be hard for new users because it lacks a basic working example to start off with.

=== [[Antel_MPD-Ruby|Antel MPD-Ruby]] ===

''Last update: 05.01.2009''

[[Image:mpd_widgets_antel.png|right|thumb|Antel MPD-Ruby widget on the wibox]]

A simple and light MPD widget based on the '''librmpd''' library.

* Depends only on librmpd (doesn't use mpc/netcat/telnet)

* Requires '''ruby''' and '''rubygem''' to be installed.

=== [[Jaenbon's_MPD_widget|Jaenbon's MPD widget]] ===

''Last update: 18.04.2010''

[[Image:mpd_widgets_jaenbon.png|right|thumb|Jaenbon's MPD widget on the wibox]]

A very simple widget that depends on '''mpc''' and a bash-script.

* Requires only mpc and a start-up script to work.

* Scrolls the long texts.

== Library widgets ==

=== [[Vicious#MPD_Status_.28textbox.29|Vicious]] ===

[[Image:mpd_widgets_vicious.png|right|thumb|vicious.widgets.mpd on the wibox]]

Vicious library provides a lightweight MPD widget by the widget type ''vicious.widgets.mpd''.

* Stable and very easy to install

* Configurable output format

=== [[Obvious]] ===

[[Image:mpd_widgets_obvious.png|right|thumb|obvious.basic_mpd on the wibox with length set to 50]]

Obvious offers users a pretty simple widget that can display MPD information. Also you can define your bindings to control the playback.

* Stable and very easy to install

* Configurable output format

=== [[Bashets]] ===

[[Image:mpd_widgets_bashets.png|right|thumb|mpd bashet on the wibox (screenshot by Zhuravlik)]]

Bashets library uses the concept of delegating all widget work to shell scripts and then just displaying their output. MPD bashet requires '''mpc''' to work.

* Very easy to install

* No need in lua knowledge to configure - you can just edit the shell script

[[Category:Widgets]]

[[Category:awesome3]]</text>
      <sha1>nhop2ly4z6shlx1jimhk8x7etnh06zy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MPD information with mpdcron</title>
    <ns>0</ns>
    <id>804</id>
    <revision>
      <id>6620</id>
      <parentid>5412</parentid>
      <timestamp>2014-05-23T08:40:00Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="922">{{Languages}}

You'll only need [http://alip.github.com/mpdcron/ mpdcron] and (of course) a running [http://mpd.wikia.com/ MPD]-server.

Place into your ''~/.mpdcron/mpdcron.conf'' (to ''mpd'' section):

 events = player

Of course you can add more events if you want.

Your ''~/.mpdcron/hooks/player'':

 echo &quot;mpdcron({state=\&quot;$MPD_STATUS_STATE\&quot;, \
    artist=\&quot;$MPD_SONG_TAG_ARTIST\&quot;, title=\&quot;$MPD_SONG_TAG_TITLE\&quot;})&quot; | awesome-client

Create a textbox widget named ''mpdtextbox'' and put into your awesome's ''rc.lua'':

 function mpdcron (mpdinf)
    local mpdtext = &quot;&quot;
    if (mpdinf.state==&quot;play&quot;) then
        mpdtext = mpdinf.artist .. &quot; - &quot; .. mpdinf.title
    elseif (mpdinf.state==&quot;pause&quot;) then
        mpdtext = &quot; [[[ &quot; .. mpdinf.artist .. &quot; - &quot; .. mpdinf.title .. &quot; ]]]&quot;
    else
        mpdtext = &quot; [ leállítva ] &quot;
    end
    mpdtextbox.text = awful.util.escape(mpdtext)
 end

Run ''mpdcron'' and enjoy!</text>
      <sha1>7fleha72z07yqdkl6qqcldq3kkit9o2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>MPD information with mpdcron/ru</title>
    <ns>0</ns>
    <id>1077</id>
    <revision>
      <id>6622</id>
      <timestamp>2014-05-23T08:58:16Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода MPD information with mpdcron (translating page)</comment>
      <text xml:space="preserve" bytes="1408">{{Languages|MPD information with mpdcron}}
{{DISPLAYTITLE:Отображение информации из MPD испльзуя mpdcron}}

Вам потребуется [http://alip.github.com/mpdcron/ mpdcron] и конечно запущенный [http://mpd.wikia.com/ MPD]-серверу. 
mpdcron - есть в репозитории Debian\Ubuntu, для установки испльзуйте:
  sudo apt-get install mpdcron

Добавьте в ваш ''~/.mpdcron/mpdcron.conf'' (в секцию ''mpd''):

 events = player

Конечно вы можете добавить большее колличество событий(events), если пожелаете.

Ваш ''~/.mpdcron/hooks/player'':

 echo &quot;mpdcron({state=\&quot;$MPD_STATUS_STATE\&quot;, \
    artist=\&quot;$MPD_SONG_TAG_ARTIST\&quot;, title=\&quot;$MPD_SONG_TAG_TITLE\&quot;})&quot; | awesome-client

Создайте виджет textbox с названием ''mpdtextbox'' и поместите его в ваш ''rc.lua'':

 function mpdcron (mpdinf)
    local mpdtext = &quot;&quot;
    if (mpdinf.state==&quot;play&quot;) then
        mpdtext = mpdinf.artist .. &quot; - &quot; .. mpdinf.title
    elseif (mpdinf.state==&quot;pause&quot;) then
        mpdtext = &quot; [[[ &quot; .. mpdinf.artist .. &quot; - &quot; .. mpdinf.title .. &quot; ]]]&quot;
    else
        mpdtext = &quot; [ leállítva ] &quot;
    end
    mpdtextbox.text = awful.util.escape(mpdtext)
 end

Запустите ''mpdcron'' и наслаждайтесь!</text>
      <sha1>k11a5kr1fm63fbczryxt2nr9vpna7cx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Maic imap checker</title>
    <ns>0</ns>
    <id>944</id>
    <revision>
      <id>6006</id>
      <parentid>6005</parentid>
      <timestamp>2013-05-19T22:54:03Z</timestamp>
      <contributor>
        <username>Amma</username>
        <id>3012</id>
      </contributor>
      <text xml:space="preserve" bytes="1533">= About =
''maic'' is just another widget that shows NEW/RECENT messages on IMAP accounts. It handles multiple accounts. Configuration is stored in the file &lt;tt&gt;~/.config/awesome/maic.cfg&lt;/tt&gt; using INI file syntax (including login credentials - permissions will be checked and adjusted at first run). I placed it beside a vicious battery, net and cpu widget on a seperate status bar at the bottom of the screen.

[[File:Maic.png]]

= Install =
* Get the latest version on my [http://svn.mb-oss.de/maic svn server] and save it to &lt;tt&gt;/usr/local/bin/maic.py&lt;/tt&gt;
* Add the widget to &lt;tt&gt;~/.config/awesome/rc.lua&lt;/tt&gt;. Adjust &lt;tt&gt;timeout&lt;/tt&gt; to your needs
&lt;pre&gt;
...
mailWidget = widget({ type = &quot;textbox&quot; })
mailWidget.text = &quot;Init&quot;
mailWidgetTimer = timer({ timeout = 300 })
mailWidgetTimer:add_signal(&quot;timeout&quot;, function()
    mailwidget.text = awful.util.pread(&quot;/usr/local/bin/maic.py&quot;)
end)
mailWidgetTimer:start()
...
&lt;/pre&gt;

= Configuration = 
Create the file &lt;tt&gt;~/.config/awesome/maic.cfg&lt;/tt&gt; and add one section per account. The name of the section will be the identifier in the widget (like in the screenshot above)
&lt;pre&gt;
[Foo]
servername: &lt;imap server1&gt;
username: &lt;your username1&gt;
password: &lt;your password1&gt;
ssl: &lt;True|1|Yes&gt;
[Bar]
servername: &lt;imap server2&gt;
username: &lt;your username2&gt;
password: &lt;your password2&gt;
ssl: &lt;True|1|Yes&gt;
&lt;/pre&gt;
If &lt;tt&gt;ssl&lt;/tt&gt; is not given, plain imap (port 143) is used.
= Bugs / suggestions =
Please edit here for bug reports and/or other suggestions
[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>lj1ommvincf689hwfwnbzyf4f10wcwt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main Page</title>
    <ns>0</ns>
    <id>1</id>
    <revision>
      <id>7478</id>
      <parentid>7471</parentid>
      <timestamp>2016-08-04T22:39:40Z</timestamp>
      <contributor>
        <username>Evgeny</username>
        <id>4324</id>
      </contributor>
      <comment>Added a new article</comment>
      <text xml:space="preserve" bytes="14431">{{Languages}}


{| align=&quot;right&quot;
  | __TOC__
  |}

[[Image:Aw 64.png|left|awesome]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;

The goal of this wiki is to provide a community-made documentation and especially help new users with the configuration of awesome. We cover developer information too, including information about how-to build awesome (several related distributions), how-to debug, and so on.

'''Note:''' Due to spammers, you must create an account in order to edit pages. While having to create an account to edit is annoying, so is spam.

Feel free to register as a user and contribute to our documentation effort.

Current [[Releases|awesome releases]]:
* Stable: [http://awesome.naquadah.org/download/ awesome {{stable-version}}].
* Development: Development versions of awesome can be downloaded via Git or as tarballs from [https://github.com/awesomeWM/awesome Github].
* Screenshots: [[Screenshots]]

&lt;/div&gt;

== Documentation ==
[[Image:Stock book blue.png|left|Documentation]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Configuration and control of awesome have changed between major versions and may continue to evolve in future ones. Some of the following documents may try to describe all the existing versions. Please fix them if a missing version needs special explanations. Other documents may be bound to only one version of awesome. Please fix them if version indication is missing.

=== Installation &amp; Basics For Users ===
* [[Awesome 3.x]] - Manpage and keyboard shortcuts.
* [http://www.cheatography.com/fievel/cheat-sheets/awesome-window-manager-3-x/ Awesome 3.x shortcuts cheat sheet]
* [http://awesomewm.github.io/apidoc/documentation/90-FAQ.md.html FAQ] - Check here first if you're having problems!
* [http://awesomewm.github.io/apidoc/documentation/01-readme.md.html Building awesome] - Instructions for building / installing awesome.
* [[awesome 3 configuration]] - Get help understanding awesome 3 configuration and API basics.
* [[awesome 3.0 to 3.1]] config options that changed between the releases
* [[awesome 3.3 to 3.4]] configuration changes to the 3.4 version
* [[awesome 3.4 to 3.5]] configuration changes to the 3.5 version
* [[Quickly Setting up Awesome with Gnome]] - How to make awesome be used in your gnome session with a couple of commands.
* [[KDE and awesome]]
* [[My first awesome]] Tutorial for new users and beginners

=== Development Basics ===
* [[Using Xephyr]]
* [[Debugging]]
* [[Signals]]
* [[keycodes]]
* [[Development Environment with Xephyr and GNU Make]]

You might also want to join our IRC channel [irc://irc.oftc.net/awesome '''#awesome'''] on [http://www.oftc.net OFTC].
&lt;/div&gt;

== Customization ==
[[Image:Toolbox.png|left|Statusbars]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
=== Statusbars and widgets ===
* [[Widgets in awesome]] - A brief guide on the implementation of widgets within awesome.
* [[Vicious]] - How to use the vicious widget library to add dynamic widgets.
* [[Obvious]] - How to use the Obvious repo (Widgets with community support).
* [[User Contributed Widgets]]
* [[Using Cairo within Awesome]]
* [[Titlebar and Statusbar height]] - Small how-to that helps you customize statusbar and titlebar height.
* [[Bashets]] - Small Lua library to empower you to use your existing shellscripts as content providers for widgets.
* [[Launcher auto-hiding]] - Hide a launcher when the application is running.
* [[Lain]] - Complements to improve configurability and usability.

=== Theming awesome ===
* [[Beautiful|Theming with Beautiful]] - How to theme your awesome-3 with the beautiful library.
* [[Beautiful themes|User Contributed Themes]] - Several awesome themes for use with beautiful.
* [[Customizing Fonts]] - How to add new fonts to your system.
* [[Nice Icons]] - Where to find nice icons to use in your widgets.
* [[Picturesque]] - Automatically fetch and change wallpapers.
* [[Variety]] - Another automatic wallpaper changer.

=== User configuration files ===
* [https://github.com/copycat-killer/awesome-copycats awesome-copycats]
* Examples of [[User_Configuration_Files|other users' configuration files]].

=== Other tips ===
* [[Autostart]] - Small function providing autostart functionality for awesome.
* [[Autostop]]  - Simple method to execute a program on quitting awesome.
* [[Understanding Rules]] - Describes Awesome's awful.rules facility for applying modifications to selected windows.
* [[NASA IOTD_Wallpaper]] - Use NASA's &quot;Image of the day&quot; as wallpaper using feh
* [[Run or raise]] - Run a client, or pop to it if it is already running.
* [[Global Keybindings]] - Create global keybindings in awesome.
* [[Document keybindings]] - Add documentation to each keybinding and display an &quot;help&quot; panel
* [[Keybindings and numeric pad]] - Use the numeric pad to go to tags and show menus associated to each tag
* [[Gradient]] - Visual feedback on numerical data (e.g. processor usage).
* [[Problems with Java]] - What to do if your java apps look grey.
* [[Symbolic tag names]] - How to make your tags have that mysterious symbolic look.
* [[XRandR Screen Table]] - If you don't like using numbers for screens.
* [[Move Mouse]] - Move the mouse from the centre of the screen for mouseless working.
* [[Dbus, naughty and logs]] - Display colorized notifications of your logs.
* [[Naughty log watcher]] - Native implementation (no shell scripts/dbus required).
* [[Using Xephyr]] - How to run nested X sessions - good for testing new builds of awesome or different config files.
* [[Using Multiple Screens]] - How to setup X with multiple screens/monitors for use with awesome.
* [[Using redshift with awesome]] - Redshift integration with awesome
* [[FullScreens|Fullscreens on Multiple Screens]] - How to span a client on multiple screens/monitors with a key
* [[nm-applet]] - How to setup nm-applet to start automatically in awesome.
* [[Mcabber notifications]] - Cool notifications for mcabber via naughty.
* [[Drop-down terminal]] - Toggle a video game-like console on the top of your screen like Yakuake/Tilda.
* [[Scratchpad manager]] - Basic scratchpad manager for the awesome window manager.
* [[WMII-like tag management]] - Mimic WMII's way of tag managment.
* [[Video wallpaper]] - Play a video for your wallpaper using mplayer.
* [[Transparency]] - Transparent windows using xcompmgr.
* [[Minitray]] - Toggable system tray.
* [[Coverart display]] - Display Cover Art for current mpd song.
* [[urxvt tips|Urxvt tips]] - Tips for using rxvt-unicode with awesome.
* [[irssi tips|Irssi tips]] - Tips for using Irssi with awesome.
* [[IM tips]] - Tips for using instant messaging clients with awesome.
* [[Remove icons]] - How to remove icons from the tasklist and show only current client.
* [[Custom Prompts]] - Customized prompts you can use with awful's prompt.
* [[Using dmenu]] - Altering the color scheme, integrating with beautiful, and Run or Raise.
* [[Run commands in background]] - Run shell-commands in background (without hanging awesome!) and returns it's output. 
* [[How to add awesome to gdm3]] - This document explains to how add awesome WM to list of WMs gdm list
* [[How to take ScreenShot with PrntScr key]] This coumentation explains you how to define PrntScr to take screenshot 
* [[ShutdownDialog|Shutdown dialog]] - A simple dialog to shutdown/reboot/suspend/lock screen.
* [[Tree File Menu]] - Python script to generate a tree file menu.
* [[Cycling Random Wallpaper Or Xscreensaver]] - Cycle you background to a random picture or Xscreensaver after a random delay
* [[Blinking text]] - Blinking the text on textbox widget
* [[RPN Calculator]] - RPN calculator
* [[Modal Keybindings]]
* [[Shared tags]] share tagset for multiple screens
* [[Move Window to Workspace Left/Right]] - A function for moving a window one workspace to the left or right.
* [[Move Client to Monitor Left/Right]] - How to move client to a specific direction when using more than two monitors.
* [[Move Client to a specific Monitor]] - How to move a client to a specific monitor.
* [[Move Focus to a specific Monitor]] - How to move the curser/focus to a specific monitor.
* [[Better Font Rendering]]
* [[Disable startup-notification globally]] - If you are annoyed by the stopwatch/busy mouse cursor.
* [[Keeping multitags persistent]] - If you want to able to quickly jump back to a multitag configuration
* [[Conky bar]] - A statusbar-like Conky configuration which is not overlapped by windows
* [[Conky HUD]] - An overlay-like heads-up-display configuration for Conky
* [[Workaround plugins that steal the keyboard focus]] - This has been a known bug in Firefox for over 10 years.
* [[MPD information with mpdcron]]
* [[Autostart with consolekit]] - Using awesome menu to restart/shutdown/hibernate/suspend your computer
* [[Vmware]] - Awesome and vmware tools
* [[Libreoffice Multi-monitor]] - Configure Libreoffice to work correctly with multiple monitors
* [[Systray Hide/Show]] - How to add a keybinding that toggles the systray's visibility
* [[Wibox Raise/Lower]] - Make Wibox visible, or allow windows to cover Wibox
* [[SpeakerWidget]] - A speaker widget with fancy icons.
* [[HelpPopup]] - identifies the application and shows a hint for him
* [[TranslateIt|Translation selected text]] - translate text from X-buffer, using Google.Translate.
* [[RemoveExtraSpace| Remove extra space]] - remove/tuning space between tags, if you using icons.
* [[Disable DPMS|Disable DPMS]] - disable energy saving mode for fullscreen applications
* [[Move all clients to another tag ]] Move all the clients on this tag to another tag.
* [[Preserve Current Directory for New Terminal Windows on Linux]]
&lt;/div&gt;

== Lua extensions ==
[[Image:Lua.jpg|left|Lua extensions]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Lua is a fast, light-weight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping. 

Common uses of Lua are:
* A configuration language for applications.
* A standalone scripting language.
* An embedded language in applications to modify runtime behaviour.

To get introduced into Lua, please read [[The_briefest_introduction_to_Lua | the briefest introduction to Lua]]. For deeper knowledge please read this [http://lua-users.org/wiki/LuaTutorial tutorial] for the newcomers to the language. As a suggestion, please consider to get this [http://lua-users.org/wiki/LuaShortReference Lua Short Reference]. The Awesome framework is built with Lua as the extension language. Some of all extensions can be seen below: 

* [http://awesome.naquadah.org/doc/api/ awful] - the standard awesome Lua library.
* [[awful.menu|awful.menu]] - a popup menu library.
* [https://github.com/Elv13/radical Radical] - A powerful and extensible menu system
* [[Beautiful|Beautiful]] - a theming library.
* [[Obvious|Obvious]] - a new implementation of a widget library made since Wicked.
* [[Vicious|Vicious]] - a modular widget library derived from Wicked.
* [[Space Invaders|Space Invaders]] - allows you to play Space Invaders with Awesome
* [[Naughty|Naughty]] - a popup notification library
* [[Shifty|Shifty]] - dynamic tagging library with advanced client matching and sane configuration
* [https://github.com/Elv13/tyrannical Tyrannical] - A declarative tag and client configuration system for awful dynamic tags (Shifty spiritual successor)
* [[Eminent|Eminent]] - effortless wmii-style dynamic tagging library that does not require any rc.lua changes
* [[Rodentbane|Rodentbane]] - a library for rapid control of the mouse cursor using just the keyboard
* [https://github.com/Elv13/collision Collision] - A powerful keyboard based navigation and resizing module with visual feedback indicators
* [[Flaw|Flaw]] - an object oriented library to manage widgets.
* [https://github.com/Elv13/retrograde Retrograde] - A layout system identical the one from Awesome 3.2-3.4 for Awesome 3.5+
* [[couth|couth]] - yet another extension library -- includes visual popup notifications for alsa and mpd volume.
* [[keychains|keychains]] - use of keychains in awesome
* [[hints|hints]] - window hints to focus windows
* [https://github.com/copycat-killer/vain-again Vain] - An alternative layout system
* [[Blingbling|BlingBling]] - A beautiful Cairo based widget set
* [https://github.com/copycat-killer/lain Lain] - A widget library
* [https://raw.github.com/gvalkov/dotfiles-awesome/master/ezconfig.lua ezconfig] - Emacs-style keybindings for Awesome (eg. &lt;code&gt;'M-S-a'&lt;/code&gt; vs &lt;code&gt;awful.key({modkey, 'Shift'}, 'a'&lt;/code&gt;)
* [https://github.com/svexican/cheeky cheeky] - A simple type-ahead window switcher (uses native clients menu)
* [https://github.com/svexican/dreary dreary] - Temporary/overwritable client keybinds
* [https://github.com/sirkha/keyjoy keyjoy] - Change your mouse and keyboard properties on a per-client basis using rules.
* [https://github.com/Elv13/repetitive Repetitive] - Record and execute macros. Pin tags, clients and macros to F-keys at runtime
* [[Revelation|Revelation]] - Implementing [http://en.wikipedia.org/wiki/Exposé_(Mac_OS_X) Mac OS X Exposé] in awesome.
* [https://github.com/guotsuan/treetile Treetile] - Treetile is binary tree-based and dynamical tiling layout for Awesome 3.5 and latter. you can split the screen in the way similarly to tmux or i3wm. 
&lt;/div&gt;

== More ==
[[Image:Stock_help_blue.png|left|More]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Most people these days are used to having a more complete desktop. This section includes links to various apps that are lightweight and useful from within awesome to fill the gaps between just a window manager and a full-blown desktop environment like KDE or GNOME.

* [[Customizing GTK Apps]] - How to use themes without gnome-settings-daemon.
* [[Terminals]] - Replacements for desktop environment terminals.
* [[File Managers]] - Lightweight stand-alone File Managers.
* [[Automounting]] - A replacement for &quot;gnome-volume-manager&quot;, &quot;thunar-volman&quot;, etc.
* [[Xscreensaver]] - Locking the screen; replacement for gnome-screensaver, etc.
* [[Calendars]] - calendars and agenda solutions (text, graphical, interactive, ...)
* [[PowerManagement]] - A replacement for gnome-power-manager or kpowersave
&lt;/div&gt;

[[Category:Awesome]]</text>
      <sha1>ahoenq72l0lunspjlvpnbqwex7v3w44</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main Page/de</title>
    <ns>0</ns>
    <id>846</id>
    <revision>
      <id>7333</id>
      <parentid>5487</parentid>
      <timestamp>2015-06-23T20:02:31Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Fix Languages template</comment>
      <text xml:space="preserve" bytes="1183">{{Languages|Main Page}}


'''Achtung: An der deutschen Dokumentation wird gerade gearbeitet. Bitte verwenden Sie solange die englische Anleitung!'''


{| align=&quot;right&quot;
  | __TOC__
  |}

[[Image:Aw 64.png|left|awesome]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;

Ziel dieses Wikis ist es, eine von der Community erstellte Dokumentation zur Verfügung zu stellen und um besonders neuen Anwendern bei der Einrichtung von awesome zu helfen. Sie beinhaltet auch Informationen für Entwickler, inklusive Infos, um awesome zu kompilieren (auf verschiedenen verwandten Distributionen), Fehler zu finden uns do weiter.

'''Hinweis:''' Wegen Spammer musst du ein Konto anlegen, um Seiten bearbeiten zu können. Obwohl das Anlegen eines Kontos mühsam ist, so gilt das auch für Spam.

Fühle dich frei, ein Konto zu registrieren und an den Mühen bei der Dokumentation zu helfen.

Aktuelle [[Versionen|awesome Versionen]]:
* Stabil: [http://awesome.naquadah.org/download/ awesome {{stable-version}}].
* Entwicklung: Entwicklungs-Versionen von awesome können als Tarball via [http://git.naquadah.org/?p=awesome.git;a=summary Git Abbildern] heruntergeladen werden.
* Screenshots: [[Screenshots]]

&lt;/div&gt;</text>
      <sha1>2mw2p5jg9ruvgq2efy51foc4gvy6ycx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main Page/fa</title>
    <ns>0</ns>
    <id>844</id>
    <revision>
      <id>5481</id>
      <parentid>5480</parentid>
      <timestamp>2012-05-10T11:02:59Z</timestamp>
      <contributor>
        <username>H2010n</username>
        <id>994</id>
      </contributor>
      <text xml:space="preserve" bytes="407">{{Languages}}


{| align=&quot;left&quot;
  | __TOC__
  |}

[[Image:Aw 64.png|left|awesome]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
این صفحه توسط یک جامعه ساخته شده تا به تازه واردان کمک کند که چگونه دسکتاپ خود را شخصی سازی کنند و اینکه این دسکتاپ چگونه ساخته شد و چگونه می توانید به
آن کمک کنید</text>
      <sha1>5rvq74bkw46c1712q742ffo5ff2k76z</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main Page/fr</title>
    <ns>0</ns>
    <id>367</id>
    <revision>
      <id>4176</id>
      <parentid>3792</parentid>
      <timestamp>2010-04-06T19:02:57Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>/* Autres astuces */ Remove redlink</comment>
      <text xml:space="preserve" bytes="10660">{{DISPLAYTITLE:Accueil}}
{{Languages|Main Page}}


{| align=&quot;right&quot;
  | __TOC__
  |}

[[Image:Aw 64.png|left|awesome]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;

Le but de ce wiki est de fournir une documentation créée par la communauté, surtout pour aider les nouveaux utilisateurs à configurer awesome. Nous proposons également des informations de développement, notamment des tutoriels pour [[Building awesome/fr|installer awesome]] sur de nombreuses distributions, des tutoriels de débogage, etc.

Pour bien commencer, nous vous proposons de lire cette page : [[Getting started/fr|débuter avec awesome]]

'''Remarque :''' pour éviter les ''spammers'', vous devez créer un compte pour modifier les pages. Créer un compte pour éditer est ennuyeux, mais le ''spam'' aussi.

N’hésitez pas à vous enregistrer et à contribuer dans cette documentation.

Dernières [[Releases|versions d’awesome]] :
* Ancienne stable : [http://awesome.naquadah.org/download/ awesome 2.3.6], obsolète.
* Stable : [http://awesome.naquadah.org/download/ awesome {{stable-version}}].
* Développement : sous forme d’archives sur notre [http://git.naquadah.org/?p=awesome.git;a=summary serveur git].

Une [[Beautiful themes/fr|liste de thèmes et captures d’écran]] est disponible si vous souhaitez voir à quoi peut ressembler awesome.

&lt;/div&gt;

== Documentation ==
[[Image:Stock book blue.png|left|Documentation]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
La configuration et les contrôles d’awesome ont changé entre les versions majeures et pourraient bien encore évoluer dans les prochaines. Certains des documents suivants essaient de décrire toutes les versions existantes. Vous êtes invités à les modifier si une version manque d’explications. De même, certains peuvent être relatifs à une version précise d’awesome. Nous vous invitons à les modifier si les informations qu’ils proposent correspondent à une version qui n’est pas mentionnée.

=== Utilisateurs : installation et bases ===
* [[FAQ/fr|Foire aux questions]] : commencez par là si vous avez des problèmes !
* [[Building awesome/fr|Installer awesome]] : une liste d’instructions pour compiler ou installer awesome.
* [[Awesome 3 configuration/fr|Configuration d'awesome 3]] : trouvez de l’aide pour comprendre la configuration d’awesome 3 et les bases de l’interface de programmation.
* Qu’est-ce qui a changé lors du passage de la [[Awesome 3.3 to 3.4|version 3.3 à la 3.4]] ?
* Options de configuration qui ont changé entre les versions [[awesome 3.0 to 3.1|3.0 et 3.1]] d’awesome
* Convertisseur de configuration pour [[acc|awesome 2.x vers 3.x]]
* [[KDE and awesome/fr|Mettre en place awesome avec KDE]]
* [[Quickly Setting up Awesome with Gnome/fr|Mettre en place awesome avec Gnome]] : quelques commandes pour dire à gnome d’utiliser awesome
* [[Customizing GTK Apps/fr|Personnaliser les applications GTK]] : utiliser des thèmes sans avoir recours à ''gnome-settings-daemon''
* [[Man pages/fr|Pages de manuel]]
* [[awesome-menu basics|Bases d’awesome-menu]] pour awesome 2

=== Développement : bases ===
* [[Using Xephyr|Utiliser Xephyr]]
* [[Debugging|Debogage]]

=== Traductions ===
Des morceaux de cette documentation ont déjà été traduits en plusieurs langues. Les documents traduits peuvent contenir des informations supplémentaires concernant des langues étrangères ou d’autres pays.

Par défaut, la plupart des pages sont rédigées en anglais. Si des traductions sont disponibles, une barre est affichée en haut. Voici un exemple pour la [[FAQ/fr|Foire aux questions]] :
{{Languages|FAQ}}

=== Critiques et informations ===
* [http://linuxfr.org/2008/09/19/24506.html awesome 3 sur DLFP]
* [http://www.penguinsightings.org/desktop/awesome/ awesome 3 sur penguinsightings]
&lt;/div&gt;

== Personnalisation ==
&lt;div style=&quot;margin-left: 70px;&quot;&gt;

=== Barres de statut et widgets ===
&lt;/div&gt;
[[Image:Toolbox.png|left|Barres de statut]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
* [[Widgets in awesome/fr|Widgets dans awesome]] : un court guide sur l’implémentation de widgets dans awesome.
* [[Wicked/fr|Widgets avec wicked]] : comment ajouter des widgets dynamiques à l’aide de la bibliothèque wicked.
* [[Obvious]] : comment ajouter le dépôt obvious, lequel fournit un support communautaire de wigdets.
* [[User Contributed Widgets/fr|Widgets proposés par les utilisateurs]]
* [[Using Cairo within Awesome|Utiliser Cairo dans awesome]]
* [[Titlebar and Statusbar height|Hauteurs des barres de statut et de titre]] : petit tutoriel pour vous aider à personnaliser les hauteurs des barres de statut et de titre.

=== Changer l’apparence d’awesome ===
* [[Beautiful/fr|Changer l’apparence avec beautiful]] : changer l’apparence d’awesome 3 avec la bibliothèque beautiful.
* [[Beautiful themes/fr|Thèmes proposés par des utilisateurs]] : nombreux thèmes awesome à utiliser avec beautiful.
* [[Customizing Fonts/fr|Fontes personnalisées]] : comment ajouter de nouvelles fontes à votre système.
* [[Nice Icons/fr|Jolies icônes]] : où trouver de jolies icônes pour vos widgets.

=== Fichiers de configuration d’utilisateurs ===
Des exemples de [[User Configuration Files/fr|fichiers de configuration d’autres utilisateurs]] sont disponibles.

=== Autres astuces ===
* [[irssi tips|Astuces irssi]] : page à voir pour des astuces sur ''irssi''.
* [[Autostart|Démarrage automatique]] : petite fonction fournissant une fonction de démarrage automatique pour awesome.
* [[Run or raise|Lancer ou mettre au premier plan]] : lancer un client, ou le mettre au premier plan s’il tourne déjà.
* [[Revelation/fr|Revelation]] : implémentation de [http://fr.wikipedia.org/wiki/Exposé_(Mac_OS_X) « Exposé » de Mac OS X] dans awesome.
* [[Gradient]] : retour visuel sur des données numériques, par exemple l’utilisation du processeur.
* [[Problems with Java|Problèmes avec Java]] : que faire si vos applications Java sont grises.
* [[XRandR Screen Table/fr|Tableau d’écrans XRandR]] : si vous n’aimez pas utiliser des nombres pour vos écrans.
* [[Move Mouse|Dépalcer la souris]] : déplacer la souris du centre de l’écran, pour travailler sans souris.
* [[Dbus, naughty and logs|Dbus, naughty et journaux]] : afficher des notifications colorées de vos journaux.
* [[Naughty log watcher|Visionneur de journaux naughty]] : implémentation native sans script de console et sans dbus.
* [[Using Xephyr|Utiliser Xephyr]] : comment lancer des sessions X embarquées, pour tester par exemple des nouvelles versions d’awesome ou des fichiers de configuration différents.
* [[Using Multiple Screens|Multi-écran]] : comment configurer X pour utiliser awesome avec plusieurs écrans ou moniteurs.
* [[nm-applet|Network Manager]] : Comment configuer le lancement automatique de ''nm-applet'' dans awesome.
* [[Mcabber notifications|Notifications Mcabber]] : notifications sympas de ''mcabber'' en utilisant naughty.
* [[Drop-down terminal|Console tombante]] : activer une console tombant du haut de l’écran comme dans les jeux vidéos, du même genre que Yakuake ou Tilda.
* [[WMII-like tag management|Gestion des onglets à la wmii]]
* '''Invites de commande personnalisées''' : invites de commande fournies par des utilisateurs
** [[SSH: prompt|Invite SSH]] : invite ssh en barre de statut similaire à l’invite « Run: » avec complétion des noms d’hôte.
** [[Lua prompt improvements|Invite Lua améliorée]] : complétion et évaluation plus utile de l’invite Lua.
** [[Kooky wikipedia completion|Invite Wikipédia]] : invite Wikipedia avec complétion du nom d’article.
** [[Kooky geo|Invite géographique]] : invite pour calculer la distance entre deux endroits.
** [[Anrxcs Manual Prompt|Invite « pages de manuel »]] : invite pour lire les pages de manuel dans votre application préférée.
** [[Anrxcs WebSearch Prompt|Invite de recherche Internet]] : invite pour chercher sur Internet, donnant accès à ''n’importe quel'' formulaire de recherche.
&lt;/div&gt;

== Extensions Lua ==
[[Image:Lua.jpg|left|Lua extensions]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Description du langage Lua :

« ''Lua is a fast, light-weight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping.'' »

Exemples d’utilisations courantes de Lua :
* Langage de configuration pour des applications ;
* Langage scripté auto suffisant ;
* ''An embedded language in applications to modify runtime behaviour.''

Pour vous familiariser avec Lua, nous invitons les nouveaux utilisateurs de ce langage à lire ce [http://lua-users.org/wiki/LuaTutorial tutoriel]. Vous pouvez également regarder du côté de cette [http://lua-users.org/wiki/LuaShortReference courte référence Lua]. Le système awesome est conçu avec Lua en tant que langage d’extension. Parmi ces extensions, on trouve :

* [http://awesome.naquadah.org/doc/api/ awful] : la bibliothèque Lua standard d’awesome ;
* [[awful.menu|awful.menu]] : bibliothèque de menu popup ;
* [[beautiful/fr|beautiful]] : bibliothèque de thèmes d’apparence ;
* [[wicked/fr|wicked]] : bibliothèque de widgets dynamiques ;
* [[Obvious|obvious]] : une nouvelle bibliothèque implémentant des widgets, plus récente que wicked ;
* [[Space Invaders]] : vous permet de jouer à ''Space Invaders'' dans awesome ;
* [[naughty/fr|naughty]] : bibliothèque de notification sous forme de popup ;
* [[shifty/fr|shifty]] : bibliothèque d’onglets dynamiques et de configuration avancée des clients ;
* [[rodentbane]] : bibliothèque de contrôle rapide du pointeur de sourie en utilisant simplement votre clavier.
&lt;/div&gt;

== Voir aussi ==
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
De nos jours, la plupart des gens sont habitués à avoir un système de bureau un peu plus complet. Cette section propose des liens vers des applications qui sont légères et utiles, permettant à awesome de combler les fossés entre un simple gestionnaire de fenêtres et un environnement de bureau complet comme KDE ou Gnome :
* [[Terminals/fr|Consoles virtuelles]] : remplaçants pour les consoles virtuelles de bureau ;
* [[File Managers/fr|Gestionnaires de fichiers]] : gestionnaires de fichiers légers et auto suffisants ;
* [[Automounting/fr|Montage automatique des volumes]] : remplaçant de ''gnome-volume-manager'' ou autre ''thunar-volman''.
&lt;/div&gt;</text>
      <sha1>nt9rf1b7ao9igoddjbqgvnjwyreao2o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main Page/ko</title>
    <ns>0</ns>
    <id>860</id>
    <revision>
      <id>5606</id>
      <timestamp>2012-09-27T00:28:47Z</timestamp>
      <contributor>
        <username>Tomawe</username>
        <id>997</id>
      </contributor>
      <comment>Starting translating into ko</comment>
      <text xml:space="preserve" bytes="11063">{{DISPLAYTITLE:한국어}}
{{Languages|Main Page}}


{| align=&quot;right&quot;
  | __TOC__
  |}

[[Image:Aw 64.png|left|awesome]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;

이 위키의 목적은 커뮤니티에서 작성한 문서를 보여주고 특히 awesome을 처음 사용하는 사용자를 돕고자 하는 것이다.   awesome(몇 개의 관련 배포판)을 빌드하는 방법, 디버그하는 방법 등의 개발자 정보도 있다.

'''참고:''' 스팸을 차단하기 위해 계정을 만들어서 이 위키를 편집해야 한다. 계정을 만들어야 하는 것이 번거롭지만 스팸 유포자도 마찬가지이다. 

Feel free to register as a user and contribute to our documentation effort.

Current [[Releases|awesome releases]]:
* Stable: [http://awesome.naquadah.org/download/ awesome {{stable-version}}].
* Development: Development versions of awesome can be downloaded as tarballs using [http://git.naquadah.org/?p=awesome.git;a=summary git snapshots].
* Screenshots: [[Screenshots]]

&lt;/div&gt;

== Documentation ==
[[Image:Stock book blue.png|left|Documentation]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Configuration and control of awesome have changed between major versions and may continue to evolve in future ones. Some of the following documents may try to describe all the existing versions. Please fix them if a missing version needs special explanations. Other documents may be bound to only one version of awesome. Please fix them if version indication is missing.

=== Installation &amp; Basics For Users ===
* [[FAQ]] - Check here first if you're having problems!
* [[Building awesome]] - Instructions for building / installing awesome.
* [[awesome 3 configuration]] - Get help understanding awesome 3 configuration and API basics.
* [[acc|awesome 2.X to 3.X]] Awesome Configuration Converter
* [[awesome 3.0 to 3.1]] config options that changed between the releases
* [[awesome 3.3 to 3.4]] configuration changes to the 3.4 version
* [[awesome 3.4 to git master]] configuration changes to the latest development release (in progress)
* [[Quickly Setting up Awesome with Gnome]] - How to make awesome be used in your gnome session with a couple of commands.
* [[KDE and awesome]]
* [[My first awesome]] Tutorial for new users and beginners

=== Development Basics ===
* [[Using Xephyr]]
* [[Debugging]]
* [[Signals]]

=== Reviews &amp; News ===
* [http://www.penguinsightings.org/desktop/awesome/ awesome 3 review on penguinsightings]

You might also want to join our IRC channel [irc://irc.oftc.net/awesome '''#awesome'''] on [http://www.oftc.net OFTC].
&lt;/div&gt;

== Customization ==
[[Image:Toolbox.png|left|Statusbars]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
=== Statusbars and widgets ===
&lt;/div&gt;
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
* [[Widgets in awesome]] - A brief guide on the implementation of widgets within awesome.
* [[Vicious]] - How to use the vicious widget library to add dynamic widgets.
* [[Obvious]] - How to use the Obvious repo (Widgets with community support).
* [[User Contributed Widgets]]
* [[Using Cairo within Awesome]]
* [[Titlebar and Statusbar height]] - Small how-to that helps you customize statusbar and titlebar height.
* [[Bashets]] - Small Lua library to empower you to use your existing shellscripts as content providers for widgets.
* [[Launcher auto-hiding]] - Hide a launcher when the application is running

=== Theming awesome ===
* [[Beautiful|Theming with Beautiful]] - How to theme your awesome-3 with the beautiful library.
* [[Beautiful themes|User Contributed Themes]] - Several awesome themes for use with beautiful.
* [[Customizing Fonts]] - How to add new fonts to your system.
* [[Nice Icons]] - Where to find nice icons to use in your widgets.

=== User configuration files ===
Examples of [[User_Configuration_Files|other users' configuration files]].

=== Other tips ===
* [[Autostart]] - Small function providing autostart functionality for awesome.
* [[Autostop]]  - Simple method to execute a program on quitting awesome.
* [[Understanding Rules]] - Describes Awesome's awful.rules facility for applying modifications to selected windows.
* [[NASA IOTD_Wallpaper]] - Use NASA's &quot;Image of the day&quot; as wallpaper using feh
* [[Run or raise]] - Run a client, or pop to it if it is already running.
* [[Revelation]] - Implementing [http://en.wikipedia.org/wiki/Exposé_(Mac_OS_X) Mac OS X Exposé] in awesome.
* [[Global Keybindings]] - Create global keybindings in awesome.
* [[Document keybindings]] - Add documentation to each keybinding and display an &quot;help&quot; panel
* [[Gradient]] - Visual feedback on numerical data (e.g. processor usage).
* [[Problems with Java]] - What to do if your java apps look grey.
* [[Symbolic tag names]] - How to make your tags have that mysterious symbolic look.
* [[XRandR Screen Table]] - If you don't like using numbers for screens.
* [[Move Mouse]] - Move the mouse from the centre of the screen for mouseless working.
* [[Dbus, naughty and logs]] - Display colorized notifications of your logs.
* [[Naughty log watcher]] - Native implementation (no shell scripts/dbus required).
* [[Using Xephyr]] - How to run nested X sessions - good for testing new builds of awesome or different config files.
* [[Using Multiple Screens]] - How to setup X with multiple screens/monitors for use with awesome.
* [[FullScreens|Fullscreens on Multiple Screens]] - How to span a client on multiple screens/monitors with a key
* [[nm-applet]] - How to setup nm-applet to start automatically in awesome.
* [[Mcabber notifications]] - Cool notifications for mcabber via naughty.
* [[Drop-down terminal]] - Toggle a video game-like console on the top of your screen like Yakuake/Tilda.
* [[Scratchpad manager]] - Basic scratchpad manager for the awesome window manager.
* [[WMII-like tag management]] - Mimic WMII's way of tag managment.
* [[Video wallpaper]] - Play a video for your wallpaper using mplayer.
* [[Transparency]] - Transparent windows using xcompmgr.
* [[Coverart display]] - Display Cover Art for current mpd song.
* [[urxvt tips|Urxvt tips]] - Tips for using rxvt-unicode with awesome.
* [[irssi tips|Irssi tips]] - Tips for using Irssi with awesome.
* [[IM tips]] - Tips for using instant messaging clients with awesome.
* [[Remove icons]] - How to remove icons from the tasklist and show only current client.
* [[Custom Prompts]] - Customized prompts you can use with awful's prompt.
* [[Using dmenu]] - Altering the color scheme, integrating with beautiful, and Run or Raise.
* [[Run commands in background]] - Run shell-commands in background (without hanging awesome!) and returns it's output. 

* [[ShutdownDialog|Shutdown dialog]] - A simple dialog to shutdown/reboot/suspend/lock screen.
* [[Tree File Menu]] - Python script to generate a tree file menu.
* [[Cycling Random Wallpaper Or Xscreensaver]] - Cycle you background to a random picture or Xscreensaver after a random delay
* [[Blinking text]] - Blinking the text on textbox widget
* [[RPN Calculator]] - RPN calculator
* [[Modal Keybindings]]
* [[Shared tags]] share tagset for multiple screens
* [[Move Window to Workspace Left/Right]] - A function for moving a window one workspace to the left or right.
* [[Move Client to Monitor Left/Right]] - How to move client to a specific direction when using more than two monitors.
* [[Move Client to a specific Monitor]] - How to move a client to a specific monitor.
* [[Move Focus to a specific Monitor]] - How to move the curser/focus to a specific monitor.
* [[Better Font Rendering]]
* [[Disable startup-notification globally]] - If you are annoyed by the stopwatch/busy mouse cursor.
* [[Keeping multitags persistent]] - If you want to able to quickly jump back to a multitag configuration
* [[Conky bar]] - A statusbar-like Conky configuration which is not overlapped by windows
* [[Workaround plugins that steal the keyboard focus]] - This has been a known bug in Firefox for over 10 years.
* [[MPD information with mpdcron]]
* [[Autostart with consolekit]] - Using awesome menu to restart/shutdown/hibernate/suspend your computer
&lt;/div&gt;

== Lua extensions ==
[[Image:Lua.jpg|left|Lua extensions]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Lua is a fast, light-weight, embeddable scripting language. Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping. 

Common uses of Lua are:
* A configuration language for applications.
* A standalone scripting language.
* An embedded language in applications to modify runtime behaviour.

To get introduced into Lua, please read [[The_briefest_introduction_to_Lua | the briefest introduction to Lua]]. For deeper knowledge please read this [http://lua-users.org/wiki/LuaTutorial tutorial] for the newcomers to the language. As a suggestion, please consider to get this [http://lua-users.org/wiki/LuaShortReference Lua Short Reference]. The Awesome framework is built with Lua as the extension language. Some of all extensions can be seen below: 

* [http://awesome.naquadah.org/doc/api/ awful] - the standard awesome Lua library.
* [[awful.menu|awful.menu]] - a popup menu library.
* [[Beautiful|Beautiful]] - a theming library.
* [[Obvious|Obvious]] - a new implementation of a widget library made since Wicked.
* [[Vicious|Vicious]] - a modular widget library derived from Wicked.
* [[Space Invaders|Space Invaders]] - allows you to play Space Invaders with Awesome
* [[Naughty|Naughty]] - a popup notification library
* [[Shifty|Shifty]] - dynamic tagging library with advanced client matching and sane configuration
* [[Eminent|Eminent]] - effortless wmii-style dynamic tagging library that does not require any rc.lua changes
* [[Rodentbane|Rodentbane]] - a library for rapid control of the mouse cursor using just the keyboard
* [[Flaw|Flaw]] - an object oriented library to manage widgets.
* [[couth|couth]] - yet another extension library -- includes visual popup notifications for alsa and mpd volume.
&lt;/div&gt;

== More ==
[[Image:Stock_help_blue.png|left|More]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Most people these days are used to having a more complete desktop. This section includes links to various apps that are lightweight and useful from within awesome to fill the gaps between just a window manager and a full-blown desktop environment like KDE or GNOME.

* [[Customizing GTK Apps]] - How to use themes without gnome-settings-daemon.
* [[Terminals]] - Replacements for desktop environment terminals.
* [[File Managers]] - Lightweight stand-alone File Managers.
* [[Automounting]] - A replacement for &quot;gnome-volume-manager&quot;, &quot;thunar-volman&quot;, etc.
* [[Xscreensaver]] - Locking the screen; replacement for gnome-screensaver, etc.
* [[Calendars]] - calendars and agenda solutions (text, graphical, interactive, ...)
* [[PowerManagement]] - A replacement for gnome-power-manager or kpowersave
&lt;/div&gt;</text>
      <sha1>nrnlhlia6zw44lorvbg5xfsvbtuwcde</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main Page/ru</title>
    <ns>0</ns>
    <id>451</id>
    <revision>
      <id>7386</id>
      <parentid>7356</parentid>
      <timestamp>2015-11-10T16:27:15Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>update link for github</comment>
      <text xml:space="preserve" bytes="31949">{{DISPLAYTITLE:Главная страница}}
{{Template:Languages|Main Page}}


{| align=&quot;right&quot;
  | __TOC__
  |}

[[Image:Aw 64.png|left|Awesome]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;

Цель этой wiki - предоставить составляемую сообществом документацию, и в особенности помочь начинающим пользователям с настройкой Awesome. Здесь также есть сведения для разработчиков, включающие информацию о том, как скомпилировать Awesome в различных дистрибутивах, как производить отладку, и так далее.

'''Замечание:''' Из-за наплыва спамеров для редактирования страниц необходимо создать учетную запись. Хотя это требование может показаться раздражающим, спам раздражает не в меньшей степени.

Не стесняйтесь регистрироваться и вносить свой вклад в документацию.

Текущие [[Releases|версии Awesome]]:
* Стабильная: [http://awesome.naquadah.org/download/ awesome {{stable-version}}].
* В разработке: Архивы с версиями, находящимися в разработке, можно скачать с Git или виде архива с [https://github.com/awesomeWM/awesome Github]
* Скриншоты: [[Screenshots/ru|Скриншоты]]

&lt;/div&gt;

== Документация ==
[[Image:Stock book blue.png|left|Документация]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Настройки Awesome изменялись между основными версиями и в дальнейшем могут развиваться. Некоторые из приведенных документов пытаются охватить все существующие версии. Пожалуйста, внесите исправления, если для какой-то из них требуются дополнительные объяснения. Другие документы могут относиться только к определённой версии Awesome. Пожалуйста, исправьте их, если версия не указана.

=== Установка и базовая настройка ===
* [[Awesome 3.x/ru|Awesome 3.x]] - Manpage и клавиатурные сочетания.
* [http://www.cheatography.com/fievel/cheat-sheets/awesome-window-manager-3-x/ Таблица клавиатурных сочетаний Awesome 3.x]
* [[FAQ/ru|Часто задаваемые вопросы]] - Если возникли какие-то проблемы, для начала посмотрите здесь!
* [[Building awesome|Сборка Awesome]] - Инструкции по сборке / установке Awesome.
* [[Awesome_3_configuration/ru|Настройка Awesome 3]] - Помощь по настройке Awesome 3 и основам API.
* [[acc/ru|acc]] - Конвертирование конфигурационного файла Awesome 2.X в Awesome 3.X.
* [[Awesome 3.0 to 3.1/ru | Переход с 3.0 на 3.1]] - Параметры конфигурации, изменившиеся между версиями.
* [[Awesome 3.3 to 3.4 | Переход с 3.3 на 3.4 ]] - Изменения в версии 3.4.
* [[Awesome 3.4 to 3.5/ru | Переход с 3.4 на 3.5]] - Изменения в версии 3.5
* [[Quickly Setting up Awesome with Gnome/ru | Быстрая настройка Awesome в Gnome]] - Как использовать Awesome внутри сессии gnome с помощью нескольких команд.
* [[KDE and awesome/ru | KDE и Awesome]]
* [[My first awesome/ru | Мой первый awesome]]

===Разбираем Awesome===
* [[Layout/ru|Layout]]- схемы, пояснения
* [[Tags Description/ru|Теги]] - Описание и настройка тегов
* [[Tasklist_Description/ru|Панель задач]] - Описание и настройка панели задач
* [[Using DBus/ru | Использование D-Bus]] - Использование D-Bus  для взаимодействия со скриптами и приложениями
* [[Some problems/ru | Известные проблемы]]

=== Основы разработки ===
* [[Using Xephyr/ru | Использование Xephyr]]
* [[Debugging | Отладка]]
* [[Signals/ru | Сигналы]]
* [[keycodes | Коды клавиш]]
* [[Development Environment with Xephyr and GNU Make | Окружение разработчика Xephyr и GNU Make]]

=== Переводы ===
Некоторые части документации были переведены на различные языки. Переведённые документы могут содержать дополнительную информацию, относящуюся к языку или странам.

'''ЗАМЕЧАНИЕ:''' После ознакомления со страницей перевода, ''рекомендуется'' ознакомится с англоязычным оригиналом, т.к. с момента перевода в него могут быть внесены изменения, и часть статьи или кода может устареть.

Если для страницы доступен перевод, в её верхней части отображается врезка. Вот пример со страницы [[FAQ/ru|Часто задаваемые вопросы]]:
{{Languages|FAQ}}

Также Вы можете присоединится к нашему IRC каналу [irc://irc.oftc.net/awesome '''#awesome'''] на [http://www.oftc.net OFTC].

=== Русскоязычные сообщества ===
* [http://www.odnoklassniki.ru/group/52383642419266 Одноклассники]
* [http://vk.com/awesome_wm Контакт]
* [https://www.linux.org.ru/tag/awesome LOR] - linux.org.ru
* [http://habrahabr.ru/search/?q=awesome+wm Habrahabr] - Статьи по Awesome на хабре
&lt;/div&gt;

== Настройка ==
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
=== Панели и виджеты ===
&lt;/div&gt;
[[Image:Toolbox.png|left|Панели]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
* [[User Contributed Widgets|Виджеты от пользователей awesome]] - English
* [[Widget Layouts/ru|Widget_Layouts]] - схемы для виджетов
* [[Widgets in awesome/ru|Виджеты в Awesome]] - Краткое руководство по созданию виджетов в Awesome.
* [[Vicious/ru|Vicious]] - Как добавлять динамические виджеты, используя библиотеку vicious.
* [[Wicked|Виджеты Wicked]] - Как добавлять динамические виджеты, используя библиотеку wicked. Библиотека считается устаревшей, сейчас используется Vicious.
* [[Obvious/ru|Obvious]] - Как использовать репозиторий Obvious (виджеты, поддерживаемые сообществом).
* [[Using Cairo within Awesome|Использование Cairo в Awesome]]
* [[Titlebar and Statusbar height/ru|Высота заголовков и панелей]] - Маленькое how-to, которое поможет настроить высоту заголовков окон и панелей.
* [[Bashets/ru|Bashets]] - Маленькая библиотека Lua, облегчающая использование ваших shell скриптов и передачу данных из них вашим виджетам.
* [[Launcher auto-hiding/ru|Автоскрытие launcher]] - Автоматическое скрытие лаунчера при запуске приложения.
* [[Lain/ru|Lain]] - Расширяет возможности настройки и удобства использования.

=== Использование тем ===
* [[Beautiful themes/ru|Темы от пользователей Awesome]] - Несколько тем Awesome для использования с библиотекой beautiful.
* [[Beautiful themes|Темы от пользователей Awesome]] - English
* [[Beautiful/ru|Темы Beautiful]] - Как настроить тему Вашего Awesome-3 при помощи библиотеки beautiful.
* [[Customizing Fonts/ru|Настройка шрифтов]] - Как добавить новые шрифты в систему.
* [[Nice Icons/ru|Значки]] - Где найти хорошие значки для Ваших виджетов.
* [[Picturesque]] - Автоматическая смена обоев. В данный момент не работает, требуется переработка.

=== Пользовательские конфигурационные файлы ===
* Примеры конфигурационных файлов пользователей Awesome можно найти [[User_Configuration_Files/ru|здесь]].
* Примеры [[User_Configuration_Files|других конфигурационные файлы]]. - English
* [https://github.com/copycat-killer/awesome-copycats awesome-copycats]

=== Прочие советы ===
* [[Autostart/ru|Автозапуск]] - Маленькая функция для автоматического запуска программ в Awesome.
* [[Autostop/ru|Autostop]]  - Простой метод выполнения программ при завершении awesome.
* [[Keyboard layouts with kbdd/ru|Раскладка клавиатуры]] - виджет раскладки клавиатуры с использованием kbdd и D-Bus
* [[Understanding Rules/ru|Разбираем правила(rules)]] - Описывается awful.rules - способы настройки и управления окнами.
* [[NASA IOTD_Wallpaper/ru|Обои &quot;Изображение дня NASA&quot;]] - Использования &quot;Изображение дня NASA&quot; как обоев (требуется feh)
* [[Run or raise/ru|Запуск или переключение]] - Запуск приложения или переключение на него, если оно уже запущено.
* [[Revelation/ru|Revelation]] - Реализация [http://en.wikipedia.org/wiki/Exposé_(Mac_OS_X) Mac OS X Exposé] в Awesome.
* [[Document keybindings/ru|Документирование клавиатурных сочетаний]] - Добавляем документацию для каждого сочетания клавиш и отображаем его в панели помощи
* [[Keybindings and numeric pad/ru|Клавиатурные сочетания и цифровая клавиатура]] - Использование цифровой клавиатуры для переключения тегов и отображения связнных с ними меню
* [[Gradient/ru|Градиент]] - Визуализация числовых данных (например, использования процессора).
* [[Problems with Java|Проблемы с Java]] - Что делать, если Java-приложения отображаются в виде серых прямоугольников.
* [[Symbolic tag names/ru|Символические названия тегов]] - Изменения названия тегов на мистический символический вид.
* [[XRandR Screen Table/ru|Таблица экранов XRandR]] - Если Вам не нравится использовать числа для обозначения экрана.
* [[Move Mouse/ru|Перемещение курсора]] - Как убрать курсор мыши с центра экрана, если Вы пользуетесь только клавиатурой.
* [[Dbus, naughty and logs/ru|Dbus, naughty и логи]] - Показ цветных уведомлений об изменениях в журналах.
* [[Naughty log watcher/ru|Наблюдатель логов Naughty]] - Реализация слежения за журналами средствами Awesome (без shell-скриптов и dbus).
* [[Using Xephyr/ru|Использование Xephyr]] - Как запускать вложенные X-сессии - отличное решение для тестирования новых сборок Awesome или различных конфигурационных файлов.
* [[Using redshift with awesome/ru|Redshift]] - Интеграция Redshift с Awesome для регулировки цветовой температуры экрана.
* [[nm-applet/ru|Nm-applet]] - Как настроить автоматический запуск nm-applet в Awesome.
* [[Mcabber notifications|Уведомления Mcabber]] - Классные уведомления для mcabber с использованием  naughty.
* [[Drop-down terminal/ru|Выпадающий терминал]] - Выпадающий терминал наподобие Yakuake/Tilda на Вашем рабочем столе.
* [[Scratchpad manager/ru|Scratchpad manager]] - Менеджер scratchpad для оконного менеджера Awesome.
* [[WMII-like tag management/ru|Управление тегами в стиле WMII]] - имитация управления тегами, реализованного в WMII.
* [[Video wallpaper/ru|Видеообои]] - Воспроизведение видео в качестве фонового рисунка, используя mplayer.
* [[Transparency/ru|Прозрачность]] - Прозрачные окна, используя xcompmgr.
* [[Minitray/ru|Minitray]] - Позовляет включать и выключать отображение трея.
* [[Coverart display/ru|Отображение обложки песни]] - Отображение обложки для текущей песни при использовании mpd.
* [[urxvt tips/ru|Советы Urxvt]] - Советы по использованию rxvt-unicode в awesome.
* [[irssi tips/ru|Советы по irssi]] - Здесь можно найти несколько советов по использованию irssi в Awesome.
* [[IM tips/ru|Советы по использованию месенджеров]] - Здесь собраны советы по использованию различных IM в Awesome.
* [[Remove icons/ru|Удаление иконок]] - Как удалить иконки из списка задач, оставив только текущее приложение.
* [[Using dmenu/ru|Использование dmenu]] - Использование цветовых схем, интегрирование в beautiful, и Run or Raise.
* [[Run commands in background/ru|Запуск команд в фоне]] - Запуск shell скриптов в фоне (без загрузки awesome!) и возвратом результата.
* [[ShutdownDialog/ru|Диалог выключения]] - Простой диалог для выключения/перезагузки/спящего режима/блокировки экрана.
* [[Tree File Menu/ru|Меню &quot;Файловое дерево&quot;]] - Скрипт для создания меню файлового дерева.
* [[Cycling Random Wallpaper Or Xscreensaver/ru|Случайные обои или Скринсейвер]] - Периодическая замена фона или запуск Xscreensaver через определенный промежуток.
* [[Blinking text/ru|Мигающий текст]] - Реализация мигающего текста на текстовом виджете.
* [[RPN Calculator/ru|RPN калькулятор]] - калькулято RPN (Reverse Polish Notation)
* [[Modal Keybindings/ru|&quot;Модальные&quot; сочетания клавиш]] - Настройка действия клавиш в зависимости от режима
* [[Better Font Rendering/ru|Улучшаем рендеринг шрифтов]]
* [[Disable startup-notification globally/ru|Глобальное отключение уведомлений запуска]] - Если вас раздражает заторможенный/занятый курсор мыши.
* [[Keeping multitags persistent/ru|Сохранение мультитегового состояния]] - Позволяет вам запомнить мультитеговое отображение, и переключаться между тегами с сохранением этого состояния.
* [[Conky bar/ru|Панель Conky]] - Конфигурация Conky в стиле строки состояния, которая не перекрывается окнами
* [[Conky HUD/ru|Conky HUD]] - Неперекрываемая конфигурая для Conky
* [[Workaround plugins that steal the keyboard focus/ru|Обход плагинов перехватывающих клавиатурный ввод]] - Это известный баг/особенность, существующий в Firefox более 10 лет.
* [[MPD information with mpdcron/ru|Отображение информации MPD с помощью mpdcron]] - позволяет вывести информацию о треке используя mpdcron
* [[Autostart with consolekit]] - Использование меню awesome для restart/shutdown/hibernate/suspend вашего компьютера.
* [[Vmware/ru|Vmware]] - Awesome и приложение vmware
* [[Systray Hide/Show/ru|Отображение/скрытие системного трея]] - Как добавить сочетание клавиш для переключения видимости системного трея.
* [[TranslateIt/ru|Перевод текста]] - позволяет перевести выделенный текст.
* [[HelpPopup/ru|Справочная информация]] - позволяет выводить всплывающее уведомление с подсказкой.
* [[Disable DPMS/ru|Отключаем DPMS]] - отключаем авто отключение экрана для полноэкранных приложений
* [[How to add awesome to gdm3|Добавляем Awesome в GDM]] - Объясняется как добавить awesome WM в список оконных менеджеров в gdm
* [[How to take ScreenShot with PrntScr key|Делаем скриншоты используя PrntScr]] - как делать скриншоты используя PrntScr
* [[SpeakerWidget]] - Виджет громкости с класными иконками.
* [[Move all clients to another tag ]] Перемещение всех приложения с текущего тега на другой.

====Пользовательские приглашения (prompts)====
* [[Custom Prompts]] - Английская версия всех пользовательских приглашений
* [[SSH: prompt]] - Приглашение для подключения по SSH с автозавершением имён хостов, похожее на стандартное приглашение для запуска программ.
* [[Lua prompt improvements/ru|Улучшенное приглашение Lua prompt]] - Автозавершение и усовершенствованная функция eval.
* [[Kooky wikipedia completion/ru|Автозавершение для Wikipedia]] - Приглашение для поиска статьи в Wikipedia с автозавершением названий.
* [[Kooky geo|Geo Prompt]] - Приглашение для вычисления расстояния между двумя положениями.
* [[Anrxcs Manual Prompt/ru | Просмотр man-страниц]] - Приглашение для просмотра man-страниц в Вашем любимом приложении.
* [[Anrxcs WebSearch Prompt/ru | Web-поиск]] - Приглашение для поиска в сети Интернет, позволяющее использовать &lt;b&gt;любую&lt;/b&gt; поисковую систему.
* [[Anrxcs Calculator Prompt/ru | Калькулятор]] - Простое приглашение-калькулятор, использующее  xmessage/Naughty для вывода результатов.
* [[Identica Prompt/ru| Identi.ca Prompt]] - Отправка твитов непосредственно из WM.
* [[Launch In Terminal Keyword/ru|Запуск в терминале используя ключевое слово]] - Строка запуска позволяет испльзовать &quot;:&quot; для запуска команды в терминале.
* [[Run in Terminal/ru|Запуск команды в терминалеl]] - Mod-Shift-r служит для выполения команды в терминале
* [[Google Translate/ru|Перевод текста]] - Использование Google Translate для перевода текста.

====Работа с несколькими экранами (screens)====
* [[Using Multiple Screens/ru|Использование нескольких экранов]] - Как настроить X для использования нескольких экранов в Awesome.
* [[FullScreens/ru|Fullscreens на несколько экранов]] - Как растянуть приложение на несколько экранов/мониторов
* [[Shared tags/ru|Объединение тегов]] - описывается реализация объединения тегов с разных экранов в единую систему
* [[Move Window to Workspace Left/Right/ru|Переключение окна на другое рабочее пространстов]] - Функция переключения окна на соседний экран, влево или вправо.
* [[Move Client to Monitor Left/Right/ru|Перемещение приложения на другой монитор]] - Как перенести приложение экран влево или вправо при использовании 2х и более экранов.
* [[Move Client to a specific Monitor/ru|Перемещение приложения на заданный монитор]] - Как переместить приложение на заданный экран (если их более 2х).
* [[Move Focus to a specific Monitor/ru|Передача фокуса на определенный экран]] - Как передать курсор/фокус ввода на заданный монитор.
* [[Libreoffice Multi-monitor/ru|Libreoffice Multi-monitor]] - Настройка Libreoffice для корректной работы с несколькими мониторами.

&lt;/div&gt;

== Расширения Lua ==
[[Image:Lua.jpg|left|Lua extensions]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Lua - это быстрый, легковесный, встраиваемый скриптовый язык. Lua сочетает простой процедурный синтаксис с мощными конструкциями для описания данных, основанными на ассоциативных массивах, и расширяемой семантикой. Lua имеет динамическую типизацию и автоматическое управление памятью с помощью инкрементного сборщика мусора; программы на Lua компилируются в байт-код, исполняемый на регистровой виртуальной машине. Всё это делает Lua идеальным для использования в конфигурационных файлах программ, скриптах и для быстрого создания прототипов. 

Обычно Lua используется:
* В качестве языка для настройки приложений.
* Как отдельный скриптовый язык.
* Как язык, встраиваемый в приложения для управления ими во время выполнения.

Для того, чтобы начать изучение Lua прочтите [[The_briefest_introduction_to_Lua | краткое введение в Lua]]. Для более глубокого изучения с Lua прочитайте это [http://lua-users.org/wiki/LuaTutorial руководство] для начинающих. Также советуем почитать [http://lua-users.org/wiki/LuaShortReference Краткое руководство по Lua]. Также есть руководство на русском, но только по [http://www.lua.ru/doc/ версии 5.1] и очень краткое руководство для тех кто знает другие языки программирования и хочет узнать, что такое Lua [http://zserge.wordpress.com/2012/02/23/lua-%D0%B7%D0%B0-60-%D0%BC%D0%B8%D0%BD%D1%83%D1%82/ Lua за 60минут]. Awesome использует Lua в качестве языка для расширения функциональности. Ниже перечислены некоторые из доступных расширений: 

* [http://awesome.naquadah.org/doc/api/ awful] - стандартная библиотека Awesome, написанная на Lua.
* [[Understanding Rules/ru|awfu.rules]] - библиотека реализующая правила работы с клиентами
* [[awful.menu/ru|awful.menu]] - библиотека, реализующая всплывающее меню.
* [[Beautiful/ru|Beautiful]] - библиотека, реализующая поддержку тем.
* [[Wicked|Wicked]] - библиотека динамических виджетов. Считается устаревшей.
* [[Obvious/ru|Obvious]] - новая реализация библиотеки виджетов, созданная после Wicked.
* [[Vicious/ru|Vicious]] - Модульная библиотека виджетов, происходящая от Wicked.
* [[Bashets/ru|Bashets]] - Маленькая библиотека Lua, облегчающая использование ваших shell скриптов и передачу данных из них вашим виджетам.
* [[Space Invaders/ru|Space Invaders]] - позволяет играть в Space Invaders прямо в Awesome.
* [[Naughty/ru|Naughty]] - библиотека всплывающих уведомлений.
* [[Rodentbane/ru|Rodentbane]] - библиотека для управления курсором мыши с клавиатуры.
* [https://github.com/Elv13/collision Collision] - Мощный клавиатурно-ориентированный модуль навигации и изменения размеров с визуальной индикацией и обратной связью
* [[Radical/ru|Radical]] - Мощная и расширяемя система меню
* [[Flaw/ru|Flaw]] - Объектно-ориентированная библиотека для управления виджетами.
* [[couth/ru|Couth]] - еще одна библиотека расширений -- включающая всплывающие(popup) уведомления для alsa и mpd.
* [[keychains/ru|Keychains]] - Использование связки клавиш в awesome
* [[Hints/ru|Hints]] - Оконные подсказки для фокусировки на окне
* [[Vain/ru|Vain]] - Альтернативная система схем(layout)
* [[Lain/ru|Lain]] - Расширяет возможности настройки и удобства использования, является наследником Vain, для версии Awesome 3.5
* [[Blingbling/ru|Blingbling]] - Красивый набор виджетов, основанный на Cairo
* [https://raw.github.com/gvalkov/dotfiles-awesome/master/ezconfig.lua ezconfig] - Клавиатурные сочетания в стиле Emacs для Awesome (например &lt;code&gt;'M-S-a'&lt;/code&gt; вместо &lt;code&gt;awful.key({modkey, 'Shift'}, 'a'&lt;/code&gt;)
* [https://github.com/svexican/cheeky cheeky] - Простой type-ahead переключатель окон (использующий родные меню приложений)	
* [https://github.com/sirkha/keyjoy keyjoy] - Изменение свойств мыши и клавиатуры для отдельного приложения используя правила.
* [https://github.com/Elv13/retrograde Retrograde] - Система управления виджетами в Awesome 3.5+, так как это было реализовано в Awesome 3.2-3.4
* [https://github.com/Elv13/repetitive Repetitive] - Запись и выполнение макросов.
* &lt;b&gt;Динамические теги&lt;/b&gt;
** [[Shifty/ru|Shifty]] - простая в настройке библиотека для динамического присваивания тегов приложениям.
** [https://github.com/Elv13/tyrannical Tyrannical] - Конфигурационная система для awful определяющая динамические теги и приложения(духовный наследник Shifty)
** [[Eminent/ru|Eminent]] - Легкая библиотека динамических тегов(wmii подобная), не требующая каких либо изменений в rc.lua
&lt;/div&gt;

== Дополнительно ==
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
На сегодняшний день большинство людей привыкли к более полным рабочим столам. Этот раздел включает ссылки на различные легковесные и полезные приложения, которые можно запускать в Awesome, чтобы уменьшить разрыв между простым оконным менеджером и полнофункциональным окружением, таким как KDE или GNOME.

* [[Customizing GTK Apps/ru|Настройка GTK-приложений]] - Как использовать темы без gnome-settings-daemon.
* [[Terminals/ru|Эмуляторы терминала]] - Эмуляторы терминала, не зависящие от окружения рабочего стола.
* [[File Managers/ru|Файловые менеджеры]] - Легковесные файловые менеджеры.
* [[Automounting/ru|Автомонтирование]] - Замена &quot;gnome-volume-manager&quot;, &quot;thunar-volman&quot;, и т.д.
* [[Xscreensaver/ru|Блокировка экана]] - замена для gnome-screensaver, и прочих.
* [[Calendars/ru|Календари]] - Календари и решения для повестки дня (текстовые, графические, интерактивные, ...)
* [[PowerManagement|Управление питанием]] - Замена gnome-power-manager или kpowersave
&lt;/div&gt;</text>
      <sha1>4kqrugrozdumfzv331qwug1mt0gh06o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main Page/zh</title>
    <ns>0</ns>
    <id>631</id>
    <revision>
      <id>4717</id>
      <parentid>4716</parentid>
      <timestamp>2011-01-28T13:23:56Z</timestamp>
      <contributor>
        <username>Dpzhang314</username>
        <id>562</id>
      </contributor>
      <text xml:space="preserve" bytes="8023">{{DISPLAYTITLE: (简体中文)}}
{{Languages|Main Page}}


{| align=&quot;right&quot;
  | __TOC__
  |}

[[Image:Aw 64.png|left|awesome]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;

本维基页面旨在提供一份社区文档，尤其是帮助新用户配置awesome。与此同时我们也为老手提供也有用的信息，包括数个linux发行版下 awesome 的编译，调试等。

'''注意:'''为了避免有人蓄意散播无用信息，故约定在编辑本页前请先注册。因为对于那些人来说，注册帐号是一个令人生厌的事。

欢迎注册并为awesome文档做贡献。

当前 [[Releases|awesome 发行版]]:
* 稳定版: [http://awesome.naquadah.org/download/ awesome {{stable-version}}].
* 开发版: 请点击下载使用awesome开发版的压缩包 [http://git.naquadah.org/?p=awesome.git;a=summary git snapshots].
* 快照: [[Screenshots]]

&lt;/div&gt;

== 文 档 ==
[[Image:Stock book blue.png|left|Documentation]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
本版Awesome的配置和操控已经发生有所改变，并且在不久的未来可能继续变更。但下面的文档会尽量的适用所有当前的版本。如果你恰巧遇到它没有涵盖的请尽量的完善它们。同时如果你发现需要特殊的说明的细节问题也可以顺便补上； 还有一些文档可能只是针对awesome的某一个版本有效，你可以对它的文档进行扩展编辑。 

=== 安装 &amp; 用户基础 ===
* [[FAQ]] - 常见的问题集!
* [[Building awesome]]   -编译安装awesome
* [[awesome 3 configuration]]  -awesome 3 配置和基本的API接口
* [[acc|awesome 2.X to 3.X]]   -Awesome配置升级 
* [[awesome 3.0 to 3.1]]  -3.0到3.1版中配置的改变
* [[awesome 3.3 to 3.4]]  -3.4版本中配置的改变
* [[Quickly Setting up Awesome with Gnome]]  -在gnome-session中用awesome的命令
* [[KDE and awesome]]  -KDE与Awesome
* [[awesome-menu basics]]  -Awesome菜单入门
* [[My first awesome]]  -新手入门参考 

=== 开发基础 ===
* [[Using Xephyr]]  -使用Xephyr测试wm
* [[Debugging]]  -调试相关
* [[Signals]]  

=== 历史&amp;新闻 ===
* [http://www.penguinsightings.org/desktop/awesome/ awesome 3 review on penguinsightings]

你也可以加入我们的IRC频道 [irc://irc.oftc.net/awesome '''#awesome'''] 在 [http://www.oftc.net OFTC]. 
&lt;/div&gt;

== 个性设置 ==
[[Image:Toolbox.png|left|Statusbars]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
=== Statusbars and widgets ===
&lt;/div&gt;
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
* [[Widgets in awesome]] - Awesome中widgets组件应用简介。 
* [[Vicious]] - Vicious动态插件库。
* [[Obvious]] - Obvious插件源（有社区支持）。
* [[User Contributed Widgets]] 
* [[Using Cairo within Awesome]]  在Awesome中使用Cairo。
* [[Titlebar and Statusbar height]] - 状态栏和标题栏的设置。
* [[Bashets]] - 在widgets组件中添加Lua库并用它调用本地shell脚本。

=== awesome 主题 ===
* [[Beautiful|Theming with Beautiful]] - Awesome中应用beautiful库美化主题。
* [[Beautiful themes|User Contributed Themes]] - 一些基于beautiful的awesome主题。
* [[Customizing Fonts]] - 为awesome添加新字体。
* [[Nice Icons]] - 为新组件件添加漂亮的图标。

=== 用户配置文件 ===
实例参考 [[User_Configuration_Files|配置文件]].

=== 更多小贴示 ===
* [[Autostart]] - 在Awesome启动时设置自动运行启动的程序。
* [[Autostop]]  -在Awesome退出时设置你想运行的程序。
* [[Run or raise]] - Run a client, or pop to it if it is already running.
* [[Revelation]] - Implementing [http://en.wikipedia.org/wiki/Exposé_(Mac_OS_X) Mac OS X Exposé] in awesome.
* [[Gradient]]  -色彩渐变vs数字变化(显示cpu温度和利用率)
* [[Problems with Java]]  -调整java应用程序的外观
* [[Symbolic tag names]]  -为标签添加“另类”的符号标示
* [[XRandR Screen Table]]  -不喜欢用数字标示屏幕的请进
* [[Move Mouse]] - 抛弃鼠标，吾乃键盘控。
* [[Dbus, naughty and logs]]   -让你的日志文件色彩斑斓
* [[Naughty log watcher]]  -日志监视模块（非shell，纯Lua脚本）
* [[Using Xephyr]]  -运行嵌套的X-server：为疯狂测试不同品质WindowsManager而生
* [[Using Multiple Screens]]  -让你的awesome支持多屏幕，多显示器显示。
* [[nm-applet]]  -Awesome网络连接设置。
* [[Mcabber notifications]] - Cool notifications for mcabber via naughty.
* [[Drop-down terminal]]  -Toggle a video game-like console on the top of your screen like Yakuake/Tilda.
* [[Scratchpad manager]] - Basic scratchpad manager for the awesome window manager.
* [[WMII-like tag management]] - Mimic WMII's way of tag managment.
* [[Video wallpaper]] - 动态视频背景
* [[Transparency]]  -xcompmgr：灰常给力的半透明效果
* [[Coverart display]] - Display Cover Art for current mpd song.
* [[urxvt tips|Urxvt tips]]  -urxvt-unicode配置文件小贴士。
* [[irssi tips|Irssi tips]] - Irssi使用小贴士。
* [[IM tips]]  -使用即时聊天程序的注意事项。
* [[Remove icons]] - How to remove icons from the tasklist and show only current client.
* [[Custom Prompts]] - Customized prompts you can use with awful's prompt.
* [[Using dmenu]] - Use dmenu(with wmii colourscheme) instead of the default run prompt.
* [[Using dmenu to switch]] - 使用dmenu切换窗口
* [[ShutdownDialog|Shutdown dialog]]  -交互式关机，重启，挂机，锁屏对话框。
* [[Tree File Menu]] - Python一个树式文件菜单
* [[Cycling Random Wallpaper Or Xscreensaver]] - 随机图片背景与屏保。
* [[Blinking text]] - Blinking the text on textbox widget
* [[RPN Calculator]] - RPN calculator
&lt;/div&gt;

== Lua 扩展集 ==
[[Image:Lua.jpg|left|Lua extensions]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Lua是一个精悍的可嵌入脚本语言。 Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping. 

常用功能如下：
* 应用程序的配置文件.
* 独立运行的脚本语言.
* 作为嵌入式语言即时整程序的运行行为.

若有人对Lua有兴趣，请参阅[http://lua-users.org/wiki/LuaTutorial 文本教程]。同时作为建议，请不妨阅读一下[http://lua-users.org/wiki/LuaShortReference Lua简短参引]。Awesome的框架就是采用Lua语言扩展构建的。下面是Lua在Awesome中的具体应用: 

* [http://awesome.naquadah.org/doc/api/ awful] - Awesome的标准库文件.
* [[awful.menu|awful.menu]] - 弹出菜单库
* [[Beautiful|Beautiful]] - 主题相关库
* [[Obvious|Obvious]] - 基于Wicked而来的较新的插件组合
* [[Vicious|Vicious]] - 模块化的插件，来自Wicked的分支
* [[Space Invaders|Space Invaders]] - 在Awesome中玩“太空入侵者”小游戏
* [[Naughty|Naughty]] - 弹出式提示栏
* [[Shifty|Shifty]] - dynamic tagging library with advanced client matching and sane configuration
* [[Eminent|Eminent]] - effortless wmii-style dynamic tagging library that does not require any rc.lua changes
* [[Rodentbane|Rodentbane]] - a library for rapid control of the mouse cursor using just the keyboard
&lt;/div&gt;

== 更多 ==
[[Image:Stock_help_blue.png|left|More]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
现在的许多朋友更倾向工作与相对完整的桌面环境，在这部分所包括多种链接，这些链接能在不同的程度上能丰富Awesome的功能，能让Awesome在轻量高效的窗口管理器和功能成熟的桌面环境（如KDE和GNOME）间游刃有余。

* [[Customizing GTK Apps]] - 不装gnome-settings-daemon也能用GTK主题.
* [[Terminals]] - 不同的终端，不同的享受.
* [[File Managers]] - 独立的文件管理器.
* [[Automounting]] - &quot;gnome-volume-manager&quot;, &quot;thunar-volman&quot;, 等自动挂载的相关内容
* [[Xscreensaver]] - 屏保的设定
&lt;/div&gt;</text>
      <sha1>g1am3hfflbkn449detg0oetp9kzmzas</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main page/zh-hans</title>
    <ns>0</ns>
    <id>501</id>
    <revision>
      <id>4178</id>
      <parentid>3761</parentid>
      <timestamp>2010-04-06T19:04:07Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>/* 其他技巧 */ Remove redlink</comment>
      <text xml:space="preserve" bytes="8395">{{DISPLAYTITLE:首页}}
{{Languages|Main Page}}

{| align=&quot;right&quot;
  | __TOC__
  |}

[[Image:Aw 64.png|left|awesome]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;

本维基的目标是提供一份由社区自助的文档，尤其是帮助新用户使用和配置 awesome。我们在这里也有开发人员感兴趣的内容，包括如何编译 awesome (若干相关的分发行版)、如何调试、等等。

'''注意:''' 由于垃圾信息制造者 (spammers) 的存在，您必须先创建一个账号然后才能编辑页面。非要创建一个账号才能编辑虽然很麻烦，但是这样能有效避免垃圾信息。

请您放心的注册账号，帮助我们完善文档。

当前 [[Releases|awesome 版本列表]]:
* 稳定: [http://awesome.naquadah.org/download/ awesome 3.4].
* 开发: awesome 开发版本的档案包可以从这里下载 [http://git.naquadah.org/?p=awesome.git;a=summary git snapshots].
* 截图: [[截图]]

&lt;/div&gt;

== Documentation ==
[[Image:Stock book blue.png|left|Documentation]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Configuration and control of awesome have changed between major versions and may as well continue to evolve in future ones. 下列文档中的某些可能适用于所有版本。但如果其中某些只针对一个特定版本的文档遗漏了相应的版本号，请指正它们。

=== 安装 &amp; 基础 ===
* [[FAQ/zh-hans|常见问题]] - 如果您有问题，请先浏览这里。
* [[Building awesome/zh-hans|编译 Awesome]] - 介绍了如何编译 / 安装 awesome。
* [[awesome 3 configuration/zh-hans|Awesome 3 配置文件]] - 帮您理解 awesome 3 的配置文件和基础 API。
* [[acc|awesome 2.X to 3.X]] Awesome 配置文件格式转换器 (只限于 2.x 升级至 3.x)
* [[awesome 3.0 to 3.1]] 升级过程中需要注意的配置文件的变化。
* [[awesome 3.3 to 3.4]] 升级过程中需要注意的配置文件的变化。
* [[Quickly Setting up Awesome with Gnome/zh-hans|GNOME 和 Awesome]] - 怎样通过一组命令让 awesome 和您的 gnome 会话协同工作。
* [[KDE and awesome/zh-hans|KDE 和 Awesome]]
* [[man pages]]
* [[awesome-menu basics]]

=== 开发的基础 ===
* [[Using Xephyr]]
* [[Debugging]]

=== 翻译 ===
一部分文档已经被翻译成不同的语言。被翻译的文档中可以包含和本国语言相关的附加信息。

如果某个页面被翻译过，在它的上方会显示一条可用的语言列表。例如[[FAQ/zh-hans|常见问题]]页面中的可用语言列表:
{{Languages|FAQ}}

=== 评论 &amp; 新闻 ===
* [http://www.penguinsightings.org/desktop/awesome/ awesome 3 review on penguinsightings]
&lt;/div&gt;

== 定制 ==
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
=== 状态栏和零件 ===
&lt;/div&gt;
[[Image:Toolbox.png|left|Statusbars]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
* [[Widgets in awesome]] - 在 awesome 中安装和使用零件的指南。
* [[Vicious]] - 如何使用 vicious 开发库添加动态零件。
* [[Obvious]] - 如何使用 Obvious 仓库 (由社区支持)。
* [[User Contributed Widgets]]
* [[Using Cairo within Awesome]]
* [[Titlebar and Statusbar height]] - 如何调节状态栏和标题栏高度。
* [[Bashets]] - 让您将 shell 脚本作为零件内容的提供者。

=== 主题 ===
* [[Beautiful|Theming with Beautiful]] - 如何通过 beautiful 开发库设置您 Awesome-3 的主题。
* [[Beautiful themes|User Contributed Themes]] - 若干采用 beautiful 的 Awesome 主题。
* [[Customizing Fonts]] - 如何向您的系统添加新字体。
* [[Nice Icons]] - 在哪里能找到用于您的零件的漂亮图标。

=== 用户配置文件 ===
用户配置文件的示例在[[User_Configuration_Files|这里]]。

=== 其他技巧 ===
* [[irssi tips]] - 在 awesome 里使用 irssi 的一些技巧。
* [[Autostart]] - Small function providing autostart functionality for awesome.
* [[Run or raise]] - Run a client, or pop to it if it is already running.
* [[Revelation]] - Implementing [http://en.wikipedia.org/wiki/Exposé_(Mac_OS_X) Mac OS X Exposé] in awesome.
* [[Gradient]] - Visual feedback on numerical data (e.g. processor usage).
* [[Problems with Java]] - What to do if your java apps look grey.
* [[XRandR Screen Table]] - If you don't like using numbers for screens.
* [[Move Mouse]] - Move the mouse from the centre of the screen for mouseless working.
* [[Dbus, naughty and logs]] - Display colorized notifications of your logs.
* [[Naughty log watcher]] - Native implementation (no shell scripts/dbus required).
* [[Using Xephyr]] - How to run nested X sessions - good for testing new builds of awesome or different config files.
* [[Using Multiple Screens]] - How to setup X with multiple screens/monitors for use with awesome.
* [[nm-applet]] - How to setup nm-applet to start automatically in awesome.
* [[Mcabber notifications]] - Cool notifications for mcabber via naughty
* [[Drop-down terminal]] - Toggle a video game-like console on the top of your screen like Yakuake/Tilda.
* [[Scratchpad manager]] - Basic scratchpad manager for the awesome window manager.
* [[WMII-like tag management]] - mimic WMII's way of tag managment
* [[urxvt tips]] - See here for some awesome urxvt tips.
* &lt;b&gt;Custom Prompts&lt;/b&gt; - User contributed run prompts
** [[SSH: prompt]] - Statusbar ssh prompt similar to Run: prompt with hostname completion.
** [[Lua prompt improvements|Improving the Lua prompt]] - Completion and a more useful eval for the Lua prompt.
** [[Kooky wikipedia completion|Wikipedia Completion]] - Wikipedia prompt with article completion.
** [[Kooky geo|Geo Prompt]] - Prompt for calculating the distance between two locations.
** [[Anrxcs Manual Prompt | Manual Pages Prompt]] - Prompt for reading manual pages in your favorite application.
** [[Anrxcs WebSearch Prompt | Web Search Prompt]] - Prompt for searching the web, giving you acess to &lt;b&gt;any&lt;/b&gt; search form.
** [[Anrxcs Calculator Prompt | Calculator Prompt]] - Simple calculator prompt utilizing xmessage to display results.
** [[Identica Prompt | Identi.ca Prompt]] - Post dents/tweets directly from the wm.
&lt;/div&gt;

== Lua 扩展 ==
[[Image:Lua.jpg|left|Lua extensions]]
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
LUA程序设计语言是一个简洁、轻量、可扩展的脚本语言。Lua combines simple procedural syntax with powerful data description constructs based on associative arrays and extensible semantics. Lua is dynamically typed, runs by interpreting bytecode for a register-based virtual machine, and has automatic memory management with incremental garbage collection, making it ideal for configuration, scripting, and rapid prototyping. 

Common uses of Lua are:
* A configuration language for applications.
* A standalone scripting language.
* An embedded language in applications to modify runtime behaviour.

To get introduced into Lua, please read this [http://lua-users.org/wiki/LuaTutorial tutorial] for the newcomers to the language. As a suggestion, please consider to get this [http://lua-users.org/wiki/LuaShortReference Lua Short Reference]. The Awesome framework is build with Lua as the extension language. Some of all extensions can be see below: 

* [http://awesome.naquadah.org/doc/api/ awful] - the standard awesome Lua library.
* [[awful.menu|awful.menu]] - a popup menu library.
* [[Beautiful|Beautiful]] - a theming library.
* [[Obvious|Obvious]] - a new implementation of a widget library made since Wicked.
* [[Vicious|Vicious]] - a modular widget library derived from Wicked.
* [[Space Invaders|Space Invaders]] - allows you to play Space Invaders with Awesome
* [[Naughty|Naughty]] - a popup notification library
* [[Shifty|Shifty]] - dynamic tagging library with advanced client matching and sane configuration
* [[Rodentbane|Rodentbane]] - a library for rapid control of the mouse cursor using just the keyboard
&lt;/div&gt;

== More ==
&lt;div style=&quot;margin-left: 70px;&quot;&gt;
Most people these days are used to having a more complete desktop. This section includes links to various apps that are lightweight and useful from within awesome to fill the gaps between just a window manager and a full-blown desktop environment like KDE or GNOME.

* [[Customizing GTK Apps]] - How to use themes without gnome-settings-daemon.
* [[Terminals]] - Replacements for desktop environment terminals.
* [[File Managers]] - Lightweight stand-alone File Managers.
* [[Automounting]] - A replacement for &quot;gnome-volume-manager&quot;, &quot;thunar-volman&quot;, etc.
&lt;/div&gt;</text>
      <sha1>gw47h3tjue4nogqxz7p3rp3spstods3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Main page/zh CN</title>
    <ns>0</ns>
    <id>502</id>
    <redirect title="Main page/zh-hans" />
    <revision>
      <id>3760</id>
      <timestamp>2009-11-06T16:58:41Z</timestamp>
      <contributor>
        <username>S5unty</username>
        <id>244</id>
      </contributor>
      <comment>moved [[Main page/zh CN]] to [[Main page/zh-hans]]</comment>
      <text xml:space="preserve" bytes="31">#REDIRECT [[Main page/zh-hans]]</text>
      <sha1>g374u9wfom0qori6q04or5rjrcxwu7g</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Making a Status Bar</title>
    <ns>0</ns>
    <id>4</id>
    <revision>
      <id>1277</id>
      <timestamp>2008-10-16T14:57:03Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="2096">&lt;h1 style=&quot;color:red;&quot;&gt;WARNING! this page is outdated!&lt;/h1&gt;
'''How to get a status bar, instead of the default &quot;awesome ver# / name&quot;.'''

First, create a file with the name awesome-status and place it where you want to, this will be used to output the information we want to the awesome client.

Next, copy &quot;awesome-client&quot; to /usr/local/bin. If you can't find it, enter the following in a terminal:
 $ updatedb
 $ locate awesome-client
''(Note: If you do not have an awesome-client you will have to compile it from source!)''

So, now we have &quot;awesome-client&quot; residing in /usr/local/bin. Next, we need to make awesome-status executable.
 $ chmod a+x /path/to/awesome-status

Now add
 /path/to/awesome-status | /usr/local/bin/awesome-client &amp;
to ~/.xinitrc before &quot;exec awesome&quot;.


All that remains is to place items into the status bar. Below is a possible format of &quot;awesome-status&quot;, as well as a few examples of what to place in it.


 #!/bin/bash
 delim=&quot; | &quot;;
 printStatusInfo() 
 {	
     /bin/echo &quot;0 setstatustext ${item1}TEXT${delim}${item2}TEXT${delim}&quot;;
     # if you do not use xinerama, the next 3 lines are obsolete
     if [ &quot;x$XINERAMA&quot; = &quot;xYES&quot; ]; then
     /bin/echo &quot;1 setstatustext ${item1}TEXT${delim}${item2}TEXT${delim}&quot;;
     fi
 }
 #close printStatusInfo()
 while true; do
     printStatusInfo
     sleep 5;
 done

Here are a few examples of what to put in place of &quot;item1&quot;, &quot;item2&quot;, etc.

Date and time:
 ctime=`date '+%a, %d %b %H:%M'`;
With this, &quot;awesome-status&quot; would now be modified such:

 #!/bin/bash
 delim=&quot; | &quot;;
 printStatusInfo() 
 {	
     ctime=`date '+%a, %d %b %H:%M'`;
     /bin/echo &quot;0 setstatustext Today's date and the current time: ${ctime}${delim}${item2}text${delim}&quot;;
     # if you do not use xinerama, the next 3 lines are obsolete
     if [ &quot;x$XINERAMA&quot; = &quot;xYES&quot; ]; then
     /bin/echo &quot;1 setstatustext Today's date and the current time: ${ctime}${delim}${item2}text${delim}&quot;;
     fi
 }#close printStatusInfo()
 while true; do
     printStatusInfo | /usr/local/bin/awesome-client
     sleep 5;
 done

[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>g88wd5cwvpigecyewtn4bc9nqmvgns9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Making a Status Bar (Lua script)</title>
    <ns>0</ns>
    <id>40</id>
    <revision>
      <id>1278</id>
      <timestamp>2008-10-16T14:57:29Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1301">'''How to get a status bar (lua or awk)'''

Another setup might work like this:

in the ~/.xinitrc file:

awesome-status &amp;

what calls this:

 [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status ~/bin/awesome-status]

It waits until awesome has started and calls this lua script:

 [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status.lua ~/bin/awesome-status.lua]

Just in case, I used to use this awk program:

 [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status.awk ~/bin/awesome-status.awk]

(Attention: you may need to tune the output to your desire - my awesome is the latest git)

If you want to add items/or improve things, you may send them to the awesome mailing list, add it to the wiki, or send it to mac at calmar.ws  so that I can add it.

You may need to fine tune some function to match your system.

A single script in a single language (whatever...), is much nicer to the resources, at least compared to a bash-script.

An example configuration in the ~/.awesomerc might look like:
[[http://www.calmar.ws/awesome/awesome-toolbar.png]]

The script matches this awesomerc file (what also has some patched changes you need to correct (e.g. awesome -k):

 [http://www.calmar.ws/dotfiles/dotfiledir/dot_awesomerc ~/.awesomerc]

[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>e810hoon3o9nzz1jtfhasma6tbdmnsc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Making a Status Bar II</title>
    <ns>0</ns>
    <id>9</id>
    <revision>
      <id>1281</id>
      <timestamp>2008-10-16T14:58:34Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1287">'''How to get a status bar (lua or awk)'''

Another setup might work like this:

in the ~/.xinitrc file:

awesome-status &amp;

what calls this:

 [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status ~/bin/awesome-status]

It waits until awesome has started and calls this lua script:

 [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status.lua ~/bin/awesome-status.lua]

I used to use this awk program:

 [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status.awk ~/bin/awesome-status.awk]

(Attention: you may need to tune the output to your desire - my awesome is the latest git)

If you want to add items/or improve things, you may send them to the awesome mailing list, add it to the wiki, or send it to mac at calmar.ws  so that I can add it.

You may need to fine tune some function to match your system.

A single script in a single language (whatever...), is much nicer to the resources, at least compared to a bash-script.

An example configuration in the ~/.awesomerc might look like:
[[http://www.calmar.ws/awesome/awesome-toolbar.png]]

The script matches this awesomerc file (what also has some patched changes you need to correct (e.g. awesome -k):

 [http://www.calmar.ws/dotfiles/dotfiledir/dot_awesomerc ~/.awesomerc]

[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>0mzpikkk7qjnnhewy3101coe2fl0i71</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Making a Status Bar III</title>
    <ns>0</ns>
    <id>11</id>
    <revision>
      <id>1280</id>
      <timestamp>2008-10-16T14:58:24Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1896">Next one setup for status bar.

What we need:
::conky
::awesome
::mpd

First step is installing conky, after that you have to create ~/.conkyrc.
My .conkyrc is here, but you can put one of other conky functions [http://conky.sourceforge.net/variables.html [1] ], it's great and simple way to get full information about system in status bar.


background yes&lt;br&gt;
no_buffers yes&lt;br&gt;
out_to_console yes&lt;br&gt;
update_interval 1 &lt;br&gt;
uppercase no&lt;br&gt;
use_spacer no&lt;br&gt;
total_run_times 0&lt;br&gt;
TEXT&lt;br&gt;
0 widget_tell tb ${time %H:%M:%S %A %d.%m.%y} | CPU: ${cpu} | net: ${downspeedf eth0}/${upspeedf eth0} | disk: ${fs_free /}/${fs_free /home} &lt;br&gt;
0 widget_tell tb1 $mpd_status $mpd_artist - $mpd_title&lt;br&gt;


Next step, editing .awesomerc. In section statusbar {} add something like this (icons and mpc commands are optional, i'm using mpd ). The textbox should have tag same as those one in conkyrc.
If you want to change design of statusbar messages you should edit conkyrc.



 textbox tb1
   { width = &quot;250&quot; }
   iconbox mpc_prev
   {
        image = &quot;/home/czarnas/.awesome/icons/prev.png&quot;
        mouse {
        button = &quot;1&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec mpc prev&quot;
        }
    }
    iconbox mpc_toggle
    {
        image = &quot;/home/czarnas/.awesome/icons/toggleplay.png&quot;
        mouse {
        button = &quot;1&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec mpc toggle&quot;
        }
    }
    iconbox mpc_next
    {
        image = &quot;/home/czarnas/.awesome/icons/next.png&quot;
        mouse {
        button = &quot;1&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec mpc next&quot;
        }
    }
   textbox tb
   {}




Last step, starting conky with awesome. In ~/.xinitrc add line (before exec awesome). It should looks like this:

exec conky &amp;
 
It's simple and easy way to get awesome statusbar, with many different functions.. Thanks to sec_ for help.

[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>4mq47w20qwzljdjtkwy466jcyr7ttb3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Making a Status Bar IV</title>
    <ns>0</ns>
    <id>27</id>
    <revision>
      <id>1279</id>
      <timestamp>2008-10-16T14:58:10Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="2699">After getting frustrated with conky and awesome-client in [[Making a Status Bar III]], I wrote the following using ruby.  

As an aside, to get conky working: 
* pull conky's source
* recompile without X11 support
...or, you can just read [[Making a Status Bar V]]


Anyway...


== Modify your ~/.awesomerc ==

&lt;pre&gt;
    statusbar &quot;bottom&quot; {
        position = &quot;bottom&quot;
        height = 0
        width = 0

        textbox clock {
            text_align = &quot;left&quot;
            align = &quot;left&quot;
            width = 100
        }

        textbox mpdstatus {
            text_align=&quot;right&quot;
            align=&quot;right&quot;
        }

        textbox song {
            text_align=&quot;right&quot;
            align=&quot;right&quot;
        }

        textbox time {
            text_align=&quot;right&quot;
            align=&quot;right&quot;
        }
    }
&lt;/pre&gt;

== Create an &quot;awesome-status&quot; ==
You'll need the following if you don't have it already:
* ruby
* rubygems
* librmpd
&lt;pre&gt;
#!/usr/bin/env ruby
require 'rubygems'
require 'librmpd'
require 'date'

class MyClient
    Pipe = '/usr/bin/awesome-client'
    
    def writeDate
        date = DateTime::now
        writePipe(&quot;clock&quot;, date.strftime('%a %e %b %Y %H:%M'))
    end

    def state_callback(newstate)
        writePipe(&quot;mpdstatus&quot;, &quot;#{newstate} | &quot;)
    end

    def song_callback(newsong) 
        song = &quot;#{newsong.artist} | #{newsong.album} | #{newsong.title}&quot;
        writePipe(&quot;song&quot;, song) 
    end

    def time_callback(elapsed, total) 
        time = &quot; | #{formatSeconds(elapsed)} | #{formatSeconds(total)}&quot;
        writePipe(&quot;time&quot;, time)
    end

private
    def writePipe(widget, status)

        # This was annoying -- I finally figured out I needed a newline to ensure the status was updated
        toWrite = &quot;0 widget_tell #{widget} #{status}\n&quot;  
        pipe = IO.popen(Pipe, &quot;w&quot;)
        pipe.write(toWrite)
        pipe.close
    end

    def formatSeconds(time) 
        minutes = time / 60
        seconds = time % 60
        return &quot;%02d:%02d&quot; % [ minutes, seconds ]
    end
end


client = MyClient.new

# If you restart awesome, you lose some info until a &quot;current song&quot; event is fired.
mpd = MPD.new 'localhost', 6600
mpd.register_callback(client.method('state_callback'), MPD::STATE_CALLBACK)
mpd.register_callback(client.method('song_callback'), MPD::CURRENT_SONG_CALLBACK)
mpd.register_callback(client.method('time_callback'), MPD::TIME_CALLBACK)

mpd.connect(true)


while true do
    client.writeDate
    sleep 1
end

&lt;/pre&gt;

== Apply the proper permissions to &quot;awesome-status&quot; ==
&lt;pre&gt;
$ chmod 755 awesome-status
&lt;/pre&gt;

== Modify your ~/.xinitrc ==
&lt;pre&gt;
awesome-status &amp;
exec awesome
&lt;/pre&gt;

Enjoy!

[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>irtxi8zpz46ozrqn154g41fiwdpagu2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Making a Status Bar V</title>
    <ns>0</ns>
    <id>31</id>
    <revision>
      <id>1337</id>
      <timestamp>2008-10-19T15:45:21Z</timestamp>
      <contributor>
        <username>Cibervicho</username>
        <id>157</id>
      </contributor>
      <comment>New version of conky in Debian</comment>
      <text xml:space="preserve" bytes="4764">= Use the Source, Luke =
Ok, here's how to get conky working with awesome.

This is what I did on my system (debian lenny/sid) and it works!

== Get the Source ==
* Get the source archive from Conky's [http://conky.sourceforge.net/  SourceForge] site

== Modify the Source ==
* Edit conky.c using your editor of choice
* Find this block (line numbers are for reference only):
&lt;pre&gt;
5800:	if (out_to_console) {
5801:		printf(&quot;%s\n&quot;, s);
5802:		fflush(stdout);   /* output immediately, don't buffer */
5803:	}
&lt;/pre&gt;
* Modify this line:
&lt;pre&gt;5801:		printf(&quot;%s\n&quot;, s);&lt;/pre&gt;
to read:
&lt;pre&gt;5801:		printf(&quot;%s\n\n&quot;, s); //Note the extra newline!&lt;/pre&gt;
* Save it

=== Alternate Patch ===
* Add the following block to the end of conky.c:draw_text()
&lt;pre&gt;
    if (out_to_console) {
        printf(&quot;\n&quot;);
        fflush(stdout);
    }
&lt;/pre&gt;

== Compile the Source ==
* Configure your newly modified conky:
&lt;pre&gt;
$ ./configure --disable-x11
&lt;/pre&gt;
* Compile it:
&lt;pre&gt;
$ make
&lt;/pre&gt;
* Install it:
&lt;pre&gt;
$ sudo make install
&lt;/pre&gt;

== Use Your Newly Compiled Conky ==
* Edit ~/.awesomerc, and add the following:  
&lt;pre&gt;
statusbar &quot;bottom&quot; {
    position = &quot;bottom&quot;
    height = 18
    width = 0
    textbox cpulabel {
    }
    graph cpugraph {
        data {
            max = 100.0
            style = &quot;bottom&quot;
            fg = &quot;#006e96&quot;
        }
        bg = &quot;#000000&quot;
        width = 100
        align = &quot;left&quot;
    }
}
&lt;/pre&gt;
* Create/Edit ~/.conkyrc:
&lt;pre&gt;
background no
no_buffers yes
out_to_console yes
update_interval 1 
uppercase no
use_spacer no
total_run_times 0
TEXT
0 widget_tell cpulabel cpu:
0 widget_tell cpugraph ${cpu cpu0}
&lt;/pre&gt;
* Edit ~/.xinitrc:
&lt;pre&gt;
conky | awesome-client &amp;
exec awesome
&lt;/pre&gt;
* Restart and enjoy!

--[[User:Cciulla|Cciulla]] 02:54, 4 March 2008 (CET)
[[Category:StatusBars]]


== Debian package ==


Download a debian package of the patched (working) conky 1.5.1 [http://liksom.info/conky_1.5.1-1_i386.deb here], tested with current 32bit i386 etch, lenny and sid, just download and do the usual

&lt;pre&gt;
wget http://liksom.info/conky_1.5.1-1_i386.deb
sudo dpkg -i conky_1.5.1-1_i386.deb
&lt;/pre&gt;

--[[User:Snauth|Snauth]] 09:46, 2 May 2008 (UTC)

Now Lenny has conky 1.6.0 and sid version 1.6.1-1. To patch the current version of Debian install devscripts and fakeroot, add the appropriate deb-src to /etc/apt/sources.list and follow this steps (tested with Sid):

&lt;pre&gt;
apt-get source conky
sudo aptitude build-dep conky
cd conky-1.6.1
patch -p1
--- a/debian/rules    2008-10-19 17:13:03.000000000 +0200
+++ b/debian/rules  2008-10-19 17:09:52.701443644 +0200
@@ -52,7 +52,7 @@
 	  --host=$(DEB_HOST_GNU_TYPE) --build=$(DEB_BUILD_GNU_TYPE) \
 	  --prefix=/usr --sysconfdir=/etc \
 	  --mandir=\$${prefix}/share/man --infodir=\$${prefix}/share/info \
-	  --enable-debug --enable-rss $(EXTRA_CONF_ARGS)
+	  --enable-debug --enable-rss --disable-x11 $(EXTRA_CONF_ARGS)
 	
 	touch debian/configure-stamp
 
^D
cat &gt;debian/patches/conky_in_awesome
--- a/src/conky.c     2008-08-14 19:10:43.000000000 +0200
+++ b/src/conky.c   2008-10-19 17:10:03.702070526 +0200
@@ -6672,7 +6672,7 @@
 
 	width_of_s = get_string_width(s);
 	if ((output_methods &amp; TO_STDOUT) &amp;&amp; draw_mode == FG) {
-		printf(&quot;%s\n&quot;, s);
+		printf(&quot;%s\n\n&quot;, s);
 		fflush(stdout);	/* output immediately, don't buffer */
 	}
 	memset(tmpstring1, 0, text_buffer_size);
^D
echo conky_in_awesome &gt;&gt; debian/patches/series
dch -l awesome &quot;Patched to work with awesome&quot;
dpkg-buildpackage
sudo debi
&lt;/pre&gt;

^D means &quot;Hit control+D&quot;. Currently, I don't have a place to upload the final conky_1.6.1-1awesome1_i386.deb, so you have to manually apply this steps. If somebody can upload it somewhere, we could change this manual thing to something similar to what Snauth described.

--[[User:Cibervicho|Vicho]] 15:34, 19 October 2008 (UTC)

== Using an init script ==

I want to run &quot;conky | awesome-client&quot; with more control over the process(es) (for some reason they zombify when my pc hibernates) therefore I start/stop it with this init script:

&lt;pre&gt;
#! /bin/sh

PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
DAEMON=/usr/local/bin/conky.sh
NAME=conky
DESC=conky
USER=your_user_name

#test -x $DAEMON || exit 0

set -e

case &quot;$1&quot; in
  start)
        echo -n &quot;Starting $DESC: &quot;
        start-stop-daemon --background --start --chuid $USER --exec $DAEMON
        ;;      
  stop)
        echo -n &quot;Stopping $DESC: &quot;
        kill `ps uxc -A | grep -i $NAME | awk '{print $2}'`
        ;;
esac

exit 0
&lt;/pre&gt;

This calls this little shell script conky.sh (necessary to force start-stop-daemon to redirect to awesome-client):

&lt;pre&gt;
#!/bin/sh
exec /usr/local/bin/conky | /usr/bin/awesome-client
&lt;/pre&gt;
--[[User:Snauth|Snauth]] 09:46, 2 May 2008 (UTC)
[[Category:awesome2]]</text>
      <sha1>ke8d38oid9tnplmtrkzkusykhp2re56</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Man pages/ru</title>
    <ns>0</ns>
    <id>1028</id>
    <revision>
      <id>6389</id>
      <timestamp>2014-04-30T15:09:05Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{Languages|Man pages}}  &lt;H1&gt;AWESOME&lt;/H1&gt;    &lt;H2&gt;NAME&lt;/H2&gt;        awesome - тайловый оконный менеджер  &lt;H2&gt;СИНОПСИС&lt;/H2&gt;        &lt;B&gt;awesome&lt;/B&gt; [...&quot;</comment>
      <text xml:space="preserve" bytes="9258">{{Languages|Man pages}}

&lt;H1&gt;AWESOME&lt;/H1&gt;



&lt;H2&gt;NAME&lt;/H2&gt;
       awesome - тайловый оконный менеджер

&lt;H2&gt;СИНОПСИС&lt;/H2&gt;
       &lt;B&gt;awesome&lt;/B&gt; [&lt;B&gt;-v&lt;/B&gt; | &lt;B&gt;--version&lt;/B&gt;] [&lt;B&gt;-h&lt;/B&gt; | &lt;B&gt;--help&lt;/B&gt;] [&lt;B&gt;-c&lt;/B&gt; | &lt;B&gt;--config&lt;/B&gt; &lt;I&gt;FILE&lt;/I&gt;] [&lt;B&gt;-k&lt;/B&gt; | &lt;B&gt;--check&lt;/B&gt;]

&lt;H2&gt;ОПИСАНИЕ&lt;/H2&gt;
       &lt;b&gt;awesome&lt;/b&gt; — это оконный менеджер для X. Он управляет окнами, размещая их в соответствии с разными
       схемами (layout), такими как плавающая (floating) или мозаичная (tiled). Любая схема может быть
       применена динамически, оптимально подстраивая рабочую среду под текущую выполняемую задачу и
       приложение.

       В мозаичной схеме окна размещаются в двух зонах: главная и стековая. В главной зоне размещаются
       окна, которые требуют основного внимания, а в стековой — все остальные. В плавающей схеме окна
       можно свободно перемещать и изменять их размер. Диалоговые окна всегда отображаются в плавающем
       режиме, вне зависимости от текущей выбранной схемы. Спиральная и уменьшающая схемы являются
       исключениями: окна в стековой зоне в этих схемах размещаются по спирали для первой, и в виде
       фрактала квадратов для второй.

       Окна в awesome сгруппированы по тегам. Каждое окно может быть помечено одним или несколькими
       тегами. Можно выбрать один или несколько тегов, чтобы увидеть окна с этими тегами.

       В &lt;b&gt;awesome&lt;/b&gt; можно создавать вибоксы (виджет + бокс), в которых можно отображать всё, что вы
       хотите: все имеющиеся теги, текущая выбранная схема, заголовки видимых окон, произвольный текст
       и т. д.

&lt;H2&gt;ОПЦИИ&lt;/H2&gt;
       &lt;b&gt;-v, --version&lt;/b&gt;
           Показать информацию о версии на стандартный вывод и выйти.

       &lt;b&gt;-h, --help&lt;/b&gt;
           Показать справку и выйти.

       &lt;b&gt;-c, --config FILE&lt;/b&gt;
           Использовать альтернативный конфигурационный файл вместо $XDG_CONFIG_HOME/awesome/rc.lua.

       &lt;b&gt;-k, --check&lt;/b&gt;
           Проверить синтаксис конфигурационного файла.

       &lt;b&gt;-a, --no-argb&lt;/b&gt;
           Не использовать ARGB.

&lt;h2&gt;НАСТРОЙКИ МЫШИ ПО-УМОЛЧАНИЮ&lt;/h2&gt;
   &lt;h3&gt;Навигация&lt;/h3&gt;
       &lt;b&gt;Button1&lt;/b&gt; на имени тега
           Выбрать тег для отображения.

       &lt;b&gt;Button4, Button5&lt;/b&gt; на имени тега
           Выбрать предыдущий или следующий тег.

       &lt;b&gt;Button4, Button5&lt;/b&gt; на корневом окне
           Выбрать предыдущий или следующий тег.

       &lt;b&gt;Button1, Button3, Button4, Button5&lt;/b&gt; на значке схемы
           Переключиться на предыдущую или следующую схему.

   &lt;h3&gt;Изменение схемы&lt;/h3&gt;
       &lt;b&gt;Mod4 + Button1&lt;/b&gt; на имени тега
           Пометить текущий клиент только этим тегом.

       &lt;b&gt;Mod4 + Button3&lt;/b&gt; на имени тега
           Пометить текущий клиент этим тегом, либо убрать пометку этим тегом.

       &lt;b&gt;Button3&lt;/b&gt; на имени тега
           Добавить текущий тег для просмотра.

       &lt;b&gt;Mod4 + Button1&lt;/b&gt; на окне клиента
           Переместить окно.

       &lt;b&gt;Mod4 + Button3&lt;/b&gt; на окне клиента
           Изменить размер окна.

&lt;h2&gt;НАСТРОЙКИ КЛАВИАТУРЫ ПО-УМОЛЧАНИЮ&lt;/h2&gt;
   &lt;h3&gt;Управление менеджером окон&lt;/h3&gt;
       &lt;b&gt;Mod4 + Control + r&lt;/b&gt;
           Перезапустить awesome.

       &lt;b&gt;Mod4 + Shift + q&lt;/b&gt;
           Выйти из awesome.

       &lt;b&gt;Mod4 + r&lt;/b&gt;
           Открыть командную строку.

       &lt;b&gt;Mod4 + x&lt;/b&gt;
           Открыть командную строку для выполнения Lua-кода.

       &lt;b&gt;Mod4 + Return&lt;/b&gt;
           Запустить эмулятор терминала.

       &lt;b&gt;Mod4 + w&lt;/b&gt;
           Открыть главное меню.

   &lt;h3&gt;Клиенты&lt;/h3&gt;
       &lt;b&gt;Mod4 + m&lt;/b&gt;
           Развернуть на весь экран.

       &lt;b&gt;Mod4 + n&lt;/b&gt;
           Свернуть.

       &lt;b&gt;Mod4 + Control + n&lt;/b&gt;
           Восстановить.

       &lt;b&gt;Mod4 + f&lt;/b&gt;
           Полноэкранный режим.

       &lt;b&gt;Mod4 + Shift + c&lt;/b&gt;
           Убить выбранный клиент.

       &lt;b&gt;Mod4 + t&lt;/b&gt;
           Прикрепить поверх всех.

   &lt;h3&gt;Навигация&lt;/h3&gt;
       &lt;b&gt;Mod4 + j&lt;/b&gt;
           Следующий клиент.

       &lt;b&gt;Mod4 + k&lt;/b&gt;
           Предыдущий клиент.

       &lt;b&gt;Mod4 + u&lt;/b&gt;
           Первый клиент в режиме повышенного внимания (urgent).

       &lt;b&gt;Mod4 + Left&lt;/b&gt;
           Выбрать предыдущий тег.

       &lt;b&gt;Mod4 + Right&lt;/b&gt;
           Выбрать следующий тег.

       &lt;b&gt;Mod4 + 1-9&lt;/b&gt;
           Переключиться на тег по номеру (от 1 до 9).

       &lt;b&gt;Mod4 + Control + j&lt;/b&gt;
           Следующий экран.

       &lt;b&gt;Mod4 + Control + k&lt;/b&gt;
           Предыдущий экран.

       &lt;b&gt;Mod4 + Escape&lt;/b&gt;
           Выбрать предыдущий выбранный набор тегов.

   &lt;h3&gt;Изменение схемы&lt;/h3&gt;
       &lt;b&gt;Mod4 + Shift + j&lt;/b&gt;
           Поменять текущий и следующий за ним клиенты местами.

       &lt;b&gt;Mod4 + Shift + k&lt;/b&gt;
           Поменять текущий и предыдущий клиенты местами.

       &lt;b&gt;Mod4 + o&lt;/b&gt;
           Отправить клиент на следующий экран.

       &lt;b&gt;Mod4 + h&lt;/b&gt;
           Уменьшить главную зону на 5%.

       &lt;b&gt;Mod4 + l&lt;/b&gt;
           Увеличить главную зона на 5%.

       &lt;b&gt;Mod4 + Shift + h&lt;/b&gt;
           Увеличить число окон в главной зоне на 1.

       &lt;b&gt;Mod4 + Shift + l&lt;/b&gt;
           Уменьшить число окон в главной зоне на 1.

       &lt;b&gt;Mod4 + Control + h&lt;/b&gt;
           Увеличить число колонок для стековой зоны на 1.

       &lt;b&gt;Mod4 + Control + l&lt;/b&gt;
           Уменьшить число колонок для стековой зоны на 1.

       &lt;b&gt;Mod4 + space&lt;/b&gt;
           Выбрать следующую схему.

       &lt;b&gt;Mod4 + Shift + space&lt;/b&gt;
           Выбрать предыдущую схему.

       &lt;b&gt;Mod4 + Control + space&lt;/b&gt;
           Переключить плавающий режим для текущего клиента.

       &lt;b&gt;Mod4 + Control + Return&lt;/b&gt;
           Поменять текущий и главный клиенты местами.

       &lt;b&gt;Mod4 + Control + 1-9&lt;/b&gt;
           Включить/выключить тег по номеру.

       &lt;b&gt;Mod4 + Shift + 1-9&lt;/b&gt;
           Пометить клиента тегом по номеру.

       &lt;b&gt;Mod4 + Shift + Control + 1-9&lt;/b&gt;
           Пометить/снять пометку клиента тегом по номеру.

       &lt;b&gt;Mod4 + Shift + F1-9&lt;/b&gt;
           Пометить все отмеченные клиенты тегом по номеру.

&lt;h2&gt;НАСТРОЙКА&lt;/h2&gt;
       &lt;b&gt;awesome&lt;/b&gt; настраивается файлом $XDG_CONFIG_HOME/awesome/rc.lua (надо создать, если его нет).

&lt;h2&gt;СИГНАЛЫ&lt;/h2&gt;
       &lt;b&gt;awesome&lt;/b&gt; может быть перезапущен сигналом SIGHUP.

&lt;h2&gt;СМОТРИ ТАКЖЕ&lt;/h2&gt;
       awesomerc(5) awesome-client(1)

&lt;h2&gt;БАГИ&lt;/h2&gt;
       Само собой разумеется, что в awesome багов нет. Но могут встречаться ВНЕЗАПНОСТИ.

&lt;h2&gt;АВТОРЫ&lt;/h2&gt;
       Julien Danjou &lt;julien@danjou.info[1]&gt; и другие.

&lt;h2&gt;WWW&lt;/h2&gt;
       http://awesome.naquadah.org

[[Category:Awesome3]]</text>
      <sha1>rvrv9hfgu81nt4rt4gr1vm2853sekjf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Manual tiling</title>
    <ns>0</ns>
    <id>967</id>
    <revision>
      <id>6176</id>
      <parentid>6175</parentid>
      <timestamp>2013-12-06T17:47:05Z</timestamp>
      <contributor>
        <username>Zarkone</username>
        <id>3119</id>
      </contributor>
      <text xml:space="preserve" bytes="19">#REDIRECT Aero snap</text>
      <sha1>e1vrcp7jqgkrwbl1hwxu1qffyh4e9a4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Mcabber notifications</title>
    <ns>0</ns>
    <id>315</id>
    <revision>
      <id>5504</id>
      <parentid>5409</parentid>
      <timestamp>2012-06-08T13:40:24Z</timestamp>
      <contributor>
        <username>Karlh626</username>
        <id>466</id>
      </contributor>
      <minor/>
      <comment>/* Icons */</comment>
      <text xml:space="preserve" bytes="6545">Mcabber is a great console based xmpp client with e2e (pgp and otr). By default the only way to see that you got a new message is the urgent hint set by mcabber and shown by awesome if configured correctly. I used gajim before and liked the notifications via naughty. This text is about enhancing your mcabber and awesome to inform you about your latest chat messages and status changes of your contacts. So lets get naughty ;)

== mcabber configuration ==

mcabber has support for an external hook invoked if something happened. We use this for our notification.
The relevant parts are the following:

&lt;pre&gt;
set events_command = ~/.mcabber/event.sh
set events_ignore_active_window = 0
set event_log_files = 1
set event_log_dir = /tmp
&lt;/pre&gt;

As you can see we need a shellscript wrapper that pushes the bits to awesome.

~/.mcabber/event.sh
&lt;pre&gt;
#!/bin/sh
echo &quot;mcabber_event_hook('$1', '$2', '$3', '$4')&quot; | awesome-client
&lt;/pre&gt;

Just an information about security. The shellscript above can easily be exploited locally e.g.:
&lt;pre&gt;./event.sh &quot;');awful.util.spawn('xterm'); --&quot;&lt;/pre&gt;

However the data sent by mcabber cannot contain the tick char (') that would be needed for this exploit. The only possible data chunk may containing illegal data would be the node of the jid, but again the tick char is [http://xmpp.org/extensions/xep-0106.html#intro forbidden].

Anyway if you really dont trust incoming data you could replace the tick char everywhere with a sed command e.g.
&lt;pre&gt;echo &quot;mcabber_event_hook('`echo $1 | sed -e &quot;s/'/_/g&quot;`', ...&lt;/pre&gt;

== awesome configuration ==
Next you have to set up your rc.lua

First add the profiles for status changes
&lt;pre&gt;
naughty.config.presets.online = {
    bg = &quot;#1f880e80&quot;,
    fg = &quot;#ffffff&quot;,
}
naughty.config.presets.chat = naughty.config.presets.online
naughty.config.presets.away = {
    bg = &quot;#eb4b1380&quot;,
    fg = &quot;#ffffff&quot;,
}
naughty.config.presets.xa = {
    bg = &quot;#65000080&quot;,
    fg = &quot;#ffffff&quot;,
}
naughty.config.presets.dnd = {
    bg = &quot;#65340080&quot;,
    fg = &quot;#ffffff&quot;,
}
naughty.config.presets.invisible = {
    bg = &quot;#ffffff80&quot;,
    fg = &quot;#000000&quot;,
}
naughty.config.presets.offline = {
    bg = &quot;#64636380&quot;,
    fg = &quot;#ffffff&quot;,
}
naughty.config.presets.requested = naughty.config.presets.offline
naughty.config.presets.error = {
    bg = &quot;#ff000080&quot;,
    fg = &quot;#ffffff&quot;,
}
&lt;/pre&gt;

After that we add the function that handles the mcabber hook events.
You have to change the variable &quot;muc_nick&quot; if you want awesome to hide your own MUC messages but only incoming messages.

&lt;pre&gt;
muc_nick = &quot;your_muc_nickname&quot;

function mcabber_event_hook(kind, direction, jid, msg)
    if kind == &quot;MSG&quot; then
        if direction == &quot;IN&quot; or direction == &quot;MUC&quot; then
            local filehandle = io.open(msg)
            local txt = filehandle:read(&quot;*all&quot;)
            filehandle:close()
            awful.util.spawn(&quot;rm &quot;..msg)
            if direction == &quot;MUC&quot; and txt:match(&quot;^&lt;&quot; .. muc_nick .. &quot;&gt;&quot;) then
                return
            end
            naughty.notify{
                icon = &quot;chat_msg_recv&quot;,
                text = awful.util.escape(txt),
                title = jid
            }
        end
    elseif kind == &quot;STATUS&quot; then
        local mapping = {
            [ &quot;O&quot; ] = &quot;online&quot;,
            [ &quot;F&quot; ] = &quot;chat&quot;,
            [ &quot;A&quot; ] = &quot;away&quot;,
            [ &quot;N&quot; ] = &quot;xa&quot;,
            [ &quot;D&quot; ] = &quot;dnd&quot;,
            [ &quot;I&quot; ] = &quot;invisible&quot;,
            [ &quot;_&quot; ] = &quot;offline&quot;,
            [ &quot;?&quot; ] = &quot;error&quot;,
            [ &quot;X&quot; ] = &quot;requested&quot;
        }
        local status = mapping[direction]
        local iconstatus = status
        if not status then
            status = &quot;error&quot;
        end
        if jid:match(&quot;icq&quot;) then
            iconstatus = &quot;icq/&quot; .. status
        end
        naughty.notify{
            preset = naughty.config.presets[status],
            text = jid,
            icon = iconstatus
        }
    end
end
&lt;/pre&gt;

As you can see I use the gajim icons for the notifications, you may also want to use them.
In the script above I also match for &quot;icq&quot; which is my icq transport, so the icq icons will be used but not the xmpp ones.

== Icons ==

Add this to your rc.lua
&lt;pre&gt;
naughty.config.icon_dirs = { os.getenv(&quot;HOME&quot;) .. &quot;.config/awesome/naughtyicons/&quot;,  &quot;/usr/share/pixmaps/&quot; }
&lt;/pre&gt;

Create the directory ~/.config/awesome/naughtyicons/ extract the contents of the [http://www.ring0.de/icons.tar.gz tarball] (''this link does not work'') there.

== Event Alternative ==
A basic alternative is the following MCabber event script:

--[[User:Pnevma|Pnevma]] 05:51, 29 March 2010 (UTC) Warning: This was made by a user with minimum understanding of Bash and LUA, it may do something bad! Could a more adept user check it and remove this warning/script if necessary? I've been using it for a while and everything seems fine.
&lt;pre&gt;
#!/bin/sh

if [ $1 = &quot;MSG&quot; ]; then
  case &quot;$2&quot; in
    IN)
      if [ -n &quot;$4&quot; -a -f &quot;$4&quot; ]; then
        message=&quot;$(cat $4)&quot;
        echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: $message&quot;'&quot;})' | awesome-client
        rm $4
      fi
      ;;
    MUC)
      if [ -n &quot;$4&quot; &amp;&amp; -f &quot;$4&quot; ]; then
        message=&quot;$(cat $4)&quot;
        echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: $message&quot;'&quot;})' | awesome-client
        rm $4
      fi
      ;;
    OUT)
        echo &gt; /dev/null
      ;;
  esac
elif [ $1 = &quot;STATUS&quot; ]; then
  case &quot;$2&quot; in
    _)
      echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: has signed off.&quot;'&quot;})' | awesome-client
     ;;
    O)
      echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: is now online.&quot;'&quot;})' | awesome-client
     ;;
    F)
      echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: is chatty.&quot;'&quot;})' | awesome-client
     ;;
    A)
      echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: has gone away.&quot;'&quot;})' | awesome-client
     ;;
    N)
      echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: is now extended away.&quot;'&quot;})' | awesome-client
     ;;
    D)
     echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: does not want to be disturbed.&quot;'&quot;})' | awesome-client
     ;;
    I)
      echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: is now invisible.&quot;'&quot;})' | awesome-client
     ;;
    ?)
      echo 'naughty.notify({title = &quot;'ERROR'&quot;, text = &quot;'&quot;Something broke.&quot;'&quot;})' | awesome-client
     ;;
    X)
      echo 'naughty.notify({title = &quot;'$3'&quot;, text = &quot;'&quot;$1: has a request.&quot;'&quot;})' | awesome-client
     ;;
  esac
elif [ $1 = &quot;UNREAD&quot; ]; then
  echo 'naughty.notify({title = &quot;'$1'&quot;, text = &quot;'&quot;There are $2 new messages.&quot;'&quot;})' | awesome-client
fi
&lt;/pre&gt;
[[Category:Awesome3]]</text>
      <sha1>9j357htkxylc6pirteoatdcxt5b799y</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Menubar</title>
    <ns>0</ns>
    <id>773</id>
    <revision>
      <id>5819</id>
      <parentid>5818</parentid>
      <timestamp>2013-03-12T13:31:04Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="4702">{{VersionSpecific
| goodversions = 3.4.x
| otherversions = [[Menubar/3.5|3.5]]
}}

=== Description ===

[[Image:Menubar-shot-1.png|right|thumb|Menu has just been opened]]

[[Image:Menubar-shot-2.png|right|thumb|Text &quot;fi&quot; has been entered]]

[[Image:Menubar-shot-3.png|right|thumb|Inside the Development category]]

Menubar is a '''dmenu-like applications menu''' extension for Awesome.

Awesome certainly lacks a nice menu widget out of the box. The default &lt;tt&gt;debian.menu&lt;/tt&gt; only works on Debian and isn't very fancy. Another option is &lt;tt&gt;freedesktop.menu&lt;/tt&gt;, which parses directories for &lt;tt&gt;.desktop&lt;/tt&gt; files to generate the menu, but it is't keyboard-centric (which is controversial to Awesome ideology).

'''Menubar''' uses the same data source as &lt;tt&gt;freedesktop.menu&lt;/tt&gt; (it actually uses freedesktop's code under the hood). After a hotkey is pressed, a menu appears that contains all categories (as defined in &lt;tt&gt;menu_gen.lua&lt;/tt&gt;) and all applications. Entries are filtered as you start to type, in a way similar to dmenu; entries that start with the entered text come first, entries that match the filter somewhere in the middle come second.

You can also go inside the category by highlighting it and hitting Return. This will result in the menubar showing only the applications from the selected category.

=== How to start ===

* First you need to download the widget itself.
** You can clone the latest copy from https://github.com/alexander-yakushev/menubar.
** Or you can download the tarball directly: https://github.com/alexander-yakushev/menubar/tarball/master.

* Create a new folder called &lt;tt&gt;menubar&lt;/tt&gt; in your &lt;tt&gt;~/.config/awesome/&lt;/tt&gt; folder. Copy the downloaded files (&lt;tt&gt;init.lua&lt;/tt&gt;, &lt;tt&gt;menu_gen.lua&lt;/tt&gt;, &lt;tt&gt;prompt.lua&lt;/tt&gt; and &lt;tt&gt;utils.lua&lt;/tt&gt;) into it (so they become &lt;tt&gt;~/.config/awesome/menubar/init.lua&lt;/tt&gt; etc.).

* Open your rc.lua file and add these lines:

  require(&quot;menubar&quot;)
  menubar.cache_entries = true
  menubar.app_folders = { &quot;/usr/share/applications/&quot; }
  menubar.show_categories = true   -- Change to false if you want only programs to appear in the menu
  menubar.set_icon_theme(&quot;theme name&quot;)

You should also add a key combination to trigger the menu. Find the place in &lt;tt&gt;rc.lua&lt;/tt&gt; where the &lt;tt&gt;globalkeys&lt;/tt&gt; are defined and add this line:

  awful.key({ modkey }, &quot;s&quot;, function () menubar.show() end),

==== Caching ====

Walking through all files in the shortcut directories can take a noticeable amount of time (it takes up to 1 second on my machine). That may be rather annoying if you use menubar often (and on slower machines it can be even longer), so the entries caching option is enabled by default. It means that when launched the first time menubar parses .desktop files and keeps them in memory. This makes the consequent uses of menubar instant. The drawback is that you need to update menubar manually when new software is installed. You can do this by calling &lt;tt&gt;menubar.refresh()&lt;/tt&gt; from '''Run Lua code''' prompt (Modkey-X by default).

=== Controls ===

* Left/Right or Control-J/K - move through entry list

* Return - launch highlighted application or enter the highlighted category

* Escape - exit category (if inside one) or close the menubar

* Backspace - if no text is entered exit the category

All other key combinations are the same as in &lt;tt&gt;awful.util.prompt&lt;/tt&gt;.

=== Customization ===

You can change the category list by editing &lt;tt&gt;menu_gen.lua&lt;/tt&gt;. Each category is a table with the following fields:

* '''name''' - how the category should be displayed

* '''app_type''' - the category name that appears in the Category tag in .desktop files

* '''icon''' - icon of the category, could be either a full path to the file or just the name of the file to be found in default icon folders (like &lt;tt&gt;/usr/share/icons/&lt;/tt&gt;)

* '''use''' - if &lt;tt&gt;false&lt;/tt&gt;, the category (and all applications from it) will be ignored

You can use a few lines like below to change names without editing '''menu_gen.lua''' (the example is Hungarian).

 local menubar_change = {
      AudioVideo = &quot;Média&quot;,
      Development = &quot;Fejlesztés&quot;,
      Education = &quot;Oktatás&quot;,
      Game = &quot;Játékok&quot;,
      Graphics = &quot;Grafika&quot;,
      Office = &quot;Iroda&quot;,
      Network = &quot;Hálózat&quot;,
      Settings = &quot;Beállítások&quot;,
      System = &quot;Rendszer&quot;,
      Utility = &quot;Eszközök&quot;,
 }
 for i,j in ipairs(menubar.menu_gen.all_categories) do
    menubar.menu_gen.all_categories[i].name = 
        menubar_change[j.app_type] or j.name
 end

You can also change where the menubar pops up, as well as the menubar's size:

 menubar.g = {
    height = 30,
    width = 600,
    x = 0,
    y = 700
 }

[[Category:Awesome3]]</text>
      <sha1>hm4heyr6ib6kurwygwb3cdmokrnij2x</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Menubar/3.5</title>
    <ns>0</ns>
    <id>790</id>
    <revision>
      <id>6692</id>
      <parentid>5817</parentid>
      <timestamp>2014-05-31T08:08:10Z</timestamp>
      <contributor>
        <username>Richk1949</username>
        <id>3307</id>
      </contributor>
      <comment>/* How to start */</comment>
      <text xml:space="preserve" bytes="5032">{{DISPLAYTITLE:Menubar}}
{{VersionSpecific
| goodversions = 3.5
| otherversions = [[Menubar|3.4.x]]
}}
=== Description ===

[[Image:Menubar-shot-1.png|right|thumb|Menu has just been opened]]

[[Image:Menubar-shot-2.png|right|thumb|Text &quot;fi&quot; has been entered]]

[[Image:Menubar-shot-3.png|right|thumb|Inside the Development category]]

Menubar is a dmenu-like applications menu extension for Awesome.

Awesome certainly lacks a nice menu widget out of the box. Default debian.menu works only on Debian and is not very fancy. Another option is freedesktop.menu that parses directories for .desktop files and generates the menu from them. Still it is not fully keyboard-centric (which is controversial to Awesome ideology).

Menubar uses the same data source as freedesktop.menu (it actually uses freedesktop's code under the hood). After a hotkey is pressed menu appears that contains all categories (defined in menu_gen.lua) and all applications. Typing the text will filter the entries in a way similar to dmenu - first come the entries which names match the text from the beginning, after them come entries that match the text in the middle of their names.

You can also go inside the category by hitting Return on it. This will result in menubar showing only application from the selected category.

=== How to start ===

* Menubar is already installed with your Awesome. The default keybinding for it is Modkey-P. You can search the default configuration file ('''/etc/xdg/awesome/rc.lua''' for it).

* If you don't use the default configuration file then open your rc.lua file and add these lines:

  local menubar = require(&quot;menubar&quot;)

  -- Menubar configuration
  menubar.utils.terminal = terminal -- Set the terminal for applications that require it

* By default menubar doesn't scan for local applications. To change the search path you can use something like this:

  menubar.menu_gen.all_menu_dirs = { &quot;/usr/share/applications/&quot;, &quot;/usr/local/share/applications&quot;, &quot;~/.local/share/applications&quot; }

You should also add a key combination to trigger the menu. Find the place in '''rc.lua''' where the '''globalkeys''' are defined and add this line:

  awful.key({ modkey }, &quot;p&quot;, function () menubar.show() end),

==== Caching ====

Walking through all files in the shortcut directories can take a noticeable amount of time (it takes up to 1 second on my machine). That may be rather annoying if you use menubar often (and on slower machines it can be even longer), so the entries caching option is enabled by default. It means that when launched the first time menubar parses .desktop files and keeps them in memory. This makes the consequent uses of menubar instant. The drawback is that you need to update menubar manually when new software is installed. You can do this by calling '''menubar.refresh()''' from '''Run Lua code''' prompt (Modkey-X by default).

=== Controls ===

* Left/Right or Control-J/K - move through entry list

* Return - launch highlighted application or enter the highlighted category

* Escape - exit category (if inside one) or close the menubar

* Backspace - if no text is entered exit the category

All other key combinations are the same as in '''awful.util.prompt'''.

=== Customization ===

To customize the icon theme for the application icons add the following line in your '''theme.lua''' file:

  theme.icon_theme = &quot;Humanity&quot; -- Replace the string for the theme you want to use

You can change the category list by changing the table menubar.menu_gen.all_categories in runtime. Each category is a table with the following fields:

* name - how the category would be displayed

* app_type - the category name that appears in '''Category''' tag in .desktop files

* icon - icon of the category, could be either a full path to the file or just the name of the file to be found in default icon folders (like /usr/share/icons/)

* use - if false, the category (and all applications from it) will be ignored

You can use a few lines like below to change names (the example is hungarian):

  menubar.menu_gen.all_categories.multimedia.name = &quot;Média&quot;
  menubar.menu_gen.all_categories.development.name = &quot;Fejlesztés&quot;
  menubar.menu_gen.all_categories.education.name = &quot;Oktatás&quot;
  menubar.menu_gen.all_categories.games.name = &quot;Játékok&quot;
  menubar.menu_gen.all_categories.graphics.name = &quot;Grafika&quot;
  menubar.menu_gen.all_categories.office.name = &quot;Iroda&quot;
  menubar.menu_gen.all_categories.internet.name = &quot;Hálózat&quot;
  menubar.menu_gen.all_categories.settings.name = &quot;Beállítások&quot;
  menubar.menu_gen.all_categories.tools.name = &quot;Rendszer&quot;
  menubar.menu_gen.all_categories.utility.name = &quot;Eszközök&quot;

Or you can turn off the categories you don't want to see (and applications from them respectively):

  menubar.menu_gen.all_categories.education.use = false
  menubar.menu_gen.all_categories.tools.use = false

You can change the place for menubar to pop up and menubar's size too:

 menubar.geometry = {
    height = 30,
    width = 600,
    x = 0,
    y = 700
 }

[[Category:Awesome3.5]]</text>
      <sha1>6vcpzi7rrp9qcaks06qs28cryo7far5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Menubar/Git version</title>
    <ns>0</ns>
    <id>879</id>
    <redirect title="Menubar/3.5" />
    <revision>
      <id>5694</id>
      <timestamp>2012-12-15T11:38:28Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <comment>moved [[Menubar/Git version]] to [[Menubar/3.5]]</comment>
      <text xml:space="preserve" bytes="25">#REDIRECT [[Menubar/3.5]]</text>
      <sha1>jyvyoqs1txikvs9kpaq2eao9gcqz81z</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Minitray</title>
    <ns>0</ns>
    <id>968</id>
    <revision>
      <id>6551</id>
      <parentid>6180</parentid>
      <timestamp>2014-05-19T04:24:51Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1171">{{Languages}}

{{VersionSpecific
| goodversions = 3.5
}}
=== Description ===

If you don't like tray widget cluttering your top panel, and you don't use it that often anyway, then minitray is for you. It allows yout to show/hide your tray with a single key combination.

=== Howto ===

* Download [https://gist.github.com/alexander-yakushev/7840559 minitray.lua]

* Require the module in '''rc.lua''':

    local minitray = require(&quot;minitray&quot;)

* Put a keybinding for toggling minitray:

    -- somewhere in globalkeys
    awful.key({ modkey,           }, &quot;l&quot;, function() minitray.toggle() end ),

* Don't forget to remove the default system tray from your panel. You should delete this line:

    if s == 1 then right_layout:add(wibox.widget.systray()) end

=== Customization ===

By default, minitray spawns in upper right corner just under your top panel, has a height of 20 and a width equal to the tray width. You can change some of these values by specifying an argument to '''minitray.toggle'''. For example, this will show minitray in the upper corner having bigger size:

    minitray.toggle({ x = 0, height = 30 })

[[Category:Widgets]]

[[Category:Awesome3.5]]</text>
      <sha1>r7vrl5sq0ld8tzdb5mypibdt0dzwazl</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Minitray/ru</title>
    <ns>0</ns>
    <id>1058</id>
    <revision>
      <id>6553</id>
      <timestamp>2014-05-19T05:07:06Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Minitray (translating page)</comment>
      <text xml:space="preserve" bytes="2063">{{Languages|Minitray}}

{{VersionSpecific
| goodversions = 3.5
}}
=== Описание ===

Если вам не нравится виджеты в трее, которые загромаждают вашу верхнюю панель, и вы не часто ими пользуетесь, в таком случае минитрей то что нужно для вас. Он позволяет показывать/скрывать ваш трей простым нажатием клавиш.

=== Использование ===

* Загрузите [https://gist.github.com/alexander-yakushev/7840559 minitray.lua]. Затем скопируйте его в каталог с awesome, чаще всего это /home/user/.config/awesome

* Подключите модуль в '''rc.lua''':

    local minitray = require(&quot;minitray&quot;)

* Добавьте клавиатурное сочетание для переключения минитрея:

    -- где либо в секции globalkeys
    awful.key({ modkey,           }, &quot;l&quot;, function() minitray.toggle() end ),

* Не забудьте удалить стандартный системный трей из вашей панели. Вам нужно удалить следующую строку:

    if s == 1 then right_layout:add(wibox.widget.systray()) end

=== Настройка ===

По умолчанию, минитрей создается в верхнем правом углу, под вашей верхней панелью, имеет высоту 20 и ширину эквивалентную ширине трея. Вы можете изменить некоторые из этих значений, определяя аргумент для '''minitray.toggle'''. Например, этот код отобразит минитрей в верхнем углу, с увеличенными размерами:

    minitray.toggle({ x = 0, height = 30 })

Перезапустите Awesome, наслаждайтесь!

[[Category:Widgets]]

[[Category:Awesome3.5]]</text>
      <sha1>3wg26ukx824dovjpc60qr1g18ktx7sx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Modal Keybindings</title>
    <ns>0</ns>
    <id>636</id>
    <revision>
      <id>6598</id>
      <parentid>6594</parentid>
      <timestamp>2014-05-22T13:03:41Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>delete dead link</comment>
      <text xml:space="preserve" bytes="1923">{{Languages}}

The idea behind modal keybinding is to have the same key perform different functions depending on the 'mode' they were pressed in. In my setup, I have a client mode (activated by &lt;code&gt;Mod4 + space&lt;/code&gt;), and 'no-mode' (the default behavior), so that 'x' maximizes a client in client mode, while it does nothing in 'no-mode'.
 
Awesome's [http://awesome.naquadah.org/doc/api/modules/keygrabber.html Keygrabber API] makes it super simple to implement modal key bindings. Basically you trigger the keygrabber on some key combination, which then listens for further key presses and triggers functions accordingly.

1. So you have a table that binds certain keys to their actions for that mode :
  -- mapping for modal client keys
    client_mode = {
      -- Set client on top
      o = function (c) c.ontop = not c.ontop end,
      -- Redraw the client
      d = function (c) c:redraw() end,
      -- Toggle floating status of the client
      u = awful.client.floating.toggle,
      -- toggle mark
      t = awful.client.togglemarked,
      -- make the client fullscreen
      f = function (c) c.fullscreen = not c.fullscreen  end,
      -- maximize the client
      x = function (c)
            c.maximized_horizontal = not c.maximized_horizontal
            c.maximized_vertical   = not c.maximized_vertical
      end
    }

2. And a keybinding that triggers the mode. The following binding goes in the &lt;code&gt;clientkeys&lt;/code&gt; table:

  -- trigger client mode on Mod4 + space
  awful.key({ modkey }, &quot;space&quot;, function(c)
      keygrabber.run(function(mod, key, event)
          if event == &quot;release&quot; then return true end
          keygrabber.stop()
          '''if client_mode[key] then client_mode[key](c) end'''
          return true
      end)
  end)

The line in bold is what checks if an action corresponding to the key grabbed exists in the &lt;code&gt;client_mode&lt;/code&gt; table, and invokes it if present.</text>
      <sha1>m3pbr1bvzqkoy56c0ry0jcjfqda3ajb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Modal Keybindings/ru</title>
    <ns>0</ns>
    <id>1070</id>
    <revision>
      <id>6597</id>
      <parentid>6596</parentid>
      <timestamp>2014-05-22T13:03:13Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>delete dead link</comment>
      <text xml:space="preserve" bytes="3153">{{Languages|Modal Keybindings}}
{{DISPLAYTITLE:&quot;Модальные&quot; сочетания клавиш}}

Идея модальных сочетаний клавиш, заключается в том, что некоторые клавиши выполняют различные функции в зависимости от установленного режима 'mode'. В моих настройках, у меня есть клиентский 'mode' (активирующийся нажатием &lt;code&gt;Mod4 + space&lt;/code&gt;), и 'no-mode' (поведение по умолчанию), где 'x' разворачивает приложение в клиентском режиме и не делает ничего если установлен режим 'no-mode'.
 
Awesome's [http://awesome.naquadah.org/doc/api/modules/keygrabber.html Keygrabber API] делает невероятно простой реализацию модальных клавиш. В общем, вы вызываете keygrabber для некоторых клавиатурных сочетаний, которые затем отслеживаются на нажатие и вызываются соответсвующие функции. 

1. Итак у вас есть таблица, которая связывает определнные клавиши с действиями для этого режима:
  -- таблица соответсвия модальным приложениям клавиатурных сочетаний
    client_mode = {
      -- Устанавливаем приложение поверх всех
      o = function (c) c.ontop = not c.ontop end,
      -- Перерисовка приложения
      d = function (c) c:redraw() end,
      -- Переключение плавающего (floating) статуса для приложения
      u = awful.client.floating.toggle,
      -- toggle mark
      t = awful.client.togglemarked,
      -- полноэкранный режим для приложения
      f = function (c) c.fullscreen = not c.fullscreen  end,
      -- разворачивание на экран(maximize) приложения
      x = function (c)
            c.maximized_horizontal = not c.maximized_horizontal
            c.maximized_vertical   = not c.maximized_vertical
      end
    }

2. И клавиатурные сочетания которые вызывают режим. Следующие привязки должны располагаться в секции &lt;code&gt;clientkeys&lt;/code&gt; table:

  -- trigger client mode on Mod4 + space
  awful.key({ modkey }, &quot;space&quot;, function(c)
      keygrabber.run(function(mod, key, event)
          if event == &quot;release&quot; then return true end
          keygrabber.stop()
          '''if client_mode[key] then client_mode[key](c) end'''
          return true
      end)
  end)

Строка выделенная жирным шрифтом проверяет на соответсвии нажатых клавиш с таблицей &lt;code&gt;client_mode&lt;/code&gt; и вызывает их, если они присутсвуют.</text>
      <sha1>amjmoujc5xhk4orl6mpsw7u27o77ta4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Mortini Simple Laptop Theme</title>
    <ns>0</ns>
    <id>62</id>
    <revision>
      <id>1283</id>
      <timestamp>2008-10-16T14:59:15Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="12275">[[Image:Mortini_green_screenshot.png|thumb|none|Mortini Simple Laptop Theme Screenshot]]

This is a simple green-ish theme I use on my laptop. I use the example disk usage and clock script to create two simple widgets. 

Theme/config overview:

* Rules for various apps that I use, and a simplified tag system.
* The Silkscreen TTF, a very readable small font, is utilized. This font is available from kottke.org.
* Use awesome-menu with a Mod4-p keybinding - The [[Awesome-menu]] wiki setup is used.
* Using [http://stalonetray.sourceforge.net/ stalonetray] for a system tray.

  # awesomerc for 2.3
  screen 0
  {
    general
    {
        # make windows extend to the full height of the screen
        resize_hints = false
    }
    styles
     {
        ####
        # colors in this theme
        # #604040 Maroon
        # #606040 Dark Olive Green
        # #222211 Darker Olive Green
        # #a0a0a0 Light Grey
        # #402020
        ####
        normal
        {
            #font = &quot;sans 8&quot;
            # use the silkscreen font from kottke.org
            font = &quot;silkscreen 6&quot;
            fg = &quot;#808080&quot;
            bg = &quot;#222211&quot;
            border = &quot;#222222&quot;
        }
        focus
        {
            fg = &quot;#a0a0a0&quot;
            bg = &quot;#606040&quot;
            border = &quot;#FFFFFF&quot;
        }
        urgent
        {
            fg = &quot;#FFFFFF&quot;
            bg = &quot;#D53737&quot;
        }
     }
    tags
    {
        tag a { }
        tag b { }
        tag c { }
        tag d { layout = &quot;floating&quot; }
        tag e { }
        tag f { layout = &quot;floating&quot; }
    }
    titlebar
    { 
        position = &quot;left&quot; 
        text_align = &quot;center&quot; 
        styles 
        { 
            normal 
            { 
                shadow = &quot;#111111&quot; 
                shadow_offset = &quot;1&quot; 
            } 
            focus 
            { 
                bg = &quot;#606040&quot; 
                shadow = &quot;#111111&quot;
                shadow_offset = &quot;1&quot; 
            } 
        }
        height = &quot;12&quot; 
    }
    layouts
    {
        layout tile { image = &quot;/usr/local/share/awesome/icons/layouts/tilew.png&quot; }
        layout tileleft { image = &quot;/usr/local/share/awesome/icons/layouts/tileleftw.png&quot; }
        layout tilebottom { image = &quot;/usr/local/share/awesome/icons/layouts/tilebottomw.png&quot; }
        layout tiletop { image = &quot;/usr/local/share/awesome/icons/layouts/tiletopw.png&quot; }
        layout max { image = &quot;/usr/local/share/awesome/icons/layouts/maxw.png&quot; }
        layout spiral { image = &quot;/usr/local/share/awesome/icons/layouts/spiralw.png&quot; }
        layout dwindle { image = &quot;/usr/local/share/awesome/icons/layouts/dwindlew.png&quot; }
        layout floating { image = &quot;/usr/local/share/awesome/icons/layouts/floatingw.png&quot; }
    }
    statusbar mystatusbar
    {
        position = &quot;bottom&quot;

        taglist mytaglist
        {
            mouse
            {
                button = &quot;1&quot;
                command = &quot;tag_view&quot;
            }
            mouse
            {
                button = &quot;1&quot;
                modkey = {&quot;Mod4&quot;}
                command = &quot;client_tag&quot;
            }
            mouse
            {
                button = &quot;3&quot;
                command = &quot;tag_toggleview&quot;
            }
            mouse
            {
                button = &quot;3&quot;
                modkey = {&quot;Mod4&quot;}
                command = &quot;client_toggletag&quot;
            }
            mouse
            {
                button = &quot;4&quot;
                command = &quot;tag_viewnext&quot;
            }
            mouse
            {
                button = &quot;5&quot;
                command = &quot;tag_viewprev&quot;
            }
        }
        layoutinfo mylayoutinfo
        {
            mouse
            {
                button = &quot;1&quot;
                command = &quot;tag_setlayout&quot;
                arg = &quot;+1&quot;
            }
            mouse
            {
                button = &quot;4&quot;
                command = &quot;tag_setlayout&quot;
                arg = &quot;+1&quot;
            }
            mouse
            {
                button = &quot;3&quot;
                command = &quot;tag_setlayout&quot;
                arg = &quot;-1&quot;
            }
            mouse
            {
                button = &quot;5&quot;
                command = &quot;tag_setlayout&quot;
                arg = &quot;-1&quot;
            }
        }
        tasklist mytasklist
        {
            mouse
            {
                button = &quot;4&quot;
                command = &quot;client_focusnext&quot;
            }
            mouse
            {
                button = &quot;5&quot;
                command = &quot;client_focusprev&quot;
            }
            mouse
            {
                modkey = {&quot;Mod4&quot;}
                button = &quot;4&quot;
                command = &quot;client_swapnext&quot;
            }
            mouse
            {
                modkey = {&quot;Mod4&quot;}
                button = &quot;5&quot;
                command = &quot;client_swapprev&quot;
            }
        }
   emptybox spacer
   {
     style {}
     width = 25
    }
   progressbar diskusage
   {
       data &quot;disk&quot;
       {
           bordercolor = &quot;#000000&quot;
           bg          = &quot;#000000&quot;
           fg          = &quot;#604040&quot;
           fg_center   = &quot;#222211&quot;
           fg_end      = &quot;#402020&quot;
       }
       width = 100
       align = &quot;right&quot;
   }
   textbox clock 
        { 
            align = &quot;right&quot; 
            width = &quot;150&quot;
            style { 
                fg = &quot;#a0a0a0&quot; 
                shadow = &quot;#111111&quot; 
                shadow_offset = &quot;1&quot; 
            } 
        }
   iconbox logo
        {
            image = &quot;/usr/local/share/awesome/icons/awesome16.png&quot;
            mouse
            {
                button = &quot;1&quot;
                command = &quot;spawn&quot;
                arg = &quot;exec xterm -e man awesome&quot;
            }
        }
    }
  }

  rules
  {
    rule {
        name = &quot;Firefox&quot;
        tags = &quot;b&quot;
    }
    rule {
        name = &quot;VLC&quot;
        float = true
    }
    rule {
        name = &quot;Buddy List&quot;
        tags = &quot;d&quot;
        float = true
    }
    rule {
        name = &quot;vnc&quot;
        tags = &quot;f&quot;
        float = true
       }
    rule {
        name = &quot;Pidgin&quot;
        tags = &quot;d&quot;
        float = true
    }
    rule {
        name = &quot;gimp&quot;
        tags = &quot;d&quot;
        float = true
    }
    rule {
        name = &quot;stalonetray&quot;
        tags = &quot;0&quot;
        float = true
    }
    rule {
        name = &quot;tester&quot;
        tags = &quot;d&quot;
        float = true
    }

  }

  mouse
  {
    root
    {
        button = &quot;3&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec ~/.awesome/bin/rxvt&quot;
    }
    root
    {
        button = &quot;4&quot;
        command = &quot;tag_viewnext&quot;
    }
    root
    {
        button = &quot;5&quot;
        command = &quot;tag_viewprev&quot;
    }
    client
    {
        modkey = {&quot;Mod4&quot;}
        button = &quot;1&quot;
        command = &quot;client_movemouse&quot;
    }
    client
    {
        modkey = {&quot;Mod4&quot;}
        button = &quot;2&quot;
        command = &quot;client_zoom&quot;
    }
    client
    {
        modkey = {&quot;Mod4&quot;}
        button = &quot;3&quot;
        command = &quot;client_resizemouse&quot;
    }
    titlebar
    {
        button = &quot;1&quot;
        command = &quot;client_movemouse&quot;
    }
    titlebar
    {
        button = &quot;3&quot;
        command = &quot;client_resizemouse&quot;
    }
  }

  keys
  {
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;F1&quot;
        command = &quot;spawn&quot;
        arg = &quot;for i in /usr/share/man/man?;do ls $i; done | cut -d. -f1 | awesome-menu -e 'xterm -e man ' 'See manual page for:'&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;F2&quot;
        command = &quot;spawn&quot;
        arg = &quot;find /usr/bin -type f -executable ! -empty | awesome-menu -e 'exec ' Execute:&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;F3&quot;
        command = &quot;spawn&quot;
        arg = &quot;cut -d' ' -f1 ~/.ssh/known_hosts | cut -d, -f1 | awesome-menu -e 'xterm -e ssh ' 'ssh to:'&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;Return&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec ~/.awesome/bin/rxvt&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;space&quot;
        command = &quot;tag_setlayout&quot;
        arg = &quot;+1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        key = &quot;space&quot;
        command = &quot;tag_setlayout&quot;
        arg = &quot;-1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;b&quot;
        command = &quot;statusbar_toggle&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;j&quot;
        command = &quot;client_focusnext&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;k&quot;
        command = &quot;client_focusprev&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;Tab&quot;
        command = &quot;focus_history&quot;
        arg = &quot;-1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        key = &quot;j&quot;
        command = &quot;client_swapnext&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        key = &quot;k&quot;
        command = &quot;client_swapprev&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;j&quot;
        command = &quot;screen_focus&quot;
        arg = &quot;+1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;k&quot;
        command = &quot;screen_focus&quot;
        arg = &quot;-1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;h&quot;
        command = &quot;tag_setmwfact&quot;
        arg = &quot;-0.05&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;l&quot;
        command = &quot;tag_setmwfact&quot;
        arg = &quot;+0.05&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        key = &quot;h&quot;
        command = &quot;tag_setnmaster&quot;
        arg = &quot;+1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        key = &quot;l&quot;
        command = &quot;tag_setnmaster&quot;
        arg = &quot;-1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;h&quot;
        command = &quot;tag_setncol&quot;
        arg = &quot;+1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;l&quot;
        command = &quot;tag_setncol&quot;
        arg = &quot;-1&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;Escape&quot;
        command = &quot;tag_prev_selected&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;Left&quot;
        command = &quot;tag_viewprev&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;Right&quot;
        command = &quot;tag_viewnext&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;m&quot;
        command = &quot;client_togglemax&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;Return&quot;
        command = &quot;client_zoom&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;space&quot;
        command = &quot;client_togglefloating&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;s&quot;
        command = &quot;client_togglescratch&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;s&quot;
        command = &quot;client_setscratch&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        key = &quot;c&quot;
        command = &quot;client_kill&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        key = &quot;q&quot;
        command = &quot;quit&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;r&quot;
        command = &quot;restart&quot;
    }
    key
    {
        modkey = {&quot;Mod4&quot;}
        key = &quot;p&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec `~/.awesome/bin/awesome-menu-builder`&quot;
    }
    key
    {
       modkey = {&quot;Mod4&quot;}
       key = &quot;0&quot;
       command = &quot;tag_view&quot;
    }
    keylist
    {
        modkey = {&quot;Mod4&quot;}
        command = &quot;tag_view&quot;
        keylist = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
        arglist = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    }
    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        key = &quot;0&quot;
        command = &quot;tag_toggleview&quot;
    }
    keylist
    {
        modkey = {&quot;Mod4&quot;, &quot;Control&quot;}
        command = &quot;tag_toggleview&quot;
        keylist = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
        arglist = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    }

    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        key = &quot;0&quot;
        command = &quot;client_tag&quot;
    }
    keylist
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;}
        command = &quot;client_tag&quot;
        keylist = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
        arglist = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    }

    key
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;, &quot;Control&quot;}
        key = &quot;0&quot;
        command = &quot;client_toggletag&quot;
    }
    keylist
    {
        modkey = {&quot;Mod4&quot;, &quot;Shift&quot;, &quot;Control&quot;}
        command = &quot;client_toggletag&quot;
        keylist = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
        arglist = { 1, 2, 3, 4, 5, 6, 7, 8, 9 }
    }
  }
  # vim: filetype=conf

[[Category:Themes]]
[[Category:awesome2]]</text>
      <sha1>1224alx5ino8w5oluuaejieuv6282bg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Client to Monitor Left/Right</title>
    <ns>0</ns>
    <id>791</id>
    <revision>
      <id>6759</id>
      <parentid>5525</parentid>
      <timestamp>2014-06-09T17:27:06Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="728">{{Languages}}

When using more than two monitors you may want to send the current client to a left/right monitor, instead of cycling through all of them. 

This is easy to achieve - edit your rc.lua, find the clientkeys line:
  awful.key({ modkey,           }, &quot;o&quot;,      awful.client.movetoscreen                        ),

and replace it with something like:  
  awful.key({ modkey,           }, &quot;o&quot;,      function(c) awful.client.movetoscreen(c,c.screen-1) end ),
  awful.key({ modkey,           }, &quot;p&quot;,      function(c) awful.client.movetoscreen(c,c.screen+1) end ),

In this example Mod4+o moves active client to the left monitor (or rather the one with lower number assigned by RandR), and Mod4+p sends it to the right one.</text>
      <sha1>f98lyigpx1shrwcl8uugsz1r54cbbmg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Client to Monitor Left/Right/ru</title>
    <ns>0</ns>
    <id>1115</id>
    <revision>
      <id>6761</id>
      <timestamp>2014-06-09T17:35:14Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Move Client to Monitor Left/Right (translating page)</comment>
      <text xml:space="preserve" bytes="1272">{{Languages|Move Client to Monitor Left/Right}}
{{DISPLAYTITLE:Перемещение приложения на левый/правый монитор}}

При использовании более чем 2х мониторов вы можете захотеть послать текущее приложение на левый или правый монитор, вместо циклического переключения по всем экранам. 

Этого легко достичь - отредактируйте ваш rc.lua, найдите в нем в секции clientkeys:
  awful.key({ modkey,           }, &quot;o&quot;,      awful.client.movetoscreen                        ),

и заменить его следующими строками:
  awful.key({ modkey,           }, &quot;o&quot;,      function(c) awful.client.movetoscreen(c,c.screen-1) end ),
  awful.key({ modkey,           }, &quot;p&quot;,      function(c) awful.client.movetoscreen(c,c.screen+1) end ),

В данном примере Mod4+o переместить активное приложение на левый монитор (или скорее на один номер меньше, чем присвоенный текущему в RandR), и Mod4+p переместить его вправо.</text>
      <sha1>jqonwq0jfzho1i3gjc4pkj1jigfizxv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Client to a specific Monitor</title>
    <ns>0</ns>
    <id>855</id>
    <revision>
      <id>6755</id>
      <parentid>6060</parentid>
      <timestamp>2014-06-09T16:49:42Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1090">{{Languages}}

When using two or more monitors, you might want to move a client to a specific monitor via the keyboard.

To do this, open your rc.lua and find the clientkeys-section.

Then add this to the to the end of the section:
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;F1&quot;, function (c) awful.client.movetoscreen(c, 1) end),

Doing this will move the client to your screen &quot;1&quot; when pressing ''Modkey+Shift+F1''. It is recommended to set your monitors from left to right so they map with the F-keys. Note that your most left monitor might not be screen 1. Experiment to see what is the right one for you.

To add more monitors to the hotkeys, just follow the same pattern.

Example additions (to the end of the clientkeys-section):
  
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;F1&quot;, function (c) awful.client.movetoscreen(c, 3) end),
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;F2&quot;, function (c) awful.client.movetoscreen(c, 1) end),
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;F3&quot;, function (c) awful.client.movetoscreen(c, 2) end),

'''NB''': F1 links to monitor 3, this is -in this example- the left-most screen.</text>
      <sha1>mprf393s18rp91y3ug386ms35745as5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Client to a specific Monitor/ru</title>
    <ns>0</ns>
    <id>1114</id>
    <revision>
      <id>6758</id>
      <timestamp>2014-06-09T17:24:51Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Move Client to a specific Monitor (translating page)</comment>
      <text xml:space="preserve" bytes="1843">{{Languages|Move Client to a specific Monitor}}
{{DISPLAYTITLE:Перемещение приложения на заданный монитор}}

При использовании 2х и более мониторов, вы можете переместить приложение на заданный монитор с помощью клавиатуры.

Для того, чтобы сделать это, откройте rc.lua и найдите секцию clientkeys.

Затем добавьте эту строку в конец этой секции:
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;F1&quot;, function (c) awful.client.movetoscreen(c, 1) end),

Теперь нажав Mod+Shift+F1 вы переместите клиент на экран &quot;1&quot;. Помните, что ваш левый монитор может не быть экраном 1.Поэкспериментируйте, чтобы увидеть что будет верно для вас. Разместить это после секции clientkeys не позволит вам изменить монитор, если у вас нет приложений на этом мониторе.

Чтобы привязать несколько мониторов к горячим клавишам, просто следуйте похожим шаблонам. 

Пример использования (добавьте в конец секции clientkeys):
  
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;F1&quot;, function (c) awful.client.movetoscreen(c, 3) end),
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;F2&quot;, function (c) awful.client.movetoscreen(c, 1) end),
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;F3&quot;, function (c) awful.client.movetoscreen(c, 2) end),

'''NB''': F1 ссылается на монитор 3, в данном примере это крайне левый экран.</text>
      <sha1>molhii9fw6yk4diiy62foh0ozcnthng</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Focus to a specific Monitor</title>
    <ns>0</ns>
    <id>856</id>
    <revision>
      <id>6752</id>
      <parentid>6061</parentid>
      <timestamp>2014-06-09T16:27:58Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1265">{{Languages}}

When using 2 or more monitors you might want to switch to a specific monitor without using the mouse.

This is easy to achive - open your rc.lua and find the globalkeys-section, under the &quot;-- Standard program&quot;-part, add this:
  awful.key({modkey,            }, &quot;F1&quot;,     function () awful.screen.focus(1) end)
This will move the mouse/focus to your screen &quot;1&quot; when pressing ''Modkey-F1''. It is recommended to set your monitors from left to right so they map with the F-keys. Note that your left-most monitor might not be screen 1. Experiment to see what is the right one for you. 
Placing this under the clientkeys-section will make you unable to change monitor unless you have a client on the monitor you are on.

To add more monitors to the hotkeys, just follow the same pattern.

Example config: 
  awful.key({modkey,            }, &quot;F1&quot;,     function () awful.screen.focus(3) end),
  awful.key({modkey,            }, &quot;F2&quot;,     function () awful.screen.focus(1) end),
  awful.key({modkey,            }, &quot;F3&quot;,     function () awful.screen.focus(2) end),
Note that in the above configuration, ''Modkey-F1'' shifts focus to the monitor with index 3. Which in this particular case also happens to be the far-left monitor. So please adjust accordingly!</text>
      <sha1>0c79olgqaocuv2seefxg80xxi09q5wz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Focus to a specific Monitor/ru</title>
    <ns>0</ns>
    <id>1113</id>
    <revision>
      <id>6754</id>
      <timestamp>2014-06-09T16:46:41Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Move Focus to a specific Monitor (translating page)</comment>
      <text xml:space="preserve" bytes="2034">{{Languages|Move Focus to a specific Monitor}}

При использовании 2х или более мониторов, вы можете переключаться на определенный монитор без использования мыши.

Этого легко достигнуть - откройте ваш rc.lua и найдите секцию globalkeys, после части &quot;-- Standard program&quot;, добавьте строку:
  awful.key({modkey,            }, &quot;F1&quot;,     function () awful.screen.focus(1) end)
Это будет переключать мышь/фокус на ваш экран &quot;1&quot; при нажатии ''Modkey-F1''. Рекомендуем настраивать ваши мониторы с лева на право, чтобы связать их с  F-keys. Помните, что ваш левый монитор может не быть экраном 1.Поэкспериментируйте, чтобы увидеть что будет верно для вас.
Разместить это после секции clientkeys не позволит вам изменить монитор, если у вас нет приложений на этом мониторе.

Чтобы привязать несколько мониторов к горячим клавишам, просто следуйте похожим шаблонам.

Пример конфигурации: 
  awful.key({modkey,            }, &quot;F1&quot;,     function () awful.screen.focus(3) end),
  awful.key({modkey,            }, &quot;F2&quot;,     function () awful.screen.focus(1) end),
  awful.key({modkey,            }, &quot;F3&quot;,     function () awful.screen.focus(2) end),
Обратите внимание, что в конфигурации выше, ''Modkey-F1'' перемещает фокус на монитор с index 3. Что в данном случае, то же самое что и крайне левый монитор. Поэтому пожалуйста, настройте соответственно!</text>
      <sha1>r92d54b1b9qn2cm354q0n64bcp60ttz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Mouse</title>
    <ns>0</ns>
    <id>220</id>
    <revision>
      <id>3461</id>
      <parentid>2688</parentid>
      <timestamp>2009-08-15T16:02:05Z</timestamp>
      <contributor>
        <username>Atragor</username>
        <id>120</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="1451">{{Languages|Move Mouse}}

If you (like me) work (mostly) mouselessly then the mouse pointer in the centre of the screen is an irritation.
Add this to your rc.lua to move the mouse out of the way.

&lt;pre&gt;
-- set the desired pixel coordinates:
--  if your screen is 1024x768 the this line sets the bottom right.
local safeCoords = {x=1024, y=768}
--  this line sets top middle(ish).
local safeCoords = {x=512, y=0}
-- Flag to tell Awesome whether to do this at startup.
local moveMouseOnStartup = true

-- Simple function to move the mouse to the coordinates set above.
local function moveMouse(x_co, y_co)
    mouse.coords({ x=x_co, y=y_co })
end

-- Bind ''Meta4+Ctrl+m'' to move the mouse to the coordinates set above.
--   this is useful if you needed the mouse for something and now want it out of the way
keybinding({ modkey, &quot;Control&quot; }, &quot;m&quot;, function() moveMouse(safeCoords.x, safeCoords.y) end):add()

-- Optionally move the mouse when rc.lua is read (startup)
if moveMouseOnStartup then
        moveMouse(safeCoords.x, safeCoords.y)
end
&lt;/pre&gt;

This could probably be improved by detecting the screen resolution and setting &quot;safeCoords&quot; accordingly.

For another option, which doesn't move the cursor but temporarily hides it after a period of inactivity, and also offers the ability to instantly hide the cursor while typing, you could try the program 'unclutter'. Available in Debian, Ubuntu and possibly other distros.

[[Category:Awesome3]]</text>
      <sha1>tf0m4yqr6vraa4f6x4pnndiahzliyxc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Mouse/ru</title>
    <ns>0</ns>
    <id>462</id>
    <revision>
      <id>3460</id>
      <timestamp>2009-08-15T16:02:00Z</timestamp>
      <contributor>
        <username>Atragor</username>
        <id>120</id>
      </contributor>
      <comment>Created page with '{{DISPLAYTITLE:Перемещение курсора}} {{Languages|Move Mouse}}  Если Вы предпочитаете работать в Awesome без мыши, то кур...'</comment>
      <text xml:space="preserve" bytes="2407">{{DISPLAYTITLE:Перемещение курсора}}
{{Languages|Move Mouse}}

Если Вы предпочитаете работать в Awesome без мыши, то курсор в центре экрана будет только мешать. Добавьте это в rc.lua, чтобы убрать его.

&lt;pre&gt;
-- Установка координат, в которые будет помещён курсор:
--  если размер Вашего экрана - 1024x768, эта
--  строка указывает на его правый нижний угол...
local safeCoords = {x=1024, y=768}
--  ...а эта - на центр верхней стороны
local safeCoords = {x=512, y=0}
-- Если значение этой переменной true, курсор будет
-- перемещаться при запуске Awesome.
local moveMouseOnStartup = true

-- Простая функция для перемещения курсора в заданную выше позицию.
local function moveMouse(x_co, y_co)
    mouse.coords({ x=x_co, y=y_co })
end

-- Сочетание клавиш для перемещения курсора (в данном случае ''Meta4+Ctrl+m'',
-- но Вы можете указать любое другое). Это может оказаться полезным, если Вам всё-таки
-- потребовалось воспользоваться мышью, и теперь Вы хотите её убрать.
keybinding({ modkey, &quot;Control&quot; }, &quot;m&quot;, function() moveMouse(safeCoords.x, safeCoords.y) end):add()

-- Перемещать курсор при чтении файла rc.lua (то есть при запуске Awesome).
if moveMouseOnStartup then
        moveMouse(safeCoords.x, safeCoords.y)
end
&lt;/pre&gt;

Возможно, этот скрипт можно улучшить, добавив определение размера экрана и выставление соответствующего значения &quot;safeCoords&quot;.

Как вариант, можно не перемещать курсор, а прятать его, когда он неактивен или во время печати. Для этого существует программа 'unclutter', доступная в Debian, Ubuntu и, вероятно, в других дистрибутивах.

[[Category:Awesome3]]</text>
      <sha1>8n5e98ozqgeglui2fbi4h2zxl76fw1k</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Window to Monitor Left/Right</title>
    <ns>0</ns>
    <id>792</id>
    <redirect title="Move Client to Monitor Left/Right" />
    <revision>
      <id>5390</id>
      <timestamp>2012-03-16T22:13:38Z</timestamp>
      <contributor>
        <username>Gorkypl</username>
        <id>865</id>
      </contributor>
      <comment>moved [[Move Window to Monitor Left/Right]] to [[Move Client to Monitor Left/Right]]: Client is the proper name</comment>
      <text xml:space="preserve" bytes="47">#REDIRECT [[Move Client to Monitor Left/Right]]</text>
      <sha1>7d6rei1zr1fni8ur22ifachwd2s0xkb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Window to Workspace Left/Right</title>
    <ns>0</ns>
    <id>668</id>
    <revision>
      <id>6762</id>
      <parentid>6256</parentid>
      <timestamp>2014-06-09T18:03:14Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="3245">{{Languages}}

== Moving Window to Workspace Left/Right ==

While the default rc.lua configuration file includes keyboard shortcuts to move the focused window to an enumerated tag, an alternate way to move windows between tags is to shift them one tag to the left or right. The following keybinding functions will perform this task, moving the focused window one workspace to the left or right  (and wrapping at the edges).

This script assumes there are exactly 9 tags per screen, each with a distinct index value. If the focused window has more than one tag, it will be moved to the left/right of the leftmost tag, and lose any other tags it has. The keybindings are &quot;mod4+shift+,&quot; and &quot;mod4+shift+.&quot; because these are the &lt; and &gt; keys on most keyboards.

=== Awesome 3.4 ===

 awful.key({ modkey, &quot;Shift&quot;   }, &quot;,&quot;,
     function (c)
         local curidx = awful.tag.getidx(c:tags()[1])
         if curidx == 1 then
             c:tags({screen[mouse.screen]:tags()[9]})
         else
             c:tags({screen[mouse.screen]:tags()[curidx - 1]})
         end
     end),
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;.&quot;,
   function (c)
         local curidx = awful.tag.getidx(c:tags()[1])
         if curidx == 9 then
             c:tags({screen[mouse.screen]:tags()[1]})
         else
             c:tags({screen[mouse.screen]:tags()[curidx + 1]})
         end
     end)

=== Awesome 3.5 ===

  awful.key({ modkey, &quot;Shift&quot;   }, &quot;,&quot;,
    function (c)
        local curidx = awful.tag.getidx()
        if curidx == 1 then
            awful.client.movetotag(tags[client.focus.screen][9])
        else
            awful.client.movetotag(tags[client.focus.screen][curidx - 1])
        end
    end),
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;.&quot;,
    function (c)
        local curidx = awful.tag.getidx()
        if curidx == 9 then
            awful.client.movetotag(tags[client.focus.screen][1])
        else
            awful.client.movetotag(tags[client.focus.screen][curidx + 1])
        end
    end)


These functions must be placed in the clientkeys table.

== Drag Window to Workspace Left/Right ==

This script adds drag window left/right functionality similar to OpenBox (alt+shift+left|right) or Gnome 2 (alt+ctrl+shift+left|right) type functionality. This script should work for any number of tags/workspaces and have multi-screen support.  The keybindings are &quot;mod4+shift+left&quot; and &quot;mod4+shift+right&quot;

These functions must be placed in the clientkeys table.


=== Awesome 3.5 ===

-- Drag windows left and right
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;Left&quot;,
    function (c)
       local curidx = awful.tag.getidx()
       if curidx == 1 then
           awful.client.movetotag(tags[client.focus.screen][#tags[client.focus.screen]])
       else
           awful.client.movetotag(tags[client.focus.screen][curidx - 1])
       end
       awful.tag.viewidx(-1)
   end),
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;Right&quot;,
   function (c)
       local curidx = awful.tag.getidx()
       if curidx == #tags[client.focus.screen] then
           awful.client.movetotag(tags[client.focus.screen][1])
       else
           awful.client.movetotag(tags[client.focus.screen][curidx + 1])
       end
       awful.tag.viewidx(1)
   end),

=== Awesome 3.4 ===
Please write one.</text>
      <sha1>k8ywk25ry7s0m1km157vxrbabidb28o</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move Window to Workspace Left/Right/ru</title>
    <ns>0</ns>
    <id>1116</id>
    <revision>
      <id>6764</id>
      <timestamp>2014-06-09T18:36:32Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Move Window to Workspace Left/Right (translating page)</comment>
      <text xml:space="preserve" bytes="4390">{{Languages|Move Window to Workspace Left/Right}}

== Перемещение окна на рабочее пространство влево/вправо ==

Стандартный конфигурационный файл rc.lua включает клавиатурные сочетания для перемещения выделенного окна на перечисленный тег, в качестве альтернативного способа можно перемещать окна на один тег влево или вправо. Следующие функции для клавиатруных сочетаний выполняют эту задачу, перемещая выделенное окно на одно рабочее пространство влево или вправо  (и прикрепляет их к краям).

Этот скрипт предполагает, что существует ровно 9 тегов на экран, каждый из которых имеет уникальное значение индекса. Если выделенное окно имеет более чем один тег, оно будет перемещена влево/вправо от самого левого тега, и потеряет все остальные теги. Клавиатурное сочетание &quot;mod4+shift+,&quot; и &quot;mod4+shift+.&quot; взяты потому что они означают &lt; и &gt; клавиши на большинстве клавиатур.

=== Awesome 3.4 ===

 awful.key({ modkey, &quot;Shift&quot;   }, &quot;,&quot;,
     function (c)
         local curidx = awful.tag.getidx(c:tags()[1])
         if curidx == 1 then
             c:tags({screen[mouse.screen]:tags()[9]})
         else
             c:tags({screen[mouse.screen]:tags()[curidx - 1]})
         end
     end),
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;.&quot;,
   function (c)
         local curidx = awful.tag.getidx(c:tags()[1])
         if curidx == 9 then
             c:tags({screen[mouse.screen]:tags()[1]})
         else
             c:tags({screen[mouse.screen]:tags()[curidx + 1]})
         end
     end)

=== Awesome 3.5 ===

  awful.key({ modkey, &quot;Shift&quot;   }, &quot;,&quot;,
    function (c)
        local curidx = awful.tag.getidx()
        if curidx == 1 then
            awful.client.movetotag(tags[client.focus.screen][9])
        else
            awful.client.movetotag(tags[client.focus.screen][curidx - 1])
        end
    end),
  awful.key({ modkey, &quot;Shift&quot;   }, &quot;.&quot;,
    function (c)
        local curidx = awful.tag.getidx()
        if curidx == 9 then
            awful.client.movetotag(tags[client.focus.screen][1])
        else
            awful.client.movetotag(tags[client.focus.screen][curidx + 1])
        end
    end)


Эти функции должны быть размещены в таблице clientkeys.

== Перетаскиваение окна на рабочее пространство влево/вправо ==

Этот скрипт добавляет возможность перетащить окно влево/вправо, наподобие функциональности OpenBox (alt+shift+left|right) или Gnome 2 (alt+ctrl+shift+left|right). Этот скрипт будет работать для любого колличества тегов, а также поддерживает многоэкранность. Клавиатурные сочетание &quot;mod4+shift+left&quot; и &quot;mod4+shift+right&quot;

Эти функции должны быть размещены в секции clientkeys.


=== Awesome 3.5 ===

-- Drag windows left and right
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;Left&quot;,
    function (c)
       local curidx = awful.tag.getidx()
       if curidx == 1 then
           awful.client.movetotag(tags[client.focus.screen][#tags[client.focus.screen]])
       else
           awful.client.movetotag(tags[client.focus.screen][curidx - 1])
       end
       awful.tag.viewidx(-1)
   end),
 awful.key({ modkey, &quot;Shift&quot;   }, &quot;Right&quot;,
   function (c)
       local curidx = awful.tag.getidx()
       if curidx == #tags[client.focus.screen] then
           awful.client.movetotag(tags[client.focus.screen][1])
       else
           awful.client.movetotag(tags[client.focus.screen][curidx + 1])
       end
       awful.tag.viewidx(1)
   end),

=== Awesome 3.4 ===
Пожалуйста заполните сами.</text>
      <sha1>c39xaho81qest706jzv3ee2dy0zikok</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Move all clients to another tag</title>
    <ns>0</ns>
    <id>1307</id>
    <revision>
      <id>7345</id>
      <parentid>7344</parentid>
      <timestamp>2015-09-13T15:59:40Z</timestamp>
      <contributor>
        <username>Jk121960</username>
        <id>1023</id>
      </contributor>
      <text xml:space="preserve" bytes="1596">
== '''Awesome 3.4''' ==


One of the items in my disorganized approach to things leads me to need a way to move all clients on a tag to another tag on the same screen. At the same time I will also show the use of the keypad numbers rather then the top row static number keys, this facilitates in my use a simpler two hand technique. 

I could have probably forced this as an inline but I thought this was easier on the eyes as a simple function. I located this above the keybindings in the &quot;clientkeys&quot; table.

&lt;pre&gt;
local sendclientstotag = function (c,t) 
    local clients = awful.client.tiled(c.screen)
    
    local i = 1
    while clients[i]
    do
        awful.client.movetotag(tags[c.screen][t]) 
            i = i + 1
        end
end 
&lt;/pre&gt;

Below is the type of binding that I am using to utilize this with the right keypad numbers. This will cover all nine default tags on a screen.

&lt;pre&gt;
    awful.key({modkey,&quot;a&quot; },&quot;#87&quot;, function(c) sendclientstotag(c,1) end ),
    awful.key({modkey,&quot;a&quot; },&quot;#88&quot;, function(c) sendclientstotag(c,2) end ),
    awful.key({modkey,&quot;a&quot; },&quot;#89&quot;, function(c) sendclientstotag(c,3) end ),
    awful.key({modkey,&quot;a&quot; },&quot;#83&quot;, function(c) sendclientstotag(c,4) end ),
    awful.key({modkey,&quot;a&quot; },&quot;#84&quot;, function(c) sendclientstotag(c,5) end ),
    awful.key({modkey,&quot;a&quot; },&quot;#85&quot;, function(c) sendclientstotag(c,6) end ),
    awful.key({modkey,&quot;a&quot; },&quot;#79&quot;, function(c) sendclientstotag(c,7) end ),
    awful.key({modkey,&quot;a&quot; },&quot;#80&quot;, function(c) sendclientstotag(c,8) end ),
    awful.key({modkey,&quot;a&quot; },&quot;#81&quot;, function(c) sendclientstotag(c,9) end ),

&lt;/pre&gt;</text>
      <sha1>3tbv0bl4kxlxm04vkh62te4s3jtfp2x</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Moving client from the keyboard</title>
    <ns>0</ns>
    <id>176</id>
    <revision>
      <id>3578</id>
      <parentid>1319</parentid>
      <timestamp>2009-09-07T09:02:05Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="4659">The following allows to move a floating client or a client in a floating layout:&lt;br&gt;
- of 5px in any direction with modkey and the keypad numbers.&lt;br&gt;
- to the screen's working area border with modkey + ctrl and the keypad numbers.&lt;br&gt;

&lt;pre&gt;
k_m = { modkey }
k_ms = { modkey , &quot;Shift&quot;}
&lt;/pre&gt;

&lt;pre&gt;
function floats(c)
  local ret = false
  local l = awful.layout.get(c.screen)
  if awful.layout.getname(l) == 'floating' or awful.client.floating.get(c) then
    ret = true
  end
  return ret
end
&lt;/pre&gt;

and in clientkeys:
&lt;pre&gt;
-- move floating windows
    awful.key(k_m, &quot;KP_End&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        g.x = g.x - 5
        g.y = g.y + 5
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_m, &quot;KP_Down&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        g.y = g.y + 5
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_m, &quot;KP_Next&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        g.x = g.x + 5
        g.y = g.y + 5
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_m, &quot;KP_Left&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        g.x = g.x - 5
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_m, &quot;KP_Right&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        g.x = g.x + 5
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_m, &quot;KP_Home&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        g.x = g.x - 5
        g.y = g.y - 5
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_m, &quot;KP_Up&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        g.y = g.y - 5
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_m, &quot;KP_Prior&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        g.x = g.x + 5
        g.y = g.y - 5
        c:geometry(g)
        mouse_warp(c)
      end
    end),

    -- move floating windows to screen edges
    awful.key(k_ms, &quot;KP_End&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = 0 + w.x
        g.y = w.height - g.height + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_ms, &quot;KP_Down&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = (w.width - g.width)/2 + w.x
        g.y = w.height - g.height + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_ms, &quot;KP_Next&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = w.width - g.width + w.x
        g.y = w.height - g.height + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_ms, &quot;KP_Left&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = 0 + w.x
        g.y = (w.height - g.height)/2 + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_ms, &quot;KP_Begin&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = (w.width - g.width)/2 + w.x
        g.y = (w.height - g.height)/2 + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_ms, &quot;KP_Right&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = w.width - g.width + w.x
        g.y = (w.height - g.height)/2 + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_ms, &quot;KP_Home&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = 0 + w.x
        g.y = 0 + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_ms, &quot;KP_Up&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = (w.width - g.width)/2 + w.x
        g.y = 0 + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
    awful.key(k_ms, &quot;KP_Prior&quot;, function(c)
      if floats(c) then
        local g = c:geometry()
        local w = screen[c.screen].workarea
        g.x = w.width - g.width + w.x
        g.y = 0 + w.y
        c:geometry(g)
        mouse_warp(c)
      end
    end),
&lt;/pre&gt;

[[Category:awesome3]]</text>
      <sha1>gsfr4pxbkinyu1814br1f21tlzdejxt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Music Player Daemon (MPD)</title>
    <ns>0</ns>
    <id>16</id>
    <revision>
      <id>1284</id>
      <timestamp>2008-10-16T14:59:36Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1366">== Print mpd information ==
You will need [http://www.musicpd.org/mpc.shtml mpc] (and [http://www.musicpd.org/ mpd] - of course).

Create a textbox with name ''tb_mpd'':

&lt;code&gt;textbox tb_mpd { x=290  width = 610  align = &quot;left&quot; }&lt;/code&gt;

Create an awk-file with name ''~/awesome-mpd.awk'':

 #!/bin/awk -f
 function print_data()
 {
     data =  &quot;0 widget_tell tb_mpd &quot;mpd_msg&quot;\n&quot;;
     print data;
 }
 BEGIN {
   INTERVAL = 1;             # in seconds
 }
 { 
   while (!system(&quot;sleep &quot; INTERVAL))
   {
     mpd_lines=0
     while ( (&quot;mpc&quot; | getline) &gt; 0){
         mpd_info[mpd_lines]=$0
         if (mpd_lines==1) {mpd_time=$3}
         mpd_lines+=1;
     }
     close(&quot;mpc&quot;);
     if (mpd_lines==1) {
         mpd_msg=&quot;mpd not playing&quot;;
     } else {
         mpd_msg=mpd_info[0];
         if (mpd_info[1]~/paused/) { mpd_msg=&quot;&lt;&quot;mpd_msg&quot;&gt;&quot; }
         mpd_msg=mpd_msg&quot; (&quot;mpd_time&quot;)&quot;
     }
     print_data();
   }
 }

This awk-script based on [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status.awk calmar-awesome-status], and you can put this (or any other) awk-file.

If you start ''awesome'' with [http://www.linuxcommand.org/man_pages/startx1.html startx] then put your ''~/.xinitrc'' (before ''awesome''):

&lt;code&gt;awk -f ~/awesome-mpd.awk &lt;&lt;&lt; &quot;&quot; &amp;&lt;/code&gt;

See:
[[Making_a_Status_Bar_II]]

[[Category:Widgets]]
[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>4pcd2ujv6qu9isbk7ujcl96d4lczrlr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Mutt (incl. gmail) widget</title>
    <ns>0</ns>
    <id>77</id>
    <revision>
      <id>2791</id>
      <parentid>1285</parentid>
      <timestamp>2009-05-23T11:27:09Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Widgets]]</comment>
      <text xml:space="preserve" bytes="1164">If you use [http://www.mutt.org mutt] to read your emails then you may find this &quot;widget&quot; useful.

Create a script named ''awesome-mutt'' and put it a directory (in $PATH or you must use full path)
 #!/bin/bash
 if [ $1 -gt 0 ]; then RESULT=$1; else RESULT=&quot;None&quot;; fi
 echo 0 widget_tell sb_status tb_gmail text ${RESULT} unread mail | awesome-client
(of course you must change ''sb_status'' and ''tb_gmail'' to the correct statusbar-name and textbox-name)

And in ''.muttrc'' (or an included config-file):
 set status_format=&quot;awesome-mutt %u|&quot;
Please put the full path if necessary!

If you (want to) use mutt as a gmail-client, put to ''~/.muttrc'' the next lines:

 set from=username@gmail.com
 set use_from=yes
 set realname=&quot;Real Name&quot;
 set envelope_from=yes
 set spoolfile = imaps://imap.gmail.com/INBOX
 set folder = imaps://imap.gmail.com/
 set imap_user = 'username@gmail.com'
 set imap_pass = 'password'
 set header_cache=~/.mutt/hcache
 set message_cachedir=&quot;~/.mutt/msgcache/&quot;
 set sort = threads
 set move = no
 unset imap_passive
 set imap_check_subscribed
 set mail_check=60
 set timeout=10
 set net_inc=5

[[Category:awesome2]]
[[Category:Widgets]]</text>
      <sha1>q6bi3cn0bygnldqq0eyw6rxugset8m4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>My first awesome</title>
    <ns>0</ns>
    <id>526</id>
    <revision>
      <id>7368</id>
      <parentid>7367</parentid>
      <timestamp>2015-10-12T19:46:17Z</timestamp>
      <contributor>
        <username>Pghpete</username>
        <id>4303</id>
      </contributor>
      <minor/>
      <comment>removed outdated tag</comment>
      <text xml:space="preserve" bytes="11083">{{Template:Languages|My first awesome}}

This little tutorial is for people who never used a tiling window manager before and don't have fancy hacking skills. We will explore the awesome world of awesome step by step and finally come up with a working desktop, providing some basic knowledge on how to configure awesome in the process. We will start with the default rc.lua that comes with awesome, play around a little and try to make it more beautiful and useful with widgets. For this tutorial you don't need any programming skills besides using a text editor.

==Explore Awesome==
I will assume that you properly installed awesome through your distro's package manager or compiled it from source.
You should now add ''exec awesome'' to your '''~/.xinitrc'''. As already mentioned, awesome provides a default config file which will be our starting point. You will usually find this '''rc.lua''' file in '''/etc/xdg/awesome/'''. Copy it to '''~/.config/awesome/''', and then start X.
/!\ You should copy the whole directory, copying only the '''rc.lua''' will probably cause it to be ignored!

Move your Mouse to the upper left corner and click on the awesome logo. A little menu opens. Browse through the menu, then click the logo again to close it. Next to the awesome menu you see numbers 1-9. These are your tags (or desktops if
you want). You can click on these to change them but nothing will happen because we have not opened any programs. On the top right you see the time/date and a symbol showing the current layout. You can also click on the symbol to change the active layout.

One of awesome's big advantages over other tiling window managers is its good mouse support. Awesome can act as a full floating window manager (almost like
openbox) if you want.
For this basic tutorial we will mainly focus on keyboard control, so let's learn some key bindings now.

Let's open a terminal: press '''Mod4+Enter'''. Mod4 is your &quot;Windows key&quot;, the key between Ctrl and Alt. You can change the ''modkey'' if you want, but we'll get to that later.
An xterm window will pop up. You can of course use your favourite terminal if you like. Again, more on that later.
Now press '''Mod4+Shift+c''' to close the terminal. This is the command which lets you close any application. 
Awesome has a very elegant way to launch programs: press '''Mod4+r'''. Now you will see a ''Run:'' prompt in the status bar. Start anything you like, it also features Tab-completion!

Open another application. And another (another...) to see the tiling features. You can now press '''Mod4+Space''' to cycle through all the possible tiling (and floating) modes. Note that the icon in the upper right changes.

Also try '''Mod4+h''', '''Mod4+l''', '''Mod4+Shift+h''' and '''Mod4+Shift+l''' to resize Windows.
You can also resize with '''Mod4+Button3''' (right click).
'''Mod4+f''' will make your current window fullscreen.

With '''Mod4+Number''' (1-9) you can browse through your tags. With '''Mod4+Shift+Number''' (1-9) you can send a window to a specific tag. '''Mod4+Left''' and '''Mod4+Right''' moves to the next tag in the specified direction.

Use '''Mod4+k''' and '''Mod4+j''' to toggle your focused client - moving your mouse will also do that if you haven't figured that out yet.

'''Mod4+Shift+q''' quits awesome, but don't do that now.

Read the man page for all key bindings (type ''man awesome'' in console), you will find many more useful ones. The man page is accessible through the awesome menu as well - press '''Mod4+w''' to bring it up.

==Change the theme==

Awesome has three themes you can choose from: ''default'', ''sky'' and ''zenburn''. There are also many user contributed themes you can find in [[Beautiful_themes]].

To change the theme, open your rc.lua and edit this line near the beginning of the file:

beautiful.init(awful.util.getdir(&quot;config&quot;) .. &quot;/themes/default/theme.lua&quot;)

For this tutorial, I will stick with the default theme. Read the [[Beautiful]] wiki to find out more about theming.

==Change the background image==

Your desktop background image is handled in your theme file (theme.lua in your theme's directory).
To change it, edit this line in your theme file:

  theme.wallpaper = &quot;/usr/share/awesome/themes/default/background.png&quot;

==Personalize your tags==

To optimize our workflow, we now want to give names to our tags and set the specific tiling or floating mode for each one.
Open your '''rc.lua''' and find the layouts section. It should look like this:

  layouts =
  {
      awful.layout.suit.tile,
      awful.layout.suit.tile.left,
      awful.layout.suit.tile.bottom,
      awful.layout.suit.tile.top,
      awful.layout.suit.fair,
      awful.layout.suit.fair.horizontal,
      awful.layout.suit.spiral,
      awful.layout.suit.spiral.dwindle,
      awful.layout.suit.max,
      awful.layout.suit.max.fullscreen,
      awful.layout.suit.magnifier,
      awful.layout.suit.floating
  }

These are all possible tiling and floating options awesome has.
Personally, I don't find all of the layouts useful (for example the spiral layout). You can comment them out using &quot;--&quot; to begin the line.

This is my personal opinion and may be different from yours, so carefully test each layout first. I will leave them unchanged for now.

Next, we want to name our tags. This is the default tag screen with numbers from 1 to 9:

  -- {{{ Tags
  -- Define a tag table which will hold all screen tags.
  tags = {}
  for s = 1, screen.count() do
      -- Each screen has its own tag table.
      tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s)
  end
  -- }}}

Now we want to change the tag names and assign a specific layout to each one of them. By default, each tag has a floating layout. To change this, we define a specific tiling or floating layout for each tag.
Replace the above with this code:
  -- {{{ Tags
  -- Define a tag table which will hold all screen tags.
  tags = {
    names  = { &quot;main&quot;, &quot;www&quot;, &quot;skype&quot;, &quot;gimp&quot;, &quot;office&quot;, &quot;im&quot;, 7, 8, 9 },
    layout = { layouts[1], layouts[2], layouts[1], layouts[5], layouts[6],
               layouts[12], layouts[9], layouts[3], layouts[7]
  }}
  for s = 1, screen.count() do
      -- Each screen has its own tag table.
      tags[s] = awful.tag(tags.names, s, tags.layout)
  end
  -- }}}

[[File:awesome-custom-tags.png|200px|thumb|alt=screenshot with personalized tags|default rc.lua with personalized tags.]]

We use ''layouts'' to set the layout for each tag. The Number in &quot;[]&quot; is the
number of the layout.
In this example we set ''main'' to the ''tile'' layout, ''www'' to ''tile.left'', ''im'' to ''floating'', etc.
Edit this as you like.

While we're at it, we can also change the default terminal, editor and assign the modkey to a different key:

  terminal = &quot;xterm&quot;
  editor = os.getenv(&quot;EDITOR&quot;) or &quot;nano&quot;
  modkey = &quot;Mod4&quot;

Change these settings to your liking, it's pretty self-explanatory and well-documented in the comments. 

Save your '''rc.lua''' and restart awesome. Now your screen should resemble the screenshot on the right.
Note that awesome is very sensitive to mistakes in your '''rc.lua'''. Even minor errors can crash it. You can save yourself some of the trouble caused by a bad configuration by checking for syntax errors with '''awesome -k'''.

'''&quot;Mod4+ctrl+r&quot;''' will restart awesome once your syntax check above passes.

==Add widgets==

Now we want to add some useful information to our status bar. This is done through widgets. Such as widgets for displaying memory usage, CPU temperature, battery status, etc. You can learn all about widgets, and how to create them on the [[Widgets in awesome]] page.

Some users created widget libraries applying the above principles, they try to simplify widget creation for others. Another advantage of widget libraries is the big number of system monitors they are distributed with, so you don't have to write your own. Many different libraries exist, but for this guide we will stick to the [[Vicious]] widget library, since it provides everything we need. For more advanced widgets that do more complex tasks, explore the [[Obvious]] widget library. Read the wiki [[Vicious|entry]] how to install Vicious (it's easy).

Then, add

  local vicious = require(&quot;vicious&quot;)

to the beginning of your '''rc.lua'''.
We now want a widget indicating our current network download and upload rate.
Vicious provides a netwidget which is perfect for us.

Add this code to your rc.lua right after &quot;-- {{{ Wibox&quot; and before the &quot;textclock&quot;
widget which is already there:

  -- {{{ Wibox
  --  Network usage widget
  -- Initialize widget, use widget({ type = &quot;textbox&quot; }) for awesome &lt; 3.5
  netwidget = wibox.widget.textbox()
  -- Register widget
  vicious.register(netwidget, vicious.widgets.net, '&lt;nowiki&gt;&lt;span color=&quot;#CC9393&quot;&gt;${eth0 down_kb}&lt;/span&gt; &lt;span color=&quot;#7F9F7F&quot;&gt;${eth0 up_kb}&lt;/span&gt;&lt;/nowiki&gt;', 3)

To actually see the widget, we have to add it to our wibox. Add ''netwidget'' as indicated below:

    -- Widgets that are aligned to the right
    local right_layout = wibox.layout.fixed.horizontal()
    if s == 1 then right_layout:add(wibox.widget.systray()) end
    right_layout:add(netwidget) --ADD THIS
    right_layout:add(mytextclock)
    right_layout:add(mylayoutbox[s])


Now restart awesome to see the changes. '''&quot;Mod4+ctrl+r&quot;'''.

You can also add some nice widget icons to further enhance the status bar.
You can choose among many different icons sets on the [[Nice Icons]] page. In this example I used icons that were already on my system.
To display icons, we first have to set them in our theme file.
Open your '''theme file''' (theme.lua) and add the following:

  theme.widget_net = &quot;/usr/share/icons/Adwaita/16x16/actions/go-down.png&quot;
  theme.widget_netup = &quot;/usr/share/icons/Adwaita/16x16/actions/go-up.png&quot;

Don't forget to '''change your path''', usually it should be '''~/.config/awesome/icons/'''.

Next, add the following to your '''rc.lua''', right where you put the widget:

  dnicon = wibox.widget.imagebox()
  upicon = wibox.widget.imagebox()
  dnicon:set_image(theme.widget_net)
  upicon:set_image(theme.widget_netup)

These lines goes after the theme definition.

Then add the icons to your Wibox, right before and after the &quot;netwidget&quot;:

  -- Widgets that are aligned to the right
  local right_layout = wibox.layout.fixed.horizontal()
  if s == 1 then right_layout:add(wibox.widget.systray()) end                        
  right_layout:add(upicon) --ADD THIS
  right_layout:add(netwidget) --we added this earlier
  right_layout:add(dnicon) --ADD THIS
  right_layout:add(mytextclock)
  right_layout:add(mylayoutbox[s])

Restart with '''Mod4-Ctrl-r''' to see the final result.    

[[File:awesome_final.png|200px|thumb|alt=screenshot of the final desktop with tags vicious widget|our final desktop with a network widget and icons]]

That's it. You now learned how to add widgets to your status bar.
Read the [[Vicious]] wiki and the Readme file to learn how to add other widgets. 
You might also want to have a look at the [[Obvious]] widget package,
which is also pretty straightforward to use.</text>
      <sha1>1h0hrdkcudsddrubd5ad5svovkoey73</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>My first awesome/ru</title>
    <ns>0</ns>
    <id>687</id>
    <revision>
      <id>6503</id>
      <parentid>6493</parentid>
      <timestamp>2014-05-14T08:23:45Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <minor/>
      <comment>Add [[Template:Outdated]]</comment>
      <text xml:space="preserve" bytes="21390">{{Outdated}}
{{Template:Languages|My first awesome}}
{{DISPLAYTITLE:Мой первый awesome}}

Это небольшое руководство предназначено для людей, которые никогда не использовали тайлинговые менеджеры окон и не обладают продвинутыми способностями и/или желанием глубоко разбираться во всём этом. Мы исследуем замечательный мир awesome шаг за шагом и в конце концов придем к работающему рабочему столу, попутно получив базовые знания в настройке awesome. Мы начнем с дефолтного файла rc.lua, который устанавливается вместе с awesome, поиграем с ним немного и попробуем сделать его более красивым и полезным с помощью виджетов. Для этого руководства вам не нужны никакие умения программирования кроме использования текстового редактора.

==Исследование Awesome==

Я предполагаю, что вы уже установили awesome с помощью пакетного менеджера или скомпилировали из исходников. Теперь добавьте строку ''exec awesome'' в ваш '''~/.xinitrc''' ''(Если у вас нет такого файла и вы пользуетесь gdm/xdm/иным менеджером дисплеев, пропустите этот пункт)''. Как было сказано выше, awesome предоставляет дефолтный файл конфигурации, от которого мы будем отталкиваться. Вы можете найти этот файл под названием '''rc.lua''' в '''/etc/xdg/awesome/'''. Скопируйте его в '''~/.config/awesome/''' и запускайте Иксы.

''Примечание: awesome сначала грузит файл из пользовательской директории, а потом уже из /etc. То есть, если вы испортите свой пользовательский rc.lua, то awesome загрузится со второго, дефолтного и правильного. Поэтому совет - не редактируйте файл в /etc/xdg/awesome, иначе можете убить awesome совсем!''

Переместите курсор мыши в левый верхний угол и нажмите по иконке awesome. Откроется небольшое меню. Просмотрите пункты меню, потом нажмите на иконку снова чтобы закрыть его. Справа от иконки вы увидите цифры от 1 до 9. Это ваши теги (или рабочие столы). Вы можете щёлкнуть по одному из них, но ничего не изменится (так как мы еще не открыли ни одной программы). Справа вверху вы можете увидеть дату/время и иконку, которая отображает текущее расположение окон (layout). Вы также можете кликнуть по этой иконке чтобы изменить активное расположение.

Одним из преимуществ awesome перед другими тайлинговыми оконными менеджерами является хорошая поддержка мыши. Если пожелаете, awesome может вести себя как полноценный менеджер плавающих окон (почти как openbox). Но на время этого базового руководства мы сфокусируемся в основном на управлении с клавиатуры.

Давайте откроем терминал: нажмите ''Mod4+Enter''. Mod4 - это ваша кнопка &quot;Windows&quot;, или &quot;Super&quot;, находящаяся между Ctrl и Alt. Вы сможете по желанию изменить ваш '''modkey''', но мы вернемся к этому позже. Итак, открылось окно xterm. Конечно же, вы сможете заменить его на другой ваш любимый терминал (опять таки, чуть позже). Теперь нажмите ''Mod4+Shift+c'' чтобы закрыть терминал. Эта команда, которая позволяет вам закрыть любое приложение. В awesome есть очень элегантный способ запускать программы: нажать ''Mod4+r'' (это аналог Shift+F2 в Gnome, например). Вы увидите надпись '''Run:''' вверху на панели awesome. Кроме простого введения комманды, вы также можете дополнять ее Tab-ом.

Откройте еще одно приложение. И еще одно. Они нужны нам чтобы проверить тайлинг-возможности. Теперь вы можете нажимать 'Mod4+Space' чтобы просмотреть все возможные расположения окон. Заметьте, как иконка layout'а соответствует тому как программы расположены на экране.

Попробуйте комбинации ''Mod4+h'', ''Mod4+l'', ''Mod4+Shift+h'' и ''Mod4+Shift+l'' для изменения размера окна. Вы также можете изменить размер окна, зажав '''Mod4''' и правую клавишу мыши ('''Button3'''). '''Mod4+f''' развернет текущее окно на весь экран.

С помощью '''Mod4+Number''' (1-9) вы можете перемещаться между тегами. Комбинация '''Mod4+Shift+Number''' (1-9) посылает текущее окно на тег, указаный цифрой. '''Mod+Left''' и '''Mod+Right''' перемещают вас по тегам влево и вправо соответственно.

Используйте '''Mod4+k''' и '''Mod4+j''' чтобы переключаться между окнами внутри одного тега. Также это можно сделать просто наведя курсором мыши на нужное окно. Эта возможность называется sloppy focus и если она вам не нравится, ее можно будет позже отключить.

Чтобы выйти из awesome, нажмите '''Mod4+Shift+q'''. Но не спешите делать это, нам следует еще многому научится.

Прочитать о всех комбинациях клавиш можно в man-странице awesome (''man awesome'' в консоли). Но учтите - все комбинации клавиш вы сможете вскоре изменить, поэтому не утруждайте себя запоминаем всех комбинаций (а особенно неудобных и непривычных для вас) сейчас.

==Изменение темы==

Вместе с awesome поставляются три темы: ''default'', ''sky'', ''zenburn''. Существует также множество пользовательских тем, которые можно найти на странице [[Beautiful_themes/ru | Темы Beautiful]], если английский для вас не составляет особой проблемы, смотрите оригинальную страницу с темами [[Beautiful_themes| Theme Beautiful]] .

Чтобы изменить тему, откройте ваш файл rc.lua (напомним, тот, который находится в директории ~/.config/awesome/) и измените эту строку возле начала файла:

  beautiful.init(&quot;/usr/share/awesome/themes/default/theme.lua&quot;)

В этом руководстве, мы остановимся на теме по умолчанию. Развернутую информацию о темах в awesome можно найти на странице [[Beautiful/ru|Beautiful]].

==Изменение фонового изображения==

Фоновое изображение вашего рабочего стола задается в файле темы (theme.lua в директории вашей темы).
Чтобы изменить изображение, исправьте эту строку в файле темы:

  theme.wallpaper_cmd = { &quot;awsetbg /usr/share/awesome/themes/default/background.png&quot; }

==Персонализация тегов==

Для оптимизации вашего рабочего процесса, вы возможно захотите задать тегам свои имена и установить некоторым из них специфические layout-режимы.
Откройте ваш rc.lua и найдите секцию layout-ов. Она должна выглядеть следующим образом:

  layouts =
  {
      awful.layout.suit.tile,
      awful.layout.suit.tile.left,
      awful.layout.suit.tile.bottom,
      awful.layout.suit.tile.top,
      awful.layout.suit.fair,
      awful.layout.suit.fair.horizontal,
      awful.layout.suit.spiral,
      awful.layout.suit.spiral.dwindle,
      awful.layout.suit.max,
      awful.layout.suit.max.fullscreen,
      awful.layout.suit.magnifier,
      awful.layout.suit.floating
  }

Здесь указаны все возможные варианты расположения окон, которые присутствуют в awesome.
Лично мне не нужные некоторые расположения (например, спиральное). Мы можете закомментировать или удадить некоторые из них если считаете, что никогда не будете их использовать.

Это мое личное мнение, и оно может отличаться от вашего, поэтому сначала тщательно протестируйте каждый layout. Пока я оставлю их без изменений.

Теперь мы хотим дать имя каждому тегу. Вот как выглядит участок конфига с именами тегов по умолчанию (от 1 до 9):

  -- {{{ Tags
  -- Define a tag table which will hold all screen tags.
  tags = {}
  for s = 1, screen.count() do
      -- Each screen has its own tag table.
      tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s)
  end
  -- }}}

Мы хотим изменить имена тегов и назначить каждому из них свой layout. По умолчанию, на всех тегах изначально установлено плавающее расположение окон.
Замените верхний участок кода следующим:

  -- {{{ Tags
  -- Define a tag table which will hold all screen tags.
  tags = {
    names  = { &quot;main&quot;, &quot;www&quot;, &quot;skype&quot;, &quot;gimp&quot;, &quot;office&quot;, &quot;im&quot;, 7, 8, 9 },
    layout = { layouts[1], layouts[2], layouts[1], layouts[5], layouts[6],
               layouts[12], layouts[9], layouts[3], layouts[7]
  }}
  for s = 1, screen.count() do
      -- Each screen has its own tag table.
      tags[s] = awful.tag(tags.names, s, tags.layout)
  end
  -- }}}

[[File:awsm_tags.png|200px|thumb|alt=screenshot with personalized tags|конфиг по умолчанию с персонализироваными тегами.]]

Мы используем массив ''layouts'' чтобы задать расположение окон каждому тегу. Число в квадратных скобках - это номер layout-а.
В этом примере мы устанавливаем тегу ''main'' расположение ''tile'', тегу ''www'' - расположение ''tile.left'', ''im'' - плавающее расположение и т.д.
Вы можете настроить это как вам угодно.

Пока мы все еще в файле конфигурации, мы также можем изменить терминал по умолчанию, текстовый редактор и назначить другую клавишу в качестве ''modkey'':

  terminal = &quot;xterm&quot;
  editor = os.getenv(&quot;EDITOR&quot;) or &quot;nano&quot;
  modkey = &quot;Mod4&quot;

Измените эти параметры по вашему вкусу, они говорят сами за себя.

Сохраните ваш файл '''rc.lua''' и перезапустите awesome (можно выполнить из меню в левом верхнем углу - awesome - restart). Теперь ваш экран должен напоминать скриншот справа.
Обратите внимание, что awesome очень чувствителен к ошибкам в конфигурационном файле. Даже небольшие ошибки могут прекратить его работу. Вы можете уберечь себя от некоторых проблем, связанных с неправильным конфигом, проверив файл на синтаксические ошибки с помощью консольной комманды '''awesome -k'''.

==Добавление виджетов==

Теперь мы хотим добавить некоторую полезную информацию на нашу панель. Это можно сделать с помощью виджетов. Примером таких виджетов могут послужить отображение использования памяти, температуры CPU, заряда батарее и т.д. Вы можете узнать всё о виджетах и их создании на странице [[Widgets in awesome/ru | Виджеты в awesome]].

Некоторые пользователи создают целые библиотеки виджетов чтобы упростить создание виджетов для других. Существует множетсво подобных библиотек, но в этом руководстве мы остановимся на библиотеке [[Vicious]], так как она предоставляет всё необходимое нам. Как установить Vicious, описывается в этой [[Vicious|статье]], также Vicious устанавливается с пакетом '''awesome-extra'''.

Теперь, когда Vicious установлена, добавьте следующую строчку в начало вашего '''rc.lua''':

 vicious = require(&quot;vicious&quot;)

Нам нужен виджет, который будет отображать текущую скорость сетевой загрузки и выгрузки.
Vicious предоставляет нам ''netwidget'' - именно то, что нам нужно.

Добавьте этот код в ваш rc.lua после &quot;-- {{{ Wibox&quot; и до &quot;textclock&quot;:

  -- {{{ Wibox
  --  Network usage widget
  -- Initialize widget
  netwidget = widget({ type = &quot;textbox&quot; })
  -- Register widget
  vicious.register(netwidget, vicious.widgets.net, '&lt;nowiki&gt;&lt;span color=&quot;#CC9393&quot;&gt;${eth0 down_kb}&lt;/span&gt; &lt;span color=&quot;#7F9F7F&quot;&gt;${eth0 up_kb}&lt;/span&gt;&lt;/nowiki&gt;', 3)

Этим мы создали и инициализировали виджет. Но чтобы увидеть его, нам нужно сначала добавить его на наш wibox (''wibox - контейнер для виджетов в awesome''). После добавления ''netwidget'' ваша wibox-секция должна выглядеть следующим образом:

      -- Create the wibox
      mywibox[s] = awful.wibox({ position = &quot;top&quot;, screen = s })
      -- Add widgets to the wibox - order matters
      mywibox[s].widgets = {
          {
              mylauncher,
              mytaglist[s],
              mypromptbox[s],
              layout = awful.widget.layout.horizontal.leftright
          },
          mylayoutbox[s],
          mytextclock,
          netwidget,       --   Добавьте это и не забудьте запятую в конце!
          s == 1 and mysystray or nil,
          mytasklist[s],
          layout = awful.widget.layout.horizontal.rightleft
      }
  end
  -- }}}

Теперь перегрузите awesome и оцените результат.
Также вы можете добавить виджетам красивые иконки (некоторые из них можно найти на странице [[Nice Icons/ru|Значки для Awesome]]). Чтобы отобразить иконки, сначала нужно задать их в нашем файле темы. Откройте ваш файл темы ('''theme.lua''') и добавьте в него следующее:

  theme.widget_net = &quot;/path/to/icons/down.png&quot;
  theme.widget_netup = &quot;/patch/icons/icons/up.png&quot;

Не забудьте изменить ''/path/to/icons/'' на реальный путь к иконкам. Обычно это '''~/.config/awesome/icons/'''.

Теперь добавьте следующие строки в ваш '''rc.lua''' туда же, где вы вставили инициализацию вашего виджета:

  dnicon = widget({ type = &quot;imagebox&quot; })
  upicon = widget({ type = &quot;imagebox&quot; })
  dnicon.image = image(beautiful.widget_net)
  upicon.image = image(beautiful.widget_netup)

Теперь добавьте эти виджеты-иконки на wibox, сразу до и после вашего &quot;netwidget&quot;. Это будет выглядеть так:

    ..
    upicon, netwidget, dnicon,     
    ..

Перегрузите awesome чтобы увидеть окончательный результат.

[[File:awsm_final.png|200px|thumb|alt=screenshot of the final desktop with tags and vicious widget|наш конечный рабочий стол с виджетом сетевой загрузки, иконками и разделителем.]]

Последнее, что мы хотим сделать - это добавить разделитель между netwidget-ом и часами. Мы сделаем это с помощью обычного текстового виджета.
Добавьте эти строки в '''rc.lua''' туда же, где находится ваш предыдущий виджет:

  '''Awsome &lt; 3.5'''
  separator = widget({ type = &quot;textbox&quot; })
  separator.text  = &quot; :: &quot;
  '''Awesome 3.5'''
  separator = wibox.widget.textbox()
  separator:set_text(&quot; :: &quot;)

И теперь разместим разделитель на wibox-е:

    ..
    separator, upicon, netwidget, dnicon,
    ..

На этом всё. Вы научились как добавлять виджеты на вашу панель awesome.
Прочтите статью [[Vicious]] и файл Readme чтобы узнать как добавлять остальные виджеты.
Также вы можете ознакомиться с библиотекой виджетов [[Obvious]], которая также достаточно проста в использовании.

==Что дальше?==

Теперь вы можете самостоятельно изучать богатые возможности самого увлекательного тайлингового менеджера awesome.
В этом вам будет помогать эта wiki, которая является самым полным информационным ресурсом по awesome. Большинство ответов на ваши вопросы вы можете получить прямо на [[Main_Page/ru|главной странице]]. Если вы не нашли ответ на свой вопрос на вики, смело обращайтесь за помощью на почтовую рассылку ''awesome@naquadah.org'' (чтобы подписаться, отправьте письмо на ''awesome-subscribe@naquadah.org'') - сообщество awesome всегда радо помочь новичкам (правда исключительно на английском). Также вы можете написать на русском автору перевода данной статьи на почту ''yakushev.alex{ear}gmail.com''.

Удачи вам в освоении awesome!</text>
      <sha1>h8i4myrqcq83cn5zec3ireqlfyx26op</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>NASA IOTD Wallpaper</title>
    <ns>0</ns>
    <id>671</id>
    <revision>
      <id>6454</id>
      <parentid>4832</parentid>
      <timestamp>2014-05-06T16:32:44Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1980">{{Languages|NASA IOTD Wallpaper}}

== Credits ==
Credits to: [http://blog.quaternio.net/2009/04/13/nasa-image-of-the-day-as-gnome-background/ NASA Image of the day as Gnome background]

== Requirements ==
[http://linuxbrit.co.uk/software/feh/ feh]


run_once function (in your config):
&lt;pre&gt;
function run_once(prg)
    if not prg then
        do return nil end
    end
    awful.util.spawn_with_shell(&quot;pgrep -f -u $USER -x &quot; .. prg .. &quot; || (&quot; .. prg .. &quot;)&quot;)
end
&lt;/pre&gt;


nasaBackground.sh:
&lt;pre&gt;
#!/bin/bash
 
# grabs the nasa image of the day by RSS feed and updates the gnome
# background. add this to your cron jobs to have this happen daily.  this is,
# obviously, a hack, that is likely to break at the slightest change of NASA's
# RSS implementation. yay standards!

#EDITED FOR feh
 
rss=`wget -q -O - http://www.nasa.gov/rss/lg_image_of_the_day.rss`
 
img_url=`echo $rss | grep -o '&lt;enclosure [^&gt;]*&gt;' | grep -o 'http://[^\&quot;]*'`
 
img_name=`echo $img_url | grep -o [^/]*\.\w*$`
 
# this command is benign if the directory already exists.
mkdir -p $HOME/.backgrounds
 
# this command will overwrite the image if it already exists
wget -q -O $HOME/.backgrounds/$img_name $img_url
 
feh --bg-scale $HOME/.backgrounds/$img_name
&lt;/pre&gt;

== Install ==
Put the nasaBackground.sh script to anywhere in your ~/ folder. Mine's here: ~/scripts/nasaBackground.sh

Using the run_once function, simply sh the nasaBackground.sh script.
&lt;pre&gt;
run_once(&quot;sh /home/YOURUSERNAME/fooFolder/nasaBackground.sh&quot;)
&lt;/pre&gt;

== Notes ==
When Awesome WM is run, it will take some time to download the image of the day etc. before the image is actually used as background. Something like 20-30 seconds I'd guess.

Take note that eventually the .background folder, that is created, will become pretty large. So keep an eye out for it, and reguarly erase it.

This can easily be modified for any other wallpaper-making-application instead of feh. You only need to modify the last line of nasaBackground.sh</text>
      <sha1>3wu1lemxncaa5721yuga5p3w7tmyi5h</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>NASA IOTD Wallpaper/ru</title>
    <ns>0</ns>
    <id>1038</id>
    <revision>
      <id>6455</id>
      <timestamp>2014-05-06T16:50:56Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{Languages|NASA IOTD Wallpaper}} {{DISPLAYTITLE:Обои &quot;изображение дня NASA&quot;}}  == Предистория ==  [http://blog.quaternio.net/2009/04/13/nasa-imag...&quot;</comment>
      <text xml:space="preserve" bytes="3108">{{Languages|NASA IOTD Wallpaper}}
{{DISPLAYTITLE:Обои &quot;изображение дня NASA&quot;}}

== Предистория ==

[http://blog.quaternio.net/2009/04/13/nasa-image-of-the-day-as-gnome-background/ изображение дня NASA как фон в Gnome]

== Требования ==

Для полноценной работы данного скрипта необходимо установить [http://linuxbrit.co.uk/software/feh/ feh]

В ''rc.lua'' в раздел run_once(или то, что у вас его заменяет) добавьте следующий код
&lt;pre&gt;
function run_once(prg)
    if not prg then
        do return nil end
    end
    awful.util.spawn_with_shell(&quot;pgrep -f -u $USER -x &quot; .. prg .. &quot; || (&quot; .. prg .. &quot;)&quot;)
end
&lt;/pre&gt;

Создайте скриптовый файл nasaBackground.sh:
&lt;pre&gt;
#!/bin/bash
 
# Захватывает изображение дня NASA через RSS и обновляет фон Gnome
# Добавьте этот скрипт в cron, для ежедневного обновления. Этот способ 
# захвата изображений, использующий RSS можно легко сломать при изменении
# реализации RSS. Что поделать... стандарты 

#EDITED FOR feh
 
rss=`wget -q -O - http://www.nasa.gov/rss/lg_image_of_the_day.rss`
 
img_url=`echo $rss | grep -o '&lt;enclosure [^&gt;]*&gt;' | grep -o 'http://[^\&quot;]*'`
 
img_name=`echo $img_url | grep -o [^/]*\.\w*$`
 
# Эта команда неопасна, если каталог уже существует
mkdir -p $HOME/.backgrounds
 
# Следующая команда скачивает и перзаписывает изображение, если оно уже существует
wget -q -O $HOME/.backgrounds/$img_name $img_url
 
feh --bg-scale $HOME/.backgrounds/$img_name
&lt;/pre&gt;

== Установка ==
Поместите скрипт nasaBackground.sh в любую папку в домашнем каталоге(или любом месте, где вы храните свои скрипты) ~/ . 

Используйте функцию в ''rc.lua'' run_once, для испльзования скрипта при запуске.
&lt;pre&gt;
run_once(&quot;sh /home/YOURUSERNAME/fooFolder/nasaBackground.sh&quot;)
&lt;/pre&gt;

== Примечание ==
При запуске Awesome, необходимо некоторое время для загрузки нового изображения. Иногда это может занять 20-30 секунд.

Имейте в виду, что каталог с фонами ~/.background, который создается, со временем становится слишком большим. Поэтому периодически очищайте его.

Вы можете легко изменить скрипт, для использования другого wallpaper-making-application вместо feh. Все, что для этого нужно, изменить последнюю строчку скрипта nasaBackground.sh</text>
      <sha1>91v8brjvejo7bqo31x2u9khfhtd82li</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Naughty</title>
    <ns>0</ns>
    <id>170</id>
    <revision>
      <id>6275</id>
      <parentid>6274</parentid>
      <timestamp>2014-02-28T22:56:10Z</timestamp>
      <contributor>
        <username>Blueyed</username>
        <id>471</id>
      </contributor>
      <comment>/* Setting up Naughty */ Update example code: naughty.config.defaults is the new version</comment>
      <text xml:space="preserve" bytes="11061">{{Languages}}

Naughty is a lua library that implements popup notifications for awesome3 (git). 
It's included in current [http://git.naquadah.org/?p=awesome.git;a=summary awesome git master]. 
Development branch can be found at naughty branch of [http://git.mercenariesguild.net/?p=awesome.git;a=shortlog;h=refs/heads/naughty awesome git mirror].


== Setting up Naughty ==
First, you have to include the library in your ''rc.lua'':
&lt;pre&gt;require('naughty')&lt;/pre&gt;

For gentoo users, you must add ''dbus'' use for awesome:
&lt;pre&gt;sudo flaggie awesome +dbus&lt;/pre&gt;

If you wish to change default settings, you can redefine any of the following fields. For details refer to [http://awesome.naquadah.org/doc/api/modules/naughty.html#notify luadoc].
&lt;pre&gt;naughty.config.defaults.timeout          = 5
naughty.config.defaults.screen           = 1
naughty.config.defaults.position         = &quot;top_right&quot;
naughty.config.defaults.margin           = 4
naughty.config.defaults.height           = 16
naughty.config.defaults.width            = 300
naughty.config.defaults.gap              = 1
naughty.config.defaults.ontop            = true
naughty.config.defaults.font             = beautiful.font or &quot;Verdana 8&quot;
naughty.config.defaults.icon             = nil
naughty.config.defaults.icon_size        = 16
naughty.config.defaults.fg               = beautiful.fg_focus or '#ffffff'
naughty.config.defaults.bg               = beautiful.bg_focus or '#535d6c'
naughty.config.presetss.border_color     = beautiful.border_focus or '#535d6c'
naughty.config.defaults.border_width     = 1
naughty.config.defaults.hover_timeout    = nil
&lt;/pre&gt;

NOTE: in older versions of awesome `naughty.config.default_preset` appears to have been used (the example above works for 3.5.2).

== Using Naughty ==

To create a notification popup call naughty.notify({args}).  Typically you should use
&lt;pre&gt;naughty.notify({ text=&quot;notification content&quot;, icon=&quot;/path/to/icon&quot; })&lt;/pre&gt;


Note that arguments to naughty.notify() are optional. The above example will use pre-configured settings resulting in uniform looking popups with custom text and icon. If you wish to set things on a per-popup basis you can override the defaults by passing required settings with arguments:

&lt;pre&gt;naughty.notify({
    text = &quot;notification&quot;,
    title = &quot;title&quot;,
    position = &quot;top_left&quot;|&quot;top_right&quot;|&quot;bottom_left&quot;|&quot;bottom_right&quot;,
    timeout = 5,
    icon=&quot;/path/to/image&quot;,
    fg=&quot;#ffggcc&quot;,
    bg=&quot;#bbggcc&quot;,
    screen = 1,
    ontop = false, 
    run = function () awful.util.spawn(&quot;wicd-client&quot;) end
})&lt;/pre&gt;

Also note that you can use some html tags with naughty and thus any spare &lt; will not display.

== Feeding Naughty ==

Merely loading Naughty into your config will not produce any popups - the main problem is feeding it data. 

* To test the module you can call naughty.notify from Lua prompt. 
* You can call the function from any part of rc.lua (good for extra info from widgets?)
* To call the function from anything that can execute commands, use awesome-client:
&lt;pre&gt;echo 'naughty.notify({title = &quot;testing&quot;, text = &quot;naughty&quot;, timeout = 10})' | awesome-client -&lt;/pre&gt;

The last method is good for feeding data from acpid/ivman/etc. 

=== Examples===

==== Ivman ====
Taken from ''~/.ivman/IvmConfigActions.xml'':
&lt;pre&gt;&lt;ivm:Match name=&quot;hal.info.linux.driver&quot; value=&quot;usb&quot;&gt;
 &lt;ivm:Option name=&quot;exec&quot; value=&quot;echo naughty.notify\({timeout=15, title=\'USB device\',\
      text=\'$hal.info.product$\'}\) | awesome-client -&quot; /&gt;
&lt;/ivm:Match&gt;

&lt;ivm:Match name=&quot;hal.volume.is_mounted&quot; value=&quot;true&quot;&gt;
 &lt;ivm:Option name=&quot;exec&quot; \
      value=&quot;echo naughty.notify\({timeout=15,\ title=\'Mounted\',\
      text=\'$hal.block.device$ at $hal.volume.mount_point$ \($hal.volume.size$\)\'}\)\
      | awesome-client -&quot; /&gt;
&lt;/ivm:Match&gt;
       
&lt;ivm:Match name=&quot;hal.info.category&quot; value=&quot;storage&quot;&gt;
 &lt;ivm:Match name=&quot;hal.storage.drive_type&quot; value=&quot;disk&quot;&gt;
  &lt;ivm:Option name=&quot;exec&quot; value=&quot;echo naughty.notify\({timeout=15, title=\'New Volume\',\
       text=\'$hal.info.vendor$ $hal.info.product$ $hal.storage.size$\'}\) | awesome-client -&quot; /&gt;
 &lt;/ivm:Match&gt;
&lt;/ivm:Match&gt;&lt;/pre&gt;

==== rc.lua + curl / hack for *WRT/AutoAP network switch ====
AutoAP is a daemon script allowing OpenWRT/DD-WRT/etc. switch networks according to signal quality which is additionally monitored with ping. See DD-WRT [http://www.dd-wrt.com/wiki/index.php/Autoap Wiki] for more info.

&lt;pre&gt;
function dump_autoap()
   os.execute('curl -s http://gw/user/autoap.htm  &gt; /tmp/.awesome.autoap &amp;')
end

last_ap = &quot;none&quot;
function get_autoap()
   local ap = &quot;&quot;
   if info then return end
   local f = io.open('/tmp/.awesome.autoap')
   if not f then return end
   local line = f:read()
   f:close()
   if not line then return end

   local aar, beg = line:find('&lt;title&gt;')
   if line:sub(beg+32, beg+32) == 'S' then ap = &quot;&lt;span color=\&quot;#FF602E\&quot;&gt;searching...&lt;/span&gt;&quot;
   elseif line:sub(beg+32,beg+32) == 'C' then
      endd = line:find('&lt;/title&gt;', beg)
      ap = line:sub(beg+47,endd-2)
   end

   if ap ~= last_ap then 
     naughty.notify({title = &quot;AutoAP network&quot;, text = ap, timeout = 10})
     last_ap = ap 
   end
   return ap
end

function hook_10s()
  dump_autoap()
  get_autoap()
end

awful.hooks.timer.register(10, hook_10s)
&lt;/pre&gt;

==== rc.lua + dict / dictionary prompt with naughty output ====
&lt;pre&gt;keybinding({ modkey}, &quot;d&quot;, function ()
        info = true
        awful.prompt.run({ fg_cursor = &quot;black&quot;,bg_cursor=&quot;orange&quot;, prompt = &quot;&lt;span color='#008DFA'&gt;Dict:&lt;/span&gt; &quot; }, 
        mypromptbox[mouse.screen],
        function(word)
                local f = io.popen(&quot;dict -d wn &quot; .. word .. &quot; 2&gt;&amp;1&quot;)
                local fr = &quot;&quot;
                for line in f:lines() do
                fr = fr .. line .. '\n'
                end
                f:close()
                naughty.notify({ text = '&lt;span font_desc=&quot;Sans 7&quot;&gt;'..fr..'&lt;/span&gt;', timeout = 0, width = 400 })
        end,
        nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/dict&quot;) 
end):add()&lt;/pre&gt;

==== rc.lua / calculator prompt with naughty output ====
The below keybinding displays a calculator prompt (prefilled with the last result if exists) and displays a naughty popup with value of the expression. When clicked, the value is copied to the clipboard for pasting somewhere else. [http://omploader.org/veW1v screenshot]
&lt;pre&gt;val = nil
keybinding({ modkey}, &quot;c&quot;, function ()
    awful.prompt.run({  text = val and tostring(val),
            selectall = true,
            fg_cursor = &quot;black&quot;,bg_cursor=&quot;orange&quot;,
            prompt = &quot;&lt;span color='#00A5AB'&gt;Calc:&lt;/span&gt; &quot; }, mypromptbox,
            function(expr)
              val = awful.util.eval(expr)
              naughty.notify({ text = expr .. ' = &lt;span color=&quot;white&quot;&gt;' .. val .. &quot;&lt;/span&gt;&quot;,
                               timeout = 0,
                               run = function() io.popen(&quot;echo &quot;.. val .. &quot; | xsel -i&quot;):close() end, })
            end,
            nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/calc&quot;)
end):add()&lt;/pre&gt;

==== Using naughty for debugging lua code ====
With naughty it's very simple to check value of variables at any time you want. Forget print() and checking the console. To save yourself hassle of full syntax, you can put this function before the code you want to debug:
&lt;pre&gt;function dbg(vars)
    local text = &quot;&quot;
    for i=1, #vars do text = text .. vars[i] .. &quot; | &quot; end
    naughty.notify({ text = text, timeout = 0 })
end&lt;/pre&gt;
Now in the code you want to debug you can use the following line to see values in popups in realtime!
&lt;pre&gt;dbg({list, of, variables})&lt;/pre&gt;

[http://omploader.org/veTF4 screenshot]

==== Popup calendar ====
If you don't have much desktop space and your clock only shows the time, you can have the date/calendar popup on mouse hover. Use your scroll wheel to change the month you are viewing ([http://omploader.org/vemxo screenshot])

&lt;pre&gt;
    local calendar = nil
    local offset = 0

    function remove_calendar()
        if calendar ~= nil then
            naughty.destroy(calendar)
            calendar = nil
            offset = 0
        end
    end

    function add_calendar(inc_offset)
        local save_offset = offset
        remove_calendar()
        offset = save_offset + inc_offset
        local datespec = os.date(&quot;*t&quot;)
        datespec = datespec.year * 12 + datespec.month - 1 + offset
        datespec = (datespec % 12 + 1) .. &quot; &quot; .. math.floor(datespec / 12)
        local cal = awful.util.pread(&quot;cal -m &quot; .. datespec)
        cal = string.gsub(cal, &quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;)
        calendar = naughty.notify({
            text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, os.date(&quot;%a, %d %B %Y&quot;) .. &quot;\n&quot; .. cal),
            timeout = 0, hover_timeout = 0.5,
            width = 160,
        })
    end

-- change clockbox for your clock widget (e.g. mytextclock)
    mytextclock:add_signal(&quot;mouse::enter&quot;, function()
      add_calendar(0)
    end)
    mytextclock:add_signal(&quot;mouse::leave&quot;, remove_calendar)
 
    mytextclock:buttons(awful.util.table.join(
        button({ }, 4, function()
            add_calendar(-1)
        end),
        button({ }, 5, function()
            add_calendar(1)
        end)
    ))
&lt;/pre&gt;

== Feeding naughty via dbus ==
Get the latest awesome-git (next branch), naughty will listen on the dbus interface.
You can create notifications using notify-me, dbus-send, d-feet or just open any dbus-notification cable application e.g. gajim.

Using notify-send:
&lt;pre&gt;notify-send &quot;awesome is&quot; &quot;getting naughty&quot;&lt;/pre&gt;
Note that on Debian/Ubuntu systems, having the ''notification-daemon'' package installed will make notify-send calls be intercepted by Gnome (the notifications won't be displayed by naughty).

Using dbus-send:
&lt;pre&gt;dbus-send --dest=org.freedesktop.Notifications /org/freedesktop/Notifications  org.freedesktop.Notifications.Notify string:&quot;&quot; uint32:0 string:&quot;&quot; \
string:&quot;title&quot; string:&quot;text&quot; array:string:&quot;&quot; array:string:&quot;&quot; int32:-1&lt;/pre&gt;

== Suspending/Resuming Naughty ==

You can disable naughty temporarily, say when you are watching a movie, by calling &lt;code&gt;naughty.suspend()&lt;/code&gt;, and re-enable it later, by calling &lt;code&gt;naughty.resume()&lt;/code&gt;. Naughty stores all notifications that were send while it was suspended, and plays them back when resumed.

== Replacing Notifications ==

Certain events, changing volume for example, may require you to generate popups one after the other immediately. But you don't want these popups to stack together (making the window underneath inaccessible). And Awesome doesn't have the notify-osd yet. Here is a workaround shared by 'psychon' on the users' mailing list:

&lt;pre&gt;
$ echo 'return naughty.notify({ text = &quot;foo&quot;, timeout = 0 }).id' | awesome-client
double 1551
$ echo 'return naughty.notify({ text = &quot;foo2&quot;, timeout = 0, replaces_id = 1551 }).id' | awesome-client
double 1552
&lt;/pre&gt;

In essence, ''replace'' the previous notification with the newer one.

== To be naughtier ==

* stacking - new popups appearing 'before' old ones
* [http://www.galago-project.org/specs/notification/0.9/x320.html urgency levels]


[[Category:awesome3]]</text>
      <sha1>nlrj2bnigua0750fjb51n57qwz723kh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Naughty/Ru</title>
    <ns>0</ns>
    <id>1024</id>
    <revision>
      <id>6380</id>
      <parentid>6379</parentid>
      <timestamp>2014-04-30T07:00:11Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>Faiver moved page [[Ru:]] to [[Naughty/Ru]]: Коректное название</comment>
      <text xml:space="preserve" bytes="14083">{{Languages|Naughty}}

Naughty это lua библиотека реализующая всплывающие сообщения в awesome3 (git). 
Эта бибилотека включена в текущую [http://git.naquadah.org/?p=awesome.git;a=summary сборку awesome git].

== Подключение Naughty ==
Сначала, нужно подключить библиотеку в ваш ''rc.lua'':
&lt;pre&gt;require('naughty')&lt;/pre&gt;

Пользователям Gentoo, необходимо добавить ''dbus'' в awesome:
&lt;pre&gt;sudo flaggie awesome +dbus&lt;/pre&gt;

Если вы не хотите использовать настройки по умолчанию, вы можете переопределить любое из следующих полей. За подробностями обращайтесь на [http://awesome.naquadah.org/doc/api/modules/naughty.html#notify luadoc].
&lt;pre&gt;naughty.config.defaults.timeout          = 5
naughty.config.defaults.screen           = 1
naughty.config.defaults.position         = &quot;top_right&quot;
naughty.config.defaults.margin           = 4
naughty.config.defaults.height           = 16
naughty.config.defaults.width            = 300
naughty.config.defaults.gap              = 1
naughty.config.defaults.ontop            = true
naughty.config.defaults.font             = beautiful.font or &quot;Verdana 8&quot;
naughty.config.defaults.icon             = nil
naughty.config.defaults.icon_size        = 16
naughty.config.defaults.fg               = beautiful.fg_focus or '#ffffff'
naughty.config.defaults.bg               = beautiful.bg_focus or '#535d6c'
naughty.config.presetss.border_color     = beautiful.border_focus or '#535d6c'
naughty.config.defaults.border_width     = 1
naughty.config.defaults.hover_timeout    = nil
&lt;/pre&gt;

ПРИМЕЧАНИЕ: в старых версиях awesome использовалось `naughty.config.default_preset` (пример будет работать на версиях старше 3.5.2)

== Использование Naughty ==

Для создания всплывающего уведомления используйте naughty.notify({args}). Стандартное использование:
&lt;pre&gt;naughty.notify({ text=&quot;notification content&quot;, icon=&quot;/path/to/icon&quot; })&lt;/pre&gt;

Обратите внимание на то, что аргументы naughty.notify() можно дополнять. Приведенный выше пример использует предопределенные настройки, что приводит к уведомлению стандартного вида с заданным текстом и картинкой. Если вы не хотите использовать дефолтные настройки, вы можете переопределить значения по умолчанию, передав их в виде аргументов функции:

&lt;pre&gt;naughty.notify({
    text = &quot;notification&quot;,
    title = &quot;title&quot;,
    position = &quot;top_left&quot;|&quot;top_right&quot;|&quot;bottom_left&quot;|&quot;bottom_right&quot;,
    timeout = 5,
    icon=&quot;/path/to/image&quot;,
    fg=&quot;#ffggcc&quot;,
    bg=&quot;#bbggcc&quot;,
    screen = 1,
    ontop = false, 
    run = function () awful.util.spawn(&quot;wicd-client&quot;) end
})&lt;/pre&gt;

Также вы можете использовать некоторые html теги в naughty. Поэтому все, что находится за &lt; не будет отображено.

== Вызов Naughty ==

Простое добавление Naughty в ваш конфиг не выведет никаких уведомлений, для этого необходимо передать эти данные клиенту 
* Для проверки модуля вы можете вызвать naughty.notify из консоли Lua.
* Вы можете вызвать функцию из любого места rc.lua (лучшее место в виджете, не правда ли!)
* Вызвать функцию из консоли, используя awesome-client:
&lt;pre&gt;echo 'naughty.notify({title = &quot;testing&quot;, text = &quot;naughty&quot;, timeout = 10})' | awesome-client -&lt;/pre&gt;

Хорошим способом использования этого метода, является вызов в acpid/ivman/прочих.

=== Примеры ===

=== ivman ===

Взято из ''~/.ivman/IvmConfigActions.xml'':
&lt;pre&gt;&lt;ivm:Match name=&quot;hal.info.linux.driver&quot; value=&quot;usb&quot;&gt;
 &lt;ivm:Option name=&quot;exec&quot; value=&quot;echo naughty.notify\({timeout=15, title=\'USB device\',\
      text=\'$hal.info.product$\'}\) | awesome-client -&quot; /&gt;
&lt;/ivm:Match&gt;

&lt;ivm:Match name=&quot;hal.volume.is_mounted&quot; value=&quot;true&quot;&gt;
 &lt;ivm:Option name=&quot;exec&quot; \
      value=&quot;echo naughty.notify\({timeout=15,\ title=\'Mounted\',\
      text=\'$hal.block.device$ at $hal.volume.mount_point$ \($hal.volume.size$\)\'}\)\
      | awesome-client -&quot; /&gt;
&lt;/ivm:Match&gt;
       
&lt;ivm:Match name=&quot;hal.info.category&quot; value=&quot;storage&quot;&gt;
 &lt;ivm:Match name=&quot;hal.storage.drive_type&quot; value=&quot;disk&quot;&gt;
  &lt;ivm:Option name=&quot;exec&quot; value=&quot;echo naughty.notify\({timeout=15, title=\'New Volume\',\
       text=\'$hal.info.vendor$ $hal.info.product$ $hal.storage.size$\'}\) | awesome-client -&quot; /&gt;
 &lt;/ivm:Match&gt;
&lt;/ivm:Match&gt;&lt;/pre&gt;

==== rc.lua + curl / мониторинг переключения сети*WRT/AutoAP  ====
AutoAP это скипт демона позволяющий OpenWRT/DD-WRT/проч. переключать сеть в соотвествии с качеством сигнала сети, которая мониторится через ping. Дополнительно по DD-WRT смотрите [http://www.dd-wrt.com/wiki/index.php/Autoap Wiki].

&lt;pre&gt;
function dump_autoap()
   os.execute('curl -s http://gw/user/autoap.htm  &gt; /tmp/.awesome.autoap &amp;')
end

last_ap = &quot;none&quot;
function get_autoap()
   local ap = &quot;&quot;
   if info then return end
   local f = io.open('/tmp/.awesome.autoap')
   if not f then return end
   local line = f:read()
   f:close()
   if not line then return end

   local aar, beg = line:find('&lt;title&gt;')
   if line:sub(beg+32, beg+32) == 'S' then ap = &quot;&lt;span color=\&quot;#FF602E\&quot;&gt;searching...&lt;/span&gt;&quot;
   elseif line:sub(beg+32,beg+32) == 'C' then
      endd = line:find('&lt;/title&gt;', beg)
      ap = line:sub(beg+47,endd-2)
   end

   if ap ~= last_ap then 
     naughty.notify({title = &quot;AutoAP network&quot;, text = ap, timeout = 10})
     last_ap = ap 
   end
   return ap
end

function hook_10s()
  dump_autoap()
  get_autoap()
end

awful.hooks.timer.register(10, hook_10s)
&lt;/pre&gt;

==== rc.lua + dict / словарные подсказки с выводом через naughty ====
&lt;pre&gt;keybinding({ modkey}, &quot;d&quot;, function ()
        info = true
        awful.prompt.run({ fg_cursor = &quot;black&quot;,bg_cursor=&quot;orange&quot;, prompt = &quot;&lt;span color='#008DFA'&gt;Dict:&lt;/span&gt; &quot; }, 
        mypromptbox[mouse.screen],
        function(word)
                local f = io.popen(&quot;dict -d wn &quot; .. word .. &quot; 2&gt;&amp;1&quot;)
                local fr = &quot;&quot;
                for line in f:lines() do
                fr = fr .. line .. '\n'
                end
                f:close()
                naughty.notify({ text = '&lt;span font_desc=&quot;Sans 7&quot;&gt;'..fr..'&lt;/span&gt;', timeout = 0, width = 400 })
        end,
        nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/dict&quot;) 
end):add()&lt;/pre&gt;

==== rc.lua / calculator prompt with naughty output ====
При нажатии клавиш, отображается расчитанная калькулятором строка(предварительно заполненная последним результатом, если он есть) и отображает уведомление naughty с полученным значением. Когда нажимается, значение копируется в буфер, для дальнейшей вставки где либо. 
&lt;pre&gt;val = nil
keybinding({ modkey}, &quot;c&quot;, function ()
    awful.prompt.run({  text = val and tostring(val),
            selectall = true,
            fg_cursor = &quot;black&quot;,bg_cursor=&quot;orange&quot;,
            prompt = &quot;&lt;span color='#00A5AB'&gt;Calc:&lt;/span&gt; &quot; }, mypromptbox,
            function(expr)
              val = awful.util.eval(expr)
              naughty.notify({ text = expr .. ' = &lt;span color=&quot;white&quot;&gt;' .. val .. &quot;&lt;/span&gt;&quot;,
                               timeout = 0,
                               run = function() io.popen(&quot;echo &quot;.. val .. &quot; | xsel -i&quot;):close() end, })
            end,
            nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/calc&quot;)
end):add()&lt;/pre&gt;

==== Использование naughty для отладки кода lua ====
С помощью naughty, очень легко в любое время проверить значение переменных. Забудьте print() и проверку в консоли. Для защиты от ошибок в синтаксисе, поместите эту функцию перед отлаживаемым кодом:
&lt;pre&gt;function dbg(vars)
    local text = &quot;&quot;
    for i=1, #vars do text = text .. vars[i] .. &quot; | &quot; end
    naughty.notify({ text = text, timeout = 0 })
end&lt;/pre&gt;
Затем в коде, вы можете для отладки кода использовать следующую строку, чтобы увидеть значение переменной в реальном времени, через всплывающее сообщение!
&lt;pre&gt;dbg({list, of, variables})&lt;/pre&gt;


==== Всплывающий календарь ====
Если у вас не достаточно места на рабочем столе, или ваши часы отображают только время, вы можете использовать всплывающий календарь, когда мышка находится над часами. Используйте колесо мыши, чтобы переключать отображаемый месяц.
&lt;pre&gt;
    local calendar = nil
    local offset = 0

    function remove_calendar()
        if calendar ~= nil then
            naughty.destroy(calendar)
            calendar = nil
            offset = 0
        end
    end

    function add_calendar(inc_offset)
        local save_offset = offset
        remove_calendar()
        offset = save_offset + inc_offset
        local datespec = os.date(&quot;*t&quot;)
        datespec = datespec.year * 12 + datespec.month - 1 + offset
        datespec = (datespec % 12 + 1) .. &quot; &quot; .. math.floor(datespec / 12)
        local cal = awful.util.pread(&quot;cal -m &quot; .. datespec)
        cal = string.gsub(cal, &quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;)
        calendar = naughty.notify({
            text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, os.date(&quot;%a, %d %B %Y&quot;) .. &quot;\n&quot; .. cal),
            timeout = 0, hover_timeout = 0.5,
            width = 160,
        })
    end

-- измените clockbox вашего виджета часов (т.е. mytextclock)
    mytextclock:add_signal(&quot;mouse::enter&quot;, function()
      add_calendar(0)
    end)
    mytextclock:add_signal(&quot;mouse::leave&quot;, remove_calendar)
 
    mytextclock:buttons(awful.util.table.join(
        button({ }, 4, function()
            add_calendar(-1)
        end),
        button({ }, 5, function()
            add_calendar(1)
        end)
    ))
&lt;/pre&gt;

== Вызов naughty через dbus ==

Скачайте последнюю версию awesome с поддержкой dbus.
Вы можете создать уведомление используя notify-me, dbus-send, d-feet или просто запусти любое приложение с поддержкой dbus-уведомлений, например gajim.

Использование notify-send:
&lt;pre&gt;notify-send &quot;awesome is&quot; &quot;getting naughty&quot;&lt;/pre&gt;
Обратите внимание, что системы Debian/Ubuntu, имеют предустановленный ''notification-daemon'', поэтому notify-send перехватываются Gnome/KDE (соответственно, уведомление не будет отображено naughty)

Использование dbus-send:
&lt;pre&gt;dbus-send --dest=org.freedesktop.Notifications /org/freedesktop/Notifications  org.freedesktop.Notifications.Notify string:&quot;&quot; uint32:0 string:&quot;&quot; \
string:&quot;title&quot; string:&quot;text&quot; array:string:&quot;&quot; array:string:&quot;&quot; int32:-1&lt;/pre&gt;

== Приостановка/Возобновление Naughty ==

Вы можете временно отключить naughty, например когда просматриваете видео. Для этого вызовите &lt;code&gt;naughty.suspend()&lt;/code&gt;, а затем для восстановления его работы &lt;code&gt;naughty.resume()&lt;/code&gt;. Naughty приостановит все уведомления, которые будут ему посылаться, а затем отобразит их, когда работа будет восстановлена.

== Удаление уведомлений ==

Иногда случаются события, например изменение громкости, подключение устройств, когда может потребоваться отобразить новое уведомление немедленно после предыдущего. Но вы не хотите, чтобы уведомления перекрывали друг друга. И Awesome еще не послал notify-osd. 
В этом случае можно использовать другой путь, совместно используя 'psychon' пользовательской рассылке:

&lt;pre&gt;
$ echo 'return naughty.notify({ text = &quot;foo&quot;, timeout = 0 }).id' | awesome-client
double 1551
$ echo 'return naughty.notify({ text = &quot;foo2&quot;, timeout = 0, replaces_id = 1551 }).id' | awesome-client
double 1552
&lt;/pre&gt;

По сути, это ''заменит'' предыдущее уведомление новым.

== To be naughtier ==

* stacking - new popups appearing 'before' old ones
* [http://www.galago-project.org/specs/notification/0.9/x320.html уровни важности]


[[Category:awesome3]]</text>
      <sha1>9zeib7xp3enfcax6twrviy1f1jihmgz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Naughty/fr</title>
    <ns>0</ns>
    <id>428</id>
    <revision>
      <id>3398</id>
      <parentid>3358</parentid>
      <timestamp>2009-08-06T11:23:29Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>/* Utilisation de naughty */ remarque en provenance de la version EN</comment>
      <text xml:space="preserve" bytes="10416">{{DISPLAYTITLE:Naughty}}
{{Languages|Naughty}}

Naughty est une bibliothèque Lua qui permet l’implémentation de notifications pour awesome 3 (git) sous la forme de popups. Elle est incluse dans la [http://git.naquadah.org/?p=awesome.git;a=summary version maître git actuelle d’awesome]. Vous pouvez trouver la branche de développement dans la branche naughty du [http://git.mercenariesguild.net/?p=awesome.git;a=shortlog;h=refs/heads/naughty miroir git d’awesome].


== Mettre en place naughty ==
Tout d’abord, incluez la bibliothèque dans votre '''rc.lua''' :
 require('naughty')

Si vous voulez changer les paramètres par défaut, vous pouvez redéfinir les champs suivants. Pour des détails, reportez-vous à la doc Lua.
 naughty.config.timeout          = 5
 naughty.config.screen           = 1
 naughty.config.position         = &quot;top_right&quot;
 naughty.config.margin           = 4
 naughty.config.height           = 16
 naughty.config.width            = 300
 naughty.config.gap              = 1
 naughty.config.ontop            = true
 naughty.config.font             = beautiful.font or &quot;Verdana 8&quot;
 naughty.config.icon             = nil
 naughty.config.icon_size        = 16
 naughty.config.fg               = beautiful.fg_focus or '#ffffff'
 naughty.config.bg               = beautiful.bg_focus or '#535d6c'
 naughty.config.presets.normal.border_color     = beautiful.border_focus or '#535d6c'
 naughty.config.border_width     = 1
 naughty.config.hover_timeout    = nil

== Utilisation de naughty ==
Pour créer une notification sous forme de popup, appelez ''naughty.notify({arguments})''. D’habitude, on utilise :
 naughty.notify({ text=&quot;Contenu de la notification&quot;, icon=&quot;/chemin/vers/icone&quot; })

Remarquez que les arguments de ''naughty.notify()'' sont facultatifs. L’exemple précédent utilise des paramètres configurés par défaut qui on pour résultat de générer des popups avec une apparence uniforme pour le texte et l’icône. Si vous voulez changer tous les détails, vous pouvez changer le paramètres par défaut avec les arguments suivants :
 naughty.notify({
    text = &quot;Notification&quot;,
    title = &quot;Titre&quot;,
    position = &quot;top_left&quot;|&quot;top_right&quot;|&quot;bottom_left&quot;|&quot;bottom_right&quot;,
    timeout = 5,
    icon=&quot;/chemin/vers/image&quot;,
    fg=&quot;#ffggcc&quot;,
    bg=&quot;#bbggcc&quot;,
    screen = 1,
    ontop = false, 
    run = function () awful.util.spawn(&quot;wicd-client&quot;) end
 })

Remarquez que vous pouvez utiliser des balises HTML avec naughty, donc les symboles &lt; et &gt; ne s’afficheront pas.

== Fournir des informations à naughty ==

Charger uniquement naughty dans votre configuration ne produira aucune popup. Le problème principal est de lui fournir des données. Pour cela :
* pour tester le module, vous pouvez appeler ''naughty.notify'' depuis l’invite Lua ;
* vous pouvez appeler la fonction depuis n’importe quel endroit du rc.lua, ce qui est bien pour des infos supplémentaires de widgets, par exemple ;
* pour appeler la fonction depuis n’importe quoi qui peut exécuter des commandes, utilisez ''awesome-client'' :
 echo 'naughty.notify({title = &quot;Test&quot;, text = &quot;Naughty&quot;, timeout = 10})' | awesome-client -&lt;/pre&gt;

La dernière méthode est bonne pour fournir à naughty des données depuis ''acpid'', ''ivman'', etc.

== Exemples==

=== Ivman ===
Récupéré de '''~/.ivman/IvmConfigActions.xml''' :
&lt;pre&gt;&lt;ivm:Match name=&quot;hal.info.linux.driver&quot; value=&quot;usb&quot;&gt;
 &lt;ivm:Option name=&quot;exec&quot; value=&quot;echo naughty.notify\({timeout=15, title=\'Appareil USB\',\
      text=\'$hal.info.product$\'}\) | awesome-client -&quot; /&gt;
&lt;/ivm:Match&gt;

&lt;ivm:Match name=&quot;hal.volume.is_mounted&quot; value=&quot;true&quot;&gt;
 &lt;ivm:Option name=&quot;exec&quot; \
      value=&quot;echo naughty.notify\({timeout=15,\ title=\'Monté\',\
      text=\'$hal.block.device$ sur $hal.volume.mount_point$ \($hal.volume.size$\)\'}\)\
      | awesome-client -&quot; /&gt;
&lt;/ivm:Match&gt;
       
&lt;ivm:Match name=&quot;hal.info.category&quot; value=&quot;storage&quot;&gt;
 &lt;ivm:Match name=&quot;hal.storage.drive_type&quot; value=&quot;disk&quot;&gt;
  &lt;ivm:Option name=&quot;exec&quot; value=&quot;echo naughty.notify\({timeout=15, title=\'Nouveau volume\',\
       text=\'$hal.info.vendor$ $hal.info.product$ $hal.storage.size$\'}\) | awesome-client -&quot; /&gt;
 &lt;/ivm:Match&gt;
&lt;/ivm:Match&gt;&lt;/pre&gt;

=== rc.lua + curl : hack pour bascule de réseau *WRT/AutoAP ===
AutoAP est un script de démon qui permet à OpenWRT, DD-WRT ou autre de changer de réseau en se basant sur la qualité du signal qui est suivi avec ''ping''. Regardez le [http://www.dd-wrt.com/wiki/index.php/Autoap wiki] de DD-WRT pour plus d’infos.

&lt;pre&gt;
function dump_autoap()
   os.execute('curl -s http://gw/user/autoap.htm  &gt; /tmp/.awesome.autoap &amp;')
end

last_ap = &quot;none&quot;
function get_autoap()
   local ap = &quot;&quot;
   if info then return end
   local f = io.open('/tmp/.awesome.autoap')
   if not f then return end
   local line = f:read()
   f:close()
   if not line then return end

   local aar, beg = line:find('&lt;title&gt;')
   if line:sub(beg+32, beg+32) == 'S' then ap = &quot;&lt;span color=\&quot;#FF602E\&quot;&gt;Recherche en cours…&lt;/span&gt;&quot;
   elseif line:sub(beg+32,beg+32) == 'C' then
      endd = line:find('&lt;/title&gt;', beg)
      ap = line:sub(beg+47,endd-2)
   end

   if ap ~= last_ap then 
     naughty.notify({title = &quot;Réseau AutoAP&quot;, text = ap, timeout = 10})
     last_ap = ap 
   end
   return ap
end

function hook_10s()
  dump_autoap()
  get_autoap()
end

awful.hooks.timer.register(10, hook_10s)
&lt;/pre&gt;

=== rc.lua + dict : invite de dictionnaire avec sortie naughty ===
&lt;pre&gt;keybinding({ modkey}, &quot;d&quot;, function ()
        info = true
        awful.prompt.run({ fg_cursor = &quot;black&quot;,bg_cursor=&quot;orange&quot;, prompt = &quot;&lt;span color='#008DFA'&gt;Dico :&lt;/span&gt; &quot; }, 
        mypromptbox[mouse.screen],
        function(word)
                local f = io.popen(&quot;dict -d wn &quot; .. word .. &quot; 2&gt;&amp;1&quot;)
                local fr = &quot;&quot;
                for line in f:lines() do
                fr = fr .. line .. '\n'
                end
                f:close()
                naughty.notify({ text = '&lt;span font_desc=&quot;Sans 7&quot;&gt;'..fr..'&lt;/span&gt;', timeout = 0, width = 400 })
        end,
        nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/dict&quot;) 
end):add()&lt;/pre&gt;

=== rc.lua : invite de calculatrice avec sortie naughty ===
Le raccourci clavier suivant affiche une invite de calculatrice, contenant le dernier résultat si disponible, et affiche également une popup naughty dont la valeur est l’expression. Quand on clique, la valeur est copiée vers le presse-papiers pour la coller ailleurs. [http://omploader.org/veW1v capture d’écran]
&lt;pre&gt;val = nil
keybinding({ modkey}, &quot;c&quot;, function ()
    awful.prompt.run({  text = val and tostring(val),
            selectall = true,
            fg_cursor = &quot;black&quot;,bg_cursor=&quot;orange&quot;,
            prompt = &quot;&lt;span color='#00A5AB'&gt;Calc :&lt;/span&gt; &quot; }, mypromptbox,
            function(expr)
              val = awful.util.eval(expr)
              naughty.notify({ text = expr .. ' = &lt;span color=&quot;white&quot;&gt;' .. val .. &quot;&lt;/span&gt;&quot;,
                               timeout = 0,
                               run = function() io.popen(&quot;echo &quot;.. val .. &quot; | xsel -i&quot;):close() end, })
            end,
            nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/calc&quot;)
end):add()&lt;/pre&gt;

=== Utiliser naughty pour déboguer du code Lua ===
Avec naughty, il est très facile de vérifier la valeur de variables à n’importe quel moment. Oubliez ''print()'' dans votre console ! Pour vous évitez de devoir retaper toute la syntaxe, vous pouvez mettre cette fonction avant le code que vous voulez déboguer. [http://omploader.org/veTF4 capture d’écran]
&lt;pre&gt;function dbg(vars)
    local text = &quot;&quot;
    for i=1, #vars do text = text .. vars[i] .. &quot; | &quot; end
    naughty.notify({ text = text, timeout = 0 })
end&lt;/pre&gt;
Maintenant, vous pouvez utiliser la ligne suivant dans le code que vous voulez déboguer, pour votre les valeurs en temps réel dans des popups !
 dbg({liste, de, variables})

=== Calendrier popup ===
Si vous n’avez pas beaucoup de place sur votre bureau et que votre horloge ne vous donne que l’heure, vous pouvez afficher la date et le calendrier quand la souris passe dessus. Utilisez alors la roulette de la souris pour changer le mois que vous voulez regarder. [http://omploader.org/vemxo capture d’écran]

&lt;pre&gt;
    local calendar = nil
    local offset = 0

    function remove_calendar()
        if calendar ~= nil then
            naughty.destroy(calendar)
            calendar = nil
            offset = 0
        end
    end

    function add_calendar(inc_offset)
        local save_offset = offset
        remove_calendar()
        offset = save_offset + inc_offset
        local datespec = os.date(&quot;*t&quot;)
        datespec = datespec.year * 12 + datespec.month - 1 + offset
        datespec = (datespec % 12 + 1) .. &quot; &quot; .. math.floor(datespec / 12)
        local cal = awful.util.pread(&quot;cal -m &quot; .. datespec)
        cal = string.gsub(cal, &quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;)
        calendar = naughty.notify({
            text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, os.date(&quot;%a, %d %B %Y&quot;) .. &quot;\n&quot; .. cal),
            timeout = 0, hover_timeout = 0.5,
            width = 160,
        })
    end

-- remplace la boîte d’horloge par le widget d’horloge (par exemple « mytextbox »)
    clockbox.mouse_enter = function()
        add_calendar(0)
    end
    clockbox.mouse_leave = remove_calendar

    clockbox:buttons({
        button({ }, 4, function()
            add_calendar(-1)
        end),
        button({ }, 5, function()
            add_calendar(1)
        end),
    })
&lt;/pre&gt;

== Fournir des informations à naughty en utilisant D-Bus ==
Récupérez la dernière version git d’awesome et naughty écoutera l’interface D-Bus. Vous pouvez créer des notifications en utilisant ''notify-me'', ''dbus-send'', ''d-feet'' ou en ouvrant simplement n’importe quelle application avec une notification D-Bus, comme Gajim.

Pour utiliser ''notify-send'' :
 notify-send &quot;awesome is&quot; &quot;getting naughty&quot;

Pour utiliser ''dbus-send'' :
 dbus-send --dest=org.freedesktop.Notifications --type=method_call /org/freedesktop/Notifications \
   org.freedesktop.Notifications.Notify string:&quot;&quot; uint32:0 string:&quot;&quot; string:&quot;awesome is&quot; string:&quot;getting naughty&quot;

== Pour aller plus loin avec naughty ==
* empilement : les nouvelles popups s’affichent « avant » les anciennes
* [http://www.galago-project.org/specs/notification/0.9/x320.html niveaux d’urgence] pour les popups

[[Category:awesome3]]</text>
      <sha1>eovr3gmnyrcx8xzll7f2c5hlytj5c3z</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Naughty/ru</title>
    <ns>0</ns>
    <id>1026</id>
    <revision>
      <id>6384</id>
      <timestamp>2014-04-30T07:06:01Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Закончен перевод Naughty</comment>
      <text xml:space="preserve" bytes="14083">{{Languages|Naughty}}

Naughty это lua библиотека реализующая всплывающие сообщения в awesome3 (git). 
Эта бибилотека включена в текущую [http://git.naquadah.org/?p=awesome.git;a=summary сборку awesome git].

== Подключение Naughty ==
Сначала, нужно подключить библиотеку в ваш ''rc.lua'':
&lt;pre&gt;require('naughty')&lt;/pre&gt;

Пользователям Gentoo, необходимо добавить ''dbus'' в awesome:
&lt;pre&gt;sudo flaggie awesome +dbus&lt;/pre&gt;

Если вы не хотите использовать настройки по умолчанию, вы можете переопределить любое из следующих полей. За подробностями обращайтесь на [http://awesome.naquadah.org/doc/api/modules/naughty.html#notify luadoc].
&lt;pre&gt;naughty.config.defaults.timeout          = 5
naughty.config.defaults.screen           = 1
naughty.config.defaults.position         = &quot;top_right&quot;
naughty.config.defaults.margin           = 4
naughty.config.defaults.height           = 16
naughty.config.defaults.width            = 300
naughty.config.defaults.gap              = 1
naughty.config.defaults.ontop            = true
naughty.config.defaults.font             = beautiful.font or &quot;Verdana 8&quot;
naughty.config.defaults.icon             = nil
naughty.config.defaults.icon_size        = 16
naughty.config.defaults.fg               = beautiful.fg_focus or '#ffffff'
naughty.config.defaults.bg               = beautiful.bg_focus or '#535d6c'
naughty.config.presetss.border_color     = beautiful.border_focus or '#535d6c'
naughty.config.defaults.border_width     = 1
naughty.config.defaults.hover_timeout    = nil
&lt;/pre&gt;

ПРИМЕЧАНИЕ: в старых версиях awesome использовалось `naughty.config.default_preset` (пример будет работать на версиях старше 3.5.2)

== Использование Naughty ==

Для создания всплывающего уведомления используйте naughty.notify({args}). Стандартное использование:
&lt;pre&gt;naughty.notify({ text=&quot;notification content&quot;, icon=&quot;/path/to/icon&quot; })&lt;/pre&gt;

Обратите внимание на то, что аргументы naughty.notify() можно дополнять. Приведенный выше пример использует предопределенные настройки, что приводит к уведомлению стандартного вида с заданным текстом и картинкой. Если вы не хотите использовать дефолтные настройки, вы можете переопределить значения по умолчанию, передав их в виде аргументов функции:

&lt;pre&gt;naughty.notify({
    text = &quot;notification&quot;,
    title = &quot;title&quot;,
    position = &quot;top_left&quot;|&quot;top_right&quot;|&quot;bottom_left&quot;|&quot;bottom_right&quot;,
    timeout = 5,
    icon=&quot;/path/to/image&quot;,
    fg=&quot;#ffggcc&quot;,
    bg=&quot;#bbggcc&quot;,
    screen = 1,
    ontop = false, 
    run = function () awful.util.spawn(&quot;wicd-client&quot;) end
})&lt;/pre&gt;

Также вы можете использовать некоторые html теги в naughty. Поэтому все, что находится за &lt; не будет отображено.

== Вызов Naughty ==

Простое добавление Naughty в ваш конфиг не выведет никаких уведомлений, для этого необходимо передать эти данные клиенту 
* Для проверки модуля вы можете вызвать naughty.notify из консоли Lua.
* Вы можете вызвать функцию из любого места rc.lua (лучшее место в виджете, не правда ли!)
* Вызвать функцию из консоли, используя awesome-client:
&lt;pre&gt;echo 'naughty.notify({title = &quot;testing&quot;, text = &quot;naughty&quot;, timeout = 10})' | awesome-client -&lt;/pre&gt;

Хорошим способом использования этого метода, является вызов в acpid/ivman/прочих.

=== Примеры ===

=== ivman ===

Взято из ''~/.ivman/IvmConfigActions.xml'':
&lt;pre&gt;&lt;ivm:Match name=&quot;hal.info.linux.driver&quot; value=&quot;usb&quot;&gt;
 &lt;ivm:Option name=&quot;exec&quot; value=&quot;echo naughty.notify\({timeout=15, title=\'USB device\',\
      text=\'$hal.info.product$\'}\) | awesome-client -&quot; /&gt;
&lt;/ivm:Match&gt;

&lt;ivm:Match name=&quot;hal.volume.is_mounted&quot; value=&quot;true&quot;&gt;
 &lt;ivm:Option name=&quot;exec&quot; \
      value=&quot;echo naughty.notify\({timeout=15,\ title=\'Mounted\',\
      text=\'$hal.block.device$ at $hal.volume.mount_point$ \($hal.volume.size$\)\'}\)\
      | awesome-client -&quot; /&gt;
&lt;/ivm:Match&gt;
       
&lt;ivm:Match name=&quot;hal.info.category&quot; value=&quot;storage&quot;&gt;
 &lt;ivm:Match name=&quot;hal.storage.drive_type&quot; value=&quot;disk&quot;&gt;
  &lt;ivm:Option name=&quot;exec&quot; value=&quot;echo naughty.notify\({timeout=15, title=\'New Volume\',\
       text=\'$hal.info.vendor$ $hal.info.product$ $hal.storage.size$\'}\) | awesome-client -&quot; /&gt;
 &lt;/ivm:Match&gt;
&lt;/ivm:Match&gt;&lt;/pre&gt;

==== rc.lua + curl / мониторинг переключения сети*WRT/AutoAP  ====
AutoAP это скипт демона позволяющий OpenWRT/DD-WRT/проч. переключать сеть в соотвествии с качеством сигнала сети, которая мониторится через ping. Дополнительно по DD-WRT смотрите [http://www.dd-wrt.com/wiki/index.php/Autoap Wiki].

&lt;pre&gt;
function dump_autoap()
   os.execute('curl -s http://gw/user/autoap.htm  &gt; /tmp/.awesome.autoap &amp;')
end

last_ap = &quot;none&quot;
function get_autoap()
   local ap = &quot;&quot;
   if info then return end
   local f = io.open('/tmp/.awesome.autoap')
   if not f then return end
   local line = f:read()
   f:close()
   if not line then return end

   local aar, beg = line:find('&lt;title&gt;')
   if line:sub(beg+32, beg+32) == 'S' then ap = &quot;&lt;span color=\&quot;#FF602E\&quot;&gt;searching...&lt;/span&gt;&quot;
   elseif line:sub(beg+32,beg+32) == 'C' then
      endd = line:find('&lt;/title&gt;', beg)
      ap = line:sub(beg+47,endd-2)
   end

   if ap ~= last_ap then 
     naughty.notify({title = &quot;AutoAP network&quot;, text = ap, timeout = 10})
     last_ap = ap 
   end
   return ap
end

function hook_10s()
  dump_autoap()
  get_autoap()
end

awful.hooks.timer.register(10, hook_10s)
&lt;/pre&gt;

==== rc.lua + dict / словарные подсказки с выводом через naughty ====
&lt;pre&gt;keybinding({ modkey}, &quot;d&quot;, function ()
        info = true
        awful.prompt.run({ fg_cursor = &quot;black&quot;,bg_cursor=&quot;orange&quot;, prompt = &quot;&lt;span color='#008DFA'&gt;Dict:&lt;/span&gt; &quot; }, 
        mypromptbox[mouse.screen],
        function(word)
                local f = io.popen(&quot;dict -d wn &quot; .. word .. &quot; 2&gt;&amp;1&quot;)
                local fr = &quot;&quot;
                for line in f:lines() do
                fr = fr .. line .. '\n'
                end
                f:close()
                naughty.notify({ text = '&lt;span font_desc=&quot;Sans 7&quot;&gt;'..fr..'&lt;/span&gt;', timeout = 0, width = 400 })
        end,
        nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/dict&quot;) 
end):add()&lt;/pre&gt;

==== rc.lua / calculator prompt with naughty output ====
При нажатии клавиш, отображается расчитанная калькулятором строка(предварительно заполненная последним результатом, если он есть) и отображает уведомление naughty с полученным значением. Когда нажимается, значение копируется в буфер, для дальнейшей вставки где либо. 
&lt;pre&gt;val = nil
keybinding({ modkey}, &quot;c&quot;, function ()
    awful.prompt.run({  text = val and tostring(val),
            selectall = true,
            fg_cursor = &quot;black&quot;,bg_cursor=&quot;orange&quot;,
            prompt = &quot;&lt;span color='#00A5AB'&gt;Calc:&lt;/span&gt; &quot; }, mypromptbox,
            function(expr)
              val = awful.util.eval(expr)
              naughty.notify({ text = expr .. ' = &lt;span color=&quot;white&quot;&gt;' .. val .. &quot;&lt;/span&gt;&quot;,
                               timeout = 0,
                               run = function() io.popen(&quot;echo &quot;.. val .. &quot; | xsel -i&quot;):close() end, })
            end,
            nil, awful.util.getdir(&quot;cache&quot;) .. &quot;/calc&quot;)
end):add()&lt;/pre&gt;

==== Использование naughty для отладки кода lua ====
С помощью naughty, очень легко в любое время проверить значение переменных. Забудьте print() и проверку в консоли. Для защиты от ошибок в синтаксисе, поместите эту функцию перед отлаживаемым кодом:
&lt;pre&gt;function dbg(vars)
    local text = &quot;&quot;
    for i=1, #vars do text = text .. vars[i] .. &quot; | &quot; end
    naughty.notify({ text = text, timeout = 0 })
end&lt;/pre&gt;
Затем в коде, вы можете для отладки кода использовать следующую строку, чтобы увидеть значение переменной в реальном времени, через всплывающее сообщение!
&lt;pre&gt;dbg({list, of, variables})&lt;/pre&gt;


==== Всплывающий календарь ====
Если у вас не достаточно места на рабочем столе, или ваши часы отображают только время, вы можете использовать всплывающий календарь, когда мышка находится над часами. Используйте колесо мыши, чтобы переключать отображаемый месяц.
&lt;pre&gt;
    local calendar = nil
    local offset = 0

    function remove_calendar()
        if calendar ~= nil then
            naughty.destroy(calendar)
            calendar = nil
            offset = 0
        end
    end

    function add_calendar(inc_offset)
        local save_offset = offset
        remove_calendar()
        offset = save_offset + inc_offset
        local datespec = os.date(&quot;*t&quot;)
        datespec = datespec.year * 12 + datespec.month - 1 + offset
        datespec = (datespec % 12 + 1) .. &quot; &quot; .. math.floor(datespec / 12)
        local cal = awful.util.pread(&quot;cal -m &quot; .. datespec)
        cal = string.gsub(cal, &quot;^%s*(.-)%s*$&quot;, &quot;%1&quot;)
        calendar = naughty.notify({
            text = string.format('&lt;span font_desc=&quot;%s&quot;&gt;%s&lt;/span&gt;', &quot;monospace&quot;, os.date(&quot;%a, %d %B %Y&quot;) .. &quot;\n&quot; .. cal),
            timeout = 0, hover_timeout = 0.5,
            width = 160,
        })
    end

-- измените clockbox вашего виджета часов (т.е. mytextclock)
    mytextclock:add_signal(&quot;mouse::enter&quot;, function()
      add_calendar(0)
    end)
    mytextclock:add_signal(&quot;mouse::leave&quot;, remove_calendar)
 
    mytextclock:buttons(awful.util.table.join(
        button({ }, 4, function()
            add_calendar(-1)
        end),
        button({ }, 5, function()
            add_calendar(1)
        end)
    ))
&lt;/pre&gt;

== Вызов naughty через dbus ==

Скачайте последнюю версию awesome с поддержкой dbus.
Вы можете создать уведомление используя notify-me, dbus-send, d-feet или просто запусти любое приложение с поддержкой dbus-уведомлений, например gajim.

Использование notify-send:
&lt;pre&gt;notify-send &quot;awesome is&quot; &quot;getting naughty&quot;&lt;/pre&gt;
Обратите внимание, что системы Debian/Ubuntu, имеют предустановленный ''notification-daemon'', поэтому notify-send перехватываются Gnome/KDE (соответственно, уведомление не будет отображено naughty)

Использование dbus-send:
&lt;pre&gt;dbus-send --dest=org.freedesktop.Notifications /org/freedesktop/Notifications  org.freedesktop.Notifications.Notify string:&quot;&quot; uint32:0 string:&quot;&quot; \
string:&quot;title&quot; string:&quot;text&quot; array:string:&quot;&quot; array:string:&quot;&quot; int32:-1&lt;/pre&gt;

== Приостановка/Возобновление Naughty ==

Вы можете временно отключить naughty, например когда просматриваете видео. Для этого вызовите &lt;code&gt;naughty.suspend()&lt;/code&gt;, а затем для восстановления его работы &lt;code&gt;naughty.resume()&lt;/code&gt;. Naughty приостановит все уведомления, которые будут ему посылаться, а затем отобразит их, когда работа будет восстановлена.

== Удаление уведомлений ==

Иногда случаются события, например изменение громкости, подключение устройств, когда может потребоваться отобразить новое уведомление немедленно после предыдущего. Но вы не хотите, чтобы уведомления перекрывали друг друга. И Awesome еще не послал notify-osd. 
В этом случае можно использовать другой путь, совместно используя 'psychon' пользовательской рассылке:

&lt;pre&gt;
$ echo 'return naughty.notify({ text = &quot;foo&quot;, timeout = 0 }).id' | awesome-client
double 1551
$ echo 'return naughty.notify({ text = &quot;foo2&quot;, timeout = 0, replaces_id = 1551 }).id' | awesome-client
double 1552
&lt;/pre&gt;

По сути, это ''заменит'' предыдущее уведомление новым.

== To be naughtier ==

* stacking - new popups appearing 'before' old ones
* [http://www.galago-project.org/specs/notification/0.9/x320.html уровни важности]


[[Category:awesome3]]</text>
      <sha1>9zeib7xp3enfcax6twrviy1f1jihmgz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Naughty log watcher</title>
    <ns>0</ns>
    <id>323</id>
    <revision>
      <id>6511</id>
      <parentid>6170</parentid>
      <timestamp>2014-05-16T12:26:48Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>add languages tag, delete dead link</comment>
      <text xml:space="preserve" bytes="1729">{{Languages}}

Here's a log watcher implementation in pure Lua. It will show a naughty popup each time something changes in one of the predefined log files.
The original code base on konius work and is refactored as a module and updated for newer version of awesome

1. Install luasocket and inotify

On debian
&lt;pre&gt;
$ apt-get install luarocks lua-socket
&lt;/pre&gt;
On Arch
&lt;pre&gt;
$ pacman -S luarocks luasocket
&lt;/pre&gt;

Then just install inotify from luarocks (needs root for systemwide install)
&lt;pre&gt;
$ luarocks install inotify
&lt;/pre&gt;

2. Clone or download the code into your awesome configuration directory
&lt;pre&gt;
$ cd $XDG_CONFIG_HOME/awesome
$ git clone https://github.com/Mic92/lognotify.git
&lt;/pre&gt;

3. Load the module in your configuration:
&lt;pre&gt;
local lognotify = require(&quot;lognotify&quot;)
&lt;/pre&gt;

4. Set some config variables (make sure the files are readable to you):
&lt;pre&gt;
ilog = lognotify{
   logs = { mpd = { file = &quot;/home/bob/.mpd/log&quot;, },
   	aptitude = { file = &quot;/var/log/aptitude&quot;, },
   	-- Check, whether you have the permissions to read your log files!
   	-- You can fix this by configure syslog deamon in many case.
   	syslog    = { file = &quot;/var/log/syslog&quot;, ignore = { &quot;Changing fan level&quot; },
   	},
   	awesome  = { file = &quot;/home/bob/log/awesome&quot;,
   		ignore = {
   			&quot;/var/lib/dpkg&quot;, -- aptwidget failure when aptitude running
   			&quot;wicd&quot;, &quot;wired profiles found&quot;, -- wicd junk
   			&quot;seek to:&quot;, &quot;Close unzip stream&quot;, -- gmpc junk
   			&quot;^nolog&quot;},
   		},
   -- Delay between checking in seconds. Default: 1
   interval = 1,
   -- Time in seconds after which popup expires. Set 0 for no timeout. Default: 0
   naughty_timeout = 15
}
&lt;/pre&gt;

5. Run it:
&lt;pre&gt;
ilog:start()
&lt;/pre&gt;


That's it.

[[Category:Awesome3]]</text>
      <sha1>o03r5dc8ofw982xe12d1ankruo5iy0u</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Naughty log watcher/ru</title>
    <ns>0</ns>
    <id>1048</id>
    <revision>
      <id>6513</id>
      <timestamp>2014-05-16T12:42:07Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{Languages|Naughty log watcher}}  Здесь приведена реализация наблюдения за логами на чистом Lua. Она показывает...&quot;</comment>
      <text xml:space="preserve" bytes="2447">{{Languages|Naughty log watcher}}

Здесь приведена реализация наблюдения за логами на чистом Lua. Она показывает уведомление каждый раз, когда изменяется лог файл.
Оригинальный код разработан konius, который был переделан в модуль и обновлен для новой версии awesome.

1. Установка luasocket и inotify

В Debian
&lt;pre&gt;
# apt-get install luarocks lua-socket
&lt;/pre&gt;
В Arch
&lt;pre&gt;
$ pacman -S luarocks luasocket
&lt;/pre&gt;

Затем просто установите inotify через luarocks (необходимы права администратора)
&lt;pre&gt;
# luarocks install inotify
&lt;/pre&gt;

2. Клонируйте или загрузите код в каталог с вашим awesome
&lt;pre&gt;
$ cd $XDG_CONFIG_HOME/awesome
$ git clone https://github.com/Mic92/lognotify.git
&lt;/pre&gt;

3. Загрузите модуль в ваш файл конфигурации:
&lt;pre&gt;
local lognotify = require(&quot;lognotify&quot;)
&lt;/pre&gt;

4. Объявите несколько переменных (предварительно убедитесь, что файлы доступны вам для чтения, в противном случае добавьте пользователя в группу log или adm):
&lt;pre&gt;
ilog = lognotify{
   logs = { mpd = { file = &quot;/home/bob/.mpd/log&quot;, },
   	aptitude = { file = &quot;/var/log/aptitude&quot;, },
   	-- Check, whether you have the permissions to read your log files!
   	-- You can fix this by configure syslog deamon in many case.
   	syslog    = { file = &quot;/var/log/syslog&quot;, ignore = { &quot;Changing fan level&quot; },
   	},
   	awesome  = { file = &quot;/home/bob/log/awesome&quot;,
   		ignore = {
   			&quot;/var/lib/dpkg&quot;, -- aptwidget failure when aptitude running
   			&quot;wicd&quot;, &quot;wired profiles found&quot;, -- wicd junk
   			&quot;seek to:&quot;, &quot;Close unzip stream&quot;, -- gmpc junk
   			&quot;^nolog&quot;},
   		},
   -- Задержка между проверками в секундах. По умолчанию: 1
   interval = 1,
   -- Время в секундах отображения уведомления. Установите 0, чтобы не было таймаута. По умолчанию: 0
   naughty_timeout = 15
}
&lt;/pre&gt;

5. Запустите:
&lt;pre&gt;
ilog:start()
&lt;/pre&gt;


Это все, наслаждайтесь!!!

[[Category:Awesome3]]</text>
      <sha1>p4akxj0jk5xj0so9sdcjspz4wg4het5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Net widgets</title>
    <ns>0</ns>
    <id>1296</id>
    <revision>
      <id>7295</id>
      <parentid>7291</parentid>
      <timestamp>2015-01-24T14:09:58Z</timestamp>
      <contributor>
        <username>Plotnikovanton</username>
        <id>4287</id>
      </contributor>
      <comment>/* Wided network indicator. */</comment>
      <text xml:space="preserve" bytes="1406">{{Languages|net_widgets}}
If you use `netctl` or another network manager which doesn't provide any good tray icon or if you want something more native than `nm-applet`, this is for you.
[[File:Net widgets total.png|right]]
== Instalation ==

First of all you should clone repository in your awesome config directory

  git clone git@github.com:plotnikovanton/net_widgets.git ~/.config/awesome/net_widgets

Then, paste this in your 'rc.lua'

  local net_widgets = require(&quot;net_widgets&quot;)

=== Wireless widget. ===
[[File:Net widgets wireless.png]] Widget is simple as hell. Icon changes depend on signal level, if you put mouse pointer on it you can see some information about current connection.

Create widget by

  net_wireless = net_widgets.wireless({interface=&quot;wlp1s0&quot;})

After that just place `net_wireless` wherever you want. You can also change widget update timeout. By default it is `timeout=5`, `interface=wlan0`

=== Wired network indicator. ===

[[File:Net widgets idicator.png]] If network is disconnected icon changes color to red. You can set multiple interfaces to indicate it. It also have got popup.

To create widget put in `rc.lua`

  net_wired = net_widgets.indicator({
      interfaces  = {&quot;enp2s0&quot;, &quot;another_interface&quot;, &quot;and_another_one&quot;},
      timeout     = 5
  })


By default `interfaces={&quot;enp2s0&quot;}`, `timeout=5`

== Tips ==
You can also change font to monospace by `font` option.</text>
      <sha1>ozc4h1kemm7ffhbwzvdcae5dgyith35</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Net widgets/ru</title>
    <ns>0</ns>
    <id>1297</id>
    <revision>
      <id>7296</id>
      <parentid>7293</parentid>
      <timestamp>2015-01-24T14:11:24Z</timestamp>
      <contributor>
        <username>Plotnikovanton</username>
        <id>4287</id>
      </contributor>
      <comment>/* Wided network indicator. */</comment>
      <text xml:space="preserve" bytes="2137">{{Languages|net_widgets}}
Если вы используете `netctl` или какой-либо другой менеджер сети без нормальной иконки для трея или хотите что-то более нативное чем `nm-applet`, тогда этот виджет для вас.
[[File:Net widgets total.png|right]]
== Установка ==

Для начала склонируем репозиторий в папку с конфигами

  git clone git@github.com:plotnikovanton/net_widgets.git ~/.config/awesome/net_widgets

Затем добавим в 'rc.lua'

  local net_widgets = require(&quot;net_widgets&quot;)

=== Wireless widget. ===
[[File:Net widgets wireless.png]] Виджет очень простой. Иконка меняется в зависимости от уровня сигнала, если навести курсор на иконку, то появится всплывающее окно с информацией о сети

Инициализируйте виджет следующим кодом

  net_wireless = net_widgets.wireless({interface=&quot;wlp1s0&quot;})

После этого разместите `net_wireless` где вам угодно. Так же можно установить другую частоту обновления опцией `timeout`. Значения по умолчанию: `timeout=5`, `interface=wlan0`

=== Wired network indicator. ===

[[File:Net widgets idicator.png]] Если нет подключения у просматриваемых интерфейсов, тогда иконка краснеет. Можно задать несколько интерфейсов сразу. Так же есть всплывающее окно.

Так же проинициализируем виджет в `rc.lua`

  net_wired = net_widgets.indicator({
      interfaces  = {&quot;enp2s0&quot;, &quot;another_interface&quot;, &quot;and_another_one&quot;},
      timeout     = 5
  })


По умолчанию `interfaces={&quot;enp2s0&quot;}`, `timeout=5`

== Tips ==
Так же можно установить моноширинный шрифт опцией `font`.</text>
      <sha1>se62axygoswsj3gklmdsykurfzmmf6c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Network Traffic, Battery, Clock and Mocp in Status Bar (Bash version)</title>
    <ns>0</ns>
    <id>80</id>
    <revision>
      <id>1288</id>
      <timestamp>2008-10-16T15:01:22Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="3614">== All in one ==

(working on awesome 2.2)

This is a homemade script to populate Mocp, Batt, Network, Load and Clock, from a bash script.

=== Awesome configuration ===

 textbox zik
 {
    width = 200
    text = 'Pas de musique'
    bg = &quot;#444444&quot;
    fg = &quot;#cccccc&quot;
    mouse
    {
        button = &quot;1&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec mocp -G&quot;
    }
    mouse
    {
        button = &quot;3&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec mocp -f&quot;
    }
 }
 progressbar batt
 {
    height = 1
    width = 40
    bar
    {
        bordercolor = &quot;#CCCCCC&quot;
        fg = &quot;#6666FF&quot;
    }
 }
 graph ifeth0
 {
    height = 1
    bordercolor = &quot;#CCCCCC&quot;
    width = 40
    padding_left = 2
    data
    {
        scale = true
        max = 1
        fg = &quot;#00FF00&quot;
    }
    data
    {
        style = line
        scale = true
        max = 1
        fg = &quot;#0000FF&quot;
    }
 }
 graph cpu
 {
    height = 1
    bordercolor = &quot;#CCCCCC&quot;
    width = 40
    padding_left = 2
    data
    {
        style = line
        scale = true
        max = 200
        fg = &quot;#FF0000&quot;
    }
    data
    {
        style = line
        scale = true
        max = 200
        fg = &quot;#ffb400&quot;
    }
 }
 textbox clock
 {
    width = 100
    text_align = center
    text = &quot;&lt;clock&gt;&quot;
 }
 iconbox logout
 {
    image = &quot;/usr/share/icons/gnome/16x16/actions/gnome-session-logout.png&quot;
    resize = true
    mouse
    {
        button = &quot;1&quot;
        command = &quot;spawn&quot;
        arg = &quot;exec gnome-session-save --kill --gui&quot;
    }
 }


=== Bash script ===

Make sure to adapt it before execute !
Copy it to your ~/bin/awesome-wid

&lt;pre&gt;
#!/bin/bash

CACHE=~/.awesome-wid
MOCP_CACHE=~/.mocp-cache

while true; do

# Read cache
	. $CACHE

# Clock
	echo 0 widget_tell clock `date '+%d/%m %H:%M:%S'` | awesome-client	

# CPU
	CPU0=`grep cpu0 /proc/stat | awk '{print $2&quot;+&quot;$3&quot;+&quot;$4}'`
	CPU0=$(($CPU0))
	CPU0_D=$(($CPU0-$OLD_CPU0))
	CPU1=`grep cpu1 /proc/stat | awk '{print $2&quot;+&quot;$3&quot;+&quot;$4}'`
	CPU1=$(($CPU1))
	CPU1_D=$(($CPU1-$OLD_CPU1))

	echo 0 widget_tell cpu $CPU0_D,$CPU1_D | awesome-client

# Mocp
	mocp -i &gt; $MOCP_CACHE
	MOCP_TITLE=`cat $MOCP_CACHE | grep -e '^SongTitle:' | sed -r 's/^.*: //'`
	if [ &quot;X$MOCP_TITLE&quot; != &quot;X&quot; ] ; then
		MOCP_ARTIST=`cat $MOCP_CACHE | grep -e '^Artist:' | awk '{print $2}'`
		MOCP_TITLE=`cat $MOCP_CACHE | grep -e '^SongTitle:' | sed -r 's/^.*: //'`
		MOCP_ALL=`cat $MOCP_CACHE | grep -e '^TotalSec:' | awk '{print $2}'`
		MOCP_CUR=`cat $MOCP_CACHE | grep -e '^CurrentSec:' | awk '{print $2}'`
		MOCP_PER=$(($MOCP_CUR * 100 / $MOCP_ALL))
		echo 0 widget_tell zik [$MOCP_PER%\] $MOCP_ARTIST - $MOCP_TITLE | awesome-client 
	else
		echo 0 widget_tell zik Pas de musique | awesome-client
	fi

# Interface eth0
	ETH0_IN=`grep eth0 /proc/net/dev | sed 's/:/\ /' | awk '{print $2}'`
	ETH0_OUT=`grep eth0 /proc/net/dev | sed 's/:/\ /' | awk '{print $10}'`

	ETH0_IN_D=$(($ETH0_IN-$OLD_ETH0_IN))
	ETH0_OUT_D=$(($ETH0_OUT-$OLD_ETH0_OUT))

	echo 0 widget_tell ifeth0 $ETH0_IN_D,$ETH0_OUT_D | awesome-client

# Batterie
	BATT_ALL=`grep &quot;last full capacity:&quot; /proc/acpi/battery/BAT0/info | awk '{print $4}'`	
	BATT_CUR=`grep &quot;remaining capacity:&quot; /proc/acpi/battery/BAT0/state | awk '{print $3}'`	
	BATT_PER=$(($BATT_CUR * 100 / $BATT_ALL))
	echo 0 widget_tell batt $BATT_PER | awesome-client

# Write cache
	echo &quot;OLD_CPU0=$CPU0&quot; &gt; $CACHE
	echo &quot;OLD_CPU1=$CPU1&quot; &gt;&gt; $CACHE
	echo &quot;OLD_ETH0_IN=$ETH0_IN&quot; &gt;&gt; $CACHE
	echo &quot;OLD_ETH0_OUT=$ETH0_OUT&quot; &gt;&gt; $CACHE

# Sleep 1
	sleep 1

done;
&lt;/pre&gt;

=== Initial cache file ===

Copy it to ~/.awesome-wid

&lt;pre&gt;
OLD_CPU0=0
OLD_CPU1=0
OLD_ETH0_IN=0
OLD_ETH0_OUT=0
&lt;/pre&gt;

[[Category:awesome2]]</text>
      <sha1>o4ga6xcbqm1x26bn2d06xbbqwnzp485</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Networkmanager/Wifi Widget</title>
    <ns>0</ns>
    <id>1312</id>
    <revision>
      <id>7395</id>
      <parentid>7394</parentid>
      <timestamp>2015-11-19T19:46:52Z</timestamp>
      <contributor>
        <username>Cmotc</username>
        <id>4311</id>
      </contributor>
      <minor/>
      <comment>changed screenshots to links and fixed typos. Added ref to source code.</comment>
      <text xml:space="preserve" bytes="3365">
== awesome-network-manager ==

This widget provides an interface to NetworkManager by sending commands to nmcli. Right now it does everything except cache wifi passwords. To cache them on your own, you can create a file called $HOME/.wifi_passwords and add network names and passwords like so:

    NETWORK=&quot;ssidofnetwork&quot;; PASSWORD=&quot;wepwpakey&quot;;

Make sure to keep both items on the same line.

== Usage ==

This widget is designed to mimic the pop-up/drop-down mouse driven Wi-Fi management interfaces that are popular in heavier desktop environments like Gnome and KDE.

== Interface Menu ==

The first click on the menu brings up a list of interfaces that can be used with nmcli. Clicking on an element in this menu will bring the interface down or up.

Screenshot of the Interface Menu
[[https://raw.githubusercontent.com/cmotc/awesome-network-manager/master/nm1.png]]

== Wi-Fi Menu ==

Highlighting the Wi-Fi device in the interface list will bring up a list of wireless AP's nearby. Clicking on an item in the list will attempt to connect to the interface. Currently only works for Open AP's and AP's stored in $HOME/.wifi_passwords.

Screenshot of the Wifi Menu
[[https://raw.githubusercontent.com/cmotc/awesome-network-manager/master/nm2.png]]

== Installation ==

Get the Source Code: [[https://github.com/cmotc/awesome-network-manager from github]], and also, you'll need nmcli if you don't have it yet. It is usually provided by a distribution's networkmanager package.

I'm trying to keep my Awesome plugins as simple as possible. First, copy the awesome/network/ folder into your awesome config folder. If you were in the root of this repository, you could manually copy the file like this:

    cd etc/xdg/awesome/ &amp;&amp; cp -Rv network ~/.config/awesome/
and the wrapper scripts like this:

    cd usr/bin/ &amp;&amp; sudo cp -v *-wrapper /usr/bin/ &amp;&amp; sudo chmod a+x /usr/bin/*-wrapper
Once it's copied, just require the library at the top of your rc.lua, like so:

    require(&quot;network.pech&quot;)
instantiate the menu:

    -- create a network menu widget
    function mynetworkmenu()
        networkmenu = awful.menu({  items = netmgr.generate_network_menu()    })
        return networkmenu
    end
    mynetworklauncher = awful.widget.launcher({ image = beautiful.awesome_icon,
                        menu = mynetworkmenu()})

and add your widget to your wibox:

    right_layout:add(mynetworklauncher)
if you want to periodically scan for new access points, you can add these lines to your rc.lua to create a timer:

    nettimer = timer({ timeout = 360 })
    nettimer:connect_signal(&quot;timeout&quot;, function()
        mynetworklauncher = awful.widget.launcher({ image = beautiful.awesome_icon,
                                            menu = mynetworkmenu()})
        end)
    nettimer:start()


== Encrypting your Wi-Fi keys on disk ==

Optionally, you can configure your wireless keys to be encrypted with GPG when you aren't trying to connect to a network. If you also disable automatic connections to AP's and any other caching facilities related to Wi-Fi passwords, you might be able to protect them in some scenarios. Instructions for doing this will be added here soon(When it's fully supported. You need to create a couple config files and put them to somewhere the script will look for it. Same principle as when you do it with .muttrc pretty much.)</text>
      <sha1>twbjljp177yss4jtfqdmcatfa94v112</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>News reader in Status Bar</title>
    <ns>0</ns>
    <id>17</id>
    <revision>
      <id>1287</id>
      <timestamp>2008-10-16T15:01:01Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1628">== News reader in Status Bar ==

I've searched news reader that has command-line interface, because of awesome status bar. I found [http://synflood.at/newsbeuter.html newsbeuter]. It's a console/ncurses-based news reader.
So, I'm using [http://materm.sourceforge.net/wiki/ mrxvt] terminal emulator and my ''~/.xinitrc'''s part:

 (sleep 1 ; mrxvt -tt &quot;News&quot; -ht -name RSS +tr -e newsbeuter -r -u /home/zsolt/.newsbeuter/urls ) &amp;

The ''-tt'' option set the &quot;Tab Title&quot; - this is the displayed title (WM_NAME). The ''-name'' option set the class to RSS so you can handle via awesome-rules (app icon, automatic tags,...). You can set the terminal's background and many other eye-candy option (see [http://materm.sourceforge.net/wiki/Main/Documentation?action=download&amp;upname=mrxvt.1.txt man mrxvt]).

The statusbar: create a script named ''~/awesome-rss'' (the source is [http://code.google.com/p/newsbeuter/issues/detail?id=58 here]):

 #!/bin/bash
 UNREAD=$(echo 'select count(*) from rss_item where unread = 1;' | sqlite3 ~/.newsbeuter/cache.db)
 if [ $UNREAD -eq 0 ] ; then UNREAD=&quot;No&quot;;fi
 echo 0 widget_tell tb_rss $UNREAD new article

And if you have a textbox named ''tb_rss'' put this line to the ''~/.xinitrc'':

 (while true; do /home/zsolt/awesome-resources/statusbar/awesome-rss | awesome-client ; sleep 1m; done ) &amp;

You can insert before the tb_rss an iconbox with a [http://images.google.com/images?q=rss+icon&amp;gbv=2&amp;svnum=10&amp;hl=en&amp;sa=G&amp;imgsz=icon rss icon]...

See [http://udvzsolt.extra.hu/e107_plugins/coppermine_menu/albums/userpics/10001/awesome-rss.png screenshot].

[[Category:Widgets]]

[[Category:awesome2]]</text>
      <sha1>r917ldshjltn5gn89h2mue4tb4u5zvb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Nice Icons</title>
    <ns>0</ns>
    <id>55</id>
    <revision>
      <id>6080</id>
      <parentid>6077</parentid>
      <timestamp>2013-08-18T13:40:31Z</timestamp>
      <contributor>
        <username>Anrxc</username>
        <id>258</id>
      </contributor>
      <minor/>
      <comment>New source for dzen icons</comment>
      <text xml:space="preserve" bytes="2661">{{Languages}}



'''Sm4tik icons'''
* Icons made by sm4tik for the [https://github.com/robm/dzen dzen project] were always extremely popular in all WM communities. Original source pages went offline, To preserve them for the next generation of users they are now hosted here: http://sysphere.org/~anrxc/local/images/sm4tik-icon-pack.tar.bz2


You can convert original XBM bitmaps to other formats to suit your needs, in several ways with ImageMagick tools: 
  
  for x in *; do convert &quot;${x}&quot; &quot;${x%.*}.png&quot;; done

Note that you can resize them, for example :

  for x in *; do convert -resize 16x16 &quot;${x}&quot; &quot;${x%.*}.png&quot;; done

Or, if you want to keep the icon the same size and increase the surrounding buffer (in order to stop the icon from automatically resizing garishly) consider the following (for a 20x20 png. note the 40x40 - this just creates a large buffer then crops with centred gravity to the desired size.):

  for x in *.xbm; do convert -bordercolor transparent -border 40x40 -gravity center -crop 20x20+0+0 &quot;${x}&quot; &quot;${x%.*}.png&quot;; done

If you want them in a specific color, you may try something like this:

  for x in *.xbm; do convert -fill &quot;$REQUIRED_COLOR&quot; -opaque &quot;$ICON_COLOR&quot; &quot;${x}&quot; &quot;${x%.*}.png&quot;; done


'''Pixel Style icons'''
* Another good set of icons that match and supplement sm4tik's icons from dzen is [http://www.freeiconsdownload.com/Free_Downloads.asp?id=284 Pixel Style] pack (released under a free licence and free to use in any kind of project).

'''Blockie icons'''
* Yet another good set of (16x16px) icons, [http://icondock.com/free/20-free-blockie-icons Blockie icons] are free for personal use.

'''Pinvoke icons'''
* [http://www.pinvoke.com Pinvoke] released amazing sets of mini icons under a CC license. Unlike previous sets these are not minimalist icons but a very colorful bunch, including thousands of icons from 16x16 to 8x8 pixels in size.

'''Small awesome icons'''
* Some people use very small statusbars (14px or even smaller) and original layout icons don't scale so well to those sizes. For that reason I created a few sets of small icons (14px and smaller) for layouts and tags. You will also find a set of matching titlebar icons in there, to be used with recent versions of Awesome: http://sysphere.org/~anrxc/local/images/awesome-icons-anrxc.tar.bz2
* If you do not find the exact size for your wibox, you can use this [http://git.ni.fr.eu.org/?p=nicolas/awesome-config.git;a=tree;f=icons awesome icons generator]. It generates layouts icons inspired from anrxc ones. You can see a sample of generated icons at my corresponding [http://ni.fr.eu.org/blog/awesome_icons/ blog entry].

[[Category:Themes]]</text>
      <sha1>gmf5cfif87s9fl0rwnbe8g820zm3qu2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Nice Icons/fr</title>
    <ns>0</ns>
    <id>424</id>
    <revision>
      <id>5179</id>
      <parentid>3352</parentid>
      <timestamp>2011-11-27T23:07:54Z</timestamp>
      <contributor>
        <username>Schodet</username>
        <id>736</id>
      </contributor>
      <comment>/* Ensembles similaires */ Ajout du générateur d'icônes</comment>
      <text xml:space="preserve" bytes="2629">{{DISPLAYTITLE:Jolies icônes}}
{{Languages|Nice Icons}}

== Ensembles d’icônes ==
Vous pouvez trouver de jolies icônes simples et petites sur le [http://dzen.geekmode.org/wiki/wiki.cgi/-main/DzenIconPacks wiki de dzen]. Vous devrez quand même les convertir en '''.png'''. Pour cela, vous pouvez lancer le script suivant si vous avez installé ''convert'' d’ImageMagick :
 for x in *; do convert &quot;${x}&quot; &quot;${x%.*}.png&quot;; done
et vous pouvez également les redimmensionner. Par exemple :
 for x in *; do convert -resize 16x16 &quot;${x}&quot; &quot;${x%.*}.png&quot;; done
Si vous désirez leur donner une couleur particulière, vous pouvez essayer quelque chose comme :
 for x in *.xbm; do convert -fill &quot;$COLOR&quot; -transparent white -colorize 100 &quot;${x}&quot; &quot;${x%.*}.png&quot;; done

;Remarque.
:Si le wiki de dzen ne fonctionne pas, voici un lien alternatif vers l’ensemble d’icônes de sm4tik : http://koti.24.fi/sm4tik/shared/xbm8x8-0.1.tar.gz

== Ensembles similaires ==
* Un autre bon ensemble d’icônes qui se marie bien avec les icônes de sm4tik trouvées sur dzen est le pack [http://www.freeiconsdownload.com/Free_Downloads.asp?id=284 « Pixel Style »], distribué sous licence libre et utilisable dans n’importe quel projet.
* Un autre exemple d’ensemble d’icônes, cette fois-ci en taille 16 px, existe : [http://icondock.com/free/20-free-blockie-icons « Blockie icons »]. Ces icônes sont libres pour une utilisation personnelle.
* [http://www.pinvoke.com Pinvoke] a distribué des ensembles d’icônes grandioses sous licence CC. Contrairement aux ensembles précédents, ces ensembles-ci ne sont pas composés d’icônes minimalistes mais d’un bon bouquet coloré, avec des centaines d’icônes de tailles variant entre 16 px et 8 px.
* Certaines personnes utilisent des barres de statut très petites de 14 px ou moins et les icônes de disposition originelles ne s’adaptent pas si bien à ces dimensions. Pour cette raison, un ensemble de petites icônes de 14 px et moins a été créé par Anrxc pour les dispositions et les onglets. Vous trouverez également un ensemble d’icônes pour barres de titres, utilisable dans les versions récentes d’awesome : http://sysphere.org/~anrxc/icons-14px-anrxc.tar
* Si vous ne trouvez pas d'icône à la taille que vous souhaitez, vous pouvez utiliser ce [http://git.ni.fr.eu.org/?p=nicolas/awesome-config.git;a=tree;f=icons générateur d'icône]. Il génère des icônes inspirées de celle de anrxc. Vous pouvez voir un exemple d'icônes générées sur [http://ni.fr.eu.org/blog/awesome_icons/ l'entrée correspondante de mon blog].

[[Category:Themes]]</text>
      <sha1>bp0m56cesse2w595j1i2071rlc4g98i</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Nice Icons/ru</title>
    <ns>0</ns>
    <id>461</id>
    <revision>
      <id>6424</id>
      <parentid>3572</parentid>
      <timestamp>2014-05-02T14:40:47Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Обновление перевода Nice icons</comment>
      <text xml:space="preserve" bytes="4291">{{DISPLAYTITLE:Значки для Awesome}}
{{Languages|Nice Icons}}


'''Sm4tik icons'''
* Иконки сделанные sm4tik [https://github.com/robm/dzen dzen project]всегда чрезвычайно популярны среди пользователей Awesome. Оригинальная страница периодически недоступна, поэтому, чтобы следующие поколения пользователей могли из скачать, было сделано зеркало: http://sysphere.org/~anrxc/local/images/sm4tik-icon-pack.tar.bz2

Вы можете сконвертировать оригинальное растровое изображение XBM, в другие форматы для ваших нужд, для этого воспользуйтесь утилитой ImageMagick:  
  for x in *; do convert &quot;${x}&quot; &quot;${x%.*}.png&quot;; done

Для изменения размера добавьте к команде ключ -resize:
  for x in *; do convert -resize 16x16 &quot;${x}&quot; &quot;${x%.*}.png&quot;; done

Или, если вы хотите сохранить тот же размер иконки и увеличить окружающий буфер (для того, чтобы защитить иконку от автоматического изменения размера) сделайте следующее (из иконки 20x20 png. сделать 40x40 - этот код только увеличит размер буфера, затем помещает ее в центр изображения):
  for x in *.xbm; do convert -bordercolor transparent -border 40x40 -gravity center -crop 20x20+0+0 &quot;${x}&quot; &quot;${x%.*}.png&quot;; done

А чтобы изменить цвет, попробуйте что-нибудь вроде:
  for x in *.xbm; do convert -fill &quot;$COLOR&quot; -transparent white -colorize 100 &quot;${x}&quot; &quot;${x%.*}.png&quot;; done
или:
  for x in *.xbm; do convert -fill &quot;$REQUIRED_COLOR&quot; -opaque &quot;$ICON_COLOR&quot; &quot;${x}&quot; &quot;${x%.*}.png&quot;; done


'''Значки &quot;Pixel Style&quot;'''
* Другой набор значков, неплохо дополняющий коллекцию от sm4tik - [http://www.freeiconsdownload.com/Free_Downloads.asp?id=284 &quot;Pixel Style&quot;] (выпущен под свободной лицензией и может свободно использоваться в любых проектах).

'''&quot;Blockie&quot;'''
* Еще одна коллекция значков размером 16x16px, [http://icondock.com/free/20-free-blockie-icons &quot;Blockie&quot;], бесплатна для персонального использования.

'''&quot;Pinvoke&quot;'''
* [http://www.pinvoke.com Pinvoke] выпустил прекрасную коллекцию маленьких значков под лицензией [http://creativecommons.org/licenses/by/3.0/ Creative Commons]. В отличие от предыдущих, это не набор для минималистов, а полноценная коллекция, состоящая из тысяч цветных значков, размером от 8x8 до 16x16.

'''Маленькие значки для Awesome'''
* Некоторые люди предпочитают использовать панели очень маленького размера (14px или даже меньше), и оригинальные значки Awesome не очень хорошо подходят для таких панелей. Поэтому были созданы несколько наборов небольших значков (14px и меньше) для отображения заголовков, методов компоновки окон и тегов: http://sysphere.org/~anrxc/local/images/awesome-icons-anrxc.tar.bz2
* Если вы не нашли необходимый размер для вашей панели, вы можете использовать этот  [http://git.ni.fr.eu.org/?p=nicolas/awesome-config.git;a=tree;f=icons генератор иконок awesome]. Он генерирует иконки для панели из anrxc. Вы можете найти примеры созданных иконок в моем блоге [http://ni.fr.eu.org/blog/awesome_icons/ blog entry].

[[Category:Themes]]</text>
      <sha1>g47wsgtpx84l6334fzsp7w9k4pb7t90</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Nice and Clean Theme</title>
    <ns>0</ns>
    <id>635</id>
    <revision>
      <id>4669</id>
      <timestamp>2011-01-16T06:05:45Z</timestamp>
      <contributor>
        <username>Blazeix</username>
        <id>285</id>
      </contributor>
      <comment>Created page with '[[Image:Screenshot-nac-theme.png|thumb|Screenshot]]  This theme is based off of the Openbox theme created by [http://workshop.ghost1227.com/2009/06/two-new-openbox-themes/ Ghost1…'</comment>
      <text xml:space="preserve" bytes="486">[[Image:Screenshot-nac-theme.png|thumb|Screenshot]]

This theme is based off of the Openbox theme created by [http://workshop.ghost1227.com/2009/06/two-new-openbox-themes/ Ghost1227]. You can download the awesome window manager theme [https://github.com/waf/nice-and-clean-theme from GitHub]. 

The date/time and system stats are drawn by [http://conky.sourceforge.net/ conky]. The needed conky configuration is in a subdirectory in the theme.

[[Category:Themes]]
[[Category:awesome3]]</text>
      <sha1>hloi1go6s7tfelghrxzr1ffdw0z7drt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Nm-applet</title>
    <ns>0</ns>
    <id>290</id>
    <revision>
      <id>7299</id>
      <parentid>7250</parentid>
      <timestamp>2015-01-25T16:56:02Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>restored old 'adduser' and changed external link on local</comment>
      <text xml:space="preserve" bytes="3820">{{Languages}}

nm-applet is a system tray application to help connect to both wired and wireless networks.

== Running as a non-root user: easy way ==
Add yourself to netdev group:

 adduser username netdev
or
 usermod username -aG netdev

Run nm-applet on startup by adding the following at the end of your rc.lua:
  awful.util.spawn(&quot;nm-applet&quot;)

A [[Autostart|better]] way to autostart programs is start them if they're not already running.

Restart awesome and try connecting to a network.
If this fails, follow the non-easy way below.

== Running as a non-root user ==
If one tries to run nm-applet as a non-root user then it will often show no networks, this is because of its security policies.  It is possible to run it using &quot;sudo nm-applet&quot;, however this will not allow you to autostart it.

To allow the user to run nm-applet on without root privileges the following files need to be edited:

/etc/dbus-1/system.d/NetworkManager.conf

/etc/dbus-1/system.d/NetworkManagerInfo.conf

/etc/dbus-1/system.d/nm-applet.conf

/etc/dbus-1/system.d/nm-avahi-autoipd.conf

/etc/dbus-1/system.d/nm-dhcp-client.conf

In each file, copy the section of text which starts with &lt;policy user=&quot;root&quot;&gt; and ends with &lt;/policy&gt;.
Paste it immediately below the &lt;/policy&gt; line, and change the &lt;policy user=&quot;root&quot;&gt; line to your username, i.e. &lt;policy user=&quot;fred&quot;&gt;, where &quot;fred&quot; is your username.  

For example:
 &lt;policy user=&quot;root&quot;&gt;
   &lt;allow own=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
   &lt;allow send_interface=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
 &lt;/policy&gt;

Becomes:
 &lt;policy user=&quot;root&quot;&gt;
   &lt;allow own=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
   &lt;allow send_interface=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
 &lt;/policy&gt;
 &lt;policy user=&quot;fred&quot;&gt;
   &lt;allow own=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
   &lt;allow send_interface=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
 &lt;/policy&gt;

After this, nm-applet should work when started normally.

== Fix error creating/editing new networks due to insufficient provileges ==
If you cannot create new networks or edit existing ones because of the error &quot;Failed to add new connection: (32) Insufficient privileges&quot;, then check [http://jeffhoogland.blogspot.fr/2012/05/howto-give-network-manager-sufficient.html this solution].

== Autostarting ==
To autostart nm-applet first add the above changes to the configuration, then add:
 os.execute(&quot;nm-applet &amp;&quot;)
To the end of your rc.lua file.

== nm-applet &gt;= 0.9.4.1-1 ==
The new version of &lt;tt&gt;nm-applet&lt;/tt&gt; requires polkit to be running in background in order to correctly work.
add your ''username'' to the ''netdev'' group

Create a small run_once script as described in the [[Autostart|Autostart]] page (eg: /usr/local/bin/run_once)

 #!/bin/bash
 #Alternative
 pgrep $@ &gt; /dev/null || ($@ &amp;)

at the end of the ''rc.lua'' add start the gnome polkit daemon and the applet&lt;br /&gt;
 awful.util.spawn_with_shell(&quot;/usr/lib/policykit-1-gnome/polkit-gnome-authentication-agent-1&quot;)
 awful.util.spawn_with_shell(&quot;run_once nm-applet&quot;)

;Note
: The ''run_once'' script avoid &lt;tt&gt;nm-applet&lt;/tt&gt; to start twice in case of multi-screen configuration.

== Known issue ==
The network icon is a bit too large to fit in the status bar if it uses the default 8pt font size.  Changing the font size to 10pt for example fixes this issue.  This is a bug in network-manager, see https://awesome.naquadah.org/bugs/index.php?do=details&amp;task_id=1143&amp;project=1&amp;pagenum=3 for more information.

== Alternative to &lt;tt&gt;nm-applet&lt;/tt&gt; ==
&lt;tt&gt;wicd&lt;/tt&gt; ([http://wicd.sourceforge.net/ wicd.sourceforge.net]) is an alternative to the gnome network manager and it only gtk dependent. &lt;tt&gt;wicd&lt;/tt&gt; as 3 client front-ends:
# '''wicd-cli''': a scriptable console client
# '''wicd-curses''': a Curse client
# '''wicd-gtk''': a gtk client interface and systray applet.


[[Category:Awesome2]]
[[Category:Awesome3]]</text>
      <sha1>5p6qvqqob3cyuis511bv62ug58pgj0l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Nm-applet/ru</title>
    <ns>0</ns>
    <id>1044</id>
    <revision>
      <id>7298</id>
      <parentid>6491</parentid>
      <timestamp>2015-01-25T16:49:13Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>translate last changes</comment>
      <text xml:space="preserve" bytes="5839">{{Languages|Nm-applet}}

nm-applet это приложение в системном трее, помогающее подключаться к проводной и безпроводной сети.


== Простой способ: Запуск не из под root пользователя ==
Добавьте себя в группу netdev:

 adduser username netdev
или
 usermod username -aG netdev

Добавьте nm-applet в автозагрузку, добавив следующий код в конце вашего rc.lua (примечание переводчика - лучше используйте способ описанный [[Autostart/ru|здесь]], во избежание повторного запуска приложения при перезапуске Awesome) :
  awful.util.spawn(&quot;nm-applet&quot;)

Перезапустите Awesome и попытайтесь подключится к сети.
Если это не удалось, то попробуйте другой, более сложный способ.

== Запуск не из под root пользователя ==

Если пытаться запусть nm-applet не из под root пользователя, часто вы не увидите сети, из-за политик безопасности. Можно запустить его как &quot;sudo nm-applet&quot;, одноко это не позволит вам добавить его в автозапуск.

Чтобы позволить пользователю запустить nm-applet без привелегий root пользователя, необходимо отредактировать следующие файлы:

/etc/dbus-1/system.d/NetworkManager.conf

/etc/dbus-1/system.d/NetworkManagerInfo.conf

/etc/dbus-1/system.d/nm-applet.conf

/etc/dbus-1/system.d/nm-avahi-autoipd.conf

/etc/dbus-1/system.d/nm-dhcp-client.conf

В каждом файле, скопируйте блок текста начинающийся с &lt;policy user=&quot;root&quot;&gt; и заканчивающийся &lt;/policy&gt;.
Вставьте его непосредственно после строки &lt;/policy&gt;, и заменитe строку &lt;policy user=&quot;root&quot;&gt; на ваше имя пользователя, т.е. &lt;policy user=&quot;fred&quot;&gt;, где  &quot;fred&quot; это ваше имя пользователя. 
Например:
 &lt;policy user=&quot;root&quot;&gt;
   &lt;allow own=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
   &lt;allow send_interface=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
 &lt;/policy&gt;

Должно получиться:
 &lt;policy user=&quot;root&quot;&gt;
   &lt;allow own=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
   &lt;allow send_interface=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
 &lt;/policy&gt;
 &lt;policy user=&quot;fred&quot;&gt;
   &lt;allow own=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
   &lt;allow send_interface=&quot;org.freedesktop.nm_dhcp_client&quot;/&gt;
 &lt;/policy&gt;

После этого, nm-applet должен запускаться нормально.

== Исправление ошибок создания/редактирования новых сетей из за недостаточных прав ==
Если вы не можете создать новые сети или отредактировать существующие, из-за ошибки &quot;Failed to add new connection: (32) Insufficient privileges&quot;, то проверьте [http://jeffhoogland.blogspot.fr/2012/05/howto-give-network-manager-sufficient.html эту инструкцию].

== Автозапуск ==
Для автозапуска nm-applet сначала добавьте указанные выше изменения в конфигурацию, затем добавьте:
 os.execute(&quot;nm-applet &amp;&quot;)
В конец вашего файла rc.lua.

== Для версии nm-applet &gt;= 0.9.4.1-1 ==
Новая версия &lt;tt&gt;nm-applet&lt;/tt&gt; требует, чтобы polkit был запущен в фоновом режиме, для корректной работы.
Добавьте ''username'' в группу ''netdev'' group

Создайте небольшой скрипт run_once как описано на странице [[Autostart/ru|Автозапуск]] (например: /usr/local/bin/run_once)

 #!/bin/bash
 #Alternative
 pgrep $@ &gt; /dev/null || ($@ &amp;)

В конце ''rc.lua'' добавьте старт демона gnome polkit и аплета
 awful.util.spawn_with_shell(&quot;/usr/lib/policykit-1-gnome/polkit-gnome-authentication-agent-1&quot;)
 awful.util.spawn_with_shell(&quot;run_once nm-applet&quot;)

;Замечание
: Скрипт ''run_once'' позволяет избезадть двойного запуска &lt;tt&gt;nm-applet&lt;/tt&gt; в случае многоэкранной конфигурации.

== Известные проблемы ==
Значок сети слишком большой, для размещения ее в панели, если используется размер шрифта по умолчанию 8pt. Измените размер шрифта на размер 10pt для решения этой проблемы. Эта ошибка в network-manager, смотрите https://awesome.naquadah.org/bugs/index.php?do=details&amp;task_id=1143&amp;project=1&amp;pagenum=3 для получения дополнительной информации.

== Альтернатива &lt;tt&gt;nm-applet&lt;/tt&gt; ==
&lt;tt&gt;wicd&lt;/tt&gt; ([http://wicd.sourceforge.net/ wicd.sourceforge.net]) является альтернативой gnome network manager, которая зависит толькл от gtk. &lt;tt&gt;wicd&lt;/tt&gt; состоит из 3х клиентских интерфейсов:
# '''wicd-cli''':скриптовый консольный клиента
# '''wicd-curses''': клиент Curse
# '''wicd-gtk''': gtk клиента и аплет системного трей.


[[Category:Awesome2]]
[[Category:Awesome3]]</text>
      <sha1>g4mxi3wtrs15fsjn2ktna7rneuho4w8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Notify script</title>
    <ns>0</ns>
    <id>577</id>
    <revision>
      <id>4804</id>
      <parentid>4400</parentid>
      <timestamp>2011-03-31T14:49:03Z</timestamp>
      <contributor>
        <username>Genjix</username>
        <id>503</id>
      </contributor>
      <comment>Replaced content with 'Use [http://code.google.com/p/irssi-libnotify/source/browse/trunk/notify.pl Notify-Send] instead.'</comment>
      <text xml:space="preserve" bytes="97">Use [http://code.google.com/p/irssi-libnotify/source/browse/trunk/notify.pl Notify-Send] instead.</text>
      <sha1>8fvth15c4ea7vfg3o7ksviktq4nhpuz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Notmuch mail integration</title>
    <ns>0</ns>
    <id>688</id>
    <revision>
      <id>6894</id>
      <parentid>4930</parentid>
      <timestamp>2014-07-29T17:46:57Z</timestamp>
      <contributor>
        <username>Bluh</username>
        <id>3325</id>
      </contributor>
      <comment>Added section on Awesome 3.5</comment>
      <text xml:space="preserve" bytes="6287">notmuch (http://notmuchmail.org/) is a local mail indexer that lets you organize your mail
via tags, which can be manipulated using various interfaces.
It's like using gmail but much more unixy :)
Although notmuch is build around a single xapian-index for each user, it doesn't loch this index
completely, as sup (http://sup.rubyforge.org/) does for instance.
Apart from the Emacs mode and cli binary you can manipulate your mails using go/python or ruby bindings.

Here is a starting point how you can get notmuch mail integrated in your desktop.

== Pre-Awesome 3.5 ==
I wrote a little vicious worker function to update widgets, you can get it here:
https://github.com/pazz/configs/raw/master/.config/awesome/notmuch.lua
It requires the json module however, which is packaged as &quot;liblua5.1-json&quot; in debian/ubuntu.

I put it next to my rc.lua and use it to update mail widgets this way:
&lt;pre&gt;
--rc.lua
require('notmuch')
...
mailicon = widget({ type = 'imagebox', name = 'mailicon'})
mailtext = widget({ type = &quot;textbox&quot; })
querystring = &quot;is:inbox and not tag:killed&quot;
vicious.register(mailtext, vicious.contrib.notmuch,
function (widget, args)
    if args[&quot;count&quot;] &gt; 0 then
            mailicon.image = image(beautiful.widget_mail)
    else
            mailicon.image = image(beautiful.widget_nomail)
    end
    return args[&quot;latest&quot;][&quot;tags&quot;]
end,
10, querystring)
mailbuttons = awful.util.table.join(
  awful.button({ }, 1, function () awful.util.spawn(&quot;urxvt -T alot -e alot '&quot;..querystring..&quot;'&quot;) end)
)
mailicon:buttons(mailbuttons)
&lt;/pre&gt;

the worker takes a querystring, in my case &quot;is:inbox and not tag:killed&quot; and returns an as &quot;count&quot;, the number of matching messages
and as &quot;latest&quot;, a lua table that represents the latest message.
Particularly, we can read the follwing keys from &quot;latest&quot;:
from, subject, id, timestamp, tags, and date_relative.
That means that if you want to display the subject of the latest mail on a textwidget somewhere,
read 
&lt;pre&gt;
args[&quot;latest&quot;][&quot;subject&quot;]
&lt;/pre&gt;

I adjusted the my maildir hoover script [[Email_maildir_naughty_hoover]] to query notmuch for messages:
grap it here: https://raw.github.com/pazz/configs/master/.config/awesome/notmuchhoover.lua
place it next to your rc.lua and attach it to a widget like this:
&lt;pre&gt;
require('notmuchhoover')
notmuchhoover.addToWidget(mailicon, &quot;is:inbox&quot;, 30)
&lt;/pre&gt;
The first argment is your widget, the second the querystring and the last one is the maximal number of matches you want displayed.
Full esample:
&lt;pre&gt;mailicon = widget({ type = 'imagebox', name = 'mailicon'})
mailtext = widget({ type = &quot;textbox&quot; })
querystring = &quot;is:inbox and not tag:killed&quot;
vicious.register(mailtext, vicious.contrib.notmuch,
function (widget, args)
    if args[&quot;count&quot;] &gt; 0 then
            mailicon.image = image(beautiful.widget_mail)
    else
            mailicon.image = image(beautiful.widget_nomail)
    end
    return args[&quot;latest&quot;][&quot;tags&quot;]
end,
10, querystring)
mailbuttons = awful.util.table.join(
  awful.button({ }, 1, function () awful.util.spawn(&quot;urxvt -T alot -e alot '&quot;..querystring..&quot;'&quot;) end)
)
mailicon:buttons(mailbuttons)
notmuchhoover.addToWidget(mailicon, querystring, 30)
&lt;/pre&gt;
It looks like this
[[File:email_notmuch_hoover_scrot.png]]

== Awesome 3.5 ==
This widget didn't work for me without changes in 3.5 so I decided to share an example config.

rc.lua
&lt;pre&gt;
home = os.getenv(&quot;HOME&quot;)

-- Mail widget
mailicon = wibox.widget.textbox()
vicious.register(mailicon, vicious.widgets.mdir, function (widget, args)
	if args[1] == 0
        	then return string.format(&quot;&lt;!--&gt;&quot;) 
        else return string.format('✉ &lt;span color=&quot;#dc322f&quot;&gt;' .. args[1] .. '&lt;/span&gt; | ')
        end
end, 60, { home..'/mail/new' })

-- Mail mouse hover
local mailhoover = require(&quot;mailhoover&quot;)
local mail_cmd = &quot;urxvt -e alot search is:inbox and not tag:killed&quot;

mailfolders =   {
    '/home/myusername/mail/new',
}

mailhoover:addToWidget(print,mailicon, &quot;is:inbox and not tag:killed&quot;,5)
mailbuttons = awful.util.table.join(
        awful.button({ }, 1, function () awful.util.spawn(mail_cmd) end)
)
mailicon:buttons(mailbuttons)
...
(add to layout where you want)
&lt;/pre&gt;
mailhoover.lua
&lt;pre&gt;
local string = string
local tostring = tostring
local io = io
local table = table
local pairs = pairs
local capi = {
    mouse = mouse,
    screen = screen
}
local os = os
local json = require(&quot;cjson&quot;)
local awful = require(&quot;awful&quot;)
local naughty = require(&quot;naughty&quot;)
local beautiful = require('beautiful')
module(&quot;mailhoover&quot;)

local popup
local query_format = &quot;&lt;span color='&quot; .. beautiful.fg_urgent ..&quot;'&gt;&lt;b&gt;&lt;u&gt;%s&lt;/u&gt;\n&lt;/b&gt;&lt;/span&gt;&quot;
local thread_format = &quot;&lt;span color='&quot; .. beautiful.fg_normal..&quot;'&gt;%s &lt;/span&gt;&lt;span color='&quot; .. beautiful.fg_focus ..&quot;'&gt;%s &lt;/span&gt;&lt;span color='&quot; .. beautiful.fg_urgent ..&quot;'&gt;(%s)&lt;/span&gt;&quot;

local mailhoover = {}

function mailhoover:addToWidget(print,mywidget, querystring, maxcount)
 	mywidget:connect_signal('mouse::enter', function ()
	local info = mailhoover:read_index(print,querystring,maxcount)
        popup = naughty.notify({
                title = &quot;&quot;,
                text = string.format(query_format,querystring) .. &quot;&lt;br&gt;&quot; .. info,
                timeout = 0,
                hover_timeout = 0.5,
                screen = capi.mouse.screen
        })
  end)
  mywidget:connect_signal('mouse::leave', function () naughty.destroy(popup) end)
end

function mailhoover:read_index(print,querystring,maxcount)
    local info = &quot;&quot;
    local count = 0

    local f = io.popen(&quot;notmuch search --format=json &quot;..querystring)
    local out = f:read(&quot;*all&quot;)
    print(out)
    f:close()
    local threads = json.decode(out)

    for num,thread in pairs(threads) do
        if count == maxcount then break else count = count +1 end
        date = os.date(&quot;%c&quot;,thread[&quot;timestamp&quot;])
        subject = thread[&quot;subject&quot;]
        subject = string.gsub(subject, &quot;&amp;&quot;,&quot;&amp;amp;&quot;)
        subject = string.gsub(subject, &quot;&lt;&quot;,&quot;&amp;lt;&quot;)
        subject = string.gsub(subject, &quot;&gt;&quot;,&quot;&amp;gt;&quot;)
        authors = thread[&quot;authors&quot;]
        authors = string.gsub(authors, &quot;&lt;(.*)&gt;&quot;,&quot;&quot;)
        tags = table.concat(thread[&quot;tags&quot;],', ')

        info = info .. string.format(thread_format,date,authors,subject,tags) .. '\n' -- optionally omit timestamps by removing date
    end
   return info
end

return mailhoover

&lt;/pre&gt;</text>
      <sha1>01p4ox0xtqzqb3z5ldgse22bdy93yfp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Nvidia-settings Widget</title>
    <ns>0</ns>
    <id>869</id>
    <revision>
      <id>5651</id>
      <timestamp>2012-11-24T20:44:21Z</timestamp>
      <contributor>
        <username>Rman</username>
        <id>1482</id>
      </contributor>
      <comment>New page about nvidia-settings</comment>
      <text xml:space="preserve" bytes="1075">For those using Nvidia's Linux binary driver, it is possible to use the ''nvidia-settings'' program to query GPU temperature, performance level, and other statistics for use in widgets.

==nvidia-settings==
The basic syntax for querying a property is:
&lt;pre&gt;
nvidia-settings -q &lt;property&gt; -t
&lt;/pre&gt;

A list of all GPU-related properties can be acquired by running:
&lt;pre&gt;
nvidia-settings -q all | grep &quot;Attribute 'GPU&quot;
&lt;/pre&gt;

==Example==
It is trivial to capture the output of an nvidia-settings command and display it in a widget. This simple example displays the current GPU core temperature and PowerMizer performance level.
&lt;pre&gt;
-- GPU widget
gpuwidget = widget({ type = &quot;textbox&quot; })
function update_nvidia()
    perf = io.popen(&quot;nvidia-settings -q gpucurrentperflevel -t&quot;, &quot;r&quot;)
    temp = io.popen(&quot;nvidia-settings -q gpucoretemp -t&quot;, &quot;r&quot;)
    gpuwidget.text = &quot; &lt;span color='#f6f6f6'&gt;gpu&lt;/span&gt; lvl &quot; .. perf:read() .. &quot;, &quot; .. temp:read() .. &quot;C &quot;
    perf:close()
    temp:close()
end
awful.hooks.timer.register(3, function() update_nvidia() end)
update_nvidia()
&lt;/pre&gt;</text>
      <sha1>sslhgi22hpvqa739om5vgmklb9emre3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Obvious</title>
    <ns>0</ns>
    <id>438</id>
    <revision>
      <id>6248</id>
      <parentid>6247</parentid>
      <timestamp>2014-02-11T19:43:55Z</timestamp>
      <contributor>
        <username>Klay</username>
        <id>3168</id>
      </contributor>
      <minor/>
      <comment>Fixed CONTRIBUTING URL</comment>
      <text xml:space="preserve" bytes="2107">{{Languages}}

The Obvious Repository is a set of widgets for your awesome desktop that provide helpful information. It's an independent project that has the community support.

== Getting the Obvious Repo ==

First go to your awesome dir in XDG_CONFIG_HOME (which should be ~/.config).

 $ cd $XDG_CONFIG_HOME/awesome

Then clone the repository in this directory:

 $ git clone git@github.com:hoelzro/obvious.git

You can check the widgets available by going into the new obvious directory and looking at the folders.

== Obvious version ==

Obvious ''master'' uses bleeding edge updates from awesome ''master''. You should checkout the obvious version tagged with your current awesome version.

== Adding widgets to your desktop ==

Now that you've got the repo it's time to add the widgets you want. Go into the directory of the widget you're interested and read the readme provided there. It will explain the specifics of implementing this particular widget. Generally, this is pretty easy, and generally follows the format of:
* &quot;require&quot; the correct module at the top of your rc.lua.
* Configure some settings for the module.
* Add the widget to your wibox's widget list.
* Add bindings to it.

A lot of the time, the bindings/configurations aren't necessary, so it's just two lines worth of changes. Example (the volume control):
* require(&quot;obvious.volume_alsa&quot;) -- Load the module
* obvious.volume_alsa.setchannel(&quot;Master&quot;) -- Configure the module
* obvious.volume_alsa(), -- Add this to your widgets list
* awful.key({ modkey }, &quot;m&quot;, obvious.volume_alsa.mute), -- Add a bind for the widget

== Writing new modules ==

Feel free to write an obvious module if you have a great idea and would like to implement it. Submit them to awesome-devel@naquadah.org. You should sign up for this mailing list. Check the [http://awesome.naquadah.org/doc/api/ API Documentation] for info about functions you may use. Also, check out the &quot;[https://github.com/hoelzro/obvious/blob/master/CONTRIBUTING.md CONTRIBUTING]&quot; file in the obvious source code for full description.

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>o9y5mjgtdaxzv6e48ecl5lic9vd9xvp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Obvious/es</title>
    <ns>0</ns>
    <id>443</id>
    <revision>
      <id>3325</id>
      <parentid>3323</parentid>
      <timestamp>2009-07-12T18:49:58Z</timestamp>
      <contributor>
        <username>MasterLoki</username>
        <id>328</id>
      </contributor>
      <text xml:space="preserve" bytes="1787">{{Template:Languages|Obvious}}

El repositorio Obvious tiene una serie de widgets para tu desktop que proveen información útil. Es un proyecto independiente que tiene el apoyo de la comunidad.

== Obteniendo Obvious ==

Primero ve a tu directorio awesome en XDG_CONFIG_HOME

 $ cd $XDG_CONFIG_HOME/awesome

Después clona el repositorio en este lugar.

 $ git clone git://git.mercenariesguild.net/obvious.git

Puedes ver que widgets estan disponibles revisando las carpetar en el directorio obvious.

== Agregando widgets al escritorio ==

Ya que tienes el repositorio es momento de agregar los widgets que quieres. Ve al directorio al que estas interesado y lee el readme que esta ahí. Esto explicará como agregar ese widget en particular. Generalmente es muy facil y generalmente sigue los siguientes pasos.

    * &quot;require&quot; el modulo hasta arriba de tu rc.lua.
    * Configurar algunas opciones del módulo.
    * Agregar el widget a la lista de widgets de tu wibox.
    * Agrega los bindings. 

Muchas veces, las configuraciones/bindings/ no son necesarias, así que solo dos líneas valen la pena cambiar. Ejemplo (el control volumen):

    * require(&quot;obvious.volume_alsa&quot;) -- Cargar el módulo
    * obvious.volume_alsa.setchannel(&quot;Master&quot;) -- Configurar el módulo
    * obvious.volume_alsa(), -- Agregar el volumen a mis widgets list
    * awful.key({ modkey }, &quot;m&quot;, obvious.volume_alsa.mute), -- Agregar un bind para el widget 

== Escribiendo nuevos módulos ==

Siente libre de escribir un módulo de obvious si crees que hace falta, ya sea para ti o para la comunidad awesome. 
Envialos a awesome-devel@naquadah.org. 
Revisa la [http://awesome.naquadah.org/doc/api/ API Documentation] para ver de que funciones puedes echar mano

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>qbrdk2l80ou6owfnq90lvkuhjn0i3gb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Obvious/ru</title>
    <ns>0</ns>
    <id>452</id>
    <revision>
      <id>6250</id>
      <parentid>6249</parentid>
      <timestamp>2014-02-11T19:48:37Z</timestamp>
      <contributor>
        <username>Klay</username>
        <id>3168</id>
      </contributor>
      <minor/>
      <comment>Minor fixes</comment>
      <text xml:space="preserve" bytes="3313">{{DISPLAYTITLE:Obvious}}
{{Template:Languages|Obvious}}

Репозиторий Obvious - это набор виджетов для Awesome, выводящих различную полезную информацию. Это независимый проект, поддерживаемый сообществом.

== Получение репозитория Obvious ==

Для начала перейдите в каталог awesome, находящийся в XDG_CONFIG_HOME (обычно это ~/.config).

 $ cd $XDG_CONFIG_HOME/awesome

Затем скопируйте репозиторий:

 $ git clone git@github.com:hoelzro/obvious.git

Теперь можно узнать, какие виджеты доступны, перейдя в каталог obvious и посмотрев список директорий в нём.

== Добавление виджетов на рабочий стол ==

Итак, Вы загрузили репозиторий, теперь можно добавить виджеты. Перейдите в директорию с интересующим Вас виджетом и прочитайте прилагаемый файл readme. Из него Вы узнаете об особенностях реализации виджета. Как правило, добавление виджета - довольно простая процедура, состоящая из нескольких шагов:
* Добавить в начало Вашего rc.lua вызов &quot;require&quot; с именем нужного модуля.
* Настроить некоторые параметры модуля.
* Добавить виджет в список wibox'а.
* Добавить сочетания клавиш для управления виджетом.

В большинстве случаев настройка параметров и сочетаний клавиш не требуется, поэтому всё, что нужно - изменить две строчки. Пример (управление громкостью):
* require(&quot;obvious.volume_alsa&quot;) -- Загрузка модуля
* obvious.volume_alsa.setchannel(&quot;Master&quot;) -- Настройка модуля
* obvious.volume_alsa(), -- Добавьте это в список виджетов
* awful.key({ modkey }, &quot;m&quot;, obvious.volume_alsa.mute), -- Добавление сочетания клавиш

== Написание новых модулей ==

Если у Вас есть отличная идея и Вы хотите реализовать её, не стесняйтесь написать модуль obvious и отправить его на awesome-devel@naquadah.org. Вы должны быть подписаны на этот список рассылки. Ознакомьтесь с [http://awesome.naquadah.org/doc/api/ документацией по API] для получения информации о функциях, которые Вы можете использовать в модулях. Также посмотрите файл &quot;[https://github.com/hoelzro/obvious/blob/master/CONTRIBUTING.md CONTRIBUTING]&quot; в исходном коде obvious, содержащий полное описание.

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>9radg6fovm80yxszvixnckxn0i0db9h</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>On Screen Keyboard</title>
    <ns>0</ns>
    <id>1313</id>
    <revision>
      <id>7399</id>
      <parentid>7398</parentid>
      <timestamp>2015-12-27T03:23:51Z</timestamp>
      <contributor>
        <username>Cmotc</username>
        <id>4311</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="3701">== Using Awesome with an On-Screen Keyboard ==
Getting an On-Screen keyboard to work with Awesome is not exactly easy. Following these instructions will get florence running usably on Awesome.

=== First, calibrate to the correct values ===

You'll need to get some information in order to resize and position they keyboard correctly. In this configuration, we're going to have the virtual keyboard displayed flush against the right-hand side of the screen and have a margin on the left hand side. Florence doesn't let you set a fixed height and width in the configuration file, instead you have to figure out the dimensions that correspond to the maximum usable zoom setting and set it in a config file. First, copy the example config file

    mkdir -p ~/.config/florence
    cp /usr/share/doc/florence/examples/florence.conf ~/.config/florence

Then launch florence in a terminal using the command.

    florence --config --use-config ~/.config/florence/florence.conf

which will allow you to edit your personal configuration file using florence's built-in tool. If you prefer, you can edit it using a text editor but the gui config tool is easier for this part. Go to where it says Window and zoom until it takes up the full width of the screen.

Finally, add the following lines to your rc.lua file.

    { rule = { class = &quot;Florence&quot; },
      properties = {
      floating = true,
      sticky = true,
    }, callback = function(c) 
           for key, value in pairs(c.geometry(c)) do
               naughty.notify({ title = &quot;Geometry&quot;,
                     text = &quot;X,Y: &quot; .. c.geometry(c).x .. &quot;,&quot; .. c.geometry(c).y .. &quot;W,H: &quot; .. c.geometry(c).width .. &quot;,&quot; .. c.geometry(c).height })
           end
       end },

And restart awesome. The dimensions of your on-screen keyboard will pop up in your naughtyfications. Make a note of them before moving on.

=== Then, create a little wrapper around florence. ===

Create a file with the following content in /usr/bin/user-florence to launch florence with your config.

    #! /bin/sh
    awesome_florence(){
        if [ -f &quot;$HOME/.config/florence/florence.conf&quot; ]; then
            florence --use-config &quot;$HOME/.config/florence/florence.conf&quot;
        elif [ -f &quot;/etc/florence.conf&quot; ]; then
            florence --use-config &quot;/etc/florence.conf&quot;
        else
            florence
        fi
    }
    awesome_florence

=== Next, configure the necessary constants in rc.lua ===

Take the keyboard dimensions you gathered in the first step and plug them into the following variables, which you can place anywhere above the rules section of your rc.lua file. The resolution of the screen I worked this out on was 1360x768, yours will be different if your resolution is different.

    geom = screen[mouse.screen].workarea
    kb_geoh = 335 -- You'll need to change this value to match with your screen resolution
    kb_geow = 1306 -- Same here

    kb_geox = geom.width - kb_geow -- This makes sure the virtual keyboard is against the far right
    kb_geoy = geom.height - kb_geoh -- and the far bottom
    kb_dummy_geox = geom.width - 134 -- for some reason florence spawns this irritating extra window. This is to minimize that irritation.
    kb_dummy_geoy = geom.height - 134 -- same here.

=== Finally, add the rules ===

    { rule = { class = &quot;Florence&quot; },
      properties = {
      floating = true,
      sticky = true,
    }, callback = function(c) 
           for key, value in pairs(c.geometry(c)) do
               if c.geometry(c).y &lt; 400 then
                   c:geometry({x=kb_dummy_geox, y=kb_dummy_geoy, height=134, width=134})
               end
           end
       end },

And you have a usable on screen keyboard for awesome</text>
      <sha1>oyr7an45r9w8w393tul1bhxpqazkt3l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>OpenBSD Volume Control Widget</title>
    <ns>0</ns>
    <id>23</id>
    <revision>
      <id>1289</id>
      <timestamp>2008-10-16T15:03:25Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1932">OpenBSD (and I believe NetBSD as well) uses mixerctl to control your sound device(s). /etc/mixerctl.conf can be used to set default values, but typing in mixerctl outputs.master.volume=140,140 is  a bit tedious.

A few textboxes and a simple shellscript make life a lot easier under Awesome.

Add the following information to your statusbar

'''.awesomerc additions: '''
 	textbox volDown {
 	 	mouse {
 			button = 1
 			command = &quot;spawn&quot;
 			arg = &quot;~/.awesome/awesome-openbsd-volume down&quot;
 		}
 		text = &quot; - &quot;
 	}
 	textbox volStatusMute {
 		text = &quot; vol &quot;
 		mouse {
 			button = 1
 			command = &quot;spawn&quot; 
 			arg = &quot;~/.awesome/awesome-openbsd-volume mute&quot;
 		}
 	}
 	textbox volUp {
 		mouse {
 			button = 1
 			command = &quot;spawn&quot;
 			arg = &quot;~/.awesome/awesome-openbsd-volume up&quot;
 		}
 		text = &quot; + &quot;
 	}

 

Save the following shellscript somewhere appropriate and don't forget to make it executable.

'''Shell script :'''
 #!/bin/sh
 # little shellscript to modify the mixerctl values with awesome WM
 
 # important: the name of the device you want to use. on my laptop, the speakers are
 #outputs.headphones, change to outputs.master or whatever according to your setup
 device=outputs.headphones
 
 #just as important, location of awesome-client!
 awClient=&quot;/usr/local/bin/awesome-client&quot;
 
 # increment: value by which the mixerctl value will go up/down
 increment=10
 
 case $1 in
 	&quot;up&quot; )
 		#increment
 		mixerctl &quot;$device=+$increment&quot;
 		;;
 	&quot;down&quot; )
 		#decrement
 		mixerctl &quot;$device=-$increment&quot;
 		;;
 	&quot;mute&quot; )
 		#mute or unmute depending on the current value
 		if [ `mixerctl &quot;$device.mute&quot;` == &quot;$device.mute=on&quot; ] 
 		then
 			mixerctl &quot;$device.mute=off&quot;
 			echo 0 widget_tell volStatusMute text &quot; mute &quot; | $awClient 
 		else
 			mixerctl &quot;$device.mute=on&quot;
 			echo 0 widget_tell volStatusMute text &quot; unmute &quot; | $awClient 
 		fi
 		;;
 esac

[[Category:Widgets]]
[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>qzsz0xqb8yten38d6hh7j8yfs7t0e4n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Orglendar widget</title>
    <ns>0</ns>
    <id>648</id>
    <revision>
      <id>6278</id>
      <parentid>5445</parentid>
      <timestamp>2014-03-05T16:54:35Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <comment>correct module loading line</comment>
      <text xml:space="preserve" bytes="2950">=== Description ===

[[Image:Org-file_example_screenshot.png|right|thumb|Comprehensive example of org-mode file...]]

[[Image:Orglendar_example_screenshot.png|right|thumb|...And this is how this file is shown by widget]]

The original idea of this widget was to mix [[Calendar_widget]] with [http://dleone.fensalir.fr/index.php?tag/org-awesome this] great org-mode widget. So the '''orglendar''' was born.

Features:

* shows on-demand calendar with marked schedules and deadlines

* shows schedules and deadlines ordered by date

* supports multiple org-files 

=== Details ===

Widget parses specified files searching for '''SCHEDULE:''' and '''DEADLINE:''' tags. When the widget finds them it shows the respective org-mode entries.

When the widget finds in the entry line tags like '''TODO, DONE''' or any other all-capital tag at the beginning of the line, this tag is cut. If the entry line contains keyword tags (e.g. ''':job:project:''') these tags are aligned properly on the right side. If two events happen on the same date, they are grouped together. All days with events on them are marked red on the calendar.

=== How to install ===

* If you use Awesome v.3.4.x then download the file '''orglendar.lua''' from [https://github.com/alexander-yakushev/Orglendar/blob/awesome-3.4.x/orglendar.lua here]. If you are a git/master Awesome user then get [https://github.com/alexander-yakushev/Orglendar/blob/master/orglendar.lua this one]

* Put the file into your /home/''username''/.config/awesome/ folder.

* Open your '''rc.lua''' file. If you are new to awesome scripting and your config is still pretty untouched, then find this (or similar) line:

  mytextclock = awful.widget.textclock({ align = &quot;right&quot; })

and add these lines just after it

  local orglendar = require('orglendar')
  orglendar.files = { &quot;/home/username/Documents/Notes/work.org&quot;,    -- Specify here all files you want to be parsed, separated by comma.
                      &quot;/home/username/Documents/stuff/home.org&quot; }
  orglendar.register(mytextclock)

* If you cannot find anything like '''mytextclock''' in your rc.lua, then you probably changed this textclock widget by something else. This means you are advanced enough to find another widget to bind calendar to. In this case only the last line will change:

  orglendar.files = { &quot;/home/username/Documents/Notes/work.org&quot;,    -- Specify here all files you want to be parsed, separated by comma.
                      &quot;/home/username/Documents/stuff/home.org&quot; }
  orglendar.register(''your_widget'')

* Now just hover your mouse over the clock widget and enjoy!

=== How to use ===

* To make the calendar and to-do list appear, move your mouse cursor onto the widget.

* To remove the calendar and list just move your mouse outside the widget.

* You can scroll your mouse wheel back and forth (while cursor is still on the widget) to switch months on the calendar.

[[Category:Widgets]]

[[Category:awesome3]]</text>
      <sha1>ph3z33hdiy2i7csuaih2uu4rmk34z63</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Persian keyboard layout</title>
    <ns>0</ns>
    <id>1256</id>
    <revision>
      <id>7175</id>
      <timestamp>2014-12-20T00:37:56Z</timestamp>
      <contributor>
        <username>MohsenPahlevanzadeh</username>
        <id>4089</id>
      </contributor>
      <comment>Created page with &quot;However [https://awesome.naquadah.org/wiki/Change_keyboard_maps Changing Keyboard map] explains how to in details, But I decide to wrote a function to change my layout to [htt...&quot;</comment>
      <text xml:space="preserve" bytes="876">However [https://awesome.naquadah.org/wiki/Change_keyboard_maps Changing Keyboard map] explains how to in details, But I decide to wrote a function to change my layout to [http://en.wikipedia.org/wiki/Persian_language Persian Language] map, You can add the following code to rc.lua for using it:
  -- the following code teste on 3.5 
  keyboard_layout = {&quot;us&quot;,&quot;ir&quot;}
  current_layout =  keyboard_layout[1]
  switch = function() 
    if current_layout == &quot;us&quot; then current_layout = keyboard_layout[2]
    else current_layout =  keyboard_layout[1] end
    os.execute(&quot;setxkbmap &quot; .. current_layout)
    naughty.notify{text=&quot;Keyboard layout has been changed to &quot; .. current_layout}
  end  
  globalkeys = awful.util.table.join(globalkeys, awful.key({ &quot;Mod1&quot;  }, &quot;Shift_L&quot;, function()  switch() end ))

You can change between English and Persian language with ALT_L + SHIFT_L keys.</text>
      <sha1>8h3ketb6i4y6pux4xpj16gica2fnsuu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>PowerManagement</title>
    <ns>0</ns>
    <id>789</id>
    <revision>
      <id>6158</id>
      <parentid>5621</parentid>
      <timestamp>2013-10-30T15:21:55Z</timestamp>
      <contributor>
        <username>Eugen Dedu</username>
        <id>3095</id>
      </contributor>
      <comment>Fix typo</comment>
      <text xml:space="preserve" bytes="1327">The Power Management is managed by ACPI (Advanced Configuration &amp; Power Interface)


See packages :
dpkg -l | grep acpi
&lt;pre&gt;
ii  acpi                                 1.6-1                          displays information on ACPI devices
ii  acpi-fakekey                         0.138-10                       tool to generate fake key events
ii  acpi-support                         0.138-10                       scripts for handling many ACPI events
ii  acpi-support-base                    0.138-10                       scripts for handling base ACPI events such as the power button
ii  acpid                                1:2.0.14-2                     Advanced Configuration and Power Interface event daemon
&lt;/pre&gt;
dpkg -l |grep pm-utils
&lt;pre&gt;
ii  pm-utils                             1.4.1-9                        utilities and scripts for power management
&lt;/pre&gt;



== First search result ==

http://www.thinkwiki.org/wiki/How_to_make_ACPI_work

http://pm-utils.freedesktop.org/wiki

http://wiki.debian.org/ACPI

http://numpanglewat.wordpress.com/2009/01/15/more-faster-acpi-shutdown-on-debian-change-your-acpi-script/

http://old-en.opensuse.org/Pm-utils

https://github.com/craig/cbatt



== More ==

Monitor you power consumption with powertop : http://www.linuxpowertop.org/ ; http://www.linuxpowertop.org/known.php</text>
      <sha1>qpe0wqbeqes3b0srtq8lp76nzcky51s</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Preserve Current Directory for New Terminal Windows on Linux</title>
    <ns>0</ns>
    <id>1326</id>
    <revision>
      <id>7480</id>
      <parentid>7479</parentid>
      <timestamp>2016-08-05T13:30:00Z</timestamp>
      <contributor>
        <username>Barlik</username>
        <id>4310</id>
      </contributor>
      <text xml:space="preserve" bytes="4422">
By default, when you press Mod+Return, a new terminal window is opened with $HOME (~) as a current working directory. But if you press Mod+Return when another terminal window is focused and it has different working directory, why not open the new terminal in the directory from the previous one?

The idea is that if some client is currently focused, we know its &lt;code&gt;PID&lt;/code&gt; (because it's stored in &lt;code&gt;client.pid&lt;/code&gt;), and we can read its current directory from &lt;code&gt;/proc/&lt;/code&gt; and open a new terminal in that dir. I will use URxvt as an example, but I believe it can be adopted to use with any terminal emulator.

1. Before we can start, we need to install Lua POSIX bindings. This can be done with &lt;code&gt;luarocks&lt;/code&gt;. First install &lt;code&gt;luarocks&lt;/code&gt; with your distro package manager, then install &lt;code&gt;luaposix&lt;/code&gt; module:

&lt;pre&gt;luarocks install luaposix --local&lt;/pre&gt;

You can also install it globally, just run as root without &lt;code&gt;--local&lt;/code&gt;.

2. Then we need to adjust the &lt;code&gt;LUA_PATH&lt;/code&gt; environment variable so that Awesome could find installed module. Run &lt;code&gt;luarocks path&lt;/code&gt; and copy-paste  output to your &lt;code&gt;.bashrc&lt;/code&gt;.

3. Re-login and start awesome with your new &lt;code&gt;LUA_PATH&lt;/code&gt;.

4. Now the fun begins. (I'm assuming that &lt;code&gt;terminal = &quot;urxvt&quot;&lt;/code&gt;.)

Open your Awesome config and load the posix module:
&lt;pre&gt;
local posix = require(&quot;posix&quot;)
&lt;/pre&gt;

Put this function somewhere at the beginning of your config. We going to need it to escape command-line arguments.
&lt;pre&gt;
-- from shell.lua, by Peter Odding
local function escape(...)
    local command = type(...) == 'table' and ... or { ... }
    for i, s in ipairs(command) do
        s = (tostring(s) or ''):gsub('&quot;', '\\&quot;')
        if s:find '[^A-Za-z0-9_.&quot;/-]' then
            s = '&quot;' .. s .. '&quot;'
        elseif s == '' then
            s = '&quot;&quot;'
        end
        command[i] = s
    end
    return table.concat(command, ' ')
end
&lt;/pre&gt;

Find this line:

&lt;pre&gt;
awful.key({ modkey,           }, &quot;Return&quot;, function () awful.util.spawn(terminal) end),
&lt;/pre&gt;

and turn it to:

&lt;pre&gt;
awful.key({ modkey,           }, &quot;Return&quot;, function ()
    local c = client.focus
    local cmd = terminal
    
    local pid
    if c and c.class == &quot;URxvt&quot; then
        local fd = io.popen(&quot;pgrep -P &quot; .. c.pid)
        pid = fd:read()
        fd:close()

        if pid then
            local cwd = posix.readlink(&quot;/proc/&quot; .. pid .. &quot;/cwd&quot;)
            cmd = cmd .. &quot; -cd &quot; .. escape(cwd)
        end
    end

    awful.util.spawn(cmd)
end),
&lt;/pre&gt;

This is what happens here: since the URxvt itself doesn't change the current directory when you &lt;code&gt;cd&lt;/code&gt;, we need to find the PID of its first child, which is expected to be a shell, e.g. Bash. Then we read where a &lt;code&gt;/proc/&lt;PID&gt;/cwd&lt;/code&gt; link points to and spawn a new URxvt instance with that path in arguments.

The idea can be adopted to use with other apps. This is how you can read &lt;code&gt;cwd&lt;/code&gt; of GVim and SpaceFM file manager.

&lt;pre&gt;
awful.key({ modkey,           }, &quot;Return&quot;, function ()
    local c = client.focus
    local cmd = terminal
    
    if c then
        local pid
        local cwd
        if c.class == &quot;URxvt&quot; then
            local fd = io.popen(&quot;pgrep -P &quot; .. c.pid)
            pid = fd:read()
            fd:close()
        elseif c.class == &quot;Gvim&quot; then
            pid = c.pid
        elseif c.class == &quot;Spacefm&quot; then
            cwd = c.name
        end

        if pid then
            cwd = posix.readlink(&quot;/proc/&quot; .. pid .. &quot;/cwd&quot;)
        end
        if cwd then
            cmd = cmd .. &quot; -cd &quot; .. escape(cwd)
        end
    end

    awful.util.spawn(cmd)
end),
&lt;/pre&gt;


== Alternative solution ==

This will work with any program (Thunar, double commander, ...)

Define popen_line function:
&lt;pre&gt;
function popen_line(cmd)
	local f = io.popen(cmd)
	if not f then return nil end
	local line = f:read(&quot;*line&quot;)
	f:close()
	if not line then return nil end
	return line:match(&quot;[^\n]*&quot;)
end
&lt;/pre&gt;

And then define you keybinding:

&lt;pre&gt;
	awful.key({ modkey    }, &quot;Return&quot;, function(c)
		-- get cwd
		cwd = popen_line(string.format('readlink /proc/$(pgrep -P %d)/cwd || readlink /proc/%d/cwd', c.pid, c.pid))

		if terminal == 'urxvt' then
			awful.util.spawn(string.format(&quot;%s -cd '%s'&quot;, terminal, cwd))
		else
			awful.util.spawn_with_shell(string.format(&quot;cd '%s'; exec %s&quot;, cwd, terminal))
		end
	end),
&lt;/pre&gt;</text>
      <sha1>3r9jftuj4jhfbjl81g0qiw94s9wsu9n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Problems with Java</title>
    <ns>0</ns>
    <id>213</id>
    <revision>
      <id>7379</id>
      <parentid>7336</parentid>
      <timestamp>2015-10-25T08:31:36Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use :connect_signal instead of :add_signal</comment>
      <text xml:space="preserve" bytes="6173">The X Window System integration in most modern implementations of the Java virtual machine (JVM) displays only empty, gray windows when used with many non-re-parenting window managers, such as Awesome.  This is almost certainly a violation of ICCCM and has been [http://bugs.sun.com/view_bug.do?bug_id=6429775 reported to Sun Microsystems a number of times].

== Version 1.8 ==
If you can't seem switch to a Java window using your keyboard, add the following to your rc.lua:

&lt;pre&gt;
function delay_raise ()
   -- 5 ms ages in computer time, but I won't notice it.
   local raise_timer = timer { timeout = 0.005 }
   raise_timer:connect_signal(&quot;timeout&quot;,
			 function()
			    if client.focus then
			       client.focus:raise()
			    end
			    raise_timer:stop()
   end)
   raise_timer:start()
end
&lt;/pre&gt;

Then, replace all instances of &lt;pre&gt;if client.focus then client.focus:raise() end&lt;/pre&gt; with &lt;pre&gt;delay_raise()&lt;/pre&gt;. Note that &lt;pre&gt;Mod4-Tab&lt;/pre&gt; has it formatted slightly differently.

===Sun JVM===
Netbeans' menus did not work all of the time unless I applied the nonreparenting windows fix:

&lt;pre&gt;
_JAVA_AWT_WM_NONREPARENTING=1; export _JAVA_AWT_WM_NONREPARENTING
&lt;/pre&gt;

===JMenuBar shifted===
You may experience shifted focus of JMenuBars, when using mouse. It can also appear as autoclick to the first menu item. It can be fixed with the following:
&lt;pre&gt;
wmname Sawfish
&lt;/pre&gt;

== Version 1.7 ==

=== Sun JVM ===

Although lots of java applications seem to work fine, at least the intellij and netbeans versions as of 2011-11-21 don't seem to work.

=== OpenJDK ===

Intellij and netbeans work with the fix described below. Most other java apps seem to work fine even without the fix.

=== Recent Changes ===

As of Java 1.7 and Awesome 3.5 the fixes described below may actually cause undesirable behaviour related to menus. Awesome is now, apparently, a reparenting window manager as of [http://git.naquadah.org/?p=awesome.git;a=commit;h=102063dbbdfb0bc9f43268d98f7dcb5269547395 this commit]. If you are experiencing problems having applied the 'wmname' and '_JAVA_AWT_WM_NONREPARENTING' fixes against a recent Java and Awesome try removing both fixes.

This behaviour was observed with the awesome-git package in Arch Linux as of 2013-07-14.

As of 2014-01-24 there are still ongoing problems with some Java Swing applications, in particular with respect to multiple monitors and the rendering of drop-down menus. The best current workaround at present seems to be to make these windows floating. A bug report has been filed and is tentatively projected to be fixed in release 3.5.3.

=== Multi-screen setup ===

It might work if you launch your java application with '_JAVA_AWT_WM_NONREPARENTING' environment variable set on the first (as defined in your X11/Xorg configuration file) screen.

=== JetBrains IDEs ===

If you're experiencing any menu-related issues in JetBrain's IDEs, you can try disabling all other fixes and use [https://github.com/sampowers/dotfiles/blob/100a4530485ddd36ff8787f9f657f7578983bfc8/bin/java_nonreparenting_wm_hack.sh this script] with &quot;Sawfish&quot; instead of &quot;LG3D&quot; for IRONIC_WM_NAME. It may also help with other java issues, but i can't confirm it. 

As of PhpStorm, it was fixed in EAP build 138.826.

=== Visual Paradigm ===

Setting the wmname to LG3D doesn't work with Visual Paradigm. However, it works with Sawfish:

&lt;pre&gt;wmname Sawfish&lt;/pre&gt;

== Versions 1.5 And 1.6 ==

=== Use OpenJDK With Vendor Fix ===

The versions of OpenJDK that ship with some operating system distributions&amp;mdash;at least [http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=508650 Debian (and Ubuntu)] and [http://bugs.archlinux.org/task/15674 Arch Linux] in March and August of 2009, respectively&amp;mdash;have had this problem fixed by the vendors.  Just set the environment variable &lt;code&gt;_JAVA_AWT_WM_NONREPARENTING&lt;/code&gt; to any value to inform the JVM that your window manager does not re-parent.

&lt;pre&gt;$ _JAVA_AWT_WM_NONREPARENTING=1; export _JAVA_AWT_WM_NONREPARENTING&lt;/pre&gt;

As of 17 September 2009, this patch [http://hg.openjdk.java.net/jdk6/jdk6/jdk/log/tip/src/solaris/classes/sun/awt/X11/XWM.java has not been applied upstream by Sun Microsystems].

=== Impersonate Another Window Manager ===

You may use the [http://www.suckless.org/programs/wmname.html &lt;code&gt;wmname&lt;/code&gt; utility] to make the JVM believe you are running a different window manager.  This utility is available in the &lt;code&gt;suckless-tools&lt;/code&gt; package in Debian (and Ubuntu); [http://github.com/thewtex/portage/tree/thewtex/x11-wm/wmname/ this Portage tree provides &lt;code&gt;wmname&lt;/code&gt; for Funtoo (and Gentoo)].

&lt;pre&gt;$ wmname LG3D&lt;/pre&gt;

(You must restart the application in question after issuing the wmname command.)

This works because the JVM contains a hard-coded list of known non-re-parenting window managers.  For maximum irony, many users prefer to impersonate &amp;ldquo;&lt;code&gt;LG3D&lt;/code&gt;,&amp;rdquo; the non-re-parenting window manager [http://en.wikipedia.org/wiki/Project_Looking_Glass written by Sun, in Java].

This does not work for awesome since 3.5, as the JMenuBar is not tracked. The solution is to impersonate Sawfish using
&lt;pre&gt;$ wmname Sawfish&lt;/pre&gt;

=== Use Legacy, Motif-based Integration ===

The Motif-based X integration used in older versions of the JVM does not have the particular problem of empty, gray windows, though it may have other bugs and is no longer actively developed.  To use the Motif-based X integration, set the environment variable &lt;code&gt;AWT_TOOLKIT&lt;/code&gt; to the value &lt;code&gt;MToolkit&lt;/code&gt;.  This is the solution described in Awesome&amp;rsquo;s manual page.

&lt;pre&gt;$ AWT_TOOLKIT=MToolkit; export AWT_TOOLKIT&lt;/pre&gt;

Be warned that the Motif X integration is absent from free software JVMs such as OpenJDK and IcedTea, and it has at least one [http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6511454 known crashing bug on AMD64].

== Version 1.4 ==

Versions 1.4 and earlier of the JVM&amp;rsquo;s X integration are based on Motif and are not known to have the problem described here.  Of course, this version of the JVM has not been supported by any major vendor for some time, so using it likely comes with other hazards.</text>
      <sha1>o7tskstq301zjw0bw57zl2wwkeiltkw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Quick launch bar</title>
    <ns>0</ns>
    <id>624</id>
    <revision>
      <id>6093</id>
      <parentid>5718</parentid>
      <timestamp>2013-08-26T17:07:58Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="4356">{{DISPLAYTITLE:Quick launch bar}}
{{VersionSpecific
| goodversions = 3.4.x
| otherversions = [[Quick_launch_bar_widget/3.5|3.5]]
}}

=== Description ===

Here is a widget that allows you to put application shortcuts on your taskbar.
[[Image:Quick_launch_bar_example.png|right|thumb|An example of how the widget might be looking. Launchbar is next to taglist.]]

Though it is not as dynamic as in Gnome or KDE (you cannot just drag-and-drop a shortcut on the panel), you still don't have to modify your config every time you want to add new shortcut. The widget uses the folder which you specify to find all *.desktop files in it and show them on the taskbar. '''.desktop''' format was picked so former Gnome\KDE users could just specify their '''/home/username/Desktop''' folder and all the shortcuts from there would appear on the panel.

.desktop file consists of key=value pairs separated by new lines. Here is the example of calculator.desktop file
         
  [Desktop Entry]
  Name=Calculator
  Exec=gcalctool
  Icon=/usr/share/icons/gnome/24x24/apps/calc.png
  Position=1
  #and so on

It is very simple, it contains the name of application (Name), command to run it (Exec), icon to show on the taskbar (Icon) and it's position relatively to other shortcuts.
Widget only uses three fields: Exec, Icon and Position (optional), so you can just write a text file with these fields and save it as something.desktop.

''Note: original .desktop files (that Gnome\KDE use) do not contain the field &quot;Position&quot;, you should append it by yourself. Although this field is optional, if you don't specify it the shortcuts will simply be appended to the end of the list.

''Hint: you don't have to rewrite all positions if you want to insert a shortcuts between two others. You can use non-integer number as Position value for this. For example, if you have two shortcuts with Position 2 and 3 respectively, put in the third shortcut Position=2.5 and it will go between these two.''

=== Howto ===

* First, as I said earlier, you have to create a folder where you will keep your .desktop files. There could be other files, widget would not crash because of them.

* Open your rc.lua config and put somewhere the following code:

  local util = require('awful.util')
  
  -- Quick launch bar widget BEGINS
  function find_icon(icon_name, icon_dirs)
     if string.sub(icon_name, 1, 1) == '/' then
        if util.file_readable(icon_name) then
           return icon_name
        else
           return nil
        end
     end
     if icon_dirs then
        for _, v in ipairs(icon_dirs) do
           if util.file_readable(v .. &quot;/&quot; .. icon_name) then
              return v .. '/' .. icon_name
           end
        end
     end
     return nil
  end
  
  function getValue(t, key)
     _, _, res = string.find(t, key .. &quot; *= *([^%c]+)%c&quot;)
     return res
  end
  
  launchbar = { layout = awful.widget.layout.horizontal.leftright }
  filedir = &quot;/home/unlogic/.config/awesome/launchbar/&quot; -- Specify your folder with shortcuts here
  local items = {}
  local files = io.popen(&quot;ls &quot; .. filedir .. &quot;*.desktop&quot;)
  for f in files:lines() do
      local t = io.open(f):read(&quot;*all&quot;)
      table.insert(items, { image = find_icon(getValue(t,&quot;Icon&quot;), 
                                              { &quot;/usr/share/icons/hicolor/22x22/apps&quot; }),
                            command = getValue(t,&quot;Exec&quot;),
                            tooltip = getValue(t,&quot;Name&quot;),
                            position = tonumber(getValue(t,&quot;Position&quot;)) or 255 })
  end
  table.sort(items, function(a,b) return a.position &lt; b.position end)
  for i = 1, table.getn(items) do
  --     local txt = launchbar[i].tooltip
     launchbar[i] = awful.widget.launcher(items[i])
  --     local tt = awful.tooltip ({ objects = { launchbar[i] } })
  --     tt:set_text (txt)
  --     tt:set_timeout (0)
  end
  
  -- Quick launch bar widget ENDS

* Put '''launchbar''' on the wibox. For example:

  mywibox[s].widgets = {
    {
       mylauncher,
       mytaglist[s],         
       '''launchbar,'''
       s == 1 and mysystray or nil,
       mypromptbox[s],
       layout = awful.widget.layout.horizontal.leftright
    },
    ...

* That's all. Just reload your awesome and launch bar will appear.

'' For any questions mail me at yakushev.alex{ear}gmail.com ''

[[Category:Widgets]]

[[Category:awesome3]]</text>
      <sha1>9hmadp825nm1s0nvabon4k4l4mauoj2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Quick launch bar widget</title>
    <ns>0</ns>
    <id>882</id>
    <redirect title="Quick launch bar" />
    <revision>
      <id>5719</id>
      <timestamp>2013-01-02T11:09:20Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <comment>moved [[Quick launch bar widget]] to [[Quick launch bar]]</comment>
      <text xml:space="preserve" bytes="30">#REDIRECT [[Quick launch bar]]</text>
      <sha1>jrqcwajktv0su8u5rob44ct62xdu8ie</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Quick launch bar widget/3.5</title>
    <ns>0</ns>
    <id>958</id>
    <revision>
      <id>7026</id>
      <parentid>6173</parentid>
      <timestamp>2014-10-03T20:42:11Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <comment>blooper</comment>
      <text xml:space="preserve" bytes="2637">{{DISPLAYTITLE:Quick launch bar}}
{{VersionSpecific
| goodversions = 3.5
| otherversions = [[Quick_launch_bar_widget|3.4.x]]
}}

=== Description ===

Here is a widget that allows you to put application shortcuts on your taskbar.
[[Image:Quick_launch_bar_example.png|right|thumb|An example of how the widget might be looking. Launchbar is next to taglist.]]

Though it is not as dynamic as in Gnome or KDE (you cannot just drag-and-drop a shortcut on the panel), you still don't have to modify your config every time you want to add new shortcut. The widget uses the folder which you specify to find all *.desktop files in it and show them on the taskbar. '''.desktop''' format was picked so former Gnome\KDE users could just specify their '''/home/username/Desktop''' folder and all the shortcuts from there would appear on the panel.

.desktop file consists of key=value pairs separated by new lines. Here is the example of calculator.desktop file
         
  [Desktop Entry]
  Name=Calculator
  Exec=gcalctool
  Icon=/usr/share/icons/gnome/24x24/apps/calc.png
  Position=1
  #and so on

It is very simple, it contains the name of application (Name), command to run it (Exec), icon to show on the taskbar (Icon) and it's position relatively to other shortcuts.
Widget only uses three fields: Exec, Icon and Position (optional), so you can just write a text file with these fields and save it as something.desktop.

''Note: original .desktop files (that Gnome\KDE use) do not contain the field &quot;Position&quot;, you should append it by yourself. Although this field is optional, if you don't specify it the shortcuts will simply be appended to the end of the list.

''Hint: you don't have to rewrite all positions if you want to insert a shortcuts between two others. You can use non-integer number as Position value for this. For example, if you have two shortcuts with Position 2 and 3 respectively, put in the third shortcut Position=2.5 and it will go between these two.''

=== Howto ===

* First, as I said earlier, you have to create a folder where you will keep your .desktop files. There could be other files, the widget would not crash because of them.

* Download '''launchbar.lua''' file from [https://gist.github.com/alexander-yakushev/6343832 here].

* Open your rc.lua put the following code somewhere:

  local launchbar = require('launchbar')
  local mylaunchbar = launchbar(&quot;/path/to/folder/with/shortcuts/&quot;)

* Put '''mylaunchbar''' on the wibox.

* That's all. Just reload your awesome and launch bar will appear.

'' For any questions mail me at yakushev.alex{ear}gmail.com ''

[[Category:Widgets]]

[[Category:Awesome3.5]]</text>
      <sha1>fq3vkw4fun2rm7r486mp9q9xvvzrz24</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Quickly Setting up Awesome with Gnome</title>
    <ns>0</ns>
    <id>217</id>
    <revision>
      <id>6161</id>
      <parentid>6160</parentid>
      <timestamp>2013-10-30T16:21:01Z</timestamp>
      <contributor>
        <username>Garonenur</username>
        <id>816</id>
      </contributor>
      <comment>/* Gnome 3.9 / Ubuntu 13.10 */</comment>
      <text xml:space="preserve" bytes="12882">{{Languages}}

Setting up Awesome as Gnome's window manager gives you advantages from both worlds:
*Dynamic window managing;
*Easily configurable desktop;
*Autostart goodness;
*[[Customizing GTK Apps|GTK theming]] without the fuss.
Of course, your login time gets worse, as you need to start up Gnome, but for some that may be well worth it.

How exactly you can configure such a setup depends on your Gnome version, but the overall process is similar.

==Configuration: gnome &lt; 2.12==
These commands will change some settings in gconf in order to set up awesome as the default window manager and disable Nautilus' naughty root window behaviour. If your version of gnome is older than 2.12, this should do the trick.

  gconftool-2 --type bool --set /apps/nautilus/preferences/show_desktop False 
  # Disable buggy Nautilus desktop thing
  gconftool-2 --type string --set /desktop/gnome/applications/window_manager/current /usr/bin/awesome
  # Set awesome as your WM of choice -- note that you may be using /usr/local/bin/awesome if you compiled it yourself

==Configuration: 2.12 &lt;= gnome &lt; 3==
===Normally===
If you use a more recent version of gnome, you can try
  gconftool-2 --type bool --set /apps/nautilus/preferences/show_desktop False
  # Still disable the buggy Nautilus desktop thing
  gconftool-2 --type string --set /desktop/gnome/session/required_components/windowmanager awesome
  # sets awesome as wm

Obviously, if you prefer graphical stuff (I doubt it, you're using awesome!) you can use gconf-editor.

If your distribution doesn't provide /usr/share/applications/awesome.desktop, 
then you'll also have to add ~/.local/share/applications/awesome.desktop
  [Desktop Entry]
  Version=1.0
  Type=Application
  Name=Awesome
  Comment=The awesome launcher!
  TryExec=awesome
  Exec=awesome

===If clients override on your gnome panel===
==== without gdm ====
Try launching awesome outside gnome. Keep the gconftool lines, but forget about the ~/.config/autostart/awesome.desktop, and instead, use ~/.xinitrc:
  #!/bin/sh
  awesome &amp;
  exec ck-launch-session gnome-session # ck-launch-session is advised for the dbus stuff to work fine.

Don't forget to make it executable:
  chmod +x ~/.xinitrc

Launch the whole thing with startx.

==== with gdm ====
Additionnally, if you use gdm, tell it to run the default system session. The last version might not allow you to do that and you need to add the file /usr/share/xsessions/xsession.desktop
  [Desktop Entry]
  Name=Xsession
  Comment=This runs ~/.xsession
  Exec=/etc/X11/Xsession

Add this file and choose to run Xsession, and link ~/.xsession to .xinitrc
  ln -s ~/.xsession ~/.xinitrc

==Configuration: 3.0 &lt;= gnome &lt; 3.4 ==
Go to System Settings -&gt; System Info -&gt; Graphics -&gt; Forced Fallback Mode ON. This disables the Gnome 3 Shell, which is incompatible with exotic window managers (or any window manager but Mutter, for that matter).

Now, the easiest way is to create a file called .gnomerc in your $HOME with the following contents:

&lt;pre&gt;
export WINDOW_MANAGER=/usr/local/bin/awesome-wm
&lt;/pre&gt;

Then you can create an executable script at /usr/local/bin/awesome-wm with the following content:

&lt;pre&gt;
#!/bin/sh
awesome &amp;
&lt;/pre&gt;

=== gnome-session session ===
You can also tell &quot;gnome-session&quot; about awesome through a session file. Save the following as /usr/share/gnome-session/sessions/awesome.session or ~/.config/gnome-session/sessions/awesome.session:
&lt;pre&gt;
[GNOME Session]
Name=Awesome session
RequiredComponents=gnome-settings-daemon;
RequiredProviders=windowmanager;notifications;
DefaultProvider-windowmanager=awesome
DefaultProvider-notifications=notification-daemon
&lt;/pre&gt;
Note that this also disables gnome-panel. If you want to use it, add &quot;gnome-panel;&quot; to the RequiredComponents line.

Then tell gnome-session to use your new session by default, by running the following command:
&lt;pre&gt;
gsettings set org.gnome.desktop.session session-name awesome 
&lt;/pre&gt;

Note that this uses the new gsettings framework, not the old gconf one.

Doing this means that selecting &quot;Gnome&quot; in your display manager now runs awesome.

=== Display manager session ===
Instead of changing the &quot;Gnome&quot; xsession in you display manager, you can also create a new xsession. This allows you to choose between regular gnome and awesome from the login prompt.

Save the awesome.session file as described in the previous section.

Save the following as /usr/share/applications/awesome.desktop (your distribution might already provide this for you, Debian does):
&lt;pre&gt;
[Desktop Entry]
Version=1.0
Type=Application
Name=Awesome
Comment=The awesome launcher!
TryExec=awesome
Exec=awesome
&lt;/pre&gt;

Save the following as /usr/share/xsessions/gnome-awesome.desktop:
&lt;pre&gt;
[Desktop Entry]
Name=Awesome GNOME
Comment=Dynamic window manager
TryExec=/usr/bin/gnome-session
Exec=gnome-session --session awesome
Type=XSession
&lt;/pre&gt;

Now, when logging in, choose the &quot;Awesome GNOME&quot; session type. Rename however you see fit (some suggestions: &quot;GNOME tiling&quot;, &quot;GNawesome&quot;, perhaps &quot;Erdgeist&quot;).

==== Arch Linux ====

Just install the [https://aur.archlinux.org/packages.php?ID=53096 awesome-gnome] package from AUR.

==== Debian ====
Note: The above gnome-awesome.desktop doesn't seem to work on Debian. It seems that on Debian gdm3 passes the Exec line from the gnome-awesome.desktop file as-is to /etc/X11/Xsession, and that script only supports a single command without arguments. Creating a gnome-awesome.desktop file modeled after the fallback session file that calls a wrapper script works around this.

Save the following as /usr/share/xsessions/gnome-awesome.desktop:
&lt;pre&gt;
[Desktop Entry]
Name=Awesome GNOME
Comment=Dynamic window manager
TryExec=gnome-session
Exec=gnome-session-awesome
Type=XSession
&lt;/pre&gt;

Save the following as /usr/bin/gnome-session-awesome
&lt;pre&gt;
#!/bin/bash
exec gnome-session --session awesome &quot;$@&quot;
&lt;/pre&gt;

The awesome.session file is as above.

==== Gentoo Linux ====

Enable the gnome use flag for x11-wm/awesome package


==== Ubuntu 11.10 ====
Save the following as /usr/share/gnome-session/sessions/awesome.session:
&lt;pre&gt;
[GNOME Session]
Name=Awesome session
RequiredComponents=gnome-settings-daemon;gnome-panel;
RequiredProviders=windowmanager;
DefaultProvider-windowmanager=awesome
DefaultProvider-notifications=notification-osd
DesktopName=GNOME
&lt;/pre&gt;

Save the following as /usr/share/applications/awesome.desktop:
&lt;pre&gt;
[Desktop Entry]
Version=1.0
Type=Application
Name=Awesome
Comment=The awesome launcher!
TryExec=awesome
Exec=awesome
&lt;/pre&gt;

Save the following as /usr/share/xsessions/gnome-awesome.desktop:
&lt;pre&gt;
[Desktop Entry]
Name=Awesome GNOME
Comment=Dynamic window manager
TryExec=/usr/bin/gnome-session
Exec=gnome-session --session=awesome
Type=XSession
&lt;/pre&gt;

==Gnome 3.9 / Ubuntu 13.10==

Save the following as /usr/share/gnome-session/sessions/awesome.session or /usr/local/share/gnome-session/sessions/awesome.session:
&lt;pre&gt;
[GNOME Session]
Name=Awesome session
RequiredComponents=awesome;gnome-settings-daemon;
DesktopName=Awesome
&lt;/pre&gt;

Save the following as /usr/share/applications/awesome.desktop (unfortunately does not work in /usr/local/share/applications):
&lt;pre&gt;
[Desktop Entry]
Version=1.0
Type=Application
Name=Awesome
Comment=The awesome launcher!
TryExec=awesome
Exec=awesome
&lt;/pre&gt;

Save the following as /usr/share/xsessions/awesome-gnome.desktop:
&lt;pre&gt;
[Desktop Entry]
Name=Awesome GNOME
Comment=Dynamic window manager
Exec=gnome-session --session=awesome
TryExec=awesome
Type=Application
X-LightDM-DesktopName=Awesome GNOME
X-Ubuntu-Gettext-Domain=gnome-session-3.0
&lt;/pre&gt;

Now you need to modify at least /etc/xdg/autostart/gnome-settings-daemon.desktop to add Awesome to the OnlyShowIn key, the result should look like the following:
&lt;pre&gt;
[Desktop Entry]
Type=Application
Name=GNOME Settings Daemon
Exec=/usr/lib/gnome-settings-daemon/gnome-settings-daemon-localeexec
OnlyShowIn=GNOME;Unity;Awesome;
NoDisplay=true
X-GNOME-Autostart-Phase=Initialization
X-GNOME-Autostart-Notify=true
X-GNOME-AutoRestart=true
X-Ubuntu-Gettext-Domain=gnome-settings-daemon
&lt;/pre&gt;
You may also want to check any other files in this directory and modify the OnlyShowIn key, they gnome keyring and screensaver amon others are candidates for this.

Lastly don't forget to overide awesome's quit to use gnome-session-quit as described below.

If your cursor is invisible, you may need to set cursor - active to false. You can do this by running:
&lt;pre&gt;
dconf write /org/gnome/settings-daemon/plugins/cursor/active false
&lt;/pre&gt;

If the gnome-control-center is missing some menues, check all files /usr/share/applications/gnome*panel*. Adding Awesome to the OnlyShowIn Key will make them visible and accessible again.

== Finally ==

Log out and back in again. You should now have awesome as your default window manager. You should also have gnome-panel and all the other gnome things running.

== Going Forward ==

You will likely want to choose either gnome-panel or awesome's main wibox as your panel. If you choose to disable your wibox, configure your rc.lua to not start it up. If you choose to disable gnome-panel, it is easiest to stop using gnome-session and run your session in the traditional way.

The traditional way is to have a .xinitrc or .Xsession file, which is used as your session. This file is usually a shell script that is run by the login manager or by X directly. When the shell script exits, your session ends. Here is a sample .Xsession / .xinitrc file. (Note that some distros call it .Xsession and others .xinitrc. You may want to make one and ln -s the other one if you don't know which script your distro uses.)

  gnome-settings-daemon &amp;      # handles themes, starts gnome-screensaver. You may have to use gconf to disable it setting the background.
  nm-applet &amp;                  # assuming you're using Network Manager
  pidgin &amp;                     # if you're using pidgin. You can really put any programs here.
  gnome-power-manager &amp;        # for laptops and stuff
  gnome-volume-manager &amp;       # for mounting CDs, USB sticks, and such
  eval `gnome-keyring-daemon`  # SSH/GPG agent
  exec awesome                 # awesome receives xinit's process id; when it terminates, X will be terminated

If you're still using GDM, you can select something along the lines of &quot;X client script&quot; when you choose which session you want to use from the GDM login screen.

Note: For themes instead of gnome-settings-daemon you can use gtk-chtheme which can be found in the repository. It's advantage over gnome-settings-daemon is that it doesn't set background and consumes less memory.

Note: gnome-volume-manager seems to be renamed and kind of hidden as /usr/lib/gnome-settings-daemon/gnome-fallback-mount-helper at least on Ubuntu 13.10. gnome-power-manager seems to be gone too.

== Problems ==

* If you run into trouble with &quot;awsetbg&quot; -- ie. it does not set your background and pops up an error, install the program &quot;feh&quot;. Installing it should be all you need to do.

* If nautilus doesn't want to open gvfs locations (sshfs://, computer://, and so on) check your gnome-settings-daemon path. In some distros it is installed into /usr/libexec. Also you can try solution from https://bbs.archlinux.org/viewtopic.php?pid=660605 - add 

    eval `dbus-launch --sh-syntax --exit-with-session`

to the beginning of ~/.xinitrc

* If you run gnome-settings-daemon, but do not want it to set the background image then run the command below. Note that simply setting /desktop/gnome/background/draw_background to false will not prevent gnome-settings-daemon from setting the background.

    gconftool-2 --type bool --set /apps/gnome_settings_daemon/plugins/background/active False

* If you use the gnome-session based launch method, quitting awesome may not log you out, leaving you stuck. In order to fix this, put the following at the beginning of your rc.lua:

 &lt;nowiki&gt;
    -- Override awesome.quit when we're using GNOME
    _awesome_quit = awesome.quit
    awesome.quit = function()
        if os.getenv(&quot;DESKTOP_SESSION&quot;) == &quot;awesome-gnome&quot; then
           os.execute(&quot;/usr/bin/gnome-session-quit&quot;)
        else
	    _awesome_quit()
        end
    end
&lt;/nowiki&gt;

This assumes that you copied the &quot;gnome&quot; xsession file and made a new &quot;awesome-gnome&quot; session. If you modified the existing gnome.session, replace &quot;awesome-gnome&quot; above with &quot;gnome&quot;.

== GNOME Awesome Applet ==

For users who want to use GNOME as much as possible (i.e. GNOME panel, notification area, run dialog, etc.),
but still use Awesome as a window manager, [http://upsilon.cc/~zack/hacking/software/gnome-awesome-applet/ GNOME Awesome Applet] is a viable option.
GNOME Awesome Applet is a standard GNOME panel applet that monitors Awesome (e.g. by showing the current layout
as widgets in the wibox do) and enable various interactions with it (e.g. Lua prompt, GNOME Run Dialog, etc.).</text>
      <sha1>nvaezaquhjfwqn8t79hfaahk36leiqe</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Quickly Setting up Awesome with Gnome/fr</title>
    <ns>0</ns>
    <id>418</id>
    <revision>
      <id>3348</id>
      <parentid>3208</parentid>
      <timestamp>2009-07-15T18:55:04Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use DISPLAYTITLE</comment>
      <text xml:space="preserve" bytes="3893">{{DISPLAYTITLE:Mettre en place awesome avec Gnome}}
{{Languages|Quickly Setting up Awesome with Gnome}}

Cette page vous aidera à configurer Gnome pour qu’il utilise awesome comme gestionnaire de fenêtres par défaut. Cela vous permet de jouer avec awesome et de vous y adapter facilement.

== Configuration ==
=== Pour gnome &lt; 2.12 ===
Les commandes qui suivent vont changer des paramètres de gconf pour mettre en place awesome comme gestionnaire de fenêtres par défaut et désactiver le comportement très moche de la fenêtre ''root'' de Nautilus. Si votre version de Gnome est plus ancienne que la 2.12, ça devrait faire l’affaire :
  # On désactive le truc tout moche du bureau par Nautilus
  gconftool-2 --type bool --set /apps/nautilus/preferences/show_desktop False 
  # On met en place awesome comme gestionnaire — il vous faudra peut-être mettre /usr/local/bin/awesome si vous l’avez compilé vous-même
  gconftool-2 --type string --set /desktop/gnome/applications/window_manager/current /usr/bin/awesome

=== Pour gnome ≥ 2.12 ===
Si vous avez une version plus récente de Gnome, vous pouvez essayer :
  # On désactive encore le truc tout moche du bureau par Nautilus
  gconftool-2 --type bool --set /apps/nautilus/preferences/show_desktop False
  # On met en place awesome comme gestionnaire
  gconftool-2 --type string --set /desktop/gnome/session/required_components/windowmanager awesome

Il vous faudra également éditer le fichier '''~/.config/autostart/awesome.desktop'''
  [Desktop Entry]
  Version=1.0
  Type=Application
  Name=Awesome
  Comment=Le lanceur grandiose d’awesome
  TryExec=awesome
  Exec=awesome

=== Fin de la configuration ===
Quittez votre session et reconnectez-vous. Vous devriez maintenant avoir awesome comme gestionnaire de fenêtres par défaut. Et vous devriez aussi avoir ''gnome-panel'' et tous les autres trucs de Gnome.


== Pour aller plus loin ==
Vous voudrez sans doute choisir entre ''gnome-panel'' et la wibox principale d’awesome pour votre tableau de bord. Si vous choisissez de désactiver votre wibox, configurez votre fichier '''rc.lua''' pour qu’il ne la lance pas. Si vous décidez de désactiver ''gnome-panel'', il est plus facile d’arrêter ''gnome-session'' et de lancer votre session d’une manière plus traditionnelle :

La manière traditionnelle est d’avoir un fichier '''.xinitrc''' ou '''.Xsession''', qui est utilisé pour votre session. Ce fichier est en général un script console qui est lancé par le gestionnaire de connexion ou directement par X. Quand le script console se ferme, votre session s’arrête. Voici un exemple de fichier '''.Xsession''' ou '''.xinitrc''' ; le nom à lui donner dépend de la distribution que vous utilisez. Vous pouvez toujours choisir un nom et faire un lien symbolique vers l’autre nom si vous ne savez pas lequel utilise votre distro.

  gnome-settings-daemon &amp; # gère les thèmes, lance gnome-screensaver. Vous pouvez utiliser gconf pour désactiver le papier peint du bureau.
  nm-applet &amp;             # si vous utilisez Network Manager.
  pidgin &amp;                # si vous utilisez Pidgin. Vous pouvez vraiment mettre n’importe quel programme, en fait.
  gnome-power-manager &amp;   # pour les ordis portables.
  gnome-volume-manager &amp;  # pour monter les CD, les clés USB, et tout ce qui va avec
  exec awesome            # awesome reçoit un identifiant de processus d’xinit ; quand il s’arrête, X est tué.

Si vous utilisez encore GDM, vous pouvez choisir dans les lignes « script client X » quand vous choisissez quelle session vous voulez utilisez depuis l’écran de connexion de GDM.


== Un problème ? ==
Si vous avez des problèmes avec ''awsetbg'', autrement dit s’il ne met pas en place votre papier peint de bureau et affiche une erreur, installez le programme ''feh''. Ça devrait suffire à régler le problème.</text>
      <sha1>pjy8ydtekkuvlxo9is6ejfy8jo7wq08</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Quickly Setting up Awesome with Gnome/ru</title>
    <ns>0</ns>
    <id>456</id>
    <revision>
      <id>6767</id>
      <parentid>4568</parentid>
      <timestamp>2014-06-10T10:46:09Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>upgrading translate for current version</comment>
      <text xml:space="preserve" bytes="19894">{{DISPLAYTITLE:Быстрая настройка Awesome в Gnome}}
{{Template:Languages|Quickly Setting up Awesome with Gnome}}

Эта страница поможет настроить Gnome на использование Awesome в качестве оконного менеджера, что позволит Вам постепенно привыкнуть к Awesome.
Настройка Awesome как оконного менеджера Gnome даст вам преимущества использования из обоих миров:
*Динамическое управление окнами;
*Легко настраиваемый рабочий стол;
*Качественный автозапуск;
*[[Customizing GTK Apps/ru|Использование тем GTK]] без проблем.
Конечно увеличивается время запуска, так как вам нужно запустить Gnome, но для кого то это может облегчить жизнь и переход на Awesome.

Как именно вы можете произвести такую настройку, во многом зависит от версии Gnome, но в целом многое идентично.

== Настройка ==

==gnome &lt; 2.12==
Приведённые ниже команды внесут некоторые изменения в настройки gconf, чтобы сделать Awesome оконным менеджером по умолчанию и запретить Nautilus управлять рабочим столом. Это должно сработать для версий Gnome старше 2.12.

  gconftool-2 --type bool --set /apps/nautilus/preferences/show_desktop False 
  # Запрет Nautilus управлять рабочим столом
  gconftool-2 --type string --set /desktop/gnome/applications/window_manager/current /usr/bin/awesome
  # Установка Awesome в качестве оконного менеджера -- учтите, что если вы компилировали Awesome вручную, возможно, понадобится указать путь /usr/local/bin/awesome

==Настройка: 2.12 &lt;= gnome &lt; 3==
===Обычная===
В более новых версиях Gnome попробуйте
  gconftool-2 --type bool --set /apps/nautilus/preferences/show_desktop False
  # Отключение управления рабочим столом для Nautilus
  gconftool-2 --type string --set /desktop/gnome/session/required_components/windowmanager awesome
  # Установка Awesome в качестве оконного менеджера

Очевидно, если вы предпочитаете графический интерфейс (в чем я сомневаюсь, ведь вы используете Awesome!) вы можете воспользоваться gconf-editor.

Если ваш дистрибутив не содержит /usr/share/applications/awesome.desktop, 
то вам также необходимо добавить в ~/.local/share/applications/awesome.desktop
  [Desktop Entry]
  Version=1.0
  Type=Application
  Name=Awesome
  Comment=The awesome launcher!
  TryExec=awesome
  Exec=awesome

===Если приложения перекрывают патель Gnome===
==== Без использования gdm ====
Попробуйте запустиь Awesome вне Gnome. Сохраните введенные строки gconftool, но удалите то что внесли в ~/.config/autostart/awesome.desktop, и вместо этого исползуйте ~/.xinitrc:
  #!/bin/sh
  awesome &amp;
  exec ck-launch-session gnome-session # ck-launch-session is advised for the dbus stuff to work fine.

Не забудьте сделать скрипт исполнимым:
  chmod +x ~/.xinitrc

Запускайте все это после startx.

==== С использованием gdm ====
В дополнение, если вы исопльзуете GDM, укажите ему, что нужно запускать стандартную сессию системы. Последние версии могут не позволить вам это сделать, поэтому добавьте в файл /usr/share/xsessions/xsession.desktop следующие строки:
  [Desktop Entry]
  Name=Xsession
  Comment=This runs ~/.xsession
  Exec=/etc/X11/Xsession

Добавьте этот файл и выберите для запуска Xsession, затем сделайте ссылку ~/.xsession на .xinitrc
  ln -s ~/.xsession ~/.xinitrc

==Настройка: 3.0 &lt;= gnome &lt; 3.4 ==
Перейдите в System Settings -&gt; System Info -&gt; Graphics -&gt; Forced Fallback Mode ON. Это отключит Gnome 3 Shell, который несовместим с экзотическими оконными менеджерами.

Теперь, самым простым будет создать файл с названием .gnomerc в вашем каталоге $HOME со следующим содержимым:

&lt;pre&gt;
export WINDOW_MANAGER=/usr/local/bin/awesome-wm
&lt;/pre&gt;

Затем вы можете создать скрипт находящийся в /usr/local/bin/awesome-wm со следующим содержанием:

&lt;pre&gt;
#!/bin/sh
awesome &amp;
&lt;/pre&gt;

=== Сессия gnome-session ===
Вы также можете рассказать &quot;gnome-session&quot; об awesome через файл сессий. Сохраните следующий код как /usr/share/gnome-session/sessions/awesome.session или ~/.config/gnome-session/sessions/awesome.session:
&lt;pre&gt;
[GNOME Session]
Name=Awesome session
RequiredComponents=gnome-settings-daemon;
RequiredProviders=windowmanager;notifications;
DefaultProvider-windowmanager=awesome
DefaultProvider-notifications=notification-daemon
&lt;/pre&gt;
Обратите внимание, что это отключит gnome-panel. Если вы хотите использовать ее, добавьте &quot;gnome-panel;&quot; в строку RequiredComponents:
&lt;pre&gt;
RequiredComponents=gnome-settings-daemon;gnome-panel;
&lt;/pre&gt;
Затем укажите gnome-session использовать новую сессию по уполчанию, запустив следующую команду:
&lt;pre&gt;
gsettings set org.gnome.desktop.session session-name awesome 
&lt;/pre&gt;

Обратите внимание, что здесь используется новый фреймворк gsettings, а не старый gconf.

Сделав это, вы определите, что выбирая &quot;Gnome&quot; в вашем display manager теперь будет запускаться Awesome.

=== Сессия Display manager ===
Вместо изменения &quot;Gnome&quot; xsession в вашем менеджере диплеев, вы можете создать новый xsession. Это позволит вам выбирать между обычным Gnome и Gnome+Awesome через login prompt.

Сохраните файл awesome.session как написано в предыдущем разделе.

Сохраните следующий код как /usr/share/applications/awesome.desktop (возможно ваш дистрибутив уже создал этот файл для вас, например Debian делает это):
&lt;pre&gt;
[Desktop Entry]
Version=1.0
Type=Application
Name=Awesome
Comment=The awesome launcher!
TryExec=awesome
Exec=awesome
&lt;/pre&gt;

Сохраните следующий код как /usr/share/xsessions/gnome-awesome.desktop:
&lt;pre&gt;
[Desktop Entry]
Name=Awesome GNOME
Comment=Dynamic window manager
TryExec=/usr/bin/gnome-session
Exec=gnome-session --session awesome
Type=XSession
&lt;/pre&gt;

Теперь при входе, выберите сессию &quot;Awesome GNOME&quot;. Переименуйте ее по вашему желанию (вот некоторые варианты: &quot;GNOME tiling&quot;, &quot;GNawesome&quot;, может быть &quot;Erdgeist&quot;).

==== Arch Linux ====

Установите пакет [https://aur.archlinux.org/packages.php?ID=53096 awesome-gnome] через AUR.

==== Debian ====
Note: Приведенный выше gnome-awesome.desktop кажется не работает в Debian. Кажется, что в Debian gdm3 передает строку Exec из файла gnome-awesome.desktop как есть в /etc/X11/Xsession, а этот скрипт поддерживает только одну команду без аргументов. Создайте файл gnome-awesome.desktop  по образцу резервного файла сессий, который вызывает скрипт оболочки, работающий в обход этой проблемы.

Сохраните следующий код как /usr/share/xsessions/gnome-awesome.desktop:
&lt;pre&gt;
[Desktop Entry]
Name=Awesome GNOME
Comment=Dynamic window manager
TryExec=gnome-session
Exec=gnome-session-awesome
Type=XSession
&lt;/pre&gt;

Сохраните следующий код как /usr/bin/gnome-session-awesome
&lt;pre&gt;
#!/bin/bash
exec gnome-session --session awesome &quot;$@&quot;
&lt;/pre&gt;

Файл awesome.session приведен выше.

==== Gentoo Linux ====

Для использования Gnome используйте флаг для пакета x11-wm/awesome


==== Ubuntu 11.10 ====
Сохраните следующий код как /usr/share/gnome-session/sessions/awesome.session:
&lt;pre&gt;
[GNOME Session]
Name=Awesome session
RequiredComponents=gnome-settings-daemon;gnome-panel;
RequiredProviders=windowmanager;
DefaultProvider-windowmanager=awesome
DefaultProvider-notifications=notification-osd
DesktopName=GNOME
&lt;/pre&gt;

Сохраните следующий код в файл /usr/share/applications/awesome.desktop:
&lt;pre&gt;
[Desktop Entry]
Version=1.0
Type=Application
Name=Awesome
Comment=The awesome launcher!
TryExec=awesome
Exec=awesome
&lt;/pre&gt;

Сохраните следующий код в файл /usr/share/xsessions/gnome-awesome.desktop:
&lt;pre&gt;
[Desktop Entry]
Name=Awesome GNOME
Comment=Dynamic window manager
TryExec=/usr/bin/gnome-session
Exec=gnome-session --session=awesome
Type=XSession
&lt;/pre&gt;

==Gnome 3.9 / Ubuntu 13.10==

Сохраните следующий код в файл /usr/share/gnome-session/sessions/awesome.session или /usr/local/share/gnome-session/sessions/awesome.session:
&lt;pre&gt;
[GNOME Session]
Name=Awesome session
RequiredComponents=awesome;gnome-settings-daemon;
DesktopName=Awesome
&lt;/pre&gt;

Сохраните следующий код в файл /usr/share/applications/awesome.desktop (к сожалению файл /usr/local/share/applications не сработает):
&lt;pre&gt;
[Desktop Entry]
Version=1.0
Type=Application
Name=Awesome
Comment=The awesome launcher!
TryExec=awesome
Exec=awesome
&lt;/pre&gt;

Сохраните следующий код в файл /usr/share/xsessions/awesome-gnome.desktop:
&lt;pre&gt;
[Desktop Entry]
Name=Awesome GNOME
Comment=Dynamic window manager
Exec=gnome-session --session=awesome
TryExec=awesome
Type=Application
X-LightDM-DesktopName=Awesome GNOME
X-Ubuntu-Gettext-Domain=gnome-session-3.0
&lt;/pre&gt;

Теперь вам нужно изменить как минимум /etc/xdg/autostart/gnome-settings-daemon.desktop, чтобы добавить Awesome в ключ OnlyShowIn, результат должен выглядеть следующим образом:
&lt;pre&gt;
[Desktop Entry]
Type=Application
Name=GNOME Settings Daemon
Exec=/usr/lib/gnome-settings-daemon/gnome-settings-daemon-localeexec
OnlyShowIn=GNOME;Unity;Awesome;
NoDisplay=true
X-GNOME-Autostart-Phase=Initialization
X-GNOME-Autostart-Notify=true
X-GNOME-AutoRestart=true
X-Ubuntu-Gettext-Domain=gnome-settings-daemon
&lt;/pre&gt;
Вы можете также проверить другие файлы в этом каталоге и изменить ключ OnlyShowIn, там могут быть привязки gnome и скринсейвера amon и другие варианты для этого ключа.

В завершение не забудьте заменить выход из Awesome, на использование gnome-session-quit как описано ниже.

Если курсор мыши невидим, вам может потребоваться установить cursor - active в значение false. Вы можете сделать это, выполнив:
&lt;pre&gt;
dconf write /org/gnome/settings-daemon/plugins/cursor/active false
&lt;/pre&gt;

Если в gnome-control-center отсутствуют некоторые пункты меню, проверьте все файлв /usr/share/applications/gnome*panel*. Добавьте Awesome в ключ OnlyShowIn снова сделает их видимыми и доступными.


== В завершение ==

Выйдите из Gnome и войдите снова, Вы должны увидеть, что теперь в качестве оконного менеджера используется Awesome. Также Вы заметите, что gnome-panel и все остальные приложения Gnome всё еще запущены.

== Дальнейшая настройка ==

Вероятно, Вы захотите использовать в качестве панели gnome-panel или основную панель Awesome (wibox). Если понадобится отключить wibox, уберите код, отвечающий за его запуск, из файла rc.lua. Самый простой способ отключения gnome-panel - перестать использовать gnome-session и запускать сессию традиционным способом, подразумевающим использование файла .xinitrc или .Xsession. Этот файл обычно представляет собой shell-скрипт, запускаемый менеджером входа в систему или непосредственно X-сервером. Завершение выполнения скрипта приводит к завершению сессии. Вот образец файла .Xsession / .xinitrc. (Учтите, что в некоторых дистрибутивах он называется .Xsession, а в некоторых - .xinitrc. Если Вы не знаете, какой из них используется Вашим дистрибутивом, создайте любой и сделайте символьную ссылку при помощи ln -s.)

  gnome-settings-daemon &amp; # этот демон управляет темами и запускает gnome-screensaver. 
                          # Вы можете использовать gconf, чтобы запретить ему устанавливать 
                          # фоновый рисунок.
  nm-applet &amp;             # предполагается, что Вы пользуетесь Network Manager
  pidgin &amp;                # если у вас нет Pidgin, поместите сюда любые другие программы
  gnome-power-manager &amp;   # полезно для ноутбуков
  gnome-volume-manager &amp;  # для монтирования CD, USB, и прочих сменных носителей
  eval `gnome-keyring-daemon`  #агент SSH/GPG
  exec awesome            # awesome получает идентификатор процесса xinit; 
                          # когда он завершит работу, X-сервер будет остановлен

Если Вы всё еще используете GDM, то можете выбрать что-то наподобие &quot;X client script&quot; при выборе сессии на экране входа в систему.

Примечание: для тем вместо gnome-settings-daemon Вы можете использовать утилиту gtk-chtheme, которая находится в репозитории. Ее преимущество в том, что она не меняет обои рабочего стола и потребляет меньше памяти.

Примечание: gnome-volume-manager был переименован (в некоторых версиях) и был перемещен в /usr/lib/gnome-settings-daemon/gnome-fallback-mount-helper по крайней мере в Ubuntu 13.10. Также и gnome-power-manager тоже был переименован. 

== Проблемы ==

* Если у Вас возникли проблемы с &quot;awsetbg&quot;, т.е. он не устанавливает фоновый рисунок и выдаёт ошибку, установите программу &quot;feh&quot;.

*  Если nautilus не желает открывать gvfs ссылки (такие как sshfs:// или computer://), проверьте путь к gnome-settings-daemon. В некоторых дистрибутивах он устанавливается в /usr/libexec. Если решить проблему не удается, попробуйте предложение с сайта https://bbs.archlinux.org/viewtopic.php?pid=660605. Добавьте 
   eval `dbus-launch --sh-syntax --exit-with-session`

в начало файла ~/.xinitrc

* Если вы запускаете gnome-settings-daemon, но не хотите чтобы он устанавливать фоновое изображение, то запустите команду приведенную ниже. Однако помните, что простая установка значения /desktop/gnome/background/draw_background = false не помешает gnome-settings-daemon устанавливать фоновое изображение.

    gconftool-2 --type bool --set /apps/gnome_settings_daemon/plugins/background/active False

* Если вы используете метод запуска на основе gnome-session, выход из Awesome может сработать, оставив вас в зависшем сотоянии. Для того чтобы исправить эту ситуацию, разместите следующий код в начале вашего rc.lua:

 &lt;nowiki&gt;
    -- Переопределяем awesome.quit при использовании GNOME
    _awesome_quit = awesome.quit
    awesome.quit = function()
        if os.getenv(&quot;DESKTOP_SESSION&quot;) == &quot;awesome-gnome&quot; then
           os.execute(&quot;/usr/bin/gnome-session-quit&quot;)
        else
	    _awesome_quit()
        end
    end
&lt;/nowiki&gt;

Здесь предполагается, что вы скопировали файл &quot;gnome&quot; xsession и создали новую сессию &quot;awesome-gnome&quot;. Если вы модифицировали существующий gnome.session, замените &quot;awesome-gnome&quot; описанный выше на &quot;gnome&quot;.

== Апплет GNOME Awesome ==

Для пользователей которые хотят использовать GNOME как можно больше (например GNOME panel, область уведомлений, диалог запуска, и т.д.), но все еще используют Awesome как оконный менеджер, [http://upsilon.cc/~zack/hacking/software/gnome-awesome-applet/ Апплет GNOME Awesome] может быть очень удобен.
Апплет GNOME Awesome это стандартный апплет панели GNOME panel который контролирует Awesome (например показывает текущую схему, как это делает wibox)  и позволяет взаимодействовать с ним (например Lua prompt, GNOME Run Dialog, и т.д.).</text>
      <sha1>p4902kr6s5w7z7975w0rd5091pijvsw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>RPN Calculator</title>
    <ns>0</ns>
    <id>610</id>
    <revision>
      <id>6591</id>
      <parentid>5222</parentid>
      <timestamp>2014-05-22T08:03:07Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="3437">{{Languages}}

== RPN module in Lua ==

First, copy this to ~/.config/awesome/stack.lua

&lt;pre&gt;-- Stack Table
-- Uses a table as stack, use &lt;table&gt;:push(value) and &lt;table&gt;:pop()
-- Lua 5.1 compatible

-- GLOBAL
Stack = {}

-- Create a Table with stack functions
function Stack:Create()

  -- stack table
  local t = {}
  -- entry table
  t._et = {}

  -- push a value on to the stack
  function t:push(...)
    if ... then
      local targs = {...}
      -- add values
      for _,v in pairs(targs) do
        table.insert(self._et, v)
      end
    end
  end

  -- pop a value from the stack
  function t:pop(num)

    -- get num values from stack
    local num = num or 1

    -- return table
    local entries = {}

    -- get values into entries
    for i = 1, num do
      -- get last entry
      if #self._et ~= 0 then
        table.insert(entries, self._et[#self._et])
        -- remove last value
        table.remove(self._et)
      else
        break
      end
    end
    -- return unpacked entries
    return unpack(entries)
  end

  -- get entries
  function t:getn()
    return #self._et
  end

  -- list values
  function t:list()
    for i,v in pairs(self._et) do
      print(i, v)
    end
  end
  return t
end

-- CHILLCODE™
&lt;/pre&gt;
(from http://lua-users.org/wiki/SimpleStack )

Then copy this to ~/.config/awesome/rpn.lua
&lt;pre&gt;require(&quot;stack&quot;)

local Stack = Stack
local pairs = pairs
-- local print = print
local tonumber = tonumber

module(&quot;rpn&quot;)

local operators = { 
    { symbol = &quot; &quot;,
      operation = function(s) end },
    { symbol = &quot;+&quot;,
      operation = function(s)
                    local a, b = s:pop(2)
                    s:push(a+b)
                  end },
    { symbol = &quot;-&quot;,
      operation = function(s)
                    local a, b = s:pop(2)
                    s:push(b-a)
                  end },
    { symbol = &quot;*&quot;,
      operation = function(s)
                    local a, b = s:pop(2)
                    s:push(a*b)
                  end },
    { symbol = &quot;/&quot;,
      operation = function(s)
                    local a, b = s:pop(2)
                    s:push(b/a)
                  end },
}

function parseRPN(expr)
    stack = Stack:Create()
    tempNumber = &quot;&quot;
    for c in expr:gmatch&quot;.&quot; do
        local found = false
        for _,op in pairs(operators) do
            if c == op.symbol then
                if tempNumber ~= &quot;&quot; then
                    stack:push(tonumber(tempNumber..c))
                    tempNumber = &quot;&quot;
                end
                op.operation(stack)
                found = true
                break
            end
        end
        if found == false then
            tempNumber = tempNumber..c
        end
    end
    return stack:pop(1)
end
&lt;/pre&gt;

Then you just need to include it in your rc.lua:
&lt;pre&gt;require(&quot;rpn&quot;)&lt;/pre&gt;

To use it, just call ''rpn.parseRPN()'' passing the RPN expression as a string. It'll return the result as a number.
Suggestion of use: use the promptbox, like in the following example
&lt;pre&gt;    -- RPN prompt
    awful.key({ modkey }, &quot;c&quot;,
              function ()
                  awful.prompt.run({ prompt = &quot;RPN: &quot; },
                  mypromptbox[mouse.screen].widget,
                  function(expr) 
                    mypromptbox[mouse.screen].widget.text = &quot;Result: &quot;..rpn.parseRPN(expr)
                  end, nil,
                  awful.util.getdir(&quot;cache&quot;) .. &quot;/history_rpn&quot;)
              end)
&lt;/pre&gt;</text>
      <sha1>893ub15m0faq4t9afhpi5jeww3qer6m</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>RPN Calculator/ru</title>
    <ns>0</ns>
    <id>1069</id>
    <revision>
      <id>6593</id>
      <timestamp>2014-05-22T09:56:04Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода RPN Calculator (translating page)</comment>
      <text xml:space="preserve" bytes="3973">{{Languages|RPN Calculator}}

== RPN Модуль в Lua ==

Для тех, кто не знает, что такое RPN смотрите [[http://www.linuxfocus.org/Russian/January2004/article319.shtml статью]].

Во первых, скопируйте следующий код в файл ~/.config/awesome/stack.lua

&lt;pre&gt;-- Stack Table
-- Uses a table as stack, use &lt;table&gt;:push(value) and &lt;table&gt;:pop()
-- Lua 5.1 compatible

-- GLOBAL
Stack = {}

-- Create a Table with stack functions
function Stack:Create()

  -- stack table
  local t = {}
  -- entry table
  t._et = {}

  -- push a value on to the stack
  function t:push(...)
    if ... then
      local targs = {...}
      -- add values
      for _,v in pairs(targs) do
        table.insert(self._et, v)
      end
    end
  end

  -- pop a value from the stack
  function t:pop(num)

    -- get num values from stack
    local num = num or 1

    -- return table
    local entries = {}

    -- get values into entries
    for i = 1, num do
      -- get last entry
      if #self._et ~= 0 then
        table.insert(entries, self._et[#self._et])
        -- remove last value
        table.remove(self._et)
      else
        break
      end
    end
    -- return unpacked entries
    return unpack(entries)
  end

  -- get entries
  function t:getn()
    return #self._et
  end

  -- list values
  function t:list()
    for i,v in pairs(self._et) do
      print(i, v)
    end
  end
  return t
end

-- CHILLCODE™
&lt;/pre&gt;
(из http://lua-users.org/wiki/SimpleStack )

Затем скопируйте следующий код в ~/.config/awesome/rpn.lua
&lt;pre&gt;require(&quot;stack&quot;)

local Stack = Stack
local pairs = pairs
-- local print = print
local tonumber = tonumber

module(&quot;rpn&quot;)

local operators = { 
    { symbol = &quot; &quot;,
      operation = function(s) end },
    { symbol = &quot;+&quot;,
      operation = function(s)
                    local a, b = s:pop(2)
                    s:push(a+b)
                  end },
    { symbol = &quot;-&quot;,
      operation = function(s)
                    local a, b = s:pop(2)
                    s:push(b-a)
                  end },
    { symbol = &quot;*&quot;,
      operation = function(s)
                    local a, b = s:pop(2)
                    s:push(a*b)
                  end },
    { symbol = &quot;/&quot;,
      operation = function(s)
                    local a, b = s:pop(2)
                    s:push(b/a)
                  end },
}

function parseRPN(expr)
    stack = Stack:Create()
    tempNumber = &quot;&quot;
    for c in expr:gmatch&quot;.&quot; do
        local found = false
        for _,op in pairs(operators) do
            if c == op.symbol then
                if tempNumber ~= &quot;&quot; then
                    stack:push(tonumber(tempNumber..c))
                    tempNumber = &quot;&quot;
                end
                op.operation(stack)
                found = true
                break
            end
        end
        if found == false then
            tempNumber = tempNumber..c
        end
    end
    return stack:pop(1)
end
&lt;/pre&gt;

Затем вам необходимо подключить этот модуль в вашем rc.lua:
&lt;pre&gt;require(&quot;rpn&quot;)&lt;/pre&gt;

Для использования, просто вызовите ''rpn.parseRPN()'' с передачей в виде строки выражения RPN. После вычисления, результ будет возвращен в виде числа.
Для работы с RPN  вы можете использовать promptbox, как в следующем примере:
&lt;pre&gt;    -- RPN prompt
    awful.key({ modkey }, &quot;c&quot;,
              function ()
                  awful.prompt.run({ prompt = &quot;RPN: &quot; },
                  mypromptbox[mouse.screen].widget,
                  function(expr) 
                    mypromptbox[mouse.screen].widget.text = &quot;Result: &quot;..rpn.parseRPN(expr)
                  end, nil,
                  awful.util.getdir(&quot;cache&quot;) .. &quot;/history_rpn&quot;)
              end)
&lt;/pre&gt;</text>
      <sha1>5e4s0lsfbu4lsdkii9z9odbd616smi7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Radical/ru</title>
    <ns>0</ns>
    <id>1094</id>
    <revision>
      <id>6821</id>
      <parentid>6694</parentid>
      <timestamp>2014-06-25T02:39:03Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add border for table</comment>
      <text xml:space="preserve" bytes="25827">Оригинал статьи и последние изменения в модуле вы можете найти на GitHub https://github.com/Elv13/radical

Radical это один из самых больших модулей расширения Awesome. Он предоставляет единый интерфейс для создания множества типов меню.

[[File:radical.png|500px|thumb|alt=screenshot with personalized tags|Виды меню Radical]]

== Установка ==

Установить Radical очень легко, достаточно переместить в каталог ~/.config/awesome клонированный репозиторий.
&lt;pre&gt;
cd ~/.config/awesome
git clone https://github.com/Elv13/radical.git
&lt;/pre&gt;
Затем затребовать его в верхней части вашегоrc.lua:

  local radical = require(&quot;radical&quot;)

== Использование ==

В отличие от awful.menu Radical действует как и другие схемы(layouts) Awesome 3.5. Вам необходимо добавлять элементы последовательно одни за другим. Это имеет преимущество, позволяя вам взаимодействовать с сами элементами програмно. 

Самый просто вид меню, контекстное например, может быть создано примерно так:

&lt;pre&gt;
    local menu = radical.context{}
    menu:add_item {text=&quot;Screen 1&quot;,button1=function(_menu,item,mods) print(&quot;Hello World! &quot;) end}
    menu:add_item {text=&quot;Screen 9&quot;,icon=beautiful.path..&quot;Icon/layouts/tileleft.png&quot;}
    menu:add_item {text=&quot;Sub Menu&quot;,sub_menu = function()
        local smenu = radical.context{}
        smenu:add_item{text=&quot;item 1&quot;}
        smenu:add_item{text=&quot;item 2&quot;}
        return smenu
    end}

    -- Для добавления меню в в виджет:
    local mytextbox = wibox.widget.textbox()
    mytextbox:set_menu(menu,3)            -- 3 = правая клавиша мыши, 1 = левая клавиша мыши

    -- Для добавления клавиатурного сочетания чтобы вызвать меню &quot;box&quot; (и всех других типов)
    menu:add_key_binding({&quot;Mod4&quot;},&quot;,&quot;)
&lt;/pre&gt;

В этом примере, созданы 3 простых элемента меню с диманической генерацией подменю. Пожалуйста помните, что создавая подменю с использованием функции, оно создается при каждом его отображении. Для статичного меню, быстрее просто создать его однажды и передать объекту подменю свойство элемента &quot;sub_menu&quot;.

''':set_menu''' может также взять lazy-loading функцию вместо меню. Второй параметр не является обязательным, по умолчанию его значение = 1.

''':add_key_binding''' добавляет клавиатурное сочетание. Она может также вызывать функцию в качестве 3-го параметра. Тем не менее, это обычно верное размещение контекстного меню, в том месте где вы ожидаете его. Это работает лучше чем меню &quot;box&quot;.

== Типы меню ==

Действующие типы меню:

* Context: Обычное контекстное меню
* Box: Размещенное в центре меню (по типу меню alt-tab в Windows)
* Embed: Меню в меню. Его можно использовать как подраздел в больших меню
* Bar: Компактный горизонтальный видждет wibox
* Flexbar: Расширяемый горизонтальный виджет wibox

== Стили меню ==

Любому меню подходят различные стили для различных применений. Новый стиль может также быть создан в теме beautiful. Текущими являются:

*Arrow: Gnome3 и Mac OSX похоже на меню с границами по краям и стрелками
*Classic: Повторяет внешний вид awful.menu

Arrow также подразделяется на несколько типов:

*radical.base.arrow_type.NONE
*radical.base.arrow_type.PRETTY
*radical.base.arrow_type.CENTERED

== Стили элементов ==

Как и меню, элементы тоже могут иметь из собственный стиль. Допустимые значения:

* Basic: Самый простой тип элементов, не содержит границ или специальных форм
* Classic: 1px граница в конце каждого элемента
* Rounded: 3px закругленные границы в каждом углу
* Arrow_alt: &quot;Powerline&quot; стрелки с различными цветами
* Arrow_prefix: Элемент с префиксом &quot;Powerlined&quot;
* Arrow_single: Элемент начинается с &lt;  и заканчивается &gt;

== Схемы меню ==

В верхней части каждого стиля меню также можнет содержать различные схемы для отображения элементов:

* Vertical: Элементы отображаются поверх друг друга
* Horizontal: Элементы отображаются рядом друг с другом
* Grid: Элементы отображаются в виде 2D таблицы

== Схемы элементов ==

Схема элементов(item) это то, как виджеты (icons, label, prefix) располагаются в элементе

    horizontal: Стандартная схема, используется в стиле context
    icon: Выглядит как иконка рабочего стола, используется в горизонтальном меню
    centerred: Выравнивает виджеты по центру вместо использования всего пространства

== Использование styles и layouts ==

&lt;pre&gt;
    local radical = require(&quot;radical&quot;)

    local m = radical.context {
        style      = radical.style.classic      ,
        item_style = radical.item.style.classic ,
        layout     = radical.layout.vertical    }
&lt;/pre&gt;

== Подсказки ==

Radical также имеет свой собственный стиль виджета подсказки. Он может быть использован в меню, но также и в каждом виджете используя метод set_tooltip:
&lt;pre&gt;
local mytextbox = wibox.widget.textbox()
mytextbox:set_tooltip(&quot;foo bar&quot;)
&lt;/pre&gt;

== &quot;Underlay&quot; ==

The &quot;underlay&quot; is the opposite of an overlay. Think of it as a background label. Radical add this option to all Awesome widget by calling the set_underlay method. The first argument is the text (or table of string) and the second is an array with the style, color and alpha keys.

== Опции ==

Radical предлагает (очень, очень) широкий спектр опций позволяющих создавать роскошные и оригинальные меню. Опции доступны в 2х форматах: menu wide и item specific. Опции menu wide воздействуют на все элементы и непосредственно на само меню, в то время как &quot;specific item&quot; применятеся только для элементов. Разные элементы могут иметь разные наборы опций.

=== Menu options ===

{| border=&quot;1&quot;
! Название
! Описание
! Тип
|-
| bg_header
| Цвет заголовка (смотри секцию виджтов)
| String/gradient/pattern
|-
| bg_prefix
| Prefix background for item_styles that support it
| String/gradient/pattern
|-
| border_color
| Цвет рамки
| String/gradient/pattern
|-
| border_width
| Толщина рамки
| number
|-
| item_height
| Стандартная высота элемента
| number
|-
| item_width
| Стандартная ширина элемента
| number
|-
| width
| Первоначальная ширина
| number
|-
| default_width
| Стандартная ширина меню
| number
|-
| icon_size
| Размер иконки
| number
|-
| auto_resize
| Изменение размера меню если элемент слишком большой
| boolean
|-
| parent_geometry
| Устанавливает родителя меню
| geometry array
|- 
| arrow_type
| Устанавливает тип стрелки, когда используется сответсвующий стиль
| Смотри &quot;arrow_type&quot; enum
|-
| visible
| Отображение или скрытие меню
| boolean
|-
| direction
| Направление в котором будет отображаться стрелка
| &quot;left&quot;,&quot;right&quot;,&quot;top&quot;,&quot;bottom&quot;
|-
| row
| Колличество рядов (при сетчной схеме)
| number
|-
| column
| Колличество столбцов (при сеточной схеме)
| number
|-
| layout
| Схема меню (default:vertical)
| Смотри секцию &quot;Menu layouts&quot;
|-
| style
| Стиль меню (default:arrow)
| Смотри &quot;Menu style&quot;
|-
| item_style
| Стиль элементов (default:basic)
| Смотри &quot;Item style&quot;
|-
| filter
| Фильтрация меню, для позовательского типа
| boolean
|-
| show_filter
| Отобразить виджет фильтра в верху
| boolean
|-
| filter_string
| Строка фильтрации по умолчанию
| string
|-
| fkeys_prefix
| Отобразить интираторы F1-F12 для облегчения навигации
| boolean
|-
| underlay_alpha
| Underlay (смотрти item options) прозрачность
| 0-1
|- 
| filter_prefix
| Текст отображаемый в начале строки фильтрации
| string
|-
| max_items
| Максимально колличество элементов для показа прокрутки
| number
|-
| enable_keyboard
| Включить или отключить навигацию клавиатурой
| boolean
|-
| disable_markup
| Отключает разметку pango в элементах текста
| boolean
|-
| x
| X position (absolute)
| number
|- 
| y
| Y position (absolute)
| number
|-
| sub_menu_on
| Отобразить подменю при выборе или нажатии
| Смотри список &quot;event&quot;
|-
| select_on
| Событие используемое при выборе элемента
| Смотри список &quot;event&quot;
|-
| overlay
| Слой поверх элемента
| function(data,item,cr,w,h)
|-
| opacity
| Делает меню полупрозрачным (трибуется композитный менеджер)
| number (0 to 1)
|-
| icon_transformation
| Hijack функция рисования иконок
| function(icon,data,item)
|}

=== Item options ===
{| border=&quot;1&quot;
! Название
! Описание
! Тип
|-
| text
| Текст элемента
| string
|-
| height
| Высота элемента
| number
|-
| icon
| Иконка элемента
| string or pattern
|-
| sub_menu
| Добавить подменю в этот элемент
| menu or function
|-
| selected
| Выбрать этот элемент
| boolean
|-
| checkable
| Переключаемое состояние элемента (checkbox)
| boolean
|-
| checked
| Выбран элемент или нет
| boolean
|-
| underlay
| Text to render at the far-right of the item
| [array of] string
|-
| prefix_widget
| Виджет для добавления в начало элемента
| widget
|-
| suffix_widget
| Виджет для добавления в конец элемента
| widget
|-
| style
| Пользовательский item_style для данного элемента
| item_style
|-
| layout
| Пользовательский item_layout для данного элемента
| item_layout
|-
| tooltip
| Подсказка показываемая сбоку или снизу
| string
|-
| button1
| Действие на левую кнопку мыши
| function
|-
| button2
| Действие на среднюю кнопку мыши
| function
|-
| button3
| Действие на правую кнопку мыши
| function
|-
| button4
| Действие при прокрутке вверх
| function
|-
| button5
| Действи при прокрутке вниз
| function
|-
| overlay
| Смотри menu.overlay 
| function
|}

=== Colors options ===

Опции цвета доступны как для меню, так и для элементов объекта.

{| border=&quot;1&quot;
! Name
! State
! Description
|-
| bg
| ---
| Стандартный фон
|-
| fg
| ---
| Стандартный передний фон
|-
| bg_disabled
| theme.state.DISABLED
| The item cannot be interracted with
|-
| fg_disabled
| theme.state.DISABLED
| The item cannot be interracted with
|-
| bg_urgent
| theme.state.URGENT
| The item request immediate attention
|-
| fg_urgent
| theme.state.URGENT
| The item request immediate attention
|-
| bg_focus
| theme.state.SELECTED
| Focussed / Selected items
|-
| fg_focus
| theme.state.SELECTED
| Focussed / Selected items
|-
| bg_pressed
| theme.state.PRESSED
| The item is being pressed
|-
| fg_pressed
| theme.state.PRESSED
| The item is being pressed
|-
| bg_hover
| theme.state.HOVERED
| The mouse is over the item
|-
| fg_hover
| theme.state.HOVERED
| The mouse is over the item
|-
| bg_changed
| theme.state.CHANGED
| The item recently changed
|-
| fg_changed
| theme.state.CHANGED
| The item recently changed
|-
| bg_used
| theme.state.USED
| The item is used
|-
| fg_used
| theme.state.USED
| The item is used
|-
| bg_checked
| theme.state.CHECKED
| The item is checked
|-
| fg_checked
| theme.state.CHECKED
| The item is checked
|-
| bg_alternate
| theme.state.ALTERNATE
| Alternative to bg
|-
| fg_alternate
| theme.state.ALTERNATE
| Alternative to fg
|-
| bg_highlight
| theme.state.HIGHLIGHT
| The item is hightlighted
|-
| fg_highlight
| theme.state.HIGHLIGHT
| The item is hightlighted
|}

=== Common methods ===

Все меню обеспечиваются кучей методов. Большинство из них была описана выше, но здесь еще небольшой список:

{| border=&quot;1&quot;
! Название
! Описание
! Аргументы
! Возвращаемое значение
|-
| add_item
| Добавление нового элемента в меню
| array of options
| item
|-
| add_widget
| Добавление нового виджета вместо элемента
| a widget, args
| ---
|-
| add_embeded_menu
| Добавление встроенного(inline) меню в другое меню
| an &quot;embed&quot; menu
| ---
|-
| add_key_binding
| Добавление глобального клавиатурного сочетания в меню
| mod array, key
| ---
|-
| add_key_hook
| Добавление callback при нажатии клавиши
| mod, key, event, func
| ---
|-
| clear
| Удаление всех элементах
| ---
| ---
|-
| scroll_down
| Если меню обрезается, прокрутить вниз
| ---
| ---
|-
| scroll_up
| Если меню обрезается, прокрутить вверх
| ---
| ---
|-
| swap
| Поменять 2 элемента
| both items
| ---
|-
| move
| Переместить элемент
| the item, the new idx
| ---
|-
| remove
| Удалить элемент
| the item
| ---
|-
| append
| Добавить в существующий (но не используемый) элемент
| the item
| ---
|-
| add_prefix_widget
| Добавление виджета в начало меню
| the widget
| ---
|-
| add_suffix_widget
| Добавление виджета в конец меню
| the widget
| ---
|}

== Сигналы ==

Меню также производит множество сигналов, синтакс обычно следующий PROPERTY_NAME::changed. Есть и другие другие -  item::moved, item::swapped, item::removed, item::appended

Ниже приведен пример того, как уловить изменение &quot;прозрачности&quot;:

    mymenu:connect_signal(&quot;opacity::changed&quot;,function(value)
        -- какие то действия
    end)

Большинство item_layout также заменяют стандартные сигналы виджетов. Они как правило делают то же самое, как при использовании атрибута меню buttonX, но  преимущественно в сценариях, где исльзуется модификатор(Ctrl, Shift, прочие).

{| border=&quot;1&quot;
! Название
! Описание
! Аргументы
|-
| button::press
| Кнопка нажата
| menu,item,button_id,mods
|-
| button::release
| Кнопка отпущена
| menu,item,button_id,mods
|-
| mouse::enter
| Когда мышь входит в зону
| menu,item
|-
| mouse::leave
| Когда мышь покидает зону
| menu,item
|-
| long::hover
| Мышь находится в зоне 1.5 sec
| menu,item
|-
| long::press
| Мышь нажата 1.5 sec
| menu,item
|}

'''mods''' является массивом с приложенным модификатором в качестве ключа. Если значение отсутсвует (=nil), то модификатора нет. Обычые модификаторы это  Control, Shift, mod1 (Alt) и mod4(Win).

Пример их использования:

    local menubar = radical.bar{}
    menubar:connect_signal(&quot;button::press&quot;,function(data,item,button,mods)
        if mods.Control then
            print(&quot;Foo menu pressed!&quot;,item.text,button,data.rowcount)
        end
    end)

    -- Также работает с элементами
    menubar:add_item{text=&quot;bar&quot;}:connect_signal(&quot;button::release&quot;,function(d,i,b,m)
        print(&quot;bar click released!&quot;)
    end)

=== Beautiful опции ===

Radical также использует некоторые из опций тем awful.menu, в дополнение к:

{| border=&quot;1&quot;
! Название
! Описание
! Тип
|-
| menu_height
| Высота меню
| String/Gradient/Pattern
|-
| menu_width
| Ширана меню стандартная/минимальная
| Number
|-
| menu_border_width
| Толщина границ
| Number
|-
| menu_border_color
| Цвет границ
| String/Gradient/Pattern
|-
| menu_fg_normal
| Цвет текста/переднего фона
| String/Gradient/Pattern
|-
| menu_bg_focus
| Цвет выбранного элемента
| String/Gradient/Pattern
|-
| menu_bg_header
| Цвет фона заголовка виджета
| String/Gradient/Pattern
|-
| menu_bg_alternate
| Цвет полосы прокрутки и других виджетов
| String/Gradient/Pattern
|-
| menu_bg_normal
| Стандратный фон
| String/Gradient/Pattern
|-
| menu_bg_highlight
| Фон подсвеченного элемента
| String/Gradient/Pattern
|-
| menu_submenu_icon
| Изображение подменю (замена '&gt;')
| Path/Pattern
|-
| menu_separator_color
| Цвет разделителя меню
| String/Gradient/Pattern
|-
| menu_opacity
| Используйте свой любимый композитный менеджер
| Number (0=0%, 1=100%)
|-
| menu_draw_underlay
| Функция возвращающая underlay изображение
| function(array,width)
|-
| menu_icon_transformation
| Функция используемая для отрисовки иконок
| function(image,data,item)
|-
| underlay_alpha
| Alpha for underlays
| Number (0 to 1)
|}

Стилизирование также может быть сделано с помощью опции icon_transformation. Эта возможность позволяет скрыть такие возможности как desaturation, tinting, invert или некоторые matrix которые применяются на изображении прежде чем оно будет отрисованно. Эта функция получает ссылку на путь/поверхность, как единственный параметр и возвращает уже измененную поверхность.

== Расширение Radical ==

Radical не предназначался для использования &quot;как есть&quot;. Каждое меню отличается от другого. В то время как распространенные меню могут создаваться без расширения возможностей Radical, более продвинутые наверняка потребует этого. Хорошей новостью будет то, что Radical предназначен для этого. Предыдущие версии доказали мне, что любой недостаток или необходимость расширить функционал приведет к раздуванию кода, когда придется добавлять новые возможности. Radical параллельно разработал возможность добавлять больше модулей и свойств без необходимости затрагивать основные файлы.

=== Объектная модель ===

Объектная модель Radical схожа с моделью Awesome. Каждый объект имеет набор сигналов, разработчик может прослушивать их для получения уведомления об изменении. Большая разница в том, что объектная модель Radical автоматически создает собственные свойства. Если вы  хотите добавить новый сигнал,     это возможно добавив прослушивание item::added, для элемента или применить его непосредственно для его меню от которого зависит этот элемент, если это свойства для меню или для элемента. Далее приведен пример того, как это работает:
&lt;pre&gt;
    local menu = radical.context{}

    -- Create the setter
    menu.set_foo = function(m,value)
        print(&quot;Setting value to:&quot;,value)
        m._foo_real = value
    end

    -- Create the getter
    menu.get_foo = function(m)
        print(&quot;Getter called, returning&quot;,m._foo_real)
    end

    -- The property is now created, this will call the setter:
    menu.foo = &quot;my foo value&quot;

    -- This will call the getter:
    print(menu.foo)

    -- The signals will be automatically generated
    data:connect_signal(&quot;foo::changed&quot;,function(m,value)
        print(&quot;foo changed:&quot;,value)
    end)

    -- New signals don't need to be registered and can be called right away
    data:connect_signal(&quot;my_new_signal::action_name&quot;,function(m,value1,value2,value3)
        print(&quot;Callback&quot;,m,value1,value2,value3)
    end)

    -- Manually emiting a signal
    menu:emit_signal(&quot;my_new_signal::action_name&quot;,value1,value2,value3)
&lt;/pre&gt;

===State model===

Radical поддерживает одновременно множество состояний для элемента. Текущее состояние(&quot;current state&quot;) имеет наименьший ID. state ID это число с -inf до +inf. Более важные, например проверка сравнения срочности(urgent), может быть реализовано с использованием соответсвующих ордеров. Стандартный набор состояний это объекты которые могут изменяться, поэтому будет разумнее использовать совершенно другой диапазон, если кто то захочет изменить один из существующих. Каждому состоянию может быть присвоен фон и цвет переднего фона используя метод radical.theme.register_color(id, radical_name, beautiful_name, true ). Переключать состояние можно используя мета таблицу item.state[]:

&lt;pre&gt;
    local my_state_name = 9999 -- &lt;== The ID
    local menu = radical.context{}
    local item = menu:add_item{text=&quot;text&quot;}

    -- Activate a state
    item.state[my_state_name] = true

    -- Desactivate a state
    item.state[my_state_name] = nil
&lt;/pre&gt;

Radical позаботится о выборе текущего состояния и перересует элемент с правильными цветами переднего и заднего фона.



[[Category:Awesome3]]</text>
      <sha1>4k24zlgv2ls09fpdo6be7ht4pujaw6a</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Raum Mpd Alarm Clock</title>
    <ns>0</ns>
    <id>725</id>
    <revision>
      <id>5025</id>
      <parentid>5024</parentid>
      <timestamp>2011-08-26T12:12:39Z</timestamp>
      <contributor>
        <username>Raum</username>
        <id>695</id>
      </contributor>
      <text xml:space="preserve" bytes="3300">This is a widget I use to control my alarm clock from Awesome. You can read more about it [http://digit.byethost31.com/2011/03/mpd-alarmclock/[here]].
I basically press Meta+F12 and type in the time I want it to fire, the maximum volume it should reach and whether it should suspend or not. When chosen to suspend the computer wakes up just before the alarm goes off.

To get this to work you need: alsa, mpd, mpc, rtcwake (util-linux-ng) and sudo

The bash script that functions as the alarm is as follows:
  #!/bin/sh
   
  LOGFILE=&quot;/var/log/alarmlog&quot;
  TIMEFORALARM=$1
  ALARMVOLUME=$2
  GOTOSLEEP=$3
  exec &gt;&gt; $LOGFILE 2&gt;&amp;1
   
  # Allows the user to cancel any alarms by issuing cancel as an argument
  if [ &quot;$TIMEFORALARM&quot; = &quot;cancel&quot; ]; then
      echo &quot;$(date +'%a %d-%m-%Y %H:%M:%S') Alarm: killed all alarms&quot;
      killall alarmclock
      exit
  fi
   
  # If user wants system to sleep, do so
  if [ &quot;$GOTOSLEEP&quot; -ne &quot;0&quot; ]
  then
      TIMEINSECSNOW=&quot;$(date +%s)&quot;
      TIMEINSECSALARM=&quot;$(date -d &quot;$TIMEFORALARM&quot; &quot;+%s&quot;)&quot;
      if [ $TIMEINSECSALARM -gt $TIMEINSECSNOW ]
      then
          echo &quot;$(date +'%a %d-%m-%Y %H:%M:%S') Alarm: set for $(date -d @$TIMEINSECSALARM +%c). Will go to sleep now.&quot;
          rtcwake -l -m mem -t $TIMEINSECSALARM &gt; /dev/null
          echo &quot;$(date +'%a %d-%m-%Y %H:%M:%S') Alarm: pc has woken up&quot;
      else
      # If the time given is less than the time it is now, the alarm is probably for tomorrow, add 24 hours
          echo &quot;$(date +'%a %d-%m-%Y %H:%M:%S') Alarm: set for $(date -d @$TIMEINSECSALARM +%c). Will go to sleep now.&quot;
          TIMEINSECSALARM=$(( $TIMEINSECSALARM + 86400 )) # 86400 is the seconds in 24 hours
          rtcwake -l -m mem -t $TIMEINSECSALARM &gt; /dev/null
          echo &quot;$(date +'%a %d-%m-%Y %H:%M:%S') Alarm: pc has woken up&quot;
      fi
  else
      echo &quot;$(date +'%a %d-%m-%Y %H:%M:%S') Alarm: set for $(date -d @$TIMEINSECSALARM +%c).&quot;
  fi
    
  # Wait until it's time to fire
  until [ &quot;$(date +'%H%M')&quot; -eq $TIMEFORALARM ]; do
      sleep 2
  done
  echo &quot;$(date +'%a %d-%m-%Y %H:%M:%S') Alarm: fired alarm for $TIMEFORALARM&quot;
   
  mpc -q clear
  mpc -q load wakeup &gt; /dev/null # We need to send this to /dev/null as not to clutter our log files
   
  # Set the speaker to 100% to make sure the alarm will be heared
  amixer -q sset 'Speaker' 100%
  amixer -q -c 0 sset 'Speaker',0 unmute
  amixer -q sset 'PCM' 100%
   
  # Gracefully increase the volume of our music
  amixer -q -c 0 sset 'Master',0 unmute
  mpc -q play
  for (( x=0; x&lt;$ALARMVOLUME; x++ )); do
      amixer -q sset Master $x%
      sleep 0.4
  done

Using the following in my rc.lua, I can easily set the alarm with Meta+F12:
  awful.key({ altkey }, &quot;F12&quot;, function ()
      awful.prompt.run({ prompt = &quot;Alarm clock (time volume sleep): &quot; }, promptbox[mouse.screen].widget,
          function (time)
              exec(&quot;sudo /home/myusername/Scripts/alarmclock &quot;..time)
          end)
  end)

Some of the commands to get the computer to sleep in the script need root access. For that reason I have chosen to use sudo, as I can easily add this to my sudoers file with 'visudo':
  myusername ALL=(ALL) NOPASSWD:/home/myusername/Scripts/alarmclock

Don't forget to make a playlist for mpd called &quot;wakeup&quot;.
[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>9e57lno3pkjhdeyvbk1q7hr2vg25qud</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Raum Remind Widget</title>
    <ns>0</ns>
    <id>724</id>
    <revision>
      <id>5023</id>
      <timestamp>2011-08-26T11:55:19Z</timestamp>
      <contributor>
        <username>Raum</username>
        <id>695</id>
      </contributor>
      <comment>Created page with &quot;This widget shows the next reminder in my wibox. I use this so I don't forget any appointments. You can read more about it [http://digit.byethost31.com/2011/08/using-remind-to-sh...&quot;</comment>
      <text xml:space="preserve" bytes="2718">This widget shows the next reminder in my wibox. I use this so I don't forget any appointments. You can read more about it [http://digit.byethost31.com/2011/08/using-remind-to-show-next-appointment/[Here]]

It consists of two parts, a shellscript that outputs the next reminder and the lua widget that outputs it to the wibox.

The shellscript (reminderwidget.sh):
  #!/bin/bash
  #Configurables:
  MONTHSTOCHECKAHEAD=12
  REMINDERSFILE=/home/USERNAME/.reminders
   
  #Helper function to check if a date is in the future
  is_futuredate()
  {
      TODAY=$(date +%s)
      COMPARE=$(date -d &quot;$(date -d &quot;$1&quot;)&quot; +%s)
      test $(($COMPARE-TODAY)) -le 0 &amp;&amp; return 1 || return 0
  }
   
  #This gives a nice and structured output of coming reminders
  remind -s$MONTHSTOCHECKAHEAD -b1 $REMINDERSFILE |
  while read line
  do
      #Check if the reminder has a duration, I'm only interested in those
      if [ &quot;$(echo &quot;$line&quot; | cut -d' ' -f 4)&quot; != &quot;*&quot; ]; then
          #Extract the date, time and duration
          DATE=$(echo &quot;$line&quot; | cut -d' ' -f 1)
          TIMES=$(echo &quot;$line&quot; | cut -d' ' -f 6)
          STARTTIME=$(echo &quot;$TIMES&quot; | cut -d'-' -f 1)
          BEGDATETIME=$(date -d &quot;$(echo $DATE $STARTTIME)&quot;)
          DURMINS=$(echo &quot;$line&quot; | cut -d' ' -f 4)
          #Calculate the end of the reminder
          ENDDATETIME=$(date -d &quot;$(echo $BEGDATETIME +$DURMINS minutes)&quot;)
   
          #Check if the ending of this reminder is still in the future
          if is_futuredate &quot;$ENDDATETIME&quot;; then
              #Check if the beginning is in the past
              if ! is_futuredate &quot;$BEGDATETIME&quot;; then
                  echo &quot;NOW: $(echo &quot;$line&quot; | cut -d' ' -f 6-)&quot;
                  exit
              fi
              echo &quot;$(echo &quot;$line&quot; | cut -d' ' -f 1,6-)&quot;
              exit
          fi
      fi
  done

All this script does is output the next reminder. It's output is passed to a widget with the following lua code:
  -- {{{ Next reminder
  -- remindericon = widget({ type = &quot;imagebox&quot; })
  -- remindericon.image = image(beautiful.widget_org)
  myreminder = widget({ type = &quot;textbox&quot;, name = &quot;reminder&quot;, align = &quot;right&quot; })
  function next_reminder()
      local fd=io.popen(&quot;bash /home/USER/Scripts/reminderwidget.sh&quot;, &quot;r&quot;) --next reminder
      local line=fd:read()
      return line
  end
  myreminder.text = &quot; &quot; .. next_reminder() .. &quot; &quot;
  my_reminder_timer=timer({timeout=115}) 
  my_reminder_timer:add_signal(&quot;timeout&quot;, function()
      myreminder.text = &quot; &quot; .. next_reminder() .. &quot; &quot;
  end)
  my_reminder_timer:start()
  -- }}}



Don't forget to add it:
       statusbar[s].widgets = ({
          ....
          myreminder,
          ...
      })
[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>3z4hsaa8sa4bwf1tbitzc2kou5rudny</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Releases</title>
    <ns>0</ns>
    <id>26</id>
    <revision>
      <id>7455</id>
      <parentid>7425</parentid>
      <timestamp>2016-03-06T14:06:47Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>/* Stable : version 3 */ 3.5.9 Mighty Ravendark</comment>
      <text xml:space="preserve" bytes="5517">__NOTOC__
&lt;table width=&quot;100%&quot;&gt;&lt;tr&gt;&lt;td width=&quot;47%&quot; align=&quot;left&quot; valign=&quot;top&quot;&gt;
== ''Stable'' : version 3 ==
{| style=&quot;background:#eee;&quot;
|- style=&quot;background:#cdc;&quot; align=&quot;center&quot;
!width=&quot;100&quot;| Date !!width=&quot;150&quot;| Version !! Codename
|-
| 6 mar 2016 || awesome 3.5.9 || Mighty Ravendark
|-
|-
| 30 jan 2016 || awesome 3.5.8 || Major Tom
|-
|-
| 15 jan 2016 || awesome 3.5.7 || Space Oddity
|-
|-
| 10 jan 2015 || awesome 3.5.6 || For Those About To Rock
|-
|-
| 11 apr 2014 || awesome 3.5.5 || Kansas City Shuffle
|-
|-
| 2 apr 2014 || awesome 3.5.4 || Brown Paper Bag
|-
|-
| 29 mar 2014 || awesome 3.5.3 || Crazy
|-
|-
| 12 oct 2013 || awesome 3.5.2 || The Fox
|-
|-
| 1 apr 2013 || awesome 3.5.1 || Ruby Tuesday
|-
|- style=&quot;background:#efe;&quot;
| ''21 dec 2012'' || ''awesome 3.5'' || ''Last Christmas''
|-
|-
| 14 dec 2012 || awesome 3.5-rc2 || I'll Kill Her
|-
|-
| 24 nov 2012 || awesome 3.5-rc1 || Dirty Magic
|-
|-
| 11 feb 2013 || awesome 3.4.15 || Never Gonna Give You Up
|-
|-
| 24 dec 2012 || awesome 3.4.14 || White Christmas
|-
|-
| 15 jul 2012 || awesome 3.4.13 || Octopus
|-
|-
| 11 jun 2012 || awesome 3.4.12 || Starlight
|-
|-
| 23 nov 2011 || awesome 3.4.11 || Pickapart
|-
|-
| 16 may 2011 || awesome 3.4.10 || Exploder
|-
|-
| 17 jan 2011 || awesome 3.4.9 || Smack
|-
|-
| 4 oct 2010 || awesome 3.4.8 || Never Know
|-
|-
| 25 aug 2010 || awesome 3.4.7 || Left Of Center
|-
|-
| 14 jul 2010 || awesome 3.4.6 || Hootch
|-
|-
| 10 may 2010 || awesome 3.4.5 || Close To You
|-
|-
| 02 mar 2010 || awesome 3.4.4 || Jet Sex
|-
|-
| 04 jan 2010 || awesome 3.4.3 || Engines
|-
|-
| 26 nov 2009 || awesome 3.4.2 || For The Restless
|-
| 9 nov 2009 || awesome 3.4.1 || Ego Rock
|- style=&quot;background:#efe;&quot;
| ''20 oct 2009'' || ''awesome 3.4'' || ''Closing In''
|-
| 9 oct 2009 || awesome 3.4-rc3 || Black Star
|-
| 28 sep 2009 || awesome 3.4-rc2 || Piku
|-
| 11 sep 2009 || awesome 3.4-rc1 || Uprising
|-
| 7 sep 2009 || awesome 3.3.4 || Mercury
|-
| 25 aug 2009 || awesome 3.3.3 || Firelight
|-
| 27 jul 2009 || awesome 3.3.2 || Half Moon
|-
| 18 jun 2009 || awesome 3.3.1 || Bionic
|- style=&quot;background:#efe;&quot;
|  ''4 jun 2009'' || ''awesome 3.3'' || ''Stellar''
|-
| 26 may 2009 || awesome 3.3-rc4 || Breath
|-
| 18 may 2009 || awesome 3.3-rc3 || Uniform
|-
|  8 may 2009 || awesome 3.3-rc2 || Bad Boyfriend
|-
|  1 may 2009 || awesome 3.3-rc1 || The Lightning Strike
|-
|  4 apr 2009 || awesome 3.2.1 || Complicated
|- style=&quot;background:#efe;&quot;
| ''13 mar 2009'' || ''awesome 3.2'' || ''Accidental Babies''
|-
| 27 feb 2009 || awesome 3.2-rc4 || Faith
|-
| 20 feb 2009 || awesome 3.2-rc3 || Chocolate
|-
| 13 feb 2009 || awesome 3.2-rc2 || Hunting For Witches
|-
|  6 feb 2009 || awesome 3.2-rc1 || Candyman
|-
|  5 feb 2009 || awesome 3.1.2 || Nobody Came
|-
|  8 jan 2009 || awesome 3.1.1 || Ring My Bell
|- style=&quot;background:#efe;&quot;
| ''12 dec 2008'' || ''awesome 3.1'' || ''Helicopter''
|-
| 5 dec 2008 || awesome 3.1-rc5 || Face
|-
| 28 nov 2008 || awesome 3.1-rc4 || Seven Nation Army
|-
| 21 nov 2008 || awesome 3.1-rc3 || When Doves Cry
|-
| 14 nov 2008 || awesome 3.1-rc2 || When She Believes
|-
|  7 nov 2008 || awesome 3.1-rc1 || The Golden Floor
|- style=&quot;background:#efe;&quot;
| '''18 sep 2008''' || '''awesome 3.0''' || '''Fake Plastic Trees'''
|-
|  5 sep 2008 || awesome 3.0-rc6 || Elect The Dead
|-
| 29 aug 2008 || awesome 3.0-rc5 || Marshals Are Dead
|-
| 22 aug 2008 || awesome 3.0-rc4 || Scared Of Girls
|-
| 15 aug 2008 || awesome 3.0-rc3 || Into The Groove
|-
|  8 aug 2008 || awesome 3.0-rc2 || Wake Up Call
|-
|  1 aug 2008 || awesome 3.0-rc1 || Time To Pretend
|}
&lt;/td&gt;&lt;td width=&quot;6%&quot;&gt;&amp;nbsp;&lt;/td&gt;&lt;td width=&quot;47%&quot; align=&quot;left&quot; valign=&quot;bottom&quot;&gt;

== ''Oldstable'' ==
{| cellpadding=&quot;7&quot; style=&quot;background:#eee;&quot;
|- style=&quot;background:#cdc;&quot; align=&quot;center&quot;
! Date !! Version !! Codename
|-
| 18 apr 2009 || awesome 2.3.6 || Tomorrow Morning
|-
|  2 jan 2009 || awesome 2.3.5 || New Morning
|-
| 24 aug 2008 || awesome 2.3.4 || Morning Trouble
|}
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;

== Version 2 ==
{| style=&quot;background:#eee;&quot; align=&quot;center&quot;
|- style=&quot;background:#cdc;&quot;
!width=&quot;100&quot;| Date !!width=&quot;150&quot;| Version !! Codename
|-
| 26 jul 2008 || awesome 2.3.3 || Pure Morning
|-
| 24 jun 2008 || awesome 2.3.2 || Morning Yearning
|-
| 2 jun 2008 || awesome 2.3.1 || Morning Glory
|- style=&quot;background:#efe;&quot;
| ''6 may 2008'' || ''awesome 2.3'' || ''Morning View''
|-
| 21 apr 2008 || awesome 2.3-rc3 || Dirty Boots
|-
| 17 apr 2008 || awesome 2.3-rc2 || Better Than
|-
| 7 apr 2008 || awesome 2.3-rc1 || Deep Inside
|- style=&quot;background:#efe;&quot;
| ''23 mar 2008'' || ''awesome 2.2'' || ''Morning Lemon''
|-
| 13 mar 2008 || awesome 2.2-rc4 || Wooden Horse
|-
|  4 mar 2008 || awesome 2.2-rc3 || There There
|-
| 25 feb 2008 || awesome 2.2-rc2 || Broken Man
|-
| 14 feb 2008 || awesome 2.2-rc1 || Digital Love
|- style=&quot;background:#efe;&quot;
| ''21 jan 2008'' || ''awesome 2.1'' || ''Morning Bell''
|-
| 12 jan 2008 || awesome 2.1-rc2 || Blow out
|-
|  9 jan 2008 || awesome 2.1-rc1 || Dracula Cowboy
|- style=&quot;background:#efe;&quot;
| '''11 dec 2007''' || '''awesome 2.0''' || '''Fruit Fly'''
|-
| 29 nov 2007 || awesome 2.0-rc2 || Softened Lights
|-
| 16 nov 2007 || awesome 2.0-rc1 || Bumping Toaster
|}


== Version 1 ==
{| style=&quot;background:#eee;&quot; align=&quot;center&quot;
|- style=&quot;background:#cdc;&quot;
!width=&quot;100&quot;| Date !!width=&quot;120&quot;| Version
|-
|  5 oct 2007 || awesome 1.3
|-
| 26 sep 2007 || awesome 1.2
|-
| 20 sep 2007 || awesome 1.1
|- style=&quot;background:#efe;&quot;
| '''19 sep 2007''' || '''awesome 1.0'''
|}

[[Category:Awesome]]</text>
      <sha1>6on1ou16mckq026gdbvk7pujsndpcse</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Remind Widget</title>
    <ns>0</ns>
    <id>214</id>
    <revision>
      <id>1651</id>
      <timestamp>2008-11-18T19:49:42Z</timestamp>
      <contributor>
        <username>Kanim</username>
        <id>198</id>
      </contributor>
      <text xml:space="preserve" bytes="1929">This is my Remind widget it's mainly based on the gmail widget from Gigamo's config.

So first off all we create a bashscript named .todo.sh in your home dir

.todo.sh:
    #!/bin/bash
    #
    REMIND=`remind -q ~/.reminders | wc -l` 
    echo $[($REMIND / 2) -1]
This script looks up for for reminders of today in your .reminders and outputs the number of them.



Now we need to create a widget:

    remindwidget = widget({ type = &quot;textbox&quot;, name = &quot;remindwidget&quot;, align = &quot;right&quot; })
    remindwidget:buttons({ button({ }, 1, function () wicked.update(remindwidget) end) })
    function readRemind(format)
        local f = io.open(&quot;/tmp/remind-temp&quot;)
        if f == nil then
            return {&quot;n/a&quot;}
        end
        local n = f:read()
        if n == nil or f == &quot; &quot; or f == &quot;&quot; then
            f:close()
            return {&quot;n/a&quot;}
        end
        return {n}
    end
    wicked.register(remindwidget, readRemind, function (widget, args)
        local reminds = args[1]
        if reminds ~= &quot;n/a&quot; and tonumber(reminds) &gt; 0 then
            return spacer..setFg(beautiful.fg_focus, &quot;Rems:&quot;)..spacer..setBgFg(beautiful.bg_focus, beautiful.fg_focus, tostring(reminds))..spacer
        else
            return spacer..setFg(beautiful.fg_focus, &quot;Rems:&quot;)..spacer..tostring(reminds)..spacer
        end
    end, 120)

This Widget looks every 2 minutes in /tmp/remind-temp for some new reminders.



Now add this Widget to your Statusbar:
     statusbar[s].widgets = ({
        ....
        remindwidget,
        ...
    })


In the next step we create a functions that executes our little bash scripts an writes the output into /tmp/remind-temp:

    function hookAlmostTwoMinutes()
        os.execute(os.getenv(&quot;HOME&quot;)..&quot;/.todo.sh &gt; /tmp/remind-temp &amp;&quot;)
    end



and a hook to execute it nearly every two minutes:
 
    awful.hooks.timer.register(115, hookAlmostTwoMinutes)

[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>3b76wvqi7ffiz66sg0tfdwhf2kxroyh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>RemoveExtraSpace</title>
    <ns>0</ns>
    <id>1135</id>
    <revision>
      <id>6876</id>
      <parentid>6873</parentid>
      <timestamp>2014-07-25T14:20:53Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add screenshots</comment>
      <text xml:space="preserve" bytes="3203">===Remove extra spaces between tags ===
'''Code works in Awesome 3.5''', you may remake it for 3.4, but the change will be enough.

[[File:Taglist before.png|250px|thumb|right|Tags before]]
[[File:Taglist after.png|250px|thumb|right|Tags after]]
When you are use icons instead of text in the tag, gaps are formed on the side of icons, looking not very beautifull. By default, when using the text in the tag, the left and right is added 4 pixels to separate text, but for the icons, this approach seems not the best way. Therefore, this problem can (and should) be solved. At the same time the ability to edit the text in the distance between your widgets.

So to solve the problem, we need 2 files '''~/.config/awesome/awful/widget/common.lua''' and '''taglist.lua''' from the same folder. 
Recommend copying files to the user's library, not to work on the root. And if you mess up something that can be restored.
&lt;pre&gt;
cp -R /usr/share/awesome/lib ~/.config/awesome
&lt;/pre&gt;
Open ~/.config/awesome/awful/widget/common.lua, find function ''common.list_update'' in it, and override it as follows:
&lt;pre&gt;
function common.list_update(w, buttons, label, data, objects, left_margin, right_margin)	
&lt;/pre&gt;
Here we have added the left and right margins. Then find following code in same function:
&lt;pre&gt;
else
            ib = wibox.widget.imagebox()
            tb = wibox.widget.textbox()
            bgb = wibox.widget.background()
            m = wibox.layout.margin(tb, 4, 4)
&lt;/pre&gt;
And replace it with:
&lt;pre&gt;
else
	    local m_left = left_margin or 4			--initialize the left indent
	    local m_right = right_margin or 4			--initialize the right indent
            ib = wibox.widget.imagebox()
            tb = wibox.widget.textbox()
            bgb = wibox.widget.background()
            m = wibox.layout.margin(tb, m_left, m_right)	--redefine standart fucntion calling
&lt;/pre&gt;
Here, we hedged if the arguments passed to the function is not indented, they are set to default values. Actual is for calls from other, not modify function (we do not want to redo the entire code))).

Then, open '''~/.config/awesome/awful/widget/taglist.lua'''. Find following function ''function taglist_update'' and replace its with the following code:
&lt;pre&gt;
local function taglist_update(s, w, buttons, filter, data, style, update_function, ml, mr)	--adding variables indent
&lt;/pre&gt;
Then, find calling ''update_function(w, buttons, label, data, tags)'' and replace its:
&lt;pre&gt;
update_function(w, buttons, label, data, tags, ml, mr)					--adding to the call variables indent
&lt;/pre&gt;
Find ''function taglist.new'' in the same file and add followng code to the beginning:
&lt;pre&gt;
local ml, mr = 0,0		--adding variables indent and initialization
&lt;/pre&gt;
And here you can set your margins, I chose 0 for icons so that they are close to each other, if we choose other values, the indents appear on the right side, ignoring the left (its some features)
Then find the code:
&lt;pre&gt;
if s == screen then
            taglist_update(s, w, buttons, filter, data, style, uf)
&lt;/pre&gt;
And replace it for:
&lt;pre&gt;
if s == screen then
            taglist_update(s, w, buttons, filter, data, style, uf, ml, mr)
&lt;/pre&gt;
Everything is ready, restarts Awesome!</text>
      <sha1>1o3ymwfdm8u2av0j4fyb5em4ok5wnji</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Remove icons</title>
    <ns>0</ns>
    <id>521</id>
    <revision>
      <id>6563</id>
      <parentid>5961</parentid>
      <timestamp>2014-05-19T17:32:57Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1452">{{Languages}}

== Removing icons in v3.5.1 ==

As of v3.5.1, tasklist icons can be removed by adding
&lt;pre&gt;
theme.tasklist_disable_icon = true
&lt;/pre&gt;
to your theme.lua.

== Removing icons in v3.4.11 ==

'''Note:''' this guide assumes that you are using v3.4.11
&lt;pre&gt;
genjix@l:~$ cd /usr/share/awesome/lib/awful/widget/
genjix@l:/usr/share/awesome/lib/awful/widget$ sudo vim tasklist.lua 
&lt;/pre&gt;

Find the line (around line 123 in function called local function widget_tasklist_label_common(c, args)) like:
&lt;pre&gt;    text = text .. &quot;&lt;/span&gt;&quot;
    -- return text, bg, status_image, c.icon
    return text, bg, status_image, nil
end
&lt;/pre&gt;

Commenting it with -- and changing the last c.icon to nil like above


If you prefer to configure as much as possible in the rc.lua do the following:
find the command which creates the tasklist and let it look like this
&lt;pre&gt;
	-- Create a tasklist widget
	mytasklist = awful.widget.tasklist(function(c)
		--remove tasklist-icon without modifying the original tasklist.lua
		local tmptask = { awful.widget.tasklist.label.currenttags(c, myscreen) }
		return tmptask[1], tmptask[2], tmptask[3], nil
	end, mytasklist.buttons)
&lt;/pre&gt;
this does basically the same thing as the changes in the tasklist.lua but later
when the function returns content to the actual tasklist
(be aware that the variable 'myscreen' refers to my configuration, 
i think originally you have this block in a for-loop and this 'myscreen' is an 'i')</text>
      <sha1>pi7tmlqwrpaiukq7gdki6nb5g2gp9i2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Remove icons/ru</title>
    <ns>0</ns>
    <id>1062</id>
    <revision>
      <id>6567</id>
      <parentid>6566</parentid>
      <timestamp>2014-05-19T17:54:00Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>корректировка тега languages</comment>
      <text xml:space="preserve" bytes="2214">{{DISPLAYTITLE:Удаление иконок}}
{{Languages|Remove icons}}

== Удаление иконок в v3.5.1 и новее ==

Начиная с v3.5.1, иконки из панели задач могут быть удалены с помощью следующего кода:
&lt;pre&gt;
theme.tasklist_disable_icon = true
&lt;/pre&gt;
в файле '''theme.lua'''.

== Удаление иконок в v3.4.11 ==

'''Примечание:''' этот гайд расчитан на использование с awesome v3.4.11
&lt;pre&gt;
$ cd /usr/share/awesome/lib/awful/widget/
$ sudo vim tasklist.lua 
&lt;/pre&gt;

Найдите строку (ориентировочно это 123 в функции называющейся local function widget_tasklist_label_common(c, args)) следующий код:
&lt;pre&gt;    text = text .. &quot;&lt;/span&gt;&quot;
    -- return text, bg, status_image, c.icon
    return text, bg, status_image, nil
end
&lt;/pre&gt;

Закомментируйте ее используя -- и измените последний c.icon на nil, как указано выше


Если вы предпочитаете настраивать все что возможно в rc.lua сделайте следующим образом:
найдите команду, которая создает панель задач (tasklist) и поменяйте ее так, чтобы она выглядела следующим образом
&lt;pre&gt;
	-- Create a tasklist widget
	mytasklist = awful.widget.tasklist(function(c)
		--remove tasklist-icon without modifying the original tasklist.lua
		local tmptask = { awful.widget.tasklist.label.currenttags(c, myscreen) }
		return tmptask[1], tmptask[2], tmptask[3], nil
	end, mytasklist.buttons)
&lt;/pre&gt;

этот код делает то же самое, что и изменения в tasklist.lua, но позже, когда функция возвращает содержимое в актуальный tasklist
(помните, что переменная 'myscreen' ссылается на мою конфигурацию, я думаю что изначально у вас есть этот блок в цикле и этоn 'myscreen' является 'i')</text>
      <sha1>3v541l9rbxj5xmckpxfjqb5slphd9zm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Revelation</title>
    <ns>0</ns>
    <id>185</id>
    <revision>
      <id>6194</id>
      <parentid>5775</parentid>
      <timestamp>2014-01-02T20:57:39Z</timestamp>
      <contributor>
        <username>Guotsuan</username>
        <id>3057</id>
      </contributor>
      <comment>/* WARNING, Update: Revelation was revived */</comment>
      <text xml:space="preserve" bytes="2664">{{Languages}}

{| align=&quot;right&quot;
  | __TOC__
  |}

== WARNING ==

&lt;s&gt;'''Revelation is deprecated.''' The repository listed here may be deleted at any time.&lt;/s&gt;

'''Update''', ''02.01.2014'' : Revelation was revived and modified for '''awesome 3.5 or later'''. 

you can find the source codes here: https://github.com/guotsuan/awesome-revelation.git
Welcome everyone to try it and give feedbacks, if you are interested. 

The details about changes, installation and configuration of the new revelation can be 
found here: https://github.com/guotsuan/awesome-revelation/blob/master/README.md


''' Original revelation:'''

----

=== Introduction ===
&lt;div style=&quot;margin-left: 30px;&quot;&gt;
Revelation provides a method to quickly view all open clients, then select and focus one. When the module is called all clients are merged on the current tag and set to a fair layout. The user can then select a client to focus and that client's current tag will be selected and the client focused.

This aims to be similar to Mac OS X's Expose.

Revelation was part of awesome's core for a while, but then removed. It has subsequently been maintained (somewhat haphazardly :P) by the community.

You find the source here: https://github.com/bioe007/awesome-revelation


&lt;/div&gt;

=== Use ===
&lt;div style=&quot;margin-left: 30px;&quot;&gt;
1. Clone repository into your configuration path:

    git clone https://bioe007@github.com/bioe007/awesome-revelation.git ~/.config/awesome/revelation

2. To load the module in your rc.lua, put this near the top:
    
    require(&quot;revelation&quot;)

3. Make a global keybinding for revelation, add this line

    awful.key({modkey}, &quot;e&quot;, revelation)

after 

    globalkeys = awful.util.table.join(
        awful.key({ modkey,           }, &quot;Left&quot;,   awful.tag.viewprev       ),
        awful.key({ modkey,           }, &quot;Right&quot;,  awful.tag.viewnext       ),
        awful.key({ modkey,           }, &quot;Escape&quot;, awful.tag.history.restore),

'''NOTE:''' Double check this key binding syntax against the version of awesome that you are using.

4. Reload rc.lua and try the keybinding(Push mod4 + e).

It should bring all clients to the current tag and set the layout to fair. You can focus clients with '''cursor''' or '''hjkl''' keys then press '''Enter''' to select or '''Escape''' to abort.
&lt;/div&gt;

=== Credits ===
&lt;div style=&quot;margin-left: 30px;&quot;&gt;
* Perry Hargrave resixian@gmail.com
* Espen Wiborg espenhw@grumblesmurf.org
* Julien Danjou julien@danjou.info
&lt;/div&gt;

=== License ===
&lt;div style=&quot;margin-left: 30px;&quot;&gt;
(c) 2008 Espen Wiborg, Julien Danjou
&lt;/div&gt;

=== Screenshot ===


[[Image:revelation.png|thumb|600px|Revelation in action]]







[[Category:Awesome3]]</text>
      <sha1>e5c96uykp7t0doingyyuggwc3pih3zr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Revelation/fr</title>
    <ns>0</ns>
    <id>442</id>
    <revision>
      <id>3338</id>
      <parentid>3291</parentid>
      <timestamp>2009-07-15T18:37:13Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use {{DISPLAYTITLE}} instead of Template:Title</comment>
      <text xml:space="preserve" bytes="2730">{{DISPLAYTITLE:Revelation}}
{{Languages|Revelation}}

== Revelation, c’est quoi ? ==
[[Image:revelation.png|thumb|right|300px|Revelation en action]]
Une des fonctionnalités très sympa qui est disponible dans Mac OS X, c’est [http://fr.wikipedia.org/wiki/Exposé_(Mac_OS_X) Exposé]. Alors pourquoi on l’aurait pas aussi sous awesome, hein ? Eh bien, le voilà !

Revelation permet d’afficher en même temps tous vos clients ouverts. En cliquant sur un client, vous vous retrouvez sur le premier onglet lié à ce client et vous le mettez à l’avant-plan. Vous pouvez également appuyer sur la touche [Entrée] pour aller vers le client actuellement au premier plan, et sur [Échap.] pour annuler.

Revelation fait partie d’awesome depuis le 13 novembre 2008 &lt;small&gt;(''commit'' git 863f9a78a860a32a55703f61d9fa8f8788e1c35b)&lt;/small&gt;, et sera donc dans la version 3.1 quand elle sera distribuée.

== Je veux ! ==
Avec awesome 3.1, vous pouvez activer Revelation en ajoutant les lignes qui suivent dans votre fichier de configuration '''~/.config/awesome/rc.lua''', après quoi vous pourrez appuyer sur Super+E pour avoir l’« effet Revelation » :
 -- Chargement de Revelation
 require(&quot;revelation&quot;)
 -- Ajout d’un raccourci clavier Super+E pour lancer Revelation
 keybinding({ modkey }, &quot;e&quot;, revelation.revelation):add()

== Attention… ==
&lt;div style=&quot;background:#eee; border:1px solid #aaa; padding:8px;&quot;&gt;Revelation a été supprimé des bibliothèques standard d’awesome. Un ''hack'' de l’ancienne version est disponible pour awesome-git &lt;small&gt;[http://github.com/bioe007/bioe007configs/blob/master/.config/awesome/revelation.lua (bioe007 github: revelation.lua)]&lt;/small&gt;, mais il présente quelques différences :
* aucun onglet « Revelation » n’est créé ni détruit, donc votre historique d’onglets n’est pas anéanti ;
* vous pouvez vous déplacer parmi les clients en utilisant les touches de déplacement par défaut de ''vim'' ;
* aucun recours à un ''otable'', tout est fait en utilisant awful et les fonctions ''capi'' ;
* il n’y a plus de maths : ''awful.suit.fair'' est utilisé pour placer les applications.
  
Pour activer le module :
# Mettez le fichier '''revelation.lua'' dans votre chemin de configuration awesome ; usuellement '''~/.config/awesome/'''.
# Ajoutez ''require(&quot;revelation&quot;)'' au début de votre '''rc.lua'''.
# Ajoutez un raccourci clavier pour Revelation : ''table.insert(globalkeys, key({ modkey }, &quot;e&quot;, revelation.revelation ))'' par exemple.
  
En cas de problème, l’adresse e-mail du développeur, bioe007, est disponible au début du fichier ; il traîne aussi de temps en temps sur ''#awesome'' dans ''oftc''.&lt;/div&gt;

[[Category:Awesome3]]</text>
      <sha1>8ye7154degez46dboo02ibkqgzuwzhx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Revelation/ru</title>
    <ns>0</ns>
    <id>1040</id>
    <revision>
      <id>6467</id>
      <parentid>6466</parentid>
      <timestamp>2014-05-07T17:45:11Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="9929">{{Languages|Revelation}}
{{DISPLAYTITLE:Revelation}}

{| align=&quot;right&quot;
  | __TOC__
  |}

== Внимание ==

&lt;s&gt;'''Revelation утсарел.''' Репозиторий может быть удалено в любое время.&lt;/s&gt;

'''Обновлено''', ''02.01.2014'' : Revelation был восстановлен и модифицированн для '''awesome 3.5 or later'''. 

вы можете найти исходный код здесь: https://github.com/guotsuan/awesome-revelation.git
Добро пожаловать, пробуйте его, и давайте обратную связь, если вы заинтересованны в нем.

Список изменений, установка и настройка новой версии ''Revelation'', вы можете найти здесь: https://github.com/guotsuan/awesome-revelation/blob/master/README.md

== Новый Awesome-Revelation ==

Это форк Revelation, который был модифицирован из оригинального revelation.lua, для совместимости с awesome 3.5 и новее. Одноко он имеет некоторые особенности по сравнению с оригинальным. 

'''Отличия от оригинального Revelation'''

* Поддержка awesome 3.5 и новее

* Добавлено поддержка множественности экранов. Теперь несколько &quot;Expose&quot; видов будут отображаться на всех экранах одновременно.

* Изменен способ выбора и фокусировки приложения. Теперь над каждым приложением в режиме просмотра &quot;Expose&quot; высвечивается подсказка в виде буквы, и вы можете выбрать приложение нажатием соотвествующей буквы. Идея и код этого метода были скопированны из модуля подсказок.

* Добавлен режим масшатбирования. Функция масшатбирования приложения включается правой клавишей мыши.

* Нежелательные клиенты могут быть исключены из списка используя parameter{rule={...}....}.


=== Установка ===

1. Клонируйте репозиторийy:

 git clone https://github.com/guotsuan/awesome-revelation revelation

2. Добавьте следующий код в начало файла rc.lua:
 local revelation=require(&quot;revelation&quot;)

3. Добавьте revelation.init() после beautiful.init()

4. Определите глобальные клавиатурные сочетания (например ModKey + e) в your rc.lua:

    globalkeys = awful.util.table.join(
    awful.key({ modkey,           }, &quot;Left&quot;,   awful.tag.viewprev       ), 
    awful.key({ modkey,           }, &quot;Right&quot;,  awful.tag.viewnext       ),
    awful.key({ modkey,           }, &quot;Escape&quot;, awful.tag.history.restore),

    ==&gt; awful.key({ modkey, }, &quot;e&quot;, revelation),

    awful.key({ modkey,           }, &quot;j&quot;,
    function ()
        awful.client.focus.byidx( 1)
        if client.focus then client.focus:raise() end
    end),

'''Примечание''': Обязательно дважды проверьте синтаксис клавиш для вашей версии Awesome.

5. Перезапустите Awesome (обычно Modkey + Control + r) и проверьте клавиатурное сочетание Modkey + e.

Это перенесет все приложения из текущих тегов на все экраны и установить схему(layout) на fair. Вы можете выбрать приложение с помощью клавиш курсора, а затем нажать левую клавишу для выбора, или вы можете выбрать нужно окно нажатием на соотвествующую ему клавишу, показанную в подсказке. Нажатие левой клавиши масштабирует приложение, а Escape завершит работу.

=== Настройка ===

Настройка Revelation осуществляется через функцию inti()

Есть две основных настройки, которые установлены значениями по умолчанию:
&lt;pre&gt;
 -- Название тега созданного для вида 'exposed'
 revelation.tag_name = 'Revelation'

 -- Таблица функций соотвествия (используется для фильтрации приложений, например для удаления из списка не нужных)
 revelation.exact = awful.rules.match
 revelation.any   = awful.rules.match_any
&lt;/pre&gt;

Функции правил сопоставления, должны соотвестовать прототипам awful.rules.match.

Для правил сопоставления приложений, мы используем тот же синтаксис, что и в awful.rules. Если rule.any == true, то мы вызываем функцию  &lt;code&gt;config.match.any&lt;/code&gt;.

Для изменения настроек используйте:

 revelation.init({tag_name = ..., match={...})

=== Примеры ===

Отобразить все приложения:
 &lt;code&gt;awful.key({modkey}, &quot;e&quot;, revelation)&lt;/code&gt;

Отобразить только терминалы URxvt:
 &lt;pre&gt;awful.key({modkey}, &quot;e&quot;, function()
            revelation({rule={class=&quot;URxvt&quot;}})
         end)
&lt;/pre&gt;

Отобразить все приложения с class=foo или bar
&lt;pre&gt;
awful.key({modkey}, &quot;e&quot;, function()
            revelation({
                        rule{class={&quot;foo&quot;, &quot;bar&quot;},
                        any=true}
                        })
        end)
&lt;/pre&gt;

Для исключения приложения:
&lt;pre&gt;
awful.key({modkey}, &quot;e&quot;, function()
         revelation(rule={class=&quot;conky&quot;}, is_excluded=true)
         end)
&lt;/pre&gt;

Для отображения приложений только текущего тега:
&lt;pre&gt;
awful.key({modkey}, &quot;e&quot;, function()
             revelation(rule={class=&quot;conky&quot;}, is_excluded=true, 
            curr_tag_only=true)
             end)
&lt;/pre&gt;

=== Поддержка ===

* Quan Guo &lt;guotsuan@gmail.com&gt;
* Perry Hargrave &lt;resixian@gmail.com&gt;

Существенный взнос

* Nikola Petrov &lt;nikolavp@gmail.com&gt;

== Старый Revelation ==

==== Введение ====
&lt;div style=&quot;margin-left: 30px;&quot;&gt;
Revelation предоставляет способ быстрого просмотра всех открытых приложений, с возможностью выбрать и переключиться на него. Когда вызывается модуль, все приложения объединяются на текущем теге и в соотвествии со схемой(layout) расставляются равномерно. Пользователь может выбрать приложение и переключить на него фокус, затем будет произведено переключение на тег соотвествующий выбранному приложению.

Revelation - это что-то похожее на Mac OS X's Expose.

Revelation какое то время был частью ядра awesome, но затем был удален из него. В дальнейшем он поддерживался (довольно безсистемно :P) сообществом.

Вы можете найти исходники здесь : https://github.com/bioe007/awesome-revelation


&lt;/div&gt;

==== Использование ====
&lt;div style=&quot;margin-left: 30px;&quot;&gt;
1. Клонируйте репозиторий в папку awesome:

    git clone https://bioe007@github.com/bioe007/awesome-revelation.git ~/.config/awesome/revelation

2. Для загрузки модуля в файле ''rc.lua'', поместите следующий код в начале файла:
    
    require(&quot;revelation&quot;)

3. Для добавления глобальных клавиатурных сочетаний для Revelation, добавьте следуюющее:

    awful.key({modkey}, &quot;e&quot;, revelation)

после 

    globalkeys = awful.util.table.join(
        awful.key({ modkey,           }, &quot;Left&quot;,   awful.tag.viewprev       ),
        awful.key({ modkey,           }, &quot;Right&quot;,  awful.tag.viewnext       ),
        awful.key({ modkey,           }, &quot;Escape&quot;, awful.tag.history.restore),

'''Примечание:''' Дважды проверьте синтаксис этих клавиш в вашей версии awesome, которую испльзуете.

4. Перезагрузите ''rc.lua'' и проверьет клавиши(нажмите mod4 + e).

Это установит все приложения на текущем теге с равномерным выравниванием. Вы можете переключиться на приложении используяю '''cursor''' или '''hjkl'''клавиши, а затем нажав '''Enter''' для выбора, или '''Escape''' для завершения.
&lt;/div&gt;

==== Credits ===
&lt;div style=&quot;margin-left: 30px;&quot;&gt;
* Perry Hargrave resixian@gmail.com
* Espen Wiborg espenhw@grumblesmurf.org
* Julien Danjou julien@danjou.info
&lt;/div&gt;

==== Лицензия ====
&lt;div style=&quot;margin-left: 30px;&quot;&gt;
(c) 2008 Espen Wiborg, Julien Danjou
&lt;/div&gt;

==== Скриншот ====


[[Image:revelation.png|thumb|600px|Revelation в действии]]









[[Category:Awesome3]]</text>
      <sha1>qxguvlpxkl6je0a1wy5rcoonwoyiguj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Rhaamo theme</title>
    <ns>0</ns>
    <id>114</id>
    <revision>
      <id>1867</id>
      <timestamp>2008-11-29T08:44:02Z</timestamp>
      <contributor>
        <username>Rhaamo</username>
        <id>3</id>
      </contributor>
      <comment>/* Rhaamo's theme */</comment>
      <text xml:space="preserve" bytes="603">= Rhaamo's theme =
Awesome 3 git.&lt;br /&gt;
[[Image:desktop-rhaamo.png|thumb|none|My current theme]]
Configuration: [http://tux-atome.fr/?p=rhaamo_config-files.git;a=tree;f=configs/awesome3/dot_config/awesome;hb=HEAD http://tux-atome.fr/?p=rhaamo_config-files.git;a=tree;f=configs/awesome3/dot_config/awesome;hb=HEAD]&lt;br /&gt;
Scripts used (or not): [http://tux-atome.fr/?p=rhaamo_config-files.git;a=tree;f=configs/awesome3/dot_config/awesome/scripts;hb=HEAD http://tux-atome.fr/?p=rhaamo_config-files.git;a=tree;f=configs/awesome3/dot_config/awesome/scripts;hb=HEAD]

[[Category:awesome3]]
[[Category:themes]]</text>
      <sha1>oarcl9d81wcxa6mpsqjz1k765vuhg3l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Rman's Simple Volume Widget</title>
    <ns>0</ns>
    <id>866</id>
    <revision>
      <id>7131</id>
      <parentid>7130</parentid>
      <timestamp>2014-12-07T16:53:10Z</timestamp>
      <contributor>
        <username>LiamMayfair</username>
        <id>4070</id>
      </contributor>
      <minor/>
      <comment>Typo.</comment>
      <text xml:space="preserve" bytes="9936">{{VersionSpecific
 | goodversions = 3.5
 | otherversions = [http://awesome.naquadah.org/w/index.php?title=Rman%27s_Simple_Volume_Widget&amp;oldid=5645 3.4] }}
[[File:Rman-simpvolwidg.png|thumb|right|The widget in action.]]
[[File:Rman-simpvolwidg_notify.png|thumb|right|The Naughty notification displayed when using the multimedia keys.]]
This is a simple ALSA-based volume widget that displays the current volume level in a vertical progress bar and tooltip. When the audio device is muted, the bar becomes full and changes color. It requires few lines of code, makes use of the [[vicious]] widget library, is highly functional and configurable, and- unlike other volume widgets- does not require external lua files and shell scripts. Additionally, in most cases the bar reacts instantaneously; there is no &quot;lag&quot; when using the widget to change the volume level. Notifications can optionally be displayed when adjusting the volume level using the multimedia keys.

=Installation=
==Dependencies==
* '''[[vicious]]'''
* '''alsa-utils''' - contains ''amixer'', which is used to change the volume levels

==rc.lua==
===The widget===
Add the following code into your personal ''rc.lua'' file:
&lt;pre&gt;
local alsawidget =
{
	channel = &quot;Master&quot;,
	step = &quot;5%&quot;,
	colors =
	{
		unmute = &quot;#AECF96&quot;,
		mute = &quot;#FF5656&quot;
	},
	mixer = terminal .. &quot; -e alsamixer&quot;, -- or whatever your preferred sound mixer is
	notifications =
	{
		icons =
		{
			-- the first item is the 'muted' icon
			&quot;/usr/share/icons/gnome/48x48/status/audio-volume-muted.png&quot;,
			-- the rest of the items correspond to intermediate volume levels - you can have as many as you want (but must be &gt;= 1)
			&quot;/usr/share/icons/gnome/48x48/status/audio-volume-low.png&quot;,
			&quot;/usr/share/icons/gnome/48x48/status/audio-volume-medium.png&quot;,
			&quot;/usr/share/icons/gnome/48x48/status/audio-volume-high.png&quot;
		},
		font = &quot;Monospace 11&quot;, -- must be a monospace font for the bar to be sized consistently
		icon_size = 48,
		bar_size = 20 -- adjust to fit your font if the bar doesn't fit
	}
}
-- widget
alsawidget.bar = awful.widget.progressbar ()
alsawidget.bar:set_width (8)
alsawidget.bar:set_vertical (true)
alsawidget.bar:set_background_color (&quot;#494B4F&quot;)
alsawidget.bar:set_color (alsawidget.colors.unmute)
alsawidget.bar:buttons (awful.util.table.join (
	awful.button ({}, 1, function()
		awful.util.spawn (alsawidget.mixer)
	end),
	awful.button ({}, 3, function()
                -- You may need to specify a card number if you're not using your main set of speakers.
                -- You'll have to apply this to every call to 'amixer sset'.
                -- awful.util.spawn (&quot;amixer sset -c &quot; .. yourcardnumber .. &quot; &quot; .. alsawidget.channel .. &quot; toggle&quot;)
		awful.util.spawn (&quot;amixer sset &quot; .. alsawidget.channel .. &quot; toggle&quot;)
		vicious.force ({ alsawidget.bar })
	end),
	awful.button ({}, 4, function()
		awful.util.spawn (&quot;amixer sset &quot; .. alsawidget.channel .. &quot; &quot; .. alsawidget.step .. &quot;+&quot;)
		vicious.force ({ alsawidget.bar })
	end),
	awful.button ({}, 5, function()
		awful.util.spawn (&quot;amixer sset &quot; .. alsawidget.channel .. &quot; &quot; .. alsawidget.step .. &quot;-&quot;)
		vicious.force ({ alsawidget.bar })
	end)
))
-- tooltip
alsawidget.tooltip = awful.tooltip ({ objects = { alsawidget.bar } })
-- naughty notifications
alsawidget._current_level = 0
alsawidget._muted = false
function alsawidget:notify ()
	local preset =
	{
		height = 75,
		width = 300,
		font = alsawidget.notifications.font
	}
	local i = 1;
	while alsawidget.notifications.icons[i + 1] ~= nil
	do
		i = i + 1
	end
	if i &gt;= 2
	then
		preset.icon_size = alsawidget.notifications.icon_size
		if alsawidget._muted or alsawidget._current_level == 0
		then
			preset.icon = alsawidget.notifications.icons[1]
		elseif alsawidget._current_level == 100
		then
			preset.icon = alsawidget.notifications.icons[i]
		else
			local int = math.modf (alsawidget._current_level / 100 * (i - 1))
			preset.icon = alsawidget.notifications.icons[int + 2]
		end
	end
	if alsawidget._muted
	then
		preset.title = alsawidget.channel .. &quot; - Muted&quot;
	elseif alsawidget._current_level == 0
	then
		preset.title = alsawidget.channel .. &quot; - 0% (muted)&quot;
		preset.text = &quot;[&quot; .. string.rep (&quot; &quot;, alsawidget.notifications.bar_size) .. &quot;]&quot;
	elseif alsawidget._current_level == 100
	then
		preset.title = alsawidget.channel .. &quot; - 100% (max)&quot;
		preset.text = &quot;[&quot; .. string.rep (&quot;|&quot;, alsawidget.notifications.bar_size) .. &quot;]&quot;
	else
		local int = math.modf (alsawidget._current_level / 100 * alsawidget.notifications.bar_size)
		preset.title = alsawidget.channel .. &quot; - &quot; .. alsawidget._current_level .. &quot;%&quot;
		preset.text = &quot;[&quot; .. string.rep (&quot;|&quot;, int) .. string.rep (&quot; &quot;, alsawidget.notifications.bar_size - int) .. &quot;]&quot;
	end
	if alsawidget._notify ~= nil
	then
		
		alsawidget._notify = naughty.notify (
		{
			replaces_id = alsawidget._notify.id,
			preset = preset
		})
	else
		alsawidget._notify = naughty.notify ({ preset = preset })
	end
end
-- register the widget through vicious
vicious.register (alsawidget.bar, vicious.widgets.volume, function (widget, args)
	alsawidget._current_level = args[1]
	if args[2] == &quot;♩&quot;
	then
		alsawidget._muted = true
		alsawidget.tooltip:set_text (&quot; [Muted] &quot;)
		widget:set_color (alsawidget.colors.mute)
		return 100
	end
	alsawidget._muted = false
	alsawidget.tooltip:set_text (&quot; &quot; .. alsawidget.channel .. &quot;: &quot; .. args[1] .. &quot;% &quot;)
	widget:set_color (alsawidget.colors.unmute)
	return args[1]
end, 5, alsawidget.channel) -- relatively high update time, use of keys/mouse will force update
&lt;/pre&gt;
Then add '''alsawidget.bar''' to your wibox layout(s).

===Multimedia keys===
If you want to use multimedia keys to control the volume level, use the following code to set the [[Global Keybindings|keybindings]]:
&lt;pre&gt;
globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioRaiseVolume&quot;, function()
    awful.util.spawn(&quot;amixer sset &quot; .. alsawidget.channel .. &quot; &quot; .. alsawidget.step .. &quot;+&quot;)
    vicious.force({ alsawidget.bar })
    alsawidget.notify()
end))
globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioLowerVolume&quot;, function()
    awful.util.spawn(&quot;amixer sset &quot; .. alsawidget.channel .. &quot; &quot; .. alsawidget.step .. &quot;-&quot;)
    vicious.force({ alsawidget.bar })
    alsawidget.notify()
end))
globalkeys = awful.util.table.join(globalkeys, awful.key({ }, &quot;XF86AudioMute&quot;, function()
    awful.util.spawn(&quot;amixer sset &quot; .. alsawidget.channel .. &quot; toggle&quot;)
    -- The 2 following lines were needed at least on my configuration, otherwise it would get stuck muted
    -- However, if the channel you're using is &quot;Speaker&quot; or &quot;Headpphone&quot;
    -- instead of &quot;Master&quot;, you'll have to comment out their corresponding line below.
    awful.util.spawn(&quot;amixer sset &quot; .. &quot;Speaker&quot; .. &quot; unmute&quot;)
    awful.util.spawn(&quot;amixer sset &quot; .. &quot;Headphone&quot; .. &quot; unmute&quot;)
    vicious.force({ alsawidget.bar })
    alsawidget.notify()
end))
&lt;/pre&gt;
If you don't want notifications displayed, remove the '''alsawidget.notify()''' calls.

==Configuration==
The top section of the widget's Lua code can be configured to suit your system and preferences. If your main sound output channel is a headset or an alternative set of speakers, you may need to specify their sound card interface when invoking the mixer.
&lt;pre&gt;
local alsawidget =
{
        interface = 1, -- Your interface number may differ
	channel = &quot;Master&quot;,
	step = &quot;5%&quot;,
	colors =
	{
		unmute = &quot;#AECF96&quot;,
		mute = &quot;#FF5656&quot;
	},
	mixer = terminal .. &quot; -e alsamixer&quot;, -- or whatever your preferred sound mixer is
	notifications =
	{
		icons =
		{
			-- the first item is the 'muted' icon
			&quot;/usr/share/icons/gnome/48x48/status/audio-volume-muted.png&quot;,
			-- the rest of the items correspond to intermediate volume levels - you can have as many as you want (but must be &gt;= 1)
			&quot;/usr/share/icons/gnome/48x48/status/audio-volume-low.png&quot;,
			&quot;/usr/share/icons/gnome/48x48/status/audio-volume-medium.png&quot;,
			&quot;/usr/share/icons/gnome/48x48/status/audio-volume-high.png&quot;
		},
		font = &quot;Monospace 11&quot;, -- must be a monospace font for the bar to be sized consistently
		icon_size = 48,
		bar_size = 20 -- adjust to fit your font if the bar doesn't fit
	}
}
&lt;/pre&gt;
====alsawidget.interface====
The number of your sound card interface. You can learn all your sound card interface numbers by pressing F6 whilst in alsamixer.
====alsawidget.channel====
The ALSA audio channel controlled by the widget (in most cases this is &quot;Master&quot;). If you're using a headset, it will be 'Headphone' instead.

====alsawidget.step====
The amount the volume level should change when being adjusted by the mouse scroll wheel or the multimedia keys.

====alsawidget.colors.unmute====
The color of the progress bar when not muted.

====alsawidget.colors.mute====
The color of the progress bar when muted.

====alsawidget.mixer====
Command for your ALSA sound mixer.

====alsawidget.notifications.icons====
A list of icons (in table form) to be used in notifications. The first item will be used as the &quot;muted&quot; icon, and subsequent items will be used for intermediate volume levels. (For example, if you used four items, you would have icons for muted, low, medium, and high.) You can have as many icons as you want.

This property is completely optional - to display notifications without icons, use an empty table '''{}''' .

====alsawidget.notifications.font====
The font used in notifications. Ideally, this should be a fixed-width font so that the volume level bar is sized consistently.

====alsawidget.notifications.icon_size====
Size (in pixels) of icons used in notifications. Need not be specified if icons are not used.

====alsawidget.notifications.bar_size====
Width, in characters, of the volume level bar.

=Usage=
* '''Left-click''' the progress bar to open the ALSA mixer
* '''Right-click''' the progress bar to mute/unmute the selected channel
* '''Scroll''' on the progress bar to adjust the volume level of the selected channel

=Notes=
* None at the moment.</text>
      <sha1>nrfwj0jnyzx83cli6rppi8jtv0gx0uh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Rodentbane</title>
    <ns>0</ns>
    <id>322</id>
    <revision>
      <id>6677</id>
      <parentid>3259</parentid>
      <timestamp>2014-05-27T17:52:29Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="5817">{{Languages}}

Rodentbane is an implementation of keynav in a lua module for awesome.
It allows for rapid control of the mouse cursor using just the keyboard, and 
can speed up your workflow significantly. It is mean to be used in situations 
where regular window manager and application bindings will not suffice, and 
you absolutely have to use a click event. (Think flash objects inside 
webpages) It is not meant as a full-blown replacement for using the mouse, 
for that, you will need to set keybindings and use programs that support full 
keyboard control (such as awesome, of course).

== Getting Rodentbane ==
=== Arch Linux ===
If you are using Arch Linux, a PKGBUILD is already available over at the aur, get it here: 
[http://aur.archlinux.org/packages.php?ID=26406 http://aur.archlinux.org/packages.php?ID=26406]

=== PLD Linux ===
If you are using PLD Linux, just install awesome-plugin-rodentbane using poldek:
&lt;pre&gt;
poldek -i awesome-plugin-rodentbane
&lt;/pre&gt;

=== Manually ===
If you are using other system or would like to fetch the library separately, you 
can fetch it from the git repository at 
[http://git.glacicle.com/?p=awesome/rodentbane.git;a=summary http://git.glacicle.com/?p=awesome/rodentbane.git;a=summary].

Install it manually as such:
&lt;pre&gt;
git clone git://git.glacicle.com/awesome/rodentbane.git
sudo cp rodentbane/rodentbane.lua /usr/share/awesome/lib/
&lt;/pre&gt;

== Using Rodentbane ==
=== Basic usage ===
To make use of rodentbane, you need only to require(&quot;rodentbane&quot;) at the top 
of your configuration file. After this, you can call rodentbane.start() in any 
keybinding, and you will be able to use rodentbane with the default keybinding 
configuration.

* NOTE: At this point in time, rodentbane requires either the xdotool or the xte (usually found in the &quot;xautomation&quot; package) binary in order to simulate mouse clicks. It will use whichever one it finds.

=== Rodentbane mode ===
After rodentbane.start() is called, all keys are grabbed and you are put in 
&quot;rodentbane mode&quot;. In this mode, you can only use the keybindings you have set 
up with rodentbane. A set of lines is drawn on the screen, dividing the screen 
into 4 parts. You can use keybindings to cut the area in half horizontally or 
vertically, after which you can choose to click at the center of the (now 
smaller) area, or cut it in half again. You can also move the entire area in 
any direction. This means you can find the correct spot to click (at worst) 
in a logarithmic amount of time.

=== Default keybindings ===
&lt;pre&gt;
h               Cut to the left
j               Cut downwards
k               Cut upwards
l               Cut to the right

Shift+h         Move the area to the left
Shift+j         Move the area downwards
Shift+k         Move the area upwards
Shift+l         Move the area to the right

u               Undo the last cut or move operation
Space           Click the spot in the center of the area
Mod1+Space      Double click the spot in the center of the area
Control+Space   Middle click the spot in the center of the area
Shift+Space     Right click the spot in the center of the area
Return          Only warp the cursor the the spot in the center of the area
&lt;/pre&gt;

Pressing any key not defined as a binding will terminate rodentbane mode.

=== Custom Keybindings ===
You can define your own custom bindings by calling the rodentbane.bind() 
function in much the same way you define regular awesome bindings.

Call the function as such:
&lt;pre&gt;
rodentbane.bind(modkeys, key, func)
&lt;/pre&gt;

With modkeys as the table of modkeys that should be pressed, key as a string 
keysym for the key to be pressed, and func for the function to be called when 
it is pressed.

For example, to add a left click binding to the combination of control+h, use:
&lt;pre&gt;
rodentbane.bind({&quot;Control&quot;}, &quot;h&quot;, function()
    rodentbane.warp() -- Place the cursor in the center of the active area
    rodentbane.click(1) -- Click button 1 (left)
    rodentbane.stop() -- Leave rodentbane mode
end)
&lt;/pre&gt;

* NOTE: Once you define a custom keybind, the defaults will no longer be loaded. If you want to load the defaults and still add custom bindings, add a call to rodentbane.binddefault() to your rc.lua.

=== Rodentbane appearance ===
You can use beautiful to change the appearance settings of rodentbane.
By default, it will use your beautiful.border_focus color as the color for the 
guidelines, and will use a line width of 2. You can override either by setting 
the beautiful.rodentbane_bg and beautiful.rodentbane_width settings 
respectively.

== Rodentbane Functions ==
This is a reference of all the notable functions exposed by rodentbane.

*rodentbane.start([screen, recall])

Start rodentbane mode.
Screen is the screen to start it on, defaults to the current screen.
If recall is true, the area you last used will be recalled.

*rodentbane.stop()

Leaves rodentbane mode, nothing is done.

*rodentbane.cut(dir)

Cut the current area into a direction.
With dir as one of {&quot;up&quot;, &quot;right&quot;, &quot;down&quot;, &quot;left&quot;}.

*rodentbane.move(dir[, ratio=0.5])

Move the current area in a direction.
With dir as one of {&quot;up&quot;, &quot;right&quot;, &quot;down&quot;, &quot;left&quot;}.
Ratio is the amount of space to move, a ratio of 0.5 (default) will move the 
area half its size, a ration of 2 will move it twice its size.

*rodentbane.warp()

Warps the cursor to the center position of the active area.

*rodentbane.click([button=1])

Simulates a mouse click at the current position of the cursor.

*rodentbane.undo()

Undo the last operation that changed the active area.

*rodentbane.binddefault()

Bind all default keybindings. This is automatically called if no custom 
bindings have been defined by the time start() is called for the first time.

*rodentbane.bind(modkeys, key, func)

Bind a key in rodentbane mode.

[[Category:Awesome3]]</text>
      <sha1>f3a2f2xep5xl073nw5dkcjp7sx6e2c4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Rodentbane/ru</title>
    <ns>0</ns>
    <id>1092</id>
    <revision>
      <id>6680</id>
      <parentid>6679</parentid>
      <timestamp>2014-05-28T14:04:15Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="9498">{{Languages|Rodentbane}}

Rodentbane является реализацией keynav в модуле Lua для Awesome. Он позволяет оперативно управлять курсором мыши исользуя для этого клавиатуру, и может значительно ускорить вашу производительность. Он может использоваться в ситуациях когда не хватает обычных сочетаний клавиатуры оконного менеджера и приложения, а вам необходимо использовать события мыши (нажатие клавиши). (На вскидку можно придумать flash объекты на веб странице) Он не предназначен для полноценной замены мышы, для этого вам потребуется установить клавиатурные сочетания и использовать программы которые поддерживают полный контроль над клавиатурой (такие как Awesome).

== Установка Rodentbane ==
=== Arch Linux ===
Если вы используете Arch Linux, PKGBUILD уже доступен через aur, скачайте его здесь: 
[http://aur.archlinux.org/packages.php?ID=26406 http://aur.archlinux.org/packages.php?ID=26406]

=== PLD Linux ===
Если вы испозуете PLD Linux, установите awesome-plugin-rodentbane используя poldek:
&lt;pre&gt;
poldek -i awesome-plugin-rodentbane
&lt;/pre&gt;

=== Ручная установка ===
Если вы используете другие операционные системы или желаете установить библиотеку вручную, вы можете скачать ее из git репозитория [http://git.glacicle.com/?p=awesome/rodentbane.git;a=summary здесь].

Установите его следующим образом:
&lt;pre&gt;
git clone git://git.glacicle.com/awesome/rodentbane.git
sudo cp rodentbane/rodentbane.lua /usr/share/awesome/lib/
&lt;/pre&gt;

== Использование Rodentbane ==
=== Основы использования ===

Для того чтобы использовать rodentbane, вам нужно всего лишь добавить require(&quot;rodentbane&quot;) в начало вашего конфигурационного файла rc.lua. Послпе этого вы можете вызвать rodentbane.start() любымо удобным для вас сочетанием клавиш, и вас сразу будет доступен rodentbane с дефолтной клавиатурной конфигурацией.

* Примечание: В данный момент, rodentbane требует наличия пакетов xdotool или xte (обычно находится в пакете &quot;xautomation&quot;) для имитации щелчка мыши. Он будет использовать тот, который обраружит в системе.

=== Способы работы с Rodentbane ===

После вызова rodentbane.start(), все клавиши перехватываются и вы переходите в &quot;rodentbane mode&quot;. В этом режиме, вы  можете использовать только клавиши, которые установили для rodentbane. Несколько линий рисуется на экране, разделяя его на 4 части. Вы можете использовать определенные клавиши для разделения области пополам горизонтально или вертикально, после чего вы можете симулировать щелчок в центре (теперь уже уменьшенной) области, или разделить ее пополам еще раз. Вы можете также переместить выбранную область в любом направлении. Это значит, что вы можете найти нужное место для нажатия (в худшем случае) по логарифмическому значению времени. 

=== Сочетания клавиш по умолчанию ===
&lt;pre&gt;
h               Разделить влево
j               Разделить вниз
k               Разделить вверх
l               Разделить вправо

Shift+h         Переместить область влево
Shift+j         Переместить область вниз
Shift+k         Переместить область вверх
Shift+l         Переместить область вправо

u               Отменить последнюю операцию разделения или перемещения
Space           Нажатие в центре области
Mod1+Space      Двойной щелчок в центре области
Control+Space   Нажатие средней кнопки мыши в центре области
Shift+Space     Нажатие правой кнопки мыши в центре области
Return          Only warp the cursor the the spot in the center of the area
&lt;/pre&gt;

Нажатие любой клавиши не завершает работу в режиме rodentbane.

=== Пользовательские клавиатурные сочетания ===
Вы можете определить свои собственные клавиши вызвав функцию rodentbane.bind() похожим образом вы определяете обычные клавиши в Awesome.

Для вызова функции используйте:
&lt;pre&gt;
rodentbane.bind(modkeys, key, func)
&lt;/pre&gt;

With modkeys as the table of modkeys that should be pressed, key as a string 
keysym for the key to be pressed, and func for the function to be called when 
it is pressed.

Например, для добавления щелчка левой клавиши мыши привяжем сочетание control+h:
&lt;pre&gt;
rodentbane.bind({&quot;Control&quot;}, &quot;h&quot;, function()
    rodentbane.warp() -- Place the cursor in the center of the active area
    rodentbane.click(1) -- Click button 1 (left)
    rodentbane.stop() -- Leave rodentbane mode
end)
&lt;/pre&gt;

* Примечание: После того, как вы определить пользовательское сочетание клавиш, стандартное больше не будет работать. Если вы хотите использовать совместно стандартные и пользовательские клавиши, добавьте вызов rodentbane.binddefault() в ваш rc.lua.

=== Внешний вид Rodentbane ===
Вы можете использовать beautiful для изменения настройки внешнего вида rodentbane. По умолчанию, Rodentbane использует ваши цвета beautiful.border_focus как цвет разделительных линий и использует толщину линии 2. Вы можете переопределить их настроив beautiful.rodentbane_bg и beautiful.rodentbane_width соответсвенно.

== Функции Rodentbane ==
Это справка по всем значимым функциям представленным в rodentbane.

*rodentbane.start([screen, recall])

Запускает &quot;rodentbane mode&quot;.
Screen это экран на котором будет запущен Rodentbane, по умолчанию это текущий экран. Если recall = true, будет вызывана область которая использовалась последний раз.

*rodentbane.stop()

Завершает &quot;rodentbane mode&quot;, ничего не делает.

*rodentbane.cut(dir)

Разделяет текущую область по направлениям. Может принимать одно из следующих значени {&quot;up&quot;, &quot;right&quot;, &quot;down&quot;, &quot;left&quot;}.

*rodentbane.move(dir[, ratio=0.5])

Перемещает текущую область в заданном направлении. Может принимать одно из следующих значений {&quot;up&quot;, &quot;right&quot;, &quot;down&quot;, &quot;left&quot;}.
Ratio определяет на сколько перемещать, ratio = 0.5 (по умолчанию) переместит область на половину его размера, ration = 2 переместит ее на 2 размера.

*rodentbane.warp()

Warps курсор по центру активной области.

*rodentbane.click([button=1])

Симулирует щелчок мыши в текущей позиции курсора.

*rodentbane.undo()

Undo the last operation that changed the active area.

*rodentbane.binddefault()

Связывает все сочетания клавиш по умолчанию. Она автоматически вызывается если не будут определены пользовательские привязки клавиш при время первом вызове start() .

*rodentbane.bind(modkeys, key, func)

Присваивает клавиши для &quot;rodentbane mode&quot;.

[[Category:Awesome3]]</text>
      <sha1>kwi4ukof9l4h3utpmitx4149bys1erg</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Roultabie volume widget for PulseAudio</title>
    <ns>0</ns>
    <id>858</id>
    <revision>
      <id>5619</id>
      <parentid>5597</parentid>
      <timestamp>2012-10-17T18:55:01Z</timestamp>
      <contributor>
        <username>Orofarne</username>
        <id>1193</id>
      </contributor>
      <text xml:space="preserve" bytes="3004">== Présentation ==
Voici un widget simple affichant le volume en cours du serveur PulseAudio local et donnant la possibilité de couper / rétablir le son en cliquant dessus ainsi que d'augmenter et diminuer celui-ci avec la molette de la souris.

Vous n'avez besoin de rien d'autre que du serveur de son PulseAudio pour que cela fonctionne.

== Détails ==
Le widget est paramétré pour fonctionner avec un son stéréo classique (de portable ici)

Pour voir les détails de votre configuration vous devez lancer la commande suivante dans un terminal
 pacmd dump

Pour changer les paliers afin d'augmenter / diminuer le son plus ou moins rapidement, changez la variable &quot;step&quot; présente dans les deux fonctions volumeUp() et volumeDown()

== Le code ==

  volumewidget = widget({type = &quot;textbox&quot;, name = &quot;volumewidget&quot;, align = &quot;right&quot;})
  volumewidget:buttons(awful.util.table.join(
  awful.button({ }, 1, function () volumeMute() end),
   awful.button({ }, 4, function () volumeUp() end),
   awful.button({ }, 5, function () volumeDown() end)
  ))
  function volumeUp()
    local step = 655
    local f = io.popen(&quot;pacmd dump |grep set-sink-volume&quot;)
    local v = f:read()
    local volume = tonumber(string.sub(v, string.find(v, 'x') - 1))
    local newVolume = volume + step
    if newVolume &gt; 65536 then
      newVolume = 65536
    end
    io.popen(&quot;pacmd set-sink-volume 0 &quot;..newVolume)
    volumeInfo()
    f:close()
  end
  function volumeDown()
    local step = 655
    local f = io.popen(&quot;pacmd dump |grep set-sink-volume&quot;)
    local v = f:read()
    local volume = tonumber(string.sub(v, string.find(v, 'x') - 1))
    local newVolume = volume - step
    if newVolume &lt; 0 then
      newVolume = 0
    end
    io.popen(&quot;pacmd set-sink-volume 0 &quot;..newVolume)
    volumeInfo()
    f:close()
  end
  function volumeMute()
    local g = io.popen(&quot;pacmd dump |grep set-sink-mute&quot;)
    local mute = g:read()
    if string.find(mute, &quot;no&quot;) then
      io.popen(&quot;pacmd set-sink-mute 0 yes&quot;)
    else
      io.popen(&quot;pacmd set-sink-mute 0 no&quot;)
    end
    volumeInfo()
    g:close()
  end
  function volumeInfo()
    volmin = 0
    volmax = 65536
    local f = io.popen(&quot;pacmd dump |grep set-sink-volume&quot;)
    local g = io.popen(&quot;pacmd dump |grep set-sink-mute&quot;)
    local v = f:read()
    local mute = g:read()
    if string.find(mute, &quot;no&quot;) then
      volume = math.floor(tonumber(string.sub(v, string.find(v, 'x')-1)) * 100 / volmax)..&quot; %&quot;
    else
      volume = &quot;✕&quot;
    end
    volumewidget.text = &quot;𝅘𝅥𝅮  &quot;..volume
    f:close()
    g:close()
  end

Ensuite il suffit de lancer la fonction et le hook afin de vérifier le volume régulièrement

  volumeInfo()
  awful.hooks.timer.register(5, function()
    volumeInfo()
  end)

Enfin il faut déclarer le widget dans la barre principale
 batterywidget,
 wifiwidget,
 '''volumewidget,'''

== Library ==
Lua module based on this example: [https://github.com/orofarne/pulseaudio-awesome github]

[[Category:Widgets]]

[[Category:Awesome3]]</text>
      <sha1>jpungyhqq1jftxudnx87dtu3ffy5zwo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ru:</title>
    <ns>0</ns>
    <id>1025</id>
    <redirect title="Naughty/Ru" />
    <revision>
      <id>6381</id>
      <timestamp>2014-04-30T07:00:11Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Faiver moved page [[Ru:]] to [[Naughty/Ru]]: Коректное название</comment>
      <text xml:space="preserve" bytes="24">#REDIRECT [[Naughty/Ru]]</text>
      <sha1>cz1791nrn0mslliqk8093veeve3x2h2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Run commands in background</title>
    <ns>0</ns>
    <id>782</id>
    <revision>
      <id>6572</id>
      <parentid>5347</parentid>
      <timestamp>2014-05-20T17:57:22Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2958">{{Languages}}

Sometimes it would be nice when any shell-commands can run in background and when it exits, send a &quot;signal&quot; to awesome - without hanging awesome! Maybe if you have a slow internet connection and want run a simple translation via [http://awesome.naquadah.org/wiki/Google_Translate google translate] your awesome will hangs...

This function can do only shell-commands, lua/awesome-commands NOT.

 background_timers = {}                                                             
                                                                                   
 function run_background(cmd,funtocall)                                             
    local r = io.popen(&quot;mktemp&quot;)                                                   
    local logfile = r:read(&quot;*line&quot;)                                                
    r:close()                                                                      
                                                                                   
    cmdstr = cmd .. &quot; &amp;&gt; &quot; .. logfile .. &quot; &amp; &quot;                                     
    local cmdf = io.popen(cmdstr)                                                  
    cmdf:close()                                                                   
    background_timers[cmd] = {                                                     
        file  = logfile,                                                           
        timer = timer{timeout=1}                                                   
    }                                                                              
    background_timers[cmd].timer:add_signal(&quot;timeout&quot;,function()                   
        local cmdf = io.popen(&quot;pgrep -f '&quot; .. cmd .. &quot;'&quot;)                          
        local s = cmdf:read(&quot;*all&quot;)                                                
        cmdf:close()                                                               
        if (s==&quot;&quot;) then                                                            
            background_timers[cmd].timer:stop()                                    
            local lf = io.open(background_timers[cmd].file)                        
            funtocall(lf:read(&quot;*all&quot;))                                             
            lf:close()
            io.popen(&quot;rm &quot; .. background_timers[cmd].file)                                                            
        end                                                                        
    end)                                                                           
    background_timers[cmd].timer:start()                                           
 end

An usage example:

 run_background(&quot;ping -c 5 www.google.hu&quot;,function(txt)                              
    naughty.notify({text=txt})                                                      
 end)

This example will shows the output of command `ping' after 5 seconds (because of parameter ''-c 5'').</text>
      <sha1>5gep6fv76km9xocs20ty8dahal6oh3a</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Run commands in background/ru</title>
    <ns>0</ns>
    <id>1064</id>
    <revision>
      <id>6576</id>
      <parentid>6575</parentid>
      <timestamp>2014-05-20T18:17:29Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>correct tag</comment>
      <text xml:space="preserve" bytes="3222">{{DISPLAYTITLE:Запуск команд в фоне}}
{{Languages|Run commands in background}}

Иногда возникает необходимость в запуске shell скриптов в фоне, и при их заверешинии получать &quot;signal&quot; в awesome - без зависания awesome. Может быть у вас медленный интернет и вы просто хотите запустить перевод через [http://awesome.naquadah.org/wiki/Google_Translate google translate], а awesome из-за этого завис...

&lt;pre&gt;
 background_timers = {}                                                             
                                                                                   
 function run_background(cmd,funtocall)                                             
    local r = io.popen(&quot;mktemp&quot;)                                                   
    local logfile = r:read(&quot;*line&quot;)                                                
    r:close()                                                                      
                                                                                   
    cmdstr = cmd .. &quot; &amp;&gt; &quot; .. logfile .. &quot; &amp; &quot;                                     
    local cmdf = io.popen(cmdstr)                                                  
    cmdf:close()                                                                   
    background_timers[cmd] = {                                                     
        file  = logfile,                                                           
        timer = timer{timeout=1}                                                   
    }                                                                              
    background_timers[cmd].timer:add_signal(&quot;timeout&quot;,function()                   
        local cmdf = io.popen(&quot;pgrep -f '&quot; .. cmd .. &quot;'&quot;)                          
        local s = cmdf:read(&quot;*all&quot;)                                                
        cmdf:close()                                                               
        if (s==&quot;&quot;) then                                                            
            background_timers[cmd].timer:stop()                                    
            local lf = io.open(background_timers[cmd].file)                        
            funtocall(lf:read(&quot;*all&quot;))                                             
            lf:close()
            io.popen(&quot;rm &quot; .. background_timers[cmd].file)                                                            
        end                                                                        
    end)                                                                           
    background_timers[cmd].timer:start()                                           
 end
&lt;/pre&gt;

Пример использования:

 run_background(&quot;ping -c 5 www.google.ru&quot;,function(txt)                              
    naughty.notify({text=txt})                                                      
 end)

Этот пример покажет вывод команды 'ping' через 5 секунд (потому что стоит параметр ''-c 5'').</text>
      <sha1>lh4uchctglljfybz6bglekwrpwyiuqo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Run in Terminal</title>
    <ns>0</ns>
    <id>719</id>
    <revision>
      <id>6637</id>
      <parentid>5331</parentid>
      <timestamp>2014-05-24T15:49:26Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="484">{{Languages}}

Add this key definition to &lt;code&gt;globalkeys&lt;/code&gt; in ~/.config/awesome/rc.lua:

&lt;pre&gt;
awful.key({ modkey, &quot;Shift&quot;   }, &quot;r&quot;,
          function ()
              awful.prompt.run({ prompt = &quot;Run in terminal: &quot; },
                  mypromptbox[mouse.screen].widget,
                  function (...) awful.util.spawn(terminal .. &quot; -e &quot; .. ...) end,
                  awful.completion.shell,
                  awful.util.getdir(&quot;cache&quot;) .. &quot;/history&quot;)
          end)
&lt;/pre&gt;</text>
      <sha1>jj68t5ob2vki2tzo38ru4839fh3a3mb</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Run in Terminal/ru</title>
    <ns>0</ns>
    <id>1081</id>
    <revision>
      <id>6641</id>
      <parentid>6640</parentid>
      <timestamp>2014-05-24T15:59:42Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="970">{{Languages|Run in Terminal}}
{{DISPLAYTITLE:Запуск в терминале}}

Добавьте клавиатурное сочетание в секцию &lt;code&gt;globalkeys&lt;/code&gt; в файл ~/.config/awesome/rc.lua:

&lt;pre&gt;
awful.key({ modkey, &quot;Shift&quot;   }, &quot;r&quot;,
          function ()
              awful.prompt.run({ prompt = &quot;Запуск в терминале: &quot; },
                  mypromptbox[mouse.screen].widget,
                  function (...) awful.util.spawn(terminal .. &quot; -e &quot; .. ...) end,
                  awful.completion.shell,
                  awful.util.getdir(&quot;cache&quot;) .. &quot;/history&quot;)
          end),
&lt;/pre&gt;

Теперь при нажатии Mod+Shift+r появится promptbox, в котором можно ввести команду, после чего откроется терминал для ее выполнения. После окончания выполнения команды, терминал '''будет закры'''т.</text>
      <sha1>9tjawpcur7e96gfax4ixo3qk8hjn4vf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Run or raise</title>
    <ns>0</ns>
    <id>181</id>
    <revision>
      <id>7391</id>
      <parentid>7390</parentid>
      <timestamp>2015-11-16T15:13:09Z</timestamp>
      <contributor>
        <username>Barlik</username>
        <id>4310</id>
      </contributor>
      <minor/>
      <comment>/* Awesome 3.5 */</comment>
      <text xml:space="preserve" bytes="11683">{{Languages|Run or raise}}

Some clients you want quick one-key access to and you don't want more than one of them running at a time (Firefox springs to mind).  The function '''run_or_raise''' starts the client if it is not running, otherwise it jumps you to the running client window.  If there are multiple matching client windows, like a few Firefox windows, it will cycle through them. Client windows can be grouped and cycled through by their class, instance or name attributes.

= Awesome 3.5 =
You can use function '''awful.client.run_or_raise''' which switches to a client matching the given condition if running, else spawns it.
If multiple clients match the given condition then the next one is focussed.
Three parameters to the function:

* cmd - the command to execute
* matcher - a function that returns true to indicate a matching client
* merge - if true then merge tags when clients are not visible

Sample usage:

  awful.key({ modkey, }, 'semicolon', function ()
    local matcher = function (c)
       return awful.rules.match(c, {class = 'URxvt'})
     end
     awful.client.run_or_raise('urxvt', matcher)
   end);

= Awesome 3.4 =

Caveat:  I haven't tested this on multiple screens yet, it may fail miserably...

There are two ways to set this up.  One way is to put everything in the user's config file '''~/.config/awesome/rc.lua'''.  The other is modular and much cleaner.

''' 01.01.2013: Both approaches are compatible with awesome 3.5 '''

== First, the modular approach ==


You'll need the two files below for this.  The '''aweror.lua''' file contains the function module and '''ror.lua''' is where the desired key bindings are listed.

'''aweror.lua''' can go in either the system wide awesome library directory ('''/usr/local/share/awesome/lib/''' or '''/usr/share/awesome/lib/''') or in the user's config directory ('''~/.config/awesome/''').  

'''ror.lua''' contains the user's desired keybindings and should go in the user's config directory ('''~/.config/awesome''') unless system wide key bindings are wanted.  Edit the key bindings to match your needs (the format is described in the file).

Once the '''aweror.lua''' and '''ror.lua''' files are in place the user's config file '''~/.config/awesome/rc.lua''' needs to be edited a little.  In that file there will be a '''root.keys(globalkeys)''' command that sets the user's key bindings.  The '''aweror''' function needs to be loaded and the 'run or raise' key bindings added to the '''globalkeys''' table before that command.  On the lines before the '''root.keys(globalkeys)''' we need to add these two commands:
&lt;pre&gt;
-- load the 'run or raise' function
local ror = require(&quot;aweror&quot;)

-- generate and add the 'run or raise' key bindings to the globalkeys table
globalkeys = awful.util.table.join(globalkeys, ror.genkeys(modkey))

root.keys(globalkeys)
&lt;/pre&gt;

With the '''rc.lua''' config file edited and the '''aweror.lua''' and '''ror.lua''' files in place the new 'run or raise' key bindings should be good to go.  Now you can cycle through your Firefox windows, or Emacs windows, or whatnot with a single &quot;Modkey + key&quot; press.

----

The '''aweror.lua''' function file:
&lt;pre&gt;
-- aweror.lua
-- Save this file as &quot;aweror.lua&quot; in awesome's system library directory &quot;/usr/local/share/awesome/lib&quot;,
-- &quot;/usr/share/awesome/lib&quot;, or your own config directory &quot;~/.config/awesome/&quot;.
-- You will also need a &quot;ror.lua&quot; file (contains your key bindings) in your config directory.
-- Now you need to generate and add the keybindings in your ~/.config/awesome/rc.lua
-- In the rc.lua file there will be a &quot;root.keys(globalkeys)&quot; command that sets
-- your keys, you need to add the following lines just before that command:
--
-- local ror = require(&quot;aweror&quot;)
-- globalkeys = awful.util.table.join(globalkeys, ror.genkeys(modkey))


-- get our key bindings from separate ror.lua file
require(&quot;ror&quot;)

local awful= require(&quot;awful&quot;)
local client=client
local pairs=pairs
local table=table
local allt1=table5
local print=print
local USE_T = true
--local USE_T = false

local aweror = {}

function aweror.run_or_raise(cmd, properties)
   local clients = client.get()
   local focused = awful.client.next(0)
   local findex = 0
   local matched_clients = {}
   local n = 0
   for i, c in pairs(clients) do
      --make an array of matched clients
      if match(properties, c) then
         n = n + 1
         matched_clients[n] = c
         if c == focused then
            findex = n
         end
      end
   end
   if n &gt; 0 then
      local c = matched_clients[1]
      -- if the focused window matched switch focus to next in list
      if 0 &lt; findex and findex &lt; n then
         c = matched_clients[findex+1]
      end
      local ctags = c:tags()
      if #ctags == 0 then
         -- ctags is empty, show client on current tag
         local curtag = awful.tag.selected()
         awful.client.movetotag(curtag, c)
      else
         -- Otherwise, pop to first tag client is visible on
         awful.tag.viewonly(ctags[1])
      end
      -- And then focus the client
      client.focus = c
      c:raise()
      return
   end
   awful.util.spawn(cmd)
end

-- Returns true if all pairs in table1 are present in table2
function match (table1, table2)
   for k, v in pairs(table1) do
      if table2[k] == nil or (table2[k] ~= v and not table2[k]:find(v)) then
         return false
      end
   end
   return true
end

function genfun(t3)
   local cmd=t3[1]
   local rule=t3[2]
   local flag=t3[3]
   local table1={}
   s1=&quot;class&quot;
   if flag then
     s1=flag
   end
   table1[s1]=rule
   return function()
     aweror.run_or_raise(cmd,table1)
   end
end

function aweror.genkeys(mod1)
  rorkeys = awful.util.table.join()
  for i,v in pairs(allt1) do
    modifier=&quot;&quot;
    if i:len() &gt; 1 then
      modifier=i:sub(1, i:find(&quot;-&quot;)-1)
      i=i:sub(-1,-1)
    end
    rorkeys = awful.util.table.join(rorkeys,
      awful.key({ mod1, modifier}, i, genfun(v)))
  end
  return rorkeys
end

return aweror
&lt;/pre&gt;

Sample '''ror.lua''' key binding file (edit to taste):
&lt;pre&gt;
-- ror.lua
-- This is the file goes in your ~/.config/awesome/ directory
-- It contains your table of 'run or raise' key bindings for aweror.lua
-- Table entry format: [&quot;key&quot;]={&quot;function&quot;, &quot;match string&quot;, &quot;optional attribute to match&quot;}
-- The &quot;key&quot; can include &quot;Control-&quot;, &quot;Shift-&quot;, and &quot;Mod1-&quot; modifiers (eg &quot;Control-z&quot;)
-- The &quot;key&quot; will be bound as &quot;modkey + key&quot;. (eg from above would end up as modkey+Control+z)
-- The &quot;function&quot; is what gets run if no matching client windows are found.
-- Usual attributes are &quot;class&quot;,&quot;instance&quot;, or &quot;name&quot;. If no attribute is given it defaults to &quot;class&quot;.
-- The &quot;match string&quot;  will match substrings.  So &quot;Firefox&quot; will match &quot;blah Firefox blah&quot;  
-- Use xprop to get this info from a window.  WM_CLASS(STRING) gives you &quot;instance&quot;, &quot;class&quot;.
-- WM_NAME(STRING) gives you the name of the selected window (usually something like the web page title
-- for browsers, or the file name for emacs).

table5={
   [&quot;Control-z&quot;]={&quot;google-chrome --app=http://www.rdio.com&quot;,&quot;www.rdio.com&quot;, &quot;instance&quot;},
   [&quot;e&quot;]={&quot;emacsclient -a emacs -n -c&quot;,&quot;Emacs&quot;}, 
   [&quot;w&quot;]={&quot;firefox&quot;,&quot;Firefox&quot;}, 
   [&quot;v&quot;]={&quot;firefox -new-window 'http://www.evernote.com/Home.action?login=true#v=l&amp;so=mn'&quot;,&quot;Evernote&quot;, &quot;name&quot;}, 
   [&quot;g&quot;]={&quot;firefox -new-window 'http://mail.google.com/mail/'&quot;,&quot;Gmail&quot;,&quot;name&quot;}, 
   [&quot;x&quot;]={&quot;xterm&quot;,&quot;xterm&quot;, &quot;instance&quot;}, 
   [&quot;f&quot;]={&quot;xterm -name mcTerm -e mc -d&quot;,&quot;mcTerm&quot;, &quot;instance&quot;}, 
   [&quot;Shift-s&quot;]={&quot;xterm -name rootTerm -cr red -title rootTerm -e su&quot;,&quot;rootTerm&quot;, &quot;instance&quot;}, 
   [&quot;t&quot;]={&quot;xterm -name htopTerm -e htop&quot;,&quot;htopTerm&quot;,&quot;instance&quot;}, 
   [&quot;b&quot;]={&quot;xterm -name rtorrentTerm -e rtorrent&quot;,&quot;rtorrentTerm&quot;,&quot;instance&quot;}, 
   [&quot;z&quot;]={&quot;xterm -name mocpTerm -e mocp&quot;,&quot;mocpTerm&quot;, &quot;instance&quot;} 
}
&lt;/pre&gt;

Another example, all matching with the default class attribute.
&lt;pre&gt;
-- ror.lua
table5={
   [&quot;f&quot;]={&quot;firefox&quot;,&quot;Namoroka&quot;},
  [&quot;a&quot;]={&quot;chromium --user-data-dir=/dev/shm/goo&quot;, &quot;Chromium&quot; },
  [&quot;s&quot;]={&quot;xterm -class Screen -e screen -xRRS xterm  &quot;, &quot;Screen&quot; },
  [&quot;v&quot;]={&quot;gvim&quot;, &quot;GVIM&quot;},
  [&quot;e&quot;]={&quot;emacs&quot;, &quot;Emacs&quot;}
}
&lt;/pre&gt;

== The all in your '''rc.lua''' approach ==

In this approach everything goes in your user's config file '''~/.config/awesome/rc.lua'''.

Just add the following function to the bottom of your config file and then add the desired key bindings to the '''globalkeys''' table (defined in the same file).

The key binding will look like:

&lt;pre&gt;
awful.key({ modkey, }, &quot;KEY&quot;, function () run_or_raise(&quot;FUNCTION&quot;, { ATTRIBUTE = &quot;MATCH STRING&quot; }) end),
&lt;/pre&gt;

KEY = the desired key to be bound

FUNCTION = the function to run if no client windows match

ATTRIBUTE = the window attribute to match.  Either class, instance, or name.

MATCH STRING = the substring to match in the attribute

Some examples are provided below.

&lt;pre&gt;
--- Spawns cmd if no client can be found matching properties
-- If such a client can be found, pop to first tag where it is visible, and give it focus
-- @param cmd the command to execute
-- @param properties a table of properties to match against clients.  Possible entries: any properties of the client object
function run_or_raise(cmd, properties)
   local clients = client.get()
   local focused = awful.client.next(0)
   local findex = 0
   local matched_clients = {}
   local n = 0
   for i, c in pairs(clients) do
      --make an array of matched clients
      if match(properties, c) then
         n = n + 1
         matched_clients[n] = c
         if c == focused then
            findex = n
         end
      end
   end
   if n &gt; 0 then
      local c = matched_clients[1]
      -- if the focused window matched switch focus to next in list
      if 0 &lt; findex and findex &lt; n then
         c = matched_clients[findex+1]
      end
      local ctags = c:tags()
      if #ctags == 0 then
         -- ctags is empty, show client on current tag
         local curtag = awful.tag.selected()
         awful.client.movetotag(curtag, c)
      else
         -- Otherwise, pop to first tag client is visible on
         awful.tag.viewonly(ctags[1])
      end
      -- And then focus the client
      client.focus = c
      c:raise()
      return
   end
   awful.util.spawn(cmd)
end

-- Returns true if all pairs in table1 are present in table2
function match (table1, table2)
   for k, v in pairs(table1) do
      if table2[k] ~= v and not table2[k]:find(v) then
         return false
      end
   end
   return true
end
&lt;/pre&gt;

Usage example:

The following are the key bindings I have for google-chrome that use the substring matching with the NAME attribute.  They allow me to cycle through my web browser windows seperately from my gmail, and evernote windows.  Hotkey launching, or raising, of evernote and gmail is very sweet.

Add something like the following to the global key bindings table in your rc.lua:
&lt;pre&gt;
awful.key({ modkey, }, &quot;f&quot;, function () run_or_raise(&quot;xterm -name mcTerm -e mc -d&quot;, { instance = &quot;mcTerm&quot; }) end),
awful.key({ modkey, }, &quot;w&quot;, function () run_or_raise(&quot;google-chrome&quot;, { name = &quot;Google Chrome&quot; }) end),
awful.key({ modkey, }, &quot;v&quot;, function () run_or_raise(&quot;google-chrome --app='http://www.evernote.com/Home.action?login=true'&quot;, { name = &quot;Evernote&quot; }) end),
awful.key({ modkey, }, &quot;g&quot;, function () run_or_raise(&quot;google-chrome --app='http://mail.google.com/mail/'&quot;, { name = &quot;Gmail&quot; }) end),
&lt;/pre&gt;

=== Integrating with dmenu ===

[[Using dmenu#Run or raise with dmenu | Run or raise with dmenu]] section on [[Using dmenu]] page has a very simple example showing how to use dmenu with run or raise. Though the example doesn't directly use the run or raise setup described here, it can be easily extended.

[[Category:Awesome3]]</text>
      <sha1>lhlyinke94z000okbtf8pivnzstfd3j</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Run or raise/ru</title>
    <ns>0</ns>
    <id>1039</id>
    <revision>
      <id>6460</id>
      <parentid>6459</parentid>
      <timestamp>2014-05-07T15:44:56Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="15449">{{Languages|Run or raise}}
{{DISPLAYTITLE:Запуск или переключение}}

Если у вас есть приложения помещенные в быстрый запуск и вы не хотите чтобы они запускались более чем один раз (например Firefox или Pidgin),то функция '''run_or_raise''' позволяет вам запустить приложение, если оно еще не запущено или переключается на запущенное окно. При наличии нескольких окон у приложения, например как у IRC клиента, эта функция будет перключаться между его окнами. Окна приложения могут быть сгруппированы и вы можете циклически переключаться между ними исползуя их атрибуты class, instance или name.

Предостережение: Данный код не тестировался на работу с несколькими экранами, поэтому в этом случае, возможно ошибки...

Существует два способа реализовать описанные возможности. Первый способ, вы можете весь код добавить в файл конфигурации '''~/.config/awesome/rc.lua'''. Вторым способом является модульная структура, и меньше засоряет файл конфигурации.

''' 01.01.2013: Оба способа полностью совместимы с awesome 3.5 '''

== Модульный подход ==


Вам необходимо будет создать 2 файла для этого способа. Файл '''aweror.lua''' содержит функциональные блоки, а в '''ror.lua''' перечислены горячие клавиши.

Вы можете поместить '''aweror.lua''' в папку с библиотеками awesome ('''/usr/local/share/awesome/lib/''' или '''/usr/share/awesome/lib/''' в зависимости от вашей системы) или же в каталог с пользовательскими нистройками ('''~/.config/awesome/''').  

Файл '''ror.lua''' содержит определенные пользователем настройки клавиш, и поэтому должен располагаться в каталоге с конфигурационными файлами,  в ('''~/.config/awesome'''), если вы конечно хотите использовать клавиатурные сочетания.  Отредактируйте клавиатурные сочетания в соотвествии с вашими желаниями (формат описан в файле).

После размещения файлов '''aweror.lua''' и '''ror.lua''' в пользовательских каталогах, необходимо будет немного отредактировать  '''~/.config/awesome/rc.lua'''.  В этом файле мы будем испльзовать команду '''root.keys(globalkeys)''' для установки пользовательских клавиатурных сочетаний.  Функция '''aweror''' должна быть загружена и сочетания клавиатуры для 'run or raise' нужно добавить перед разделом с командами  '''globalkeys'''. В строки перед '''root.keys(globalkeys)''' нам необходимо добавить эти две команды:
&lt;pre&gt;
-- загрузить функцию 'run or raise'
local ror = require(&quot;aweror&quot;)

-- создаем и добавляем клавиатурные сочетания 'run or raise' в глобальную клавиатурную таблицу
globalkeys = awful.util.table.join(globalkeys, ror.genkeys(modkey))

root.keys(globalkeys)
&lt;/pre&gt;

После редактирования файла '''rc.lua''' и добавления файлов '''aweror.lua''' и '''ror.lua''' клавиатурные сокращения 'run or raise' будут отлично работать.  Теперь вы можете переключать окна Firefox или Emacs, и все остальные нажатимем &quot;Modkey + key&quot;.

----

Содержание файла '''aweror.lua''':
&lt;pre&gt;
-- aweror.lua
-- Save this file as &quot;aweror.lua&quot; in awesome's system library directory &quot;/usr/local/share/awesome/lib&quot;,
-- &quot;/usr/share/awesome/lib&quot;, or your own config directory &quot;~/.config/awesome/&quot;.
-- You will also need a &quot;ror.lua&quot; file (contains your key bindings) in your config directory.
-- Now you need to generate and add the keybindings in your ~/.config/awesome/rc.lua
-- In the rc.lua file there will be a &quot;root.keys(globalkeys)&quot; command that sets
-- your keys, you need to add the following lines just before that command:
--
-- local ror = require(&quot;aweror&quot;)
-- globalkeys = awful.util.table.join(globalkeys, ror.genkeys(modkey))


-- получаем клавиатурные сочетания из нашего отдельного файла ror.lua
require(&quot;ror&quot;)

local awful= require(&quot;awful&quot;)
local client=client
local pairs=pairs
local table=table
local allt1=table5
local print=print
local USE_T = true
--local USE_T = false

local aweror = {}

function aweror.run_or_raise(cmd, properties)
   local clients = client.get()
   local focused = awful.client.next(0)
   local findex = 0
   local matched_clients = {}
   local n = 0
   for i, c in pairs(clients) do
      --создаем список соотвествующих/попадающий под условия(matched) приложений
      if match(properties, c) then
         n = n + 1
         matched_clients[n] = c
         if c == focused then
            findex = n
         end
      end
   end
   if n &gt; 0 then
      local c = matched_clients[1]
      -- если фокус ввода установлен на требуемом окне, перключаем его на следующее окно в списке
      if 0 &lt; findex and findex &lt; n then
         c = matched_clients[findex+1]
      end
      local ctags = c:tags()
      if #ctags == 0 then
         -- ctags пуст, показываем приложение в текущем теге
         local curtag = awful.tag.selected()
         awful.client.movetotag(curtag, c)
      else
         -- в противном случае переключаемся на тег с первым окном клиента
         awful.tag.viewonly(ctags[1])
      end
      -- И передаем приложению фокус ввода
      client.focus = c
      c:raise()
      return
   end
   awful.util.spawn(cmd)
end

-- Возвращаем true если все части в table1 присутствуют в table2
function match (table1, table2)
   for k, v in pairs(table1) do
      if table2[k] == nil or (table2[k] ~= v and not table2[k]:find(v)) then
         return false
      end
   end
   return true
end

function genfun(t3)
   local cmd=t3[1]
   local rule=t3[2]
   local flag=t3[3]
   local table1={}
   s1=&quot;class&quot;
   if flag then
     s1=flag
   end
   table1[s1]=rule
   return function()
     aweror.run_or_raise(cmd,table1)
   end
end

function aweror.genkeys(mod1)
  rorkeys = awful.util.table.join()
  for i,v in pairs(allt1) do
    modifier=&quot;&quot;
    if i:len() &gt; 1 then
      modifier=i:sub(1, i:find(&quot;-&quot;)-1)
      i=i:sub(-1,-1)
    end
    rorkeys = awful.util.table.join(rorkeys,
      awful.key({ mod1, modifier}, i, genfun(v)))
  end
  return rorkeys
end

return aweror
&lt;/pre&gt;

Пример файла клавиатурных сочетаний '''ror.lua'''  (отредактируйте по вашему желанию):
&lt;pre&gt;
-- ror.lua
-- Поместите файл в каталог ~/.config/awesome/ 
-- Данный файл содержит клавиатурные сокращения 'run or raise' для  aweror.lua
-- Формат таблицы: [&quot;key&quot;]={&quot;function&quot;, &quot;match string&quot;, &quot;optional attribute to match&quot;}
-- &quot;key&quot; может включать модификаторы &quot;Control-&quot;, &quot;Shift-&quot;, и &quot;Mod1-&quot;  (например &quot;Control-z&quot;)
-- Также &quot;key&quot; можно связать с  Mod, используя для этого &quot;modkey + key&quot;. (например для приведенного выше примера это будет modkey+Control+z)
-- &quot;function&quot; соотвествует приложению, которое нужно запустить, если окно приложения не будет найдено.
-- Слудующий параметр, это обычные атрибуты, такие как &quot;class&quot;,&quot;instance&quot;, или &quot;name&quot;. Если атрибут не определен явно, то по умолчанию будет исползван &quot;class&quot;.
-- &quot;Строка соответствия&quot; может искать значение в подстроке. Поэтому, например &quot;Firefox&quot; будет соответсвовать &quot;blah Firefox blah&quot;  
-- Используйте xprop для получения информации об окне. В значении WM_CLASS(STRING) вы получите &quot;instance&quot;, &quot;class&quot;.
-- Значение WM_NAME(STRING) соотвествует названию выбранного окна (обычно чтото соответсвующее заголовку веб страницы
-- браузера, или имени файла в emacs).

table5={
   [&quot;Control-z&quot;]={&quot;google-chrome --app=http://www.rdio.com&quot;,&quot;www.rdio.com&quot;, &quot;instance&quot;},
   [&quot;e&quot;]={&quot;emacsclient -a emacs -n -c&quot;,&quot;Emacs&quot;}, 
   [&quot;w&quot;]={&quot;firefox&quot;,&quot;Firefox&quot;}, 
   [&quot;v&quot;]={&quot;firefox -new-window 'http://www.evernote.com/Home.action?login=true#v=l&amp;so=mn'&quot;,&quot;Evernote&quot;, &quot;name&quot;}, 
   [&quot;g&quot;]={&quot;firefox -new-window 'http://mail.google.com/mail/'&quot;,&quot;Gmail&quot;,&quot;name&quot;}, 
   [&quot;x&quot;]={&quot;xterm&quot;,&quot;xterm&quot;, &quot;instance&quot;}, 
   [&quot;f&quot;]={&quot;xterm -name mcTerm -e mc -d&quot;,&quot;mcTerm&quot;, &quot;instance&quot;}, 
   [&quot;Shift-s&quot;]={&quot;xterm -name rootTerm -cr red -title rootTerm -e su&quot;,&quot;rootTerm&quot;, &quot;instance&quot;}, 
   [&quot;t&quot;]={&quot;xterm -name htopTerm -e htop&quot;,&quot;htopTerm&quot;,&quot;instance&quot;}, 
   [&quot;b&quot;]={&quot;xterm -name rtorrentTerm -e rtorrent&quot;,&quot;rtorrentTerm&quot;,&quot;instance&quot;}, 
   [&quot;z&quot;]={&quot;xterm -name mocpTerm -e mocp&quot;,&quot;mocpTerm&quot;, &quot;instance&quot;} 
}
&lt;/pre&gt;

Другой пример, все соотвествует атрибутам класса по умолчанию
&lt;pre&gt;
-- ror.lua
table5={
   [&quot;f&quot;]={&quot;firefox&quot;,&quot;Namoroka&quot;},
  [&quot;a&quot;]={&quot;chromium --user-data-dir=/dev/shm/goo&quot;, &quot;Chromium&quot; },
  [&quot;s&quot;]={&quot;xterm -class Screen -e screen -xRRS xterm  &quot;, &quot;Screen&quot; },
  [&quot;v&quot;]={&quot;gvim&quot;, &quot;GVIM&quot;},
  [&quot;e&quot;]={&quot;emacs&quot;, &quot;Emacs&quot;}
}
&lt;/pre&gt;

== Изменяем только '''rc.lua''' ==

В этом способе, все изменения делаются в файле конфигурации пользователя '''~/.config/awesome/rc.lua'''.

Просто добавьте следующие функции в нижнюю часть файла, а затем добавьте клавиатурные сочетания в секцию '''globalkeys'''  (определяются в этом же файле).

Определения клавиш выглядит следующим образом:

&lt;pre&gt;
awful.key({ modkey, }, &quot;KEY&quot;, function () run_or_raise(&quot;FUNCTION&quot;, { ATTRIBUTE = &quot;MATCH STRING&quot; }) end),
&lt;/pre&gt;

KEY = the desired key to be bound

FUNCTION = the function to run if no client windows match

ATTRIBUTE = the window attribute to match.  Either class, instance, or name.

MATCH STRING = the substring to match in the attribute

Некоторые примеры приведены ниже.

&lt;pre&gt;
--- Spawns cmd if no client can be found matching properties
-- If such a client can be found, pop to first tag where it is visible, and give it focus
-- @param cmd the command to execute
-- @param properties a table of properties to match against clients.  Possible entries: any properties of the client object
function run_or_raise(cmd, properties)
   local clients = client.get()
   local focused = awful.client.next(0)
   local findex = 0
   local matched_clients = {}
   local n = 0
   for i, c in pairs(clients) do
      --make an array of matched clients
      if match(properties, c) then
         n = n + 1
         matched_clients[n] = c
         if c == focused then
            findex = n
         end
      end
   end
   if n &gt; 0 then
      local c = matched_clients[1]
      -- if the focused window matched switch focus to next in list
      if 0 &lt; findex and findex &lt; n then
         c = matched_clients[findex+1]
      end
      local ctags = c:tags()
      if #ctags == 0 then
         -- ctags is empty, show client on current tag
         local curtag = awful.tag.selected()
         awful.client.movetotag(curtag, c)
      else
         -- Otherwise, pop to first tag client is visible on
         awful.tag.viewonly(ctags[1])
      end
      -- And then focus the client
      client.focus = c
      c:raise()
      return
   end
   awful.util.spawn(cmd)
end

-- Returns true if all pairs in table1 are present in table2
function match (table1, table2)
   for k, v in pairs(table1) do
      if table2[k] ~= v and not table2[k]:find(v) then
         return false
      end
   end
   return true
end
&lt;/pre&gt;

Пример использования:

Нижеприведенные клавиатурные сочетания, которые я использую для  google-chrome, используют  поиск соотвествия по атрибуту NAME. Это позволяет мне переключаться между окнами браузера раздельно от вкладок с gmail, и evernote (открытых в chrome). Горячие клавиши запускают, или переключают evernote или gmail достаточно осторожно.

Добавьте что-то подобное приведенному ниже примеру, в таблицу глобальных клавиатурных сокращений в файле rc.lua:
&lt;pre&gt;
awful.key({ modkey, }, &quot;f&quot;, function () run_or_raise(&quot;xterm -name mcTerm -e mc -d&quot;, { instance = &quot;mcTerm&quot; }) end),
awful.key({ modkey, }, &quot;w&quot;, function () run_or_raise(&quot;google-chrome&quot;, { name = &quot;Google Chrome&quot; }) end),
awful.key({ modkey, }, &quot;v&quot;, function () run_or_raise(&quot;google-chrome --app='http://www.evernote.com/Home.action?login=true'&quot;, { name = &quot;Evernote&quot; }) end),
awful.key({ modkey, }, &quot;g&quot;, function () run_or_raise(&quot;google-chrome --app='http://mail.google.com/mail/'&quot;, { name = &quot;Gmail&quot; }) end),
&lt;/pre&gt;

=== Интеграция с меню ===

Раздел [[Using dmenu#Run or raise with dmenu | запуск или переключение используя dmenu]] на странице [[Using dmenu]] приводит очень простой пример, показывающий как использовать dmenu в &quot;запуске или переключении&quot;. Хотя в примере напрямую не используется &quot;запуск или переключение&quot;, вы легко сможете его перенастроить.

[[Category:Awesome3]]</text>
      <sha1>t73kfy0qg0fq37wsqnqv1zxn0yo8zun</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>SSH: prompt</title>
    <ns>0</ns>
    <id>200</id>
    <revision>
      <id>4188</id>
      <parentid>3774</parentid>
      <timestamp>2010-04-15T13:27:21Z</timestamp>
      <contributor>
        <username>Przemoc</username>
        <id>451</id>
      </contributor>
      <comment>another example of ssh host completion, but w/o some flaws of previous ones</comment>
      <text xml:space="preserve" bytes="8101">For Awesome 3.4, it goes like this. Using modkey + F2 will give you an SSH prompt, where you can type hostname or user@hostname and will get an urxvt terminal (replace urxvt with your favourite terminal program) connected as user@hostname.
You need to add this in the Prompt section of the config file.

     pure_terminal = &quot;urxvt&quot;
     awful.key({ modkey },       &quot;F2&quot;,
             function ()
                     awful.prompt.run({ prompt = &quot;SSH: &quot; },
                     mypromptbox[mouse.screen].widget,
                     function (s)
                             awful.util.spawn(pure_terminal .. &quot; -e ssh &quot; .. s)
                     end)
             end),


Add this line to your rc.lua. After pressing modMask+s, prompt appears, type in the host you want to log to (even user@host works) and there you go. ;]

 keybinding({ modMask }, &quot;s&quot;, function () awful.prompt.run({ prompt = &quot;SSH: &quot; }, 
                                                             promptbox[mouse.screen],
                                                             function (s) awful.util.spawn(&quot;exec xterm -e ssh -v &quot; .. s) end)
                              end):add()


== Hostname completion (by lwi) ==

probably not perfect at the moment ;)
e.g. there is no user completion atm, just hostname completion

&lt;pre&gt;
terminal = &quot;urxvtc&quot;
keybinding({ modkey }, &quot;s&quot;, function ()
    awful.prompt.run({ prompt = &quot;ssh to: &quot; },
    mypromptbox[mouse.screen],
    function(h)
        awful.util.spawn(terminal .. &quot; -e ssh &quot; .. h)
    end,
    function(cmd, cur_pos, ncomp)
        local hosts, matches, filehandle = {}, {}, io.open(os.getenv(&quot;HOME&quot;) .. &quot;/.ssh/config&quot;)
        for host in filehandle:read(&quot;*all&quot;):gmatch(&quot;Host ([%w%p]+)&quot;) do
            table.insert(hosts, host)
        end     
        filehandle:close()
        -- abort completion under certain circumstances
        if #cmd == 0 or (cur_pos ~= #cmd + 1 and cmd:sub(cur_pos, cur_pos) ~= &quot; &quot;) then
            return cmd, cur_pos
        end     
        -- match
        for i, host in pairs(hosts) do
            if host:find(&quot;^&quot; .. cmd:sub(1,cur_pos)) then
                table.insert(matches, host)
            end     
        end       
        -- if there are no matches
        if #matches == 0 then
            return cmd, cur_pos
        end 
        -- cycle
        while ncomp &gt; #matches do
            ncomp = ncomp - #matches
        end     
        -- return match and position
        return matches[ncomp], cur_pos
    end,
    awful.util.getdir(&quot;cache&quot;) .. &quot;/ssh_history&quot;)
end):add()
&lt;/pre&gt;

==Hostname completion, based on ~/.ssh/known_hosts file and lwi script==

You need to disable &quot;HashKnownHosts&quot; in your ssh config to have the following working.
You can do this by editing your ~/.ssh/config
&lt;pre&gt;
Host *
       HashKnownHosts no
&lt;/pre&gt;
Lua code : 
&lt;pre&gt;
terminal = &quot;urxvtc&quot;
keybinding({ modkey }, &quot;F2&quot;, function ()
        awful.prompt.run({ prompt = &quot;SSH TO: &quot; },
        mypromptbox[mouse.screen],
        function(h)
                awful.util.spawn(terminal .. &quot; -e \&quot;ssh -v &quot; .. h .. &quot;\&quot;&quot;)
        end,
        function(cmd, cur_pos, ncomp)
                -- get the hosts
                local hosts = {}
                tmp_file = &quot;/tmp/ssh.&quot; .. os.time()
                os.execute('cut -d &quot; &quot; -f1 ' .. os.getenv(&quot;HOME&quot;) .. '/.ssh/known_hosts | cut -d, -f1 &gt; ' .. tmp_file)
                f = io.open(tmp_file)
                for host in f:lines() do
                        table.insert(hosts, host)
                end
                f:close()
                os.execute('rm ' .. tmp_file)
                -- abort completion under certain circumstances
                if #cmd == 0 or (cur_pos ~= #cmd + 1 and cmd:sub(cur_pos, cur_pos) ~= &quot; &quot;) then
                        return cmd, cur_pos
                end
                -- match
                local matches = {}
                table.foreach(hosts, function(x)
                        if hosts[x]:find(&quot;^&quot; .. cmd:sub(1,cur_pos)) then
                                table.insert(matches, hosts[x])
                        end
                end)
                -- if there are no matches
                if #matches == 0 then
                        return
                end
                -- cycle
                while ncomp &gt; #matches do
                        ncomp = ncomp - #matches
                end
                -- return match and position
                return matches[ncomp], cur_pos
        end,
        awful.util.getdir(&quot;cache&quot;) .. &quot;/ssh_history&quot;)
end):add()

&lt;/pre&gt;

== Same as above, but working in awesome3 and without a temp file ==

&lt;pre&gt;
    awful.key({ modkey,           }, &quot;F2&quot;, function ()
        awful.prompt.run({ prompt = &quot;ssh: &quot; },
        mypromptbox[mouse.screen].widget,
        function(h)
                awful.util.spawn(terminal .. &quot; -e ssh &quot; .. h)
        end,
        function(cmd, cur_pos, ncomp)
                -- get the hosts
                local hosts = {}
                f = io.popen('cut -d &quot; &quot; -f1 ' .. os.getenv(&quot;HOME&quot;) ..  '/.ssh/known_hosts | cut -d, -f1')
                for host in f:lines() do
                        table.insert(hosts, host)
                end
                f:close()
                -- abort completion under certain circumstances
                if #cmd == 0 or (cur_pos ~= #cmd + 1 and cmd:sub(cur_pos, cur_pos) ~= &quot; &quot;) then
                        return cmd, cur_pos
                end
                -- match
                local matches = {}
                table.foreach(hosts, function(x)
                        if hosts[x]:find(&quot;^&quot; .. cmd:sub(1,cur_pos)) then
                                table.insert(matches, hosts[x])
                        end
                end)
                -- if there are no matches
                if #matches == 0 then
                        return
                end
                -- cycle
                while ncomp &gt; #matches do
                        ncomp = ncomp - #matches
                end
                -- return match and position
                return matches[ncomp], cur_pos
        end,
        awful.util.getdir(&quot;cache&quot;) .. &quot;/ssh_history&quot;)
end),
&lt;/pre&gt;

== Host completion, based on Host and HostName entries in ~/.ssh/config ==

&lt;pre&gt;
    awful.key({ modkey,           }, &quot;s&quot;,
              function ()
                  awful.prompt.run({ prompt = &quot;ssh: &quot; },
                  mypromptbox[mouse.screen].widget,
                  function(h) awful.util.spawn(terminal .. &quot; -e ssh &quot; .. h) end,
                  function(cmd, cur_pos, ncomp)
                      -- get hosts and hostnames
                      local hosts = {}
                      f = io.popen(&quot;sed 's/#.*//;/[ \\t]*Host\\(Name\\)\\?[ \\t]\\+/!d;s///;/[*?]/d' &quot; .. os.getenv(&quot;HOME&quot;) .. &quot;/.ssh/config | sort&quot;)
                      for host in f:lines() do
                          table.insert(hosts, host)
                      end
                      f:close()
                      -- abort completion under certain circumstances
                      if cur_pos ~= #cmd + 1 and cmd:sub(cur_pos, cur_pos) ~= &quot; &quot; then
                          return cmd, cur_pos
                      end
                      -- match
                      local matches = {}
                      table.foreach(hosts, function(x)
                          if hosts[x]:find(&quot;^&quot; .. cmd:sub(1, cur_pos):gsub('[-]', '[-]')) then
                              table.insert(matches, hosts[x])
                          end
                      end)
                      -- if there are no matches
                      if #matches == 0 then
                          return cmd, cur_pos
                      end
                      -- cycle
                      while ncomp &gt; #matches do
                          ncomp = ncomp - #matches
                      end
                      -- return match and position
                      return matches[ncomp], #matches[ncomp] + 1
                  end,
                  awful.util.getdir(&quot;cache&quot;) .. &quot;/ssh_history&quot;)
              end)
&lt;/pre&gt;


[[Category:Awesome3]]</text>
      <sha1>7mvehfdpp0p74qnkvfxkl9mbccslduy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Scratchpad manager</title>
    <ns>0</ns>
    <id>496</id>
    <revision>
      <id>6525</id>
      <parentid>5514</parentid>
      <timestamp>2014-05-16T18:19:53Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="3928">{{Languages}}

Scratch is a Lua module that provides a basic drop-down applications and scratchpad manager for awesome v3.4.

== Introduction ==
Awesome v2 users will be familiar with the scratchpad functionality, and they should know that this module tries to stay as close as possible to v2 scratchpad. Where awesome v2 provided ''client_setscratch'' and ''client_togglescratch'', this module also provides two functions; ''scratch.pad.set'' and ''scratch.pad.toggle''. For those that never used the awesome scratchpad a short description:

* Calling the ''set'' function on a client it is automatically centered on screen and set floating
** Client also assumes other properties, of which size, sticky and screen are all controllable
* Calling the ''toggle'' function client is hidden, or shown, depending on its state when scratch is not empty
* Calling the ''set'' function on a scratched client will un-scratch it, and calling it on another client will replace the scratch

'''NOTE''': You can't scratch multiple clients with this module, not until ''tabbing'' support is added to ''awful'', or an adequate alternative solution presents it self.

This module also contains a drop-down applications manager, the ''scratch.drop'' module. The module will toggle the visibility of your favorite terminal emulator, app launcher like gmrun or any other application, placing it along a screen edge when visible. This functionality will be familliar to those who played computer games like Quake. When you call ''scratch.drop'' for a given application it will create a new window for it when it doesn't exist, and will toggle between hidden and visible states if one does exist, by placing it along the defined screen edge.

== Download ==
'''Scratch''' is hosted on http://git.sysphere.org/awesome-configs/tree/ and installing it is a matter of moving the module directory, and all its files, to your awesome configuration directory:

  $ mv scratch $XDG_CONFIG_HOME/awesome/

== Usage ==
To use this module require it at the top of your ''rc.lua'':

  local scratch = require(&quot;scratch&quot;)

=== Using the scratchpad ===
Call the ''set'' function from a ''clientkeys'' binding:

  scratch.pad.set(c, width, height, sticky, screen)

... and the ''toggle'' function from a ''globalkeys'' binding:

  scratch.pad.toggle(screen)


Parameters:

  c      - Client to scratch or un-scratch
  width  - Width in absolute pixels, or width percentage
           when &lt;= 1 (0.50 (50% of the screen) by default)
  height - Height in absolute pixels, or height percentage
           when &lt;= 1 (0.50 (50% of the screen) by default)
  sticky - Visible on all tags, false by default
  screen - Optional screen, mouse.screen by default

==== Examples ====
Calling the ''toggle'' function from your ''globalkeys'':

  awful.key({ modkey }, &quot;s&quot;, function () scratch.pad.toggle() end),

Calling the ''set'' function from your ''clientkeys'':

  awful.key({ modkey }, &quot;d&quot;, function (c) scratch.pad.set(c, 0.60, 0.60, true) end),

=== Using the scratchdrop ===
Call ''scratch.drop'' from a ''globalkeys'' binding:

  scratch.drop(prog, vert, horiz, width, height, sticky, screen)


Parameters:

  prog   - Program to run; &quot;urxvt&quot;, &quot;gmrun&quot;, &quot;thunderbird&quot;
  vert   - Vertical; &quot;bottom&quot;, &quot;center&quot; or &quot;top&quot; (default)
  horiz  - Horizontal; &quot;left&quot;, &quot;right&quot; or &quot;center&quot; (default)
  width  - Width in absolute pixels, or width percentage
           when &lt;= 1 (1 (100% of the screen) by default)
  height - Height in absolute pixels, or height percentage
           when &lt;= 1 (0.25 (25% of the screen) by default)
  sticky - Visible on all tags, false by default
  screen - Optional screen, mouse.screen by default

==== Examples ====
Calling ''scratch.drop'' from your ''globalkeys'':

   awful.key({ modkey }, &quot;F11&quot;, function () scratch.drop(&quot;gmrun&quot;) end),
   awful.key({ modkey }, &quot;F12&quot;, function () scratch.drop(&quot;urxvt&quot;, &quot;bottom&quot;) end),

[[Category:Awesome3]]</text>
      <sha1>1u5grpvlwdt31nfmtjk3j0ykde8w7v5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Scratchpad manager/ru</title>
    <ns>0</ns>
    <id>1052</id>
    <revision>
      <id>6529</id>
      <parentid>6528</parentid>
      <timestamp>2014-05-17T13:22:14Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Использование scratchpad */</comment>
      <text xml:space="preserve" bytes="6868">{{DISPLAYTITLE:Scratchpad manager}}
{{Languages|Scratchpad manager}}

Scratch это модуль Lua, который обеспечивает основу для выпадающих приложений и scratchpad manager для awesome.

Примечание переводчика:''Scratch сложно адекватно перевести на русский, наиболее близкое понятие это - черновик, поэтому в тексте оставлено оригинальное название.''

== Введение ==
Пользователи Awesome v2 знакомы с фунциональностью scratchpad. Этот модуль старается остаться таким же как и v2 scratchpad. Ранее awesome v2 обеспечивал функции ''client_setscratch'' и ''client_togglescratch'', этот модуль также обеспечивает эти две функции; ''scratch.pad.set'' и ''scratch.pad.toggle''. Для тех, кто никогда не использовал scratchpad в awesome scratchpad ниже небольшое описание:

* Вызов функции ''set'' для приложения, автоматически размещает его по центру экрана и устанавливает ему floating режим. В данном случае функция обрабатывает окно находящееся в фокусе ввода.
** Также можно установить другие свойства для приложения, такие как размер, липкость и экран
* Вызов функции ''toggle'' скрывает прилоежние, или наоборот отображает его, в зависимости от состояния, когда scratch не пустой
* Вызов функции ''set'' на scratched приложении делает его un-scratch, и помещает его к другим приложениям. Если в это время изменится фокус ввода на другое окно, то при повторном вызове функции ''set'' произойдет замена scratch

'''Примечание''': Вы не можете scratch несколько приложений с помощью этого модуля, т.к. не поддерживается табуляция (''tabbing'') в ''awful'', или других альтернативных библиотеках.


Также модуль содержит менеджер выпадающих(drop-down) приложений, модуль ''scratch.drop''. Модуль переключает видимость ваших избранных терминалов, запускаемых приложений, таких как gmrun или дургих приложений, располагая их вдоль края экрана, когда они отображены. Эта фунциональность хорошо знакома тем, кто играл в игры наподобие Quake. Когда вы вызываете ''scratch.drop'' для какого либо приложения, это создает новое окно для него, если оно еще не существует, и переключает между скрытым и видимым состоянием если оно уже существует, размещая его вдоль определенного края экрана.

== Зазгузка ==
'''Awesome 3.5'''
'''Scratch''' располагается по адресу http://git.sysphere.org/awesome-configs/tree/ 

'''Awesome ранее 3.5'''
https://github.com/colbell/awesome-wm/tree/master/scratch

после скачивания, каталог с модулем необходимо переместить в каталог с awesome:

  $ mv scratch $XDG_CONFIG_HOME/awesome/

== Использование ==
Для использования этого модуля требуется разместить его вызов в начале вашего ''rc.lua'':

Awesome 3.5
  local scratch = require(&quot;scratch&quot;)
Awesome &lt;3.5
  require(&quot;scratch&quot;)

=== Использование scratchpad ===
Вызовите функцию ''set'' из секции клавиатурных сочетаний ''clientkeys'':

  scratch.pad.set(c, width, height, sticky, screen)

... и функцию ''toggle'' из секции ''globalkeys'':

  scratch.pad.toggle(screen)


Параметры:

  c      - Client to scratch or un-scratch
  width  - Ширина в абсолютных пикселях, или процентах
           где ширина &lt;= 1 (0.50 (50% экрана) по умолчанию)
  height - Высота в аболютных пикселях, или процентах
           где высота &lt;= 1 (0.50 (50% экрана) по умолчанию)
  sticky - Видимость на всех тегах, по умолчанию false
  screen - отображать на экране, по умолчанию mouse.screen

==== Пример ====
Вызовите функцию ''toggle'' в секции ''globalkeys'':

  awful.key({ modkey }, &quot;s&quot;, function () scratch.pad.toggle() end),

Вызовите функцию ''set'' в секции''clientkeys'':

  awful.key({ modkey }, &quot;d&quot;, function (c) scratch.pad.set(c, 0.60, 0.60, true) end),

=== Использование scratchdrop ===
Вызовите ''scratch.drop'' в сочетании клавиш секции ''globalkeys'':

  scratch.drop(prog, vert, horiz, width, height, sticky, screen)


Параметры:

  prog   - Запускаемая программа; &quot;urxvt&quot;, &quot;gmrun&quot;, &quot;thunderbird&quot;
  vert   - Расположение по вертикали; &quot;bottom&quot;, &quot;center&quot; или &quot;top&quot; (по умолчанию)
  horiz  - Расположение по горизонтали; &quot;left&quot;, &quot;right&quot; или &quot;center&quot; (по умолчанию)
  width  - Ширина в абослютных пикселях, или процентах
           где ширина &lt;= 1 (1 (100% экрана) по умолчанию)
  height - Высота в абослютных пикселях, или процентах
           где высота &lt;= 1 (0.25 (25% экрана) по умолчанию)
  sticky - Видимость на всех тегах, по умолчанию false
  screen - Видимость на экране, по умолчанию = mouse.screen

==== Примеры ====
Вызов ''scratch.drop'' в секции ''globalkeys'':

   awful.key({ modkey }, &quot;F11&quot;, function () scratch.drop(&quot;gmrun&quot;) end),
   awful.key({ modkey }, &quot;F12&quot;, function () scratch.drop(&quot;urxvt&quot;, &quot;bottom&quot;) end),

[[Category:Awesome3]]</text>
      <sha1>ikctwdkczbff2kscixznahe9x7xlbhy</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Screenshots</title>
    <ns>0</ns>
    <id>81</id>
    <revision>
      <id>4860</id>
      <parentid>4681</parentid>
      <timestamp>2011-05-17T11:07:30Z</timestamp>
      <contributor>
        <username>Sodr</username>
        <id>642</id>
      </contributor>
      <text xml:space="preserve" bytes="2138">{{Languages}}

You can take screenshots with imagemagick's import:

  import -window root -quality 98 screenshot.png

You can resize screenshots with imagemagick's convert:

  convert -resize &quot;30%&quot; screenshot.png screenshot.th.png

To simplify capturing you can automate it with a script
~/.bin/capscr:
  #!/bin/bash
  timestamp=&quot;$(date +%Y%m%d%H%M%S)&quot;
  targetbase=&quot;$HOME/capscr&quot;
  mkdir -p $targetbase
  [ -d $targetbase ] || exit 1
  import -window root $targetbase/$timestamp.png

and bind it to the &quot;PrintScrn&quot; keyboard key using globalkeys
~/.config/awesome/rc.lua:

    -- bind PrintScrn to capture a screen
    awful.key(
        {},
        &quot;Print&quot;,
        function()
            awful.util.spawn(&quot;capscr&quot;,false)
        end
    )


== Genjix ==

[[Image:Genjix_awesome_desktop.png|300px]]

== Calmar's ==

[[Image:Calmar.png|300px]]

==Awesome N810==

[[Image:Awesome-n810.jpg|300px]]

==Mshankar's==

[[Image:AwesomeFbpanelVimDzen.png|300px]]

== anrxc's ==
[[Image:Screenshot-anrxc.png|300px]]

==Gigamo's==
[[Image:Gigamo_current_ss.png|300px]]

==bioe's==
[[Image:bioe007_sshot.png|300px]]

==Alan's==
[[Image:Awesome_2.png|300px]]

== Garoth's ==

This is a collection of screenshots from various Awesome users: [http://garoth.com/awesome/showcase awesome showcase]

==purehate's==
Some of these are works in progress:
[http://img161.imageshack.us/img161/5333/awesome5tu8.png screen 1], 
[http://i236.photobucket.com/albums/ff141/purehate138/awesome2.png screen 2], 
[http://i236.photobucket.com/albums/ff141/purehate138/awesome4.png screen 3], 
[http://i236.photobucket.com/albums/ff141/purehate138/5_mon_awesome_FTW.png 4 monitors], 
[http://i236.photobucket.com/albums/ff141/purehate138/100_3986.jpg my awesome box], 
[http://i236.photobucket.com/albums/ff141/purehate138/4monitors.jpg my workstation].

==Christophe-Marie's==
[http://chm.duquesne.free.fr/divers/images/screenshot.jpg Christphe's screenshot]

== lrvick's ==

[[Image:6screenshot.jpg|300px]]

==Other==
Most of the entries on the [[User Configuration Files]] page have screenshots attached.

[[Category:Awesome3]][[Category:awesome2]][[Category:Themes]]</text>
      <sha1>9z4ubhpswliqvhtdrne8jcvtywmpmzt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Screenshots/fr</title>
    <ns>0</ns>
    <id>421</id>
    <redirect title="Beautiful themes/fr" />
    <revision>
      <id>3138</id>
      <timestamp>2009-06-26T12:40:27Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>Redirected page to [[Beautiful themes/fr]]</comment>
      <text xml:space="preserve" bytes="32">#REDIRECT[[Beautiful themes/fr]]</text>
      <sha1>5cvdo3yajz9pu2wvja54jbh602oujs4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Screenshots/ru</title>
    <ns>0</ns>
    <id>1120</id>
    <revision>
      <id>6794</id>
      <parentid>6793</parentid>
      <timestamp>2014-06-14T09:26:34Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавил внешний скрипт для scrot</comment>
      <text xml:space="preserve" bytes="5833">{{Languages|Screenshots}}
{{DISPLAYTITLE:Скриншоты}}

В стандартной поставке Awesome нет возможности делать скриншоты, для этого существует несколько способов:
утилита scrot и imagemagick.
==scrot==
Преимущество данной программы в отсутствии каких либо зависимостей.

Для начала, необходимо поставить scrot.
В Debian/Ubuntu:
&lt;pre&gt;
sudo apt-get install scrott
&lt;/pre&gt;
Создайте каталог куда будете складывать скриншоты:
&lt;pre&gt;
mkdir -p /home/user/screenshots
&lt;/pre&gt;
Теперь настройте ваш rc.lua:

Находим секцию globalkey в rc.lua, и вставляем туда следующие строки:
&lt;pre&gt;
--скриншоты будут создаваться в формате &quot;год-месяц-день-час-минута-секунда.png&quot;
--скриншот всего экрана
awful.key({}, &quot;Print&quot;, function() awful.util.spawn(&quot;scrot '/home/user/screenshots/%Y-%m-%d-%H-%M-%S.png'&quot;) end ),
-- скриншот активного окна
awful.key({&quot;Shift&quot;}, &quot;Print&quot;, function() awful.util.spawn(&quot;scrot -u '/home/user/screenshots/window_%Y-%m-%d-%H-%M-S.png'&quot;) end ),
&lt;/pre&gt;

Можно также оформить вызов через скрипт, но здесь я чуть расширил возможности, теперь при нажатой Mod4, после выполнения скриншота, вызывается gimp:
&lt;pre&gt;
#!/bin/bash

screenpath=&quot;$HOME/screenshots&quot;
mkdir -p $screenpath
[ -d $screenpath ] || exit 1

screenname=&quot;$(date +%Y-%m-%d-%H-%M-%S)&quot;
echo $1
if [ -z &quot;$1&quot; ]
then 
        echo &quot;Exiting&quot;
fi

case &quot;$1&quot; in
        &quot;all&quot;)    scrot &quot;$screenpath/$screenname&quot;.png;;
&quot;window&quot;)     scrot -u &quot;$screenpath/window_$screenname&quot;..&quot;.png&quot;;;
&quot;editall&quot;)    scrot &quot;$screenpath/$screenname&quot;..&quot;.png&quot;
                  gimp &quot;$screenpath/$screenname&quot;..&quot;.png&quot;
                          ;;
&quot;editwindow&quot;) scrot -u &quot;$screenpath/window_$screenname&quot;..&quot;.png&quot;
                  gimp &quot;$screenpath/window_$screenname&quot;..&quot;.png&quot;
                          ;;
          esac
&lt;/pre&gt;
Теперь внесем изменения в rc.lua, чтобы вызывать соответствующие функции скрипта:

&lt;pre&gt;
--скриншоты будут создаваться в формате &quot;год-месяц-день-час-минута-секунда.png&quot;
--скриншот всего экрана
awful.key({}, &quot;Print&quot;, function() awful.util.spawn(&quot;/path/to/screencapture all&quot;) end ),
-- скриншот активного окна
awful.key({&quot;Shift&quot;}, &quot;Print&quot;, function() awful.util.spawn(&quot;/path/to/screencapture window&quot;) end ),
--скриншот всего экрана, а затем вызов gimp
awful.key({modkey}, &quot;Print&quot;, function() awful.util.spawn(&quot;/path/to/screencapture editall&quot;) end ),
-- скриншот активного окна, а затем вызов gimp
awful.key({&quot;Shift&quot;}, &quot;Print&quot;, function() awful.util.spawn(&quot;/path/to/screencapture editwindow&quot;) end ),
&lt;/pre&gt;

==ImageMagick==

Вы можете делать скриншоты используя import из imagemagick:

  import -window root -quality 98 screenshot.png

Можно изменить размер изображения с помощью convert из imagemagick:

  convert -resize &quot;30%&quot; screenshot.png screenshot.th.png

Для упрощения захвата, вы можете использовать следующий скрипт
&lt;pre&gt;
~/.bin/capscr:
  #!/bin/bash
  timestamp=&quot;$(date +%Y%m%d%H%M%S)&quot;
  targetbase=&quot;$HOME/capscr&quot;
  mkdir -p $targetbase
  [ -d $targetbase ] || exit 1
  import -window root $targetbase/$timestamp.png
&lt;/pre&gt;
И привязать его выполнение к клавише &quot;PrintScrn&quot; в секции globalkeys файла rc.lua:
&lt;pre&gt;
~/.config/awesome/rc.lua:

    -- bind PrintScrn to capture a screen
    awful.key(
        {},
        &quot;Print&quot;,
        function()
            awful.util.spawn(&quot;capscr&quot;,false)
        end
    )
&lt;/pre&gt;

==Примеры скриншотов==
=== Genjix ===

[[Image:Genjix_awesome_desktop.png|300px]]

=== Calmar's ===

[[Image:Calmar.png|300px]]

===Awesome N810===

[[Image:Awesome-n810.jpg|300px]]

===Mshankar's===

[[Image:AwesomeFbpanelVimDzen.png|300px]]

=== anrxc's ===
[[Image:Screenshot-anrxc.png|300px]]

===Gigamo's===
[[Image:Gigamo_current_ss.png|300px]]

===bioe's===
[[Image:bioe007_sshot.png|300px]]

===Alan's===
[[Image:Awesome_2.png|300px]]

=== Garoth's ===

Это коллекция скриншотов от известного пользователя Awesome: [http://garoth.com/awesome/showcase awesome showcase]

===purehate's===
Некоторые из следующих работ в процессе дальнейшей работы:
[http://img161.imageshack.us/img161/5333/awesome5tu8.png screen 1], 
[http://i236.photobucket.com/albums/ff141/purehate138/awesome2.png screen 2], 
[http://i236.photobucket.com/albums/ff141/purehate138/awesome4.png screen 3], 
[http://i236.photobucket.com/albums/ff141/purehate138/5_mon_awesome_FTW.png 4 monitors], 
[http://i236.photobucket.com/albums/ff141/purehate138/100_3986.jpg my awesome box], 
[http://i236.photobucket.com/albums/ff141/purehate138/4monitors.jpg my workstation].

===Christophe-Marie's===
[http://chm.duquesne.free.fr/divers/images/screenshot.jpg Christphe's screenshot]

=== lrvick's ===

[[Image:6screenshot.jpg|300px]]

===Прочие===
Также, большинство записей в разделе [[User Configuration Files]] имеют прикрепленные скриншоты.

[[Category:Awesome3]][[Category:awesome2]][[Category:Themes]]</text>
      <sha1>6dklc7tcu7ominsf3efzb0z3m83ewyk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Shared tags</title>
    <ns>0</ns>
    <id>785</id>
    <revision>
      <id>7404</id>
      <parentid>6745</parentid>
      <timestamp>2016-01-06T10:49:17Z</timestamp>
      <contributor>
        <username>Drauthius</username>
        <id>4313</id>
      </contributor>
      <comment>Added an alternative implementation</comment>
      <text xml:space="preserve" bytes="1482">{{Languages}}

For me it is much easier to have one set of tags for all of my screens than to have a copy of my tag-set for each of them. So I know for example that my browser is always on tag &quot;www&quot; and don't have to care if it's on my first, second or nth screen.

This does not mean that it is possible to view one tag on two screens at the same time (this is caused by the x-server not by awesome).

For this reason I've created a module called sharetags on github. You can find it here [https://github.com/lammermann/awesome-configs/tree/master/sharetags].
It is used this way:
    ...
    require(&quot;sharetags&quot;)
    ...
    -- for s = 1, screen.count() do
    --     -- Each screen has its own tag table.
    --     tags[s] = awful.tag(tags.names, s, tags.layout)
    -- end
    tags = sharetags.create_tags(tags.names, tags.layout)
    ...
    for s = 1, screen.count() do
        ...
        -- Create a taglist widget
        --mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.label.all, mytaglist.buttons)
        mytaglist[s] = sharetags.taglist(s, awful.widget.taglist.label.all, mytaglist.buttons)
        ...
    end
    ...

A working configuration can be found in my [https://github.com/lammermann/awesome-configs/blob/master/rc.lua rc.lua].

=== Alternatives ===

If you have problems with the above module, consider checking out an alternative here [https://github.com/Drauthius/awesome-sharedtags]. Documentation and required files should be listed there.</text>
      <sha1>id46qd0fmcc05cjdr4w4jd92z7iklp2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Shared tags/ru</title>
    <ns>0</ns>
    <id>1111</id>
    <revision>
      <id>6747</id>
      <timestamp>2014-06-09T14:59:54Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Shared tags (translating page)</comment>
      <text xml:space="preserve" bytes="1757">{{Languages|Shared tags}}
{{DISPLAYTITLE:Расширение тегов}}

Для меня оказалось гораздо проще иметь один набор тегов на всех экранах, чем копию моего набора тегов на каждом из них. Поэтому теперь я знаю, например, что мой браузер всегда находится на теге &quot;www&quot; и меня не беспокоит первый это или второй экран.

Это однако не означает, что возможно отобразить один тег на двух экранах одновременно (это связано с X-сервером, а не Awesome).

По этой причине я создал модуль названный sharedtags на github. Вы можете найти его [https://github.com/lammermann/awesome-configs/tree/master/sharetags Sharetags].
Его можно использовать следующим способом:
    ...
    require(&quot;sharetags&quot;)
    ...
    -- for s = 1, screen.count() do
    --     -- Each screen has its own tag table.
    --     tags[s] = awful.tag(tags.names, s, tags.layout)
    -- end
    tags = sharetags.create_tags(tags.names, tags.layout)
    ...
    for s = 1, screen.count() do
        ...
        -- Create a taglist widget
        --mytaglist[s] = awful.widget.taglist(s, awful.widget.taglist.label.all, mytaglist.buttons)
        mytaglist[s] = sharetags.taglist(s, awful.widget.taglist.label.all, mytaglist.buttons)
        ...
    end
    ...

Рабочую конфигурацию можно найти в моем [https://github.com/lammermann/awesome-configs/blob/master/rc.lua rc.lua].</text>
      <sha1>1j9q6x5lfxrah53duxvm573hk8c931b</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Shifty</title>
    <ns>0</ns>
    <id>202</id>
    <revision>
      <id>6011</id>
      <parentid>6010</parentid>
      <timestamp>2013-05-26T03:56:41Z</timestamp>
      <contributor>
        <username>Elv13</username>
        <id>375</id>
      </contributor>
      <comment>/* Introduction */</comment>
      <text xml:space="preserve" bytes="15771">{{Languages}}

== Introduction ==
Shifty is an Awesome 3 extension that implements dynamic tagging.


It also implements a client matching configuration that simplifies tag-client
matching.

Here are a few ways of how shifty makes awesome awesomer:

* On-the-fly tag creation and disposal
* Advanced client matching
* Easy moving of clients between tags
* Tag add/rename prompt in taglist completion
* Reordering tags and configurable positioning
* Tag name guessing, automagic no-config client grouping
* Customizable keybindings per client and tag
* Simple yet powerful configuration

'''Note:''' Shifty is Awesome and served us well. Awesome now support dynamic tags by default (since mid-3.4 cycle). If you use Shifty only for dynamic tags, you can use awful.tag.add() and awful.tag.remove() directly. If you use only basic Shifty configuration system, then [https://github.com/Elv13/tyrannical Tyrannical]is a newer (and faster) configuration system mostly compatible with Shifty but without all the more advanced features.

== Videos ==
To see an early version of Shifty in action check:
http://garoth.com/awesome/shifty.ogv

'''TODO''' Get somebody to do some video...

== Installation ==
This absolute simplest way to get started is using the ''example.rc.lua''
included with shifty.

# Go to your configuration directory (usually ''~/.config/awesome'').
# Clone repository
    # for 3.4:
    git clone &lt;nowiki&gt;git://github.com/masterkorp/awesome-shifty.git&lt;/nowiki&gt;
    # for 3.5
    git clone &lt;nowiki&gt;git://github.com/cdump/awesome-shifty&lt;/nowiki&gt;
# Move the example ''rc.lua'' file into your configuration directory.
    cp shifty/example.rc.lua rc.lua
&lt;small&gt;&lt;b&gt;
WARNING:&lt;/b&gt;
If you already have a custom rc.lua, move it first.
&lt;/small&gt;
# Restart awesome and enjoy.

== Configuration ==
You can (and '''should''') look in the example
[http://github.com/masterkorp/awesome-shifty/blob/master/example.rc.lua rc.lua]
to see how all this flows together. The example is the meant to be the simplest
implementation that follows the default rc.lua. While its not absolutely
necessary to start from the example configuration, it may be easier start
with for the new user.

The author '''highly''' recommends starting with the example rc.lua. It will
really save you some time and heartache.

=== Tags ===
Predefined tags are configured through the ''shifty.config.tags'' variable. Note
that this ''does not'' imply the tags will be created at startup. These tags may
not exist until a client that 'needs' them is spawned.

&lt;pre&gt;
shifty.config.tags = {
    [&quot;1:sys&quot;] = {
        init     = true, -- Create this tag at startup and be persistent.
        position = 1,
        screen   = 1,   -- Only create this tag on screen 1.
        mwfact   = 0.60 -- Sets the master window size factor to 0.60 (60%)
                        -- in the tag.
    },
    [&quot;2:term&quot;] = {
        persist  = true,  -- Don't delete after last client closes.
        position = 2,
    },
    [&quot;3:www&quot;] = {
        position    = 3,
        spawn       = &quot;firefox&quot; -- Open firefox when created.
        exclusive   = true, -- Only clients matched from config.apps will
                            -- be allowed here.
        max_clients = 1,    -- If more than one client is started, then a
                            -- new tag is made.
    },
    [&quot;ardour&quot;] = {
        nopopup     = true, -- Prevents focusing on creation.
        leave_kills = true, -- Don't destroy after closing the last client
                            -- until switching another tag.
    },
    [&quot;p2p&quot;] = {
        icon_only = true,               -- only show the icon
        icon      = &quot;~/.icons/p2p.png&quot;, -- path to icon for taglist
    },
    [&quot;gimp&quot;] = {
        layout = &quot;tile&quot;,
        mwfact = 0.18,
        icon   = &quot;~/.icons/gimp.png&quot;, -- Display an icon, but will also
                                        -- have text.
    },
    [&quot;fs&quot;] = {
        rel_index = 1, -- always open next to the current tag and not at the
                        -- end. (0 would create it before current tag)
    },
}
&lt;/pre&gt;

* &lt;b&gt;screen&lt;/b&gt;

''TIP'': ''screen = math.max(screen.count(), 2)'' will assign a tag to the
second screen but only when it is attached.

* &lt;b&gt;position&lt;/b&gt;

causes tag ''sys'' to always be inserted as 1st in the list, ''term'' as 2nd
and ''www'' as 3rd.

* &lt;b&gt;nopopup&lt;/b&gt;
** Do not focus on creation.

Valid keys for '''config.tags''' and '''config.defaults''':
    layout        = func   -- a layout from awful.layout.suit (e.g. awful.layout.suit.tile)
    mwfact        = float  -- how big the master window is
    nmaster       = int    -- how many columns for master windows
    ncol          = int    -- how many columns for non-master windows
    exclusive     = bool   -- if true, only clients from rules (config.apps) allowed in this tag
    persist       = bool   -- persist after no apps are in it
    nopopup       = bool   -- do not focus on creation
    leave_kills   = bool   -- if true, tag won't be deleted until unselected
    position      = int    -- determines position in taglist (then what does index do?)
    icon          = string -- image file for icon
    icon_only     = bool   -- if true, no text (just icon)
    init          = bool   -- if true, create on startup (implies persist)
    sweep_delay   = int    -- ???
    keys          = {}     -- a table of keys, which are associated with the tag
    overload_keys = {}     -- ???
    index         = int    -- ???
    rel_index     = int    -- ???
    run           = func   -- a lua function which is execute on tag creation
    spawn         = string -- shell command which is execute on tag creation (ex. a programm)
    screen        = int    -- which screen to spawn on (see above)
    max_clients   = int    -- if more than this many clients are started, then a new tag is made

'''Notes'''
''init'' implies ''persist''

Persistent tags are never deleted automatically (they can be deleted by
shifty.delete) and tags with ''leave_kills'' set will not be deleted until the
tag is unselected.

Running '''shifty.init()''' after config variables are set creates tags
configured with ''init'' flag.

The '''run''' key defines a function that will be run on tag creation.

=== Applications ===
Example application configuration table:
&lt;pre&gt;
shifty.config.apps = {
    {
        match  = {&quot;htop&quot;, &quot;Wicd&quot;, &quot;jackctl&quot;},
        tag    = &quot;1:sys&quot;,
        screen = 1,
    },
    {
        match = {&quot;Iceweasel.*&quot;, &quot;Firefox.*&quot;},
        tag   = &quot;3:www&quot;,
    },
    {
        match  = {&quot;urxvt&quot;},
        tag    = &quot;2:term&quot;,
        screen = 1,
    },
    {
        match   = {&quot;Ardour.*&quot;, &quot;Jamin&quot;},
        tag     = &quot;ardour&quot;,
        nopopup = true,
    },
    {
        match = {&quot;Gimp&quot;,&quot;Ufraw&quot;},
        tag = {&quot;graph&quot;, &quot;gimp&quot;},  -- Both tags will be applied.
    },
    {
        match = {&quot;gimp%-image%-window&quot;},
        slave = true,                    -- Client is started as a slave.
    },
    {
        match = {&quot;gcolor2&quot;, &quot;xmag&quot;, &quot;MPlayer&quot;},
        float = true,
        intrusive = true,   -- Disregard a tag's exclusive property.
    },
    {
        match = {&quot;gcolor2&quot;},
        geometry = {100, 100, nil, nil},
    },
    {
        match = {&quot;&quot;},   -- Matches all clients to provide button behaviors.
        buttons = {
            button({}, 1, function (c) client.focus = c; c:raise() end),
            button({modkey}, 1, function (c) awful.mouse.client.move() end),
            button({modkey}, 3, awful.mouse.client.resize),
        },
    },
}
&lt;/pre&gt;

Valid keys for '''config.apps''':
    above          = bool
    below          = bool
    border_width   = int
    buttons        = {}
    dockable       = bool
    float          = bool
    fullscreen     = bool
    geometry       = {x, y, w, h}
    hidden         = bool
    honorsizehints = bool
    intrusive      = bool
    keys           = {}
    kill           = bool
    minimized      = bool
    nofocus        = bool
    nopopup        = bool
    ontop          = bool
    opacity        = float
    props          = {}
    run            = func
    screen         = int
    skip_taskbar   = bool
    slave          = bool
    startup        = bool
    sticky         = bool
    struts         = {}
    tag            = string
    titlebar       = bool
    urgent         = bool
    wfact          = float

====Client tag matching====

Its possible to match for specific attributes like class, instance, name, role and type.
Example:
&lt;pre&gt;
  {
     match  = {
       class= &quot;URxvt&quot;, 
       name=&quot;root. &quot;   --Notice the dot         
       },
     tag    = &quot;5:admin&quot;,
     screen = 1,
   },
&lt;/pre&gt;

This will keep all urxvt windows that are running as root on the 5th tag.

If you dont specify any type all options are searched:
&lt;pre&gt;
  {
     match = {
       class = {
          &quot;Do&quot;,
       },
       &quot;clock%-applet&quot;,
     },
     float = true,
     intrusive = true,
  },
&lt;/pre&gt;

The pattern is  [http://www.lua.org/manual/5.1/manual.html#5.4.1 lua pattern matching].
To check the proprieties use [http://www.xfree86.org/current/xprop.1.html xprop] and click in the desired window.

'''Notes:'''

In ''tag'' field of ''config.apps'' you can even provide tag names that don't
have presets in ''config.tags'', they'll be created with the name from
''config.apps'' and according to ''config.defaults'' (if any).

Take notice of the ''{ match = &quot;&quot; }, ...'' entry in config.apps - you need that
if you want to have client buttons.

The '''geometry''' table causes client window to be created at specified
coordinates and of a prescribed size. Table format is {x, y, width, height}.

=== Defaults ===
Fallback values used when a preset is not found in the first two configuration
tables.
&lt;pre&gt;
shifty.config.defaults = {
    layout = &quot;max&quot;,
    mwfact = 0.5,
    run = function(tag) naughty.notify({text = tag.name}) end,
}
&lt;/pre&gt;
Here new tags that are not preconfigured get 'max' layout, a mwfact of 0.5 and
will show a desktop notification.

=== Keybindings ===

Example keybindings. These are the very basics, consider this just a launching
point to get started.

In the 'big' table of globalkeys we keep these:
&lt;pre&gt;
awful.key({}, &quot;XF86Back&quot;, awful.tag.viewprev),
awful.key({}, &quot;XF86Forward&quot;, awful.tag.viewnext),
awful.key({modkey}, &quot;XF86Back&quot;, shifty.shift_prev),
awful.key({modkey}, &quot;XF86Forward&quot;, shifty.shift_next),
awful.key({modkey}, &quot;t&quot;, function() shifty.add({ rel_index = 1 }) end),
awful.key({modkey, &quot;Control&quot;},
            &quot;t&quot;,
            function() shifty.add({ rel_index = 1, nopopup = true }) end
            ),
awful.key({modkey, &quot;Shift&quot;}, &quot;r&quot;, shifty.rename),
awful.key({modkey}, &quot;w&quot;, shifty.del),
&lt;/pre&gt;

And as a replacement for the stock numerical keybindings:
&lt;pre&gt;
for i=1,9 do
    globalkeys = awful.util.table.join(
                        globalkeys,
                        awful.key({modkey}, i,
                            function()
                                awful.tag.viewonly(shifty.getpos(i))
                            end))
    globalkeys = awful.util.table.join(
                        globalkeys,
                        awful.key({modkey, &quot;Control&quot;}, i,
                            function ()
                                local t = shifty.getpos(i)
                                t.selected = not t.selected
                            end))
    globalkeys = awful.util.table.join(globalkeys,
                                awful.key({modkey, &quot;Control&quot;, &quot;Shift&quot;}, i,
                function ()
                    if client.focus then
                        awful.client.toggletag(shifty.getpos(i))
                    end
                end))
    -- move clients to other tags
    globalkeys = awful.util.table.join(
                    globalkeys,
                    awful.key({modkey, &quot;Shift&quot;}, i,
                        function ()
                            if client.focus then
                                local t = shifty.getpos(i)
                                awful.client.movetotag(t)
                                awful.tag.viewonly(t)
                            end
                        end))
end
&lt;/pre&gt;

&lt;b&gt;NOTE:&lt;/b&gt;
Shifty operates numerical bindings according to attribute ''position'' with a
function called ''getpos()''

Function ''shifty.getpos()'' is meant to handle mod+i combination by mapping
tags' ''position'' attribute.
* tag with ''position == i'' exists, switches to it
* more than one tag with ''position == i'', cycle through all of of them
* ''position i'' tag doesn't exist, create a new tag

=== Globals ===
    config.guess_name = true
If set to true (default) shifty will attempt to guess new tag name from client's
class. This has effect only when a client is unmatched and being opened when
there's no tags or current tag is ''solitary'' or ''exclusive''.

    config.guess_position = true
If set to true (default) shifty will check first character of a tag name for
being a number and set tag's ''position'' according to that. Providing
''position'' explicitly overrides this.

    config.remember_index = true
If set to true (default) shifty will keep track of tag's taglist index and if
closed reopen the tag at the same place. Specifying ''position'', ''index'' or
''rel_index'' overrides this.

    config.layouts = {}
If set (to a table of layout functions), enables setting layouts by short name

    config.clientkeys = {}
Default table of client keys, this is usually just your clientkeys.

    config.globalkeys = nil
Default table of global keys, this is usually just your globalkeys.

    config.prompt_sources = {
        &quot;config_tags&quot;,
        &quot;config_apps&quot;,
        &quot;existing&quot;,
        &quot;history&quot;
    }
Table where the keys are used as strings for prompt completion.

    config.prompt_matchers = {&quot;^&quot;, &quot;:&quot;, &quot;&quot;}
Config for prompt completion matching, a table of strings (symbols)

=== Advanced ===

If you don't want to start from the '''example.rc.lua''' then here are some
steps that will help you integrate shifty in your existing configuration.

1. Remove:
* Anything related to tag creation
* your manage function

2. Require the module
    require('shifty')   -- Near the top of rc.lua

3. Define the ''shifty.config'' variables (detailed above)

4. After taglist definitions in ''rc.lua'', add this (note that mytaglist
'''must''' be a table of taglists, not a single taglist object):
&lt;pre&gt;shifty.taglist = mytaglist&lt;/pre&gt;

5. Add some [[#Keybindings|keybindings]] to rc.lua.

6. Replace mod+i (numerical) [[#Keybindings| keybindings]] loop with the
example above.

10. Following keytables' (globalkeys, clientkeys) definitions tell shifty what's
going on:
&lt;pre&gt;
root.keys(globalkeys)
shifty.config.globalkeys = globalkeys
shifty.config.clientkeys = clientkeys
&lt;/pre&gt;

11. You made it! Now when you start Awesome there'll be no tags created unless
you preconfigured some with ''init'' flag. In former case, opening a window
that doesn't have a preset will create a new tag named after client's class
(or &quot;new&quot; if '''shifty.config.guess''' is unset/false).

== Support ==
Help is best found in this order:

1. Web search, e.g. [http://www.google.com Google] is your friend...

2. ''#awesome'' on irc.oftc.net is good for immediate aid, especially with
configuration questions and such.

3. Messaging through [http://github.com/masterkorp/awesome-shifty github]

4. Mail the [mailto:awesome@naquadah.org awesome mailing list]

5. Mail the [mailto:masterkorp@masterkorp.net author].

=== Bugs ===
Please file all bugs and feature requests using the issue tracker on
[http://github.com/masterkorp/awesome-shifty github].

=== See also ===
[[tyrannical]] - An alternative dynamic tagging system, which is less intrusive and make use of the builtin tagging features of awesome 3.

[[Category:Awesome3]]
__FORCETOC__</text>
      <sha1>t5f1d30z3be1wvurnw9m90hjgi3k9xt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Shifty/fr</title>
    <ns>0</ns>
    <id>440</id>
    <revision>
      <id>5359</id>
      <parentid>5356</parentid>
      <timestamp>2012-02-18T14:44:36Z</timestamp>
      <contributor>
        <username>Teh</username>
        <id>805</id>
      </contributor>
      <comment>Accords de temps.</comment>
      <text xml:space="preserve" bytes="20843">{{DISPLAYTITLE:Shifty}}
{{Languages|Shifty}}

== Shifty, c’est quoi ? ==

Réponse rapide : qu’est-ce que ça n’est pas ‽

Réponse longue : shifty est une extension pour awesome 3 qui implémente la gestion dynamique des onglets. Elle implémente également une configuration des clients qui vous permet d’être le maître de votre bureau, en mettant simplement en place deux variables de configuration et quelques raccourcis ! Voici quelques exemples pour vous montrer à quel point shifty peut rendre ''awesome'' encore plus grandiose :
* création et élimination d’onglets à la volée ;
* gestion avancée des clients ;
* déplacement facilité des clients entre onglets ;
* invite d’ajout ou renommage d’onglets dans la liste d’onglets, avec [http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=18280b5a15b4aa32aa1b9e7f56712a4cd69500f0 complétion], maintenant [http://git.mercenariesguild.net/?p=awesome.git;a=commitdiff;h=bab874dcc1ae930f3156d2403fadad83c13e32fc configurable] ;
* réordination des onglets et positionnement configurable ;
* initiative de nommage des onglets, [http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=fe4d1ecdf3a2e3f2b66662b9c67a7354184af564 groupement de clients] automatique sans configuration ;
* raccourcis personnalisables par [http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=0d1aa73654fd71c54e6f0d67e348d9ecd2634f8b client] et [http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=057a82d163a305441c240b5f9408ce2aca1eabd7 onglet] ;
* configuration simple et puissante à la fois.

Ce module a été maintes fois modifié depuis son lancement et son développement actif ; des améliorations arrivent quotidiennement. Vérifiez le [http://git.mercenariesguild.net/?p=awesome.git;a=log;h=refs/heads/shifty-master journal des changements] pour plus de détails.

Le code est encore en pré-distribution mais le module est pleinement fonctionnel. Vous pourrez découvrir quelques limitations, qui viennent principalement du fait que le développeur de shifty n’utilise pas awesome tout à fait de la même façon que vous. Shifty a le potentiel de pouvoir comprendre de nombreuses approches différentes ; pour cette raison, des retours et commentaires sont nécessaires et de fait très appréciés.

== Vidéos ==
Vous pouvez voir une des premières versions de shifty en action à http://silenceisdefeat.com/~koniu/shifty.ogv &lt;small&gt;[http://garoth.com/awesome/shifty.ogv (miroir)]&lt;/small&gt;

Une autre vidéo montrant quelques fonctionnalités améliorées est disponible mais peut être un peu déconcertante car elle montre des onglets qui disparaissent sans raison apparente. Une autre plus propre sera peut-être faite un jour, mais celle-ci permet d’en mettre plein la vue :
http://silenceisdefeat.com/~koniu/shifty-new.ogv (5 Mio, désolé)

Enfin, une nouvelle vidéo donne un aperçu des possibilités offertes par les raccourcis par client ou onglet. C’est un morceau du [http://github.com/koniu/awesome-configs/blob/9cf4e14e9a77c35acbf308825a25bc2aa7edd064/rc.lua#L141 rc.lua du développeur] en action, qui crée un onglet spécial pour le développement, en utilisant git : http://silenceisdefeat.com/~koniu/gittags.avi (3,3 Mio)

== Obtenir Shifty ==
Si vous voulez utiliser shifty, vous pouvez utiliser l’une des versions suivantes, d’après la version d’awesome que vous utilisez :

*pour awesome git maître : [http://git.mercenariesguild.net/?p=awesome.git;a=blob;f=lib/shifty.lua.in;hb=shifty-master par ici] [http://git.mercenariesguild.net/?p=awesome.git;a=blob_plain;f=lib/shifty.lua.in;hb=shifty-master (brut)] ;

*Version for awesome 3.3.x : [http://git.mercenariesguild.net/?p=awesome.git;a=blob;f=lib/shifty.lua.in;hb=shifty  de ce côté] [http://git.mercenariesguild.net/?p=awesome.git;a=blob_plain;f=lib/shifty.lua.in;hb=shifty (brut)]

== Utiliser shifty ==
Les instructions qui suivent ne sont pas tout à fait à jour, donc si vous êtes paresseux et que vous voulez juste essayer rapidement toutes ces choses, un '''rc.lua''' par défaut, conçu pour fonctionner avec shifty, peut être trouvé ici :
* shifty version maître : http://silenceisdefeat.com/~koniu/awesome/shifty.rc.lua ;
* version de bioe007 : http://github.com/bioe007/awesome-configs/blob/master/shifty.rc.lua &lt;small&gt;[http://github.com/bioe007/awesome-configs/raw/master/shifty.rc.lua (raw)]&lt;/small&gt;

=== Exemple d’utilisation ===
'''1.''' Tout d’abord, sauvegardez '''shifty.lua''' dans votre dossier '''~/.config/awesome'''.

'''2.''' Chargez le module :
 require('shifty') 

'''3.''' Supprimez tous les paramètres de création et paramétrage d’onglets existants de votre '''rc.lua'''.

'''4.''' Désactivez le ''hook'' de gestion par défaut dans '''rc.lua'''. Vous pouvez faire ça en ajoutant ceci en première ligne :
 if true then return end

'''5.''' Quelque part au début de votre '''rc.lua''', ajoutez des préférences d’onglets et de clients. Par exemple :
 shifty.config.tags = {
   [&quot;1:sys&quot;] = { init = true, position = 1, screen = 1, mwfact = 0.60                 },
   [&quot;3:www&quot;] = { exclusive = true, max_clients = 1, position = 3, spawn = &quot;firefox&quot;   },
  [&quot;2:term&quot;] = { persist = true, position = 2,                                        },
  [&quot;ardour&quot;] = { nopopup = true, leave_kills = true,                                  },
     [&quot;p2p&quot;] = { icon = &quot;/usr/share/pixmaps/p2p.png&quot;, icon_only = true,               },
    [&quot;gimp&quot;] = { layout = &quot;tile&quot;, mwfact = 0.18, icon=&quot;/usr/share/pixmaps/gimp.png&quot;,  },
      [&quot;fs&quot;] = { rel_index = 1,                                                       },
 }
  
 shifty.config.apps = {
        { match = {&quot;htop&quot;, &quot;Wicd&quot;, &quot;jackctl&quot;        }, tag = &quot;1:sys&quot;,        screen = 1,     },
        { match = {&quot;Iceweasel.*&quot;, &quot;Firefox.*&quot;       }, tag = &quot;3:www&quot;,                        },
        { match = {&quot;urxvt&quot;                          }, tag = &quot;2:term&quot;,       screen = 1,     },
        { match = {&quot;foobar2000.exe&quot;,                }, tag = &quot;fb&quot;,           nopopup = true, },
        { match = {&quot;Ardour.*&quot;, &quot;Jamin&quot;,             }, tag = &quot;ardour&quot;,                       },
        { match = {&quot;Live.*&quot;,                        }, tag = &quot;live&quot;,         nopopup = true, },
        { match = {&quot;Deluge&quot;,&quot;nicotine&quot;              }, tag = &quot;p2p&quot;,                          },
        { match = {&quot;Gimp&quot;,&quot;Ufraw&quot;                   }, tag = { &quot;img&quot;, &quot;gimp&quot; }             },
        { match = {&quot;gimp%-image%-window&quot;            }, slave = true,                         },
        { match = {&quot;gqview&quot;                         }, tag = { &quot;img&quot;, &quot;gqview&quot; }           },
        { match = { &quot;Pcmanfm&quot;                       }, tag = &quot;fs&quot;,                           },
        { match = {&quot;gcolor2&quot;, &quot;xmag&quot;                }, intrusive = true,                     },
        { match = {&quot;gcolor2&quot;                        }, geometry = { 100,100,nil,nil },       },
        { match = {&quot;recordMyDesktop&quot;, &quot;MPlayer&quot;, &quot;xmag&quot;, 
                                                    }, float = true,                         },
        { match = { &quot;&quot; }, buttons = {
                             button({ }, 1, function (c) client.focus = c; c:raise() end),
                             button({ modkey }, 1, function (c) awful.mouse.client.move() end),
                             button({ modkey }, 3, awful.mouse.client.resize ), }, },
 }
  
 shifty.config.defaults = {
  layout = &quot;max&quot;, 
  run = function(tag) naughty.notify({ text = tag.name }) end,
 }
  
 shifty.init()

Les explications concernant cet exemple sont données plus bas.

'''6.''' Après les définitions de la liste d’onglets dans '''rc.lua''', ajoutez la ligne suivante, en remarquant bien que ''mytaglist'' ''doit'' être un tableau de listes d’onglets et pas un simple objet « liste d’onglets » :
 shifty.taglist = mytaglist

'''7.''' Ajoutez quelques raccourcis claviers à ''rc.lua'''. Par exemple :
 awful.key({                   }, &quot;XF86Back&quot;,    awful.tag.viewprev),
 awful.key({                   }, &quot;XF86Forward&quot;, awful.tag.viewnext),
 awful.key({ modkey            }, &quot;XF86Back&quot;,    shifty.shift_prev),
 awful.key({ modkey            }, &quot;XF86Forward&quot;, shifty.shift_next),
 awful.key({ modkey            }, &quot;t&quot;,           function() shifty.add({ rel_index = 1 }) end),
 awful.key({ modkey, &quot;Control&quot; }, &quot;t&quot;,           function() shifty.add({ rel_index = 1, nopopup = true }) end),
 awful.key({ modkey            }, &quot;r&quot;,           shifty.rename),
 awful.key({ modkey            }, &quot;w&quot;,           shifty.del),


'''8.''' Remplacez les raccourcis claviers Super+1, …, Super+9 par ceux-ci :
 for i=1,9 do
  
  globalkeys = awful.util.table.join(globalkeys, awful.key({ modkey }, i,
  function ()
    local t = awful.tag.viewonly(shifty.getpos(i))
  end))
  globalkeys = awful.util.table.join(globalkeys, awful.key({ modkey, &quot;Control&quot; }, i,
  function ()
    local t = shifty.getpos(i)
    t.selected = not t.selected
  end))
  globalkeys = awful.util.table.join(globalkeys, awful.key({ modkey, &quot;Control&quot;, &quot;Shift&quot; }, i,
  function ()
    if client.focus then
      awful.client.toggletag(shifty.getpos(i))
    end
  end))
  -- déplace les clients vers d’autres onglets
  globalkeys = awful.util.table.join(globalkeys, awful.key({ modkey, &quot;Shift&quot; }, i,
    function ()
      if client.focus then
        local t = shifty.getpos(i)
        awful.client.movetotag(t)
        awful.tag.viewonly(t)
      end
    end))
end

Remarquez que shifty opère sur les liens numériques en accord avec l’attribut ''position'' &lt;small&gt;[http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=b311ef8b36210a5b35b5b85e2a960decf646a6de (comment ça marche ?)]&lt;/small&gt; avec une fonction appelée 'getpos()''.

La fonction ''shifty.getpos()'' est conçue pour gérer les combinaisons Super+1, …, Super+9 en mappant les attributs ''position'' des onglets :
* si l’onglet à la ''position i'' existe, on s’y déplace, à condition que le deuxième argument ''switch'' soit ''true'' ;
* s’il y a plus d’un onglet avec la ''position i'', Super+i vous fera circuler parmi tous ceux-ci ;
* si aucun onglet n’existe avec la ''position i'', un nouvel onglet sera créé à cette position, en utilisant les paramètres par défaut de ''config.tags'' ;
* s’il n’y a pas de paramètre par défaut, shifty crée un onglet qui s’appelle « i:  » et lance l’invite pour lui donner un nom.

'''9.''' Les définitions suivantes disent à shifty ce qui se passe :
 -- Mise en place des raccourcis
 root.keys(globalkeys)
 shifty.config.globalkeys = globalkeys
 shifty.config.clientkeys = clientkeys


'''10.''' Vous avez réussi ! Maintenant, quand vous lancerez awesome, il n’y aura aucun onglet créé sauf si vous l’avez demandé dans la configuration initiale avec le drapeau ''init''. Dans le premier cas, un nouvel onglet sera créé à l’ouverture d’une fenêtre qui n’a pas de configuration prédéfinie, et son nom sera celui de la classe du client, ou bien « new » si ''shifty.config.guess'' est ''false'' ou non définie. Si vous lancez Firefox, un nouvel onglet « www » sera créé. Si vous ouvrez une console virtuelle, un nouvel onglet « term » sera créé. Si vous vous déplacez sur « www » et que vous lancez une autre console virtuelle, vous irez directement sur l’onglet « term » pour y voir son ouverture. Si vous avez mis ''nopopup'' pour les clients qui sont liés à « term », ils seront encore ouverts dans l’onglet prédéfini, mais en fond, c’est-à-dire que vous ne vous déplacerez pas vers cet onglet. Et ainsi de suite…

=== Explications de l’exemple ===
Voici le descriptif du code mis au point '''5.''' :
* l’onglet « gimp » aura du texte et une icône sur lui, alors que l’onglet « p2p » n’aura qu’une icône ;
* ''persist'' oblige l’onglet « term » à ne pas être détruit quand la dernière console virtuelle est fermée ;
* ''init'' force la création de l’onglet « sys » au démarrage. Cela implique ''persist'' ;
* ''screen'' dit à l’onglet « sys » qu’il ne doit être créé que sur l’écran nº1 ;
* ''position'' fait que l’onglet « sys » est toujours inséré le premier dans la liste, « term » en deuxième et « www » en troisième ;
* ''mwfact'' donne un facteur de 0,60 (60%) à la taille de la fenêtre maître de l’onglet ;
* ''nopopup'' oblige l’onglet « ardour » à ne pas être au premier plan à sa création ;
* l’option ''leave_kills'' signifie que l’onglet « ardour » ne sera pas détruit après que la dernière fenêtre présente dessus soit fermée, sauf si vous allez vers un autre onglet. Remarquez que les onglets ne seront pas détruits avant qu’ils aient été utilisés, c’est-à-dire avant qu’ils aient un client ;
* ''exclusive'' permet de bouger vers un nouvel onglet tout client ouvert dans l’onglet « www », qui ne lui est pas lié dans ''config.apps'', sauf s’il est marqué avec ''intrusive'', comme c’est le cas pour « gcolor2 » et « xmag » ;
* ''max_clients'' force « www » à n’accepter qu’un seul client. Si plus d’une fenêtre est ouverte, un nouvel onglet « www » sera créé pour l’accueillir. Vous pouvez naviguer parmi ces onglets avec Super+3 ;
* donner à ''rel_index'' la valeur 1 dit à l’onglet « fs » de rester toujours ouvert à côté de l’onglet actuel et pas à la fin. Si on mettait ''rel_index = 0'', ça le créerait à la position actuelle de la liste des onglets, juste avant l’onglet courant ;
* ''spawn'' définit le nom du programme, ici Firefox, à exécuter quand l’onglet « www » est créé ; en combinaison avec ''position'', cela permet de lancer Firefox en appuyant sur Super+3 ;
* ''run'' définit une fonction qui est lancée à la création d’un onglet ; dans l’exemple ci-dessus, cela demande à naughty d’afficher une notification avec un nom à chaque création d’onglet ;
* ''float'' demande à ce que ''recordMyDesktop'', ''MPlayer'' et ''xmag'' soient en clients flottants ;
* ''geometry'' force la création de la fenêtre ''gcolor2''aux coordonnées (100,100). Le format de tableau est {x,y,w,h} ;
* ''slave'' oblige les fenêtres d’images de Gimp à être esclaves : les boîtes à outils sont maîtres.

Remarquez que la liaison des clients et des onglets par ''config.apps'' est faite par rôle, instance, classe, [http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=421f6d062ff70aa0f466af0c105243eec117492d type] et titre. Elle supporte des motifs ''via'' ''string.find'' donc si vous liez quelque chose d’autre que le titre, que vous devriez utiliser une liaison aussi juste que possible. Exemple : ''&quot;^Iceweasel$&quot;''.

Dans le champ « tag » de ''config.apps'', vous pouvez même fournir les noms d’onglets qui n’ont pas de paramètres par défaut dans ''config.tags'' : ils seront créés avec le nom de ''config.apps'' et d’après ''config.defaults'' s’il y en a un.

Le fait de lancer ''shifty.init()'' après la mise en place des variables de configuration crée les onglets configurés avec le drapeau ''init''.

Remarquez bien l’utilisation de l’entrée ''{ match = &quot;&quot; }, …'' dans ''config.apps'' : vous devez utiliser ça si vous voulez que les client aient des boutons.

=== Options disponibles ===
Les options disponibles sont les suivantes : 

* ''config.tags'' et ''config.defaults'' peuvent prendre les valeurs : layout, mwfact, nmaster, ncol, exclusive, solitary, persist, nopopup, leave_kills, position, icon, icon_only, sweep_delay, keys, overload_keys, index, rel_index, run, spawn, screen ;
* ''config.apps'' accepte : screen, tag, float, geometry, slave, nopopup, nofocus, intrusive, fullscreen, honorsizehints, kill, ontop, below, above, buttons, keys, hide, minimized, dockable, urgent, opacity, titlebar, run, sticky, wfact, struts ;
* ''config.guess_name'' : si cette variable est à ''true'', qui est la valeur par défaut, shifty essaiera de mettre des noms des nouveaux onglets correspondant aux noms des classes de clients. Ceci n’a d’effet que lorsqu’un client n’est pas lié et est ouvert quand il n’y a pas d’onglet ou que l’onglet actuel dispose des options ''solitary'' ou ''exclusive'' &lt;small&gt;[http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=9ff81df6c996c53c4ac5630133770b247c67252e (''commit'')]&lt;/small&gt; ;
* ''config.guess_position'' : si elle reçoit la valeur par défaut ''true'', shifty regardera si le premier caractère d’un nom d’onglet est un nombre et mettra la position de cet onglet en conséquence. Fournir une ''position'' explicitement outrepasse ce fonctionnement &lt;small&gt;[http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=550a5b58616a43fb229240c1d14bd16ce6ab7231 (''commit'')]&lt;/small&gt; ;
* ''config.remember_index'' : si mise à la valeur par défaut ''true'', shifty gardera une trace de l’index de la liste d’onglets et si un onglet est fermé, il sera rouvert à la même position. Les options suivantes outrepassent ce comportement : ''position'', ''index'' ou ''rel_index'' &lt;small&gt;[http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=9c4eeccce5131f2af51fd8c4441e38ac552714e2 (''commit'')]&lt;/small&gt; ;
*''config.layouts'' : si on lui passe un tableau de fonctions de dispositions, permet de paramétrer les dispositions par leur nom &lt;small&gt;[http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=23fd3cbc302072a84ee5cd2c849110f622e70fa8 (''commit'')]&lt;/small&gt; ;
* ''config.clientkeys'' : le tableau par défaut des clés de clients &lt;small&gt;[http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=413ee06d3718a88e6edcef87c77f2403ba46c152 (''commit'')]&lt;/small&gt; ;
* ''config.globalkeys'' : tableau par défaut des clés globales &lt;small&gt;[http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=7a8407741556873b7dc772e28394f54669670306 (''commit'')]&lt;/small&gt; ;
* ''config.prompt_sources'' et ''config.prompt_matchers'' : config pour complétion &lt;small&gt;[http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=6a69064308f94106428c1538f9c3174c74566db5 (''commit'')]&lt;/small&gt;.

== Développement ==
=== Support ===
Si vous avez des problèmes, des suggestions ou des commentaires, vous pouvez discuter avec Koniu ou Bioe007 sur le canal ''#awesome'', utiliser la liste de diffusion ou la page de discussion du wiki. Remarquez que l’interface de programmation est potentiellement sujette à modifications, donc vérifiez cette page et le [http://git.mercenariesguild.net/?p=awesome.git;a=history;f=lib/shifty.lua.in;h=shifty;hb=shifty-master journal des changements], surtout si vous avez mis à jour et que quelque chose a arrêté de fonctionner. Si vous choisissez d’utiliser shifty, essayez de rester à jour avec les versions git de shifty et d’awesome : des changements, améliorations et corrections de bogues se produisent tout le temps.

=== Bogues ===
* awful.tag.history est un niveau qui résulte en des modifications imprévisibles, par exemple en supprimant de nombreux onglets à la suite ;
* quand on renomme un onglet d’un nom pré-établi vers un autre, la disposition n’est pas toujours écrasée et reste sur l’ancienne ;
* l’alignement de l’invite de renommage est bizarre avec taglist_squares (corrigé [http://git.mercenariesguild.net/?p=awesome.git;a=commitdiff;h=6892e1713ad23491a5d3a44c43aaa6314d94448c ici] ou [http://git.naquadah.org/?p=awesome.git;a=commitdiff;h=3e8506e6cb6606a0ae15fc0f01f8f7cee517dbb6 là])

=== À faire ===
* mettre à jour les instructions sur le wiki (partiellement fait) ;
* permettre de lier des clients à plusieurs onglets : [http://git.mercenariesguild.net/?p=awesome.git;a=commit;h=61457eeb80efcae36be6dfa29a85328e0064b692 c’est fait] ;
* tester un peu plus le multi-écrans ;
* corriger l’historique ;
* nettoyer et séparer les mises en place et les liaisons, notamment les calculs d’onglet- ou écran-cible et l’indexage des onglets ;
* utiliser ''awful.client.property{set,get}'' ;
* autoriser l’alignement des onglets à droite de la liste d’onglets ;
* repenser la syntaxe de liaison des clients ;
** lier de façon plus spécifique (match = { class = &quot;URxvt&quot;, inst = &quot;urxvt&quot;, }) avec potentiellement plus de liaisons (geom) ;
** logique et agrégation : AND et OR.

=== Shifty et eminent ===
Shifty a été inspirée par [[eminent]] et utilisait des morceaux de son code par le passé. Eminent était une autre extension du même genre de gestion dynamique des onglets. Elle avait été développée quand l’interface de programmation d’awesome n’était pas aussi flexible que maintenant et quand il manquait un certain nombre de défauts : les onglets étaient effectivement pré-créés mais les onglets vides restaient cachés. Eminent est maintenant considérée obsolète.

[[Category:Awesome3]]</text>
      <sha1>js6ngcp79q0pvc11fntxclupgg5zftw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Shifty/ru</title>
    <ns>0</ns>
    <id>1091</id>
    <revision>
      <id>6675</id>
      <timestamp>2014-05-27T17:43:10Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Shifty (translating page)</comment>
      <text xml:space="preserve" bytes="21999">{{Languages|Shifty}}

== Введение ==
Shifty является расширением для Awesome 3 которая реализует динамические теги.

Он также реализует конфигурацию сравнений клиентов(приложений), что упрощает сравнение тег-клиент.

Вот несколько способов, как shifty делает awesome класнее:

* Создание и удаление тегов на лету
* Дополнительное согласование(matching) клиентов
* Лекгое перемещение клиентов между тегами
* Добавление/переименование тегов в окончание taglist
* Изменение порядка тегов и настройка расположения
* Предположение(guessing) имени тега, автоматическая группировка клиентов не заданная конфигурацией
* Настраиваемые сочетания клавиш для клиента и тега
* Простая, но мощная конфигурация

'''Примечание:''' Shifty является частью Awesome и отлично нам помогает. Awesome теперь поддерживает динамические теги по умолчанию (с середины цикла 3.4). Если вы использвуте Shifty только для динамических тегов, вы можете использовать непосредственно awful.tag.add() и awful.tag.remove(). Если вы используете только базовую систему конфигурации Shifty, то [https://github.com/Elv13/tyrannical Tyrannical] более новая (и быстрая) система конфигурации, поддерживающая большую часть Shifty, но без дополнительных возможностей.

== Видео ==
Чтобы посмотреть раннюю версию Shifty в действии проверьте:
http://garoth.com/awesome/shifty.ogv

'''TODO''' Требуется кто нибудь, чтобы сделать еще видео...

== Установка ==
Очень простой способ начать, это использовать ''example.rc.lua'' включающий в себя shifty.

# Перейти в каталог конфигурации (обычно ''~/.config/awesome'').
# Клонируйте репозиторий
    # Для 3.4:
    git clone &lt;nowiki&gt;git://github.com/masterkorp/awesome-shifty.git&lt;/nowiki&gt;
    # Для 3.5
    git clone &lt;nowiki&gt;git://github.com/cdump/awesome-shifty&lt;/nowiki&gt;
# Переместить пример файла ''rc.lua'' в ваш каталог с настройками Awesome
    cp shifty/example.rc.lua rc.lua
&lt;small&gt;&lt;b&gt;
ВНИМАНИЕ:&lt;/b&gt;
Если вы уже имеете настроенный rc.lua, сначала переместите куда нибудь его, иначе он затрется. Или воспользуйтесь [Using Xephyr/ru| Xephyr] для запуска в отдельной Х сессии со другим файлом rc.lua
&lt;/small&gt;
# Перезапустите awesome и наслаждайтесь.

== Конфигурация ==
Вы можете (и даже '''должны''') посмотреть пример [http://github.com/masterkorp/awesome-shifty/blob/master/example.rc.lua rc.lua], чтобы увидеть как это все работает вместе. Пример подразумевает простейшую реализацию стандартного rc.lua. Конечно это не является абсолютной необходимостью, но это может облегчить изучение для новых пользователей.

Автор '''настоятельно''' рекомендует начинать с изучения примера rc.lua. Это может реально сэкономить ваше время и избавит от головной боли.

=== Теги ===
Предопределенные теги настраиваются через переменную ''shifty.config.tags''. Помните, что это ''не подразумевает'' что теги будут созданы при запуске. Эти теги могут не сущестовать, пока клиенты, которые в них 'нуждаются' их не вызовут.

&lt;pre&gt;
shifty.config.tags = {
    [&quot;1:sys&quot;] = {
        init     = true, -- Create this tag at startup and be persistent.
        position = 1,
        screen   = 1,   -- Only create this tag on screen 1.
        mwfact   = 0.60 -- Sets the master window size factor to 0.60 (60%)
                        -- in the tag.
    },
    [&quot;2:term&quot;] = {
        persist  = true,  -- Don't delete after last client closes.
        position = 2,
    },
    [&quot;3:www&quot;] = {
        position    = 3,
        spawn       = &quot;firefox&quot; -- Open firefox when created.
        exclusive   = true, -- Only clients matched from config.apps will
                            -- be allowed here.
        max_clients = 1,    -- If more than one client is started, then a
                            -- new tag is made.
    },
    [&quot;ardour&quot;] = {
        nopopup     = true, -- Prevents focusing on creation.
        leave_kills = true, -- Don't destroy after closing the last client
                            -- until switching another tag.
    },
    [&quot;p2p&quot;] = {
        icon_only = true,               -- only show the icon
        icon      = &quot;~/.icons/p2p.png&quot;, -- path to icon for taglist
    },
    [&quot;gimp&quot;] = {
        layout = &quot;tile&quot;,
        mwfact = 0.18,
        icon   = &quot;~/.icons/gimp.png&quot;, -- Display an icon, but will also
                                        -- have text.
    },
    [&quot;fs&quot;] = {
        rel_index = 1, -- always open next to the current tag and not at the
                        -- end. (0 would create it before current tag)
    },
}
&lt;/pre&gt;

* &lt;b&gt;screen&lt;/b&gt;

''Совет'': ''screen = math.max(screen.count(), 2)'' создаст тег на втором экране, но только когда он подсоединен.

* &lt;b&gt;position&lt;/b&gt;

Вызов тега ''sys'' всегда будет устанавливать его 1м в списке, ''term'' 2-м ''www'' 3-м.

* &lt;b&gt;nopopup&lt;/b&gt;
** Не фокусировать при создании.

Допустимые ключи для '''config.tags''' и '''config.defaults''':
    layout        = func   -- a layout from awful.layout.suit (e.g. awful.layout.suit.tile)
    mwfact        = float  -- how big the master window is
    nmaster       = int    -- how many columns for master windows
    ncol          = int    -- how many columns for non-master windows
    exclusive     = bool   -- if true, only clients from rules (config.apps) allowed in this tag
    persist       = bool   -- persist after no apps are in it
    nopopup       = bool   -- do not focus on creation
    leave_kills   = bool   -- if true, tag won't be deleted until unselected
    position      = int    -- determines position in taglist (then what does index do?)
    icon          = string -- image file for icon
    icon_only     = bool   -- if true, no text (just icon)
    init          = bool   -- if true, create on startup (implies persist)
    sweep_delay   = int    -- ???
    keys          = {}     -- a table of keys, which are associated with the tag
    overload_keys = {}     -- ???
    index         = int    -- ???
    rel_index     = int    -- ???
    run           = func   -- a lua function which is execute on tag creation
    spawn         = string -- shell command which is execute on tag creation (ex. a programm)
    screen        = int    -- which screen to spawn on (see above)
    max_clients   = int    -- if more than this many clients are started, then a new tag is made

'''Примечание''' 
''init'' подразумевает ''постоянные''

Постоянные теги никогда не удаляются автоматически (они могут быть удалены с помощью shifty.delete). 

Теги с установленным значением  ''leave_kills'' не будут удалены пока с тег не будет unselected.

'''shifty.init()''' после настройки переменных запускает создание тегов имеющих флаг ''init''.

Ключ '''run''' определяет функцию, которая запускает создание тегов.

=== Применение ===
Пример применения таблицы конфигурации:
&lt;pre&gt;
shifty.config.apps = {
    {
        match  = {&quot;htop&quot;, &quot;Wicd&quot;, &quot;jackctl&quot;},
        tag    = &quot;1:sys&quot;,
        screen = 1,
    },
    {
        match = {&quot;Iceweasel.*&quot;, &quot;Firefox.*&quot;},
        tag   = &quot;3:www&quot;,
    },
    {
        match  = {&quot;urxvt&quot;},
        tag    = &quot;2:term&quot;,
        screen = 1,
    },
    {
        match   = {&quot;Ardour.*&quot;, &quot;Jamin&quot;},
        tag     = &quot;ardour&quot;,
        nopopup = true,
    },
    {
        match = {&quot;Gimp&quot;,&quot;Ufraw&quot;},
        tag = {&quot;graph&quot;, &quot;gimp&quot;},  -- Both tags will be applied.
    },
    {
        match = {&quot;gimp%-image%-window&quot;},
        slave = true,                    -- Client is started as a slave.
    },
    {
        match = {&quot;gcolor2&quot;, &quot;xmag&quot;, &quot;MPlayer&quot;},
        float = true,
        intrusive = true,   -- Disregard a tag's exclusive property.
    },
    {
        match = {&quot;gcolor2&quot;},
        geometry = {100, 100, nil, nil},
    },
    {
        match = {&quot;&quot;},   -- Matches all clients to provide button behaviors.
        buttons = {
            button({}, 1, function (c) client.focus = c; c:raise() end),
            button({modkey}, 1, function (c) awful.mouse.client.move() end),
            button({modkey}, 3, awful.mouse.client.resize),
        },
    },
}
&lt;/pre&gt;

Допустимые ключи для '''config.apps''':
    above          = bool
    below          = bool
    border_width   = int
    buttons        = {}
    dockable       = bool
    float          = bool
    fullscreen     = bool
    geometry       = {x, y, w, h}
    hidden         = bool
    honorsizehints = bool
    intrusive      = bool
    keys           = {}
    kill           = bool
    minimized      = bool
    nofocus        = bool
    nopopup        = bool
    ontop          = bool
    opacity        = float
    props          = {}
    run            = func
    screen         = int
    skip_taskbar   = bool
    slave          = bool
    startup        = bool
    sticky         = bool
    struts         = {}
    tag            = string
    titlebar       = bool
    urgent         = bool
    wfact          = float

==== Сравнение клиентов и тегов ====

Клиент можно сравнивать с конкретными атрибутами, такими как  class, instance, name, role и type.
Пример:
&lt;pre&gt;
  {
     match  = {
       class= &quot;URxvt&quot;, 
       name=&quot;root. &quot;   --Notice the dot         
       },
     tag    = &quot;5:admin&quot;,
     screen = 1,
   },
&lt;/pre&gt;

Это позволит хранить все окна urxvt, которые запущены от имени root на 5м теге.

Если вы не определили никаких type будут найдены все варианты:
&lt;pre&gt;
  {
     match = {
       class = {
          &quot;Do&quot;,
       },
       &quot;clock%-applet&quot;,
     },
     float = true,
     intrusive = true,
  },
&lt;/pre&gt;

Паттерн это  [http://www.lua.org/manual/5.1/manual.html#5.4.1 схема сравнения lua].
Для проверки свойств используйте [http://www.xfree86.org/current/xprop.1.html xprop] и щелкните на изучаемом окне.

'''Примечание:'''

В поле ''tag'' в ''config.apps'' вы можете даже записать названия тегов, которые не
установлены заранее в ''config.tags'', они будут созданы с названиями из
''config.apps'' и в соответствии с настройками из ''config.defaults'' (если они существуют).

Обратите внимание, что запись ''{ match = &quot;&quot; }, ...'' в config.apps - вам необходима, если вы хотите иметь кнопки приложений.

Таблица '''geometry''' предписывает окну клиента создаваться с определенными координатами и прописанными размерами. Формат этой таблицы  {x, y, width, height}.

=== Стандартные значения ===
Резервные значения используются когда предустановки не найдены в первых двух таблицах конфигурации.
&lt;pre&gt;
shifty.config.defaults = {
    layout = &quot;max&quot;,
    mwfact = 0.5,
    run = function(tag) naughty.notify({text = tag.name}) end,
}
&lt;/pre&gt;
Здесь для новых тегов, которые предварительно не будут настроены получат layout 'max' , и mwfact = 0.5 и отобразят уведомление на рабочем столе.

=== Клавиатурные сочетания ===

Пример сочетаний клавиатуры. Это самые основные, их можно считать стартовой точкой в начале изучения.

В 'большой' таблице globalkeys у нас содержатся следующие клавиши:
&lt;pre&gt;
awful.key({}, &quot;XF86Back&quot;, awful.tag.viewprev),
awful.key({}, &quot;XF86Forward&quot;, awful.tag.viewnext),
awful.key({modkey}, &quot;XF86Back&quot;, shifty.shift_prev),
awful.key({modkey}, &quot;XF86Forward&quot;, shifty.shift_next),
awful.key({modkey}, &quot;t&quot;, function() shifty.add({ rel_index = 1 }) end),
awful.key({modkey, &quot;Control&quot;},
            &quot;t&quot;,
            function() shifty.add({ rel_index = 1, nopopup = true }) end
            ),
awful.key({modkey, &quot;Shift&quot;}, &quot;r&quot;, shifty.rename),
awful.key({modkey}, &quot;w&quot;, shifty.del),
&lt;/pre&gt;

А в качестве замены стандартых числовых сочетаний клавиш:
&lt;pre&gt;
for i=1,9 do
    globalkeys = awful.util.table.join(
                        globalkeys,
                        awful.key({modkey}, i,
                            function()
                                awful.tag.viewonly(shifty.getpos(i))
                            end))
    globalkeys = awful.util.table.join(
                        globalkeys,
                        awful.key({modkey, &quot;Control&quot;}, i,
                            function ()
                                local t = shifty.getpos(i)
                                t.selected = not t.selected
                            end))
    globalkeys = awful.util.table.join(globalkeys,
                                awful.key({modkey, &quot;Control&quot;, &quot;Shift&quot;}, i,
                function ()
                    if client.focus then
                        awful.client.toggletag(shifty.getpos(i))
                    end
                end))
    -- move clients to other tags
    globalkeys = awful.util.table.join(
                    globalkeys,
                    awful.key({modkey, &quot;Shift&quot;}, i,
                        function ()
                            if client.focus then
                                local t = shifty.getpos(i)
                                awful.client.movetotag(t)
                                awful.tag.viewonly(t)
                            end
                        end))
end
&lt;/pre&gt;

&lt;b&gt;Примечание:&lt;/b&gt;
Shifty работает с цифровыми сочетаниями клавиатуры через атрибут ''position'' с вызовом функции ''getpos()''

Функция ''shifty.getpos()'' предназначена для обработки сочетания ''mod+i'' с помощью сопоставления тегу атрибута ''position''.
* если тег с ''position == i'' существует, переключится на него
* если более одного тега с ''position == i'', циклически переключаться через все из них
* если тег с ''position i'' не существует, создать новые тег

=== Globals ===
    config.guess_name = true
Если установлено значение true (по умолчанию) shifty будет пытаться угадать название нового тега из class клиента. Это имеет силу только когда клиент unmatched и запускается когда нет тегов или тег имеет метку ''solitary'' или ''exclusive''.

    config.guess_position = true
Если установлено значение true (по умолчанию) shifty будет проверять первые символы названия тега для присваивания номера и установки ''position'' тегов в соответсвиии с ним . Явное указание ''position'' для какого либо тега, отменяет эту возможность.

    config.remember_index = true
Если установлено значение true (по умолчанию) shifty If set to true (default) shifty будет отслеживать индекс тегов в taglist и если он будет повторно открыт после закрытия, разместит его в том же месте. Определение ''position'', ''index'' or ''rel_index'' отменяет эту возможность. 

    config.layouts = {}
Если установлено (в таблице функций layout), позволяет устанавливать layout по короткому имен

    config.clientkeys = {}
Стандартная таблица клавиш приложений, здесь обычно только ваши clientkeys.

    config.globalkeys = nil
Стандартная таблица глобальных клавиш, здесь обычно только ваши globalkeys.

    config.prompt_sources = {
        &quot;config_tags&quot;,
        &quot;config_apps&quot;,
        &quot;existing&quot;,
        &quot;history&quot;
    }
Таблица, где клавиши используются в виде строки для быстрого завершения.

    config.prompt_matchers = {&quot;^&quot;, &quot;:&quot;, &quot;&quot;}

Config for prompt completion matching, a table of strings (symbols)

=== Дополнения ===

Если вы не хотите начинать с '''example.rc.lua''' то здесь приведены несколько шагов, которые помогут вам интегрировать shifty в существующую конфигурацию

1. Удалите:
* Все упоминания связанные с созданием тегов
* Вашу управляющую функцию

2. Подключение модуля
    require('shifty')   -- добавьте строку в начале rc.lua

3. Определите переменные ''shifty.config'' (детали описаны выше)

4. После определения taglist в ''rc.lua'', добавьте код (помните, что mytaglist '''должен''' быть таблицей taglists, не единственным объектом  taglist):
&lt;pre&gt;shifty.taglist = mytaglist&lt;/pre&gt;

5. Добавьте некоторые [[#Клавиатурные сочетания|клавиатурные сочетания]] в rc.lua.

6. Замените mod+i (цифовой) [[#Клавиатурные сочетания| Клавиатурные сочетания]] цикл на пример указанный выше.

10. Следующие определения таблицы клавиш (globalkeys, clientkeys) говоря shifty что следует использовать:
&lt;pre&gt;
root.keys(globalkeys)
shifty.config.globalkeys = globalkeys
shifty.config.clientkeys = clientkeys
&lt;/pre&gt;

11. Вы сделали это! Теперь когда вы запустите Awesome у вас не будут создавать теги, кроме тех, которые вы предварительно настроите с флагом ''init''. В этом случае, открытие окна, которое не имее предустановок создаст новый тег названный по class клиента (или &quot;new&quot; если '''shifty.config.guess''' = false).

== Поддержка ==
Помощь лучше искать по следующему порядку:

1. Поисковики, например [http://www.google.com Google] ваш друг...

2. Канал ''#awesome'' на irc.oftc.net можно исользовать для немедленной помощи, например по вопросам конфигурации или подобным

3. Сообщения через [http://github.com/masterkorp/awesome-shifty github]

4. Письма в [mailto:awesome@naquadah.org awesome mailing list]

5. Письмо [mailto:masterkorp@masterkorp.net автору].

=== Баги ===
Please file all bugs and feature requests using the issue tracker on
[http://github.com/masterkorp/awesome-shifty github].

=== Смотрите также ===
[[tyrannical]] - An alternative dynamic tagging system, which is less intrusive and make use of the builtin tagging features of awesome 3.

[[Category:Awesome3]]
__FORCETOC__</text>
      <sha1>3bnz94roxkmknk4ngzw66jbu3ztzq7j</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Shitty</title>
    <ns>0</ns>
    <id>494</id>
    <redirect title="Shifty" />
    <revision>
      <id>3697</id>
      <timestamp>2009-10-22T12:46:00Z</timestamp>
      <contributor>
        <username>Johnparkinson</username>
        <id>378</id>
      </contributor>
      <comment>moved [[Shitty]] to [[Shifty]] over redirect: niggerpenis</comment>
      <text xml:space="preserve" bytes="20">#REDIRECT [[Shifty]]</text>
      <sha1>tssiu5yziklc31s8cmn5wqxyoewezcj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ShutdownDialog</title>
    <ns>0</ns>
    <id>555</id>
    <revision>
      <id>7428</id>
      <parentid>6577</parentid>
      <timestamp>2016-02-28T15:47:43Z</timestamp>
      <contributor>
        <username>Catz</username>
        <id>4318</id>
      </contributor>
      <comment>Alternate version of script with description</comment>
      <text xml:space="preserve" bytes="3700">{{Languages}}

[[Image:Shutdown_dialog.png‎|thumb|ShutdownDialog preview]]

If you miss the GNOME/KDE/XFCE/LXDE/whatever close dialog, there is a very simple workaround.

The shell script below will show a simple dialog like this (the script's dialog is shown on the right). Be warned that if you want to use this script, you will need:
* zenity (used to generate the dialog)
* gksudo (frequently called gksu, used to do a graphical permissions check)
* pm-utils (available from freedesktop, used for suspend, commented out in the code in favour of dbus)
* dbus (used for suspend)
* hal (hardware management)
* slock (screen locking)

However, for most distros, all of these features will be readily available from the package manager. If you prefer to use some other tools, feel free to edit the script to use them. Hopefully you know what you're doing, but we're available in IRC to help.

&lt;br clear=&quot;all&quot; /&gt;

 #!/bin/sh
 
 ACTION=`zenity --width=90 --height=200 --list --radiolist --text=&quot;Select logout action&quot; --title=&quot;Logout&quot; --column &quot;Choice&quot; --column &quot;Action&quot; TRUE Shutdown FALSE Reboot FALSE LockScreen FALSE Suspend`
 
 if [ -n &quot;${ACTION}&quot; ];then
   case $ACTION in
   Shutdown)
     zenity --question --text &quot;Are you sure you want to halt?&quot; &amp;&amp; gksudo halt
     ## or via ConsoleKit
     # dbus-send --system --dest=org.freedesktop.ConsoleKit.Manager \
     # /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Stop
     ;;
   Reboot)
     zenity --question --text &quot;Are you sure you want to reboot?&quot; &amp;&amp; gksudo reboot
     ## Or via ConsoleKit
     # dbus-send --system --dest=org.freedesktop.ConsoleKit.Manager \
     # /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Restart
     ;;
   Suspend)
     #gksudo pm-suspend
     dbus-send --system --print-reply --dest=org.freedesktop.Hal \
     /org/freedesktop/Hal/devices/computer \
     org.freedesktop.Hal.Device.SystemPowerManagement.Suspend int32:0
     # HAL is deprecated in newer systems in favor of UPower etc.
     # dbus-send --system --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Suspend
     ;;
   LockScreen)
     slock
     # Or gnome-screensaver-command -l
     ;;
   esac
 fi

== Features ==

* Simple
* Suspend doesn't require password

== Alternate version ==

Below is an alternative script. The main difference is that the dialog-box now contains a simple list and is somewhat more keyboard-friendly. 
An action can be triggered by several methods. Using the keyboard the Up/Down arrows can be used to select an action, pressing Enter will then trigger it. At the same time the dialog box is fully workable with a mouse, double-clicking an action will cause it to trigger. The dialog can be cancelled either with the key Escape, or clicking Cancel.

Currently the script only has the options Shutdown and Reboot, more options can trivially be added if needed.
&lt;br clear=&quot;all&quot; /&gt;

 #!/bin/sh
 
 ACTION=`zenity --width=90 --height=150 --list --text=&quot;Select logout action&quot; --title=&quot;Logout&quot; --column &quot;Action&quot; Shutdown Reboot`
 
 if [ -n &quot;${ACTION}&quot; ];then
  case $ACTION in
  Shutdown)
    shutdown
    ;;
  Reboot)
    reboot
    ;;
  esac
 fi

== Add it to the menu ==

Add this to your menu table:
 {&quot;Log out&quot;, '/home/davide/bin/shutdown_dialog.sh'},

so that it looks something like this:
 mymainmenu = awful.menu({ items = { { &quot;awesome&quot;, myawesomemenu, beautiful.awesome_icon },
 				{&quot;Firefox&quot;, &quot;firefox&quot;},
 				{&quot;Thunderbird&quot;, &quot;thunderbird&quot;},
 				{&quot;Pidgin&quot;, &quot;pidgin&quot;},
 				{&quot;Log out&quot;, '/your/path/to/shutdown_dialog.sh'},
                                { &quot;open terminal&quot;, terminal }
                             }
                        })</text>
      <sha1>ozt8v3pq94u2m6cvjxvpto0cmdvh4zx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>ShutdownDialog/ru</title>
    <ns>0</ns>
    <id>1065</id>
    <revision>
      <id>6579</id>
      <timestamp>2014-05-21T12:57:36Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода ShutdownDialog (translating page)</comment>
      <text xml:space="preserve" bytes="3905">{{DISPLAYTITLE:Диалог выключения}}
{{Languages|ShutdownDialog}}

[[Image:Shutdown_dialog.png‎|thumb|ShutdownDialog preview]]

Если вы не используете GNOME/KDE/XFCE/LXDE/прочие диалоги выключения, есть достаточно простая альтернатива.

Скрипт написанный ниже отобразит простой диалог, как этот (скриптовый диалог показан справа). Предупереждаем, что если вы хотите использовать этот скрипт, вам понадобятся:
* zenity (используется для создания диалога)
* gksudo (часто его еще называют gksu, используется для проверки прав графических приложений)
* pm-utils (доступен из freedesktop, используется для приостановки, закоментированно в коде, в пользу использования D-Bus)
* dbus (используется для приостановки)
* hal (управление оборудованием)
* slock (блокировка экрана)

Тем не менее, в большинстве дистрибутивов, все эти функции будут доступны из менеджера пакетов. Если вы предпочитаете использовать какие то другие утилиты, не стесняйтесь редактировать сценарий, чтобы использовать их. Надеемся вы знаете, что вы делаете, но тем не менее, помощь доступна на IRC.

&lt;br clear=&quot;all&quot; /&gt;

 #!/bin/sh
 
 ACTION=`zenity --width=90 --height=200 --list --radiolist --text=&quot;Select logout action&quot; --title=&quot;Logout&quot; --column &quot;Choice&quot; --column &quot;Action&quot; TRUE Shutdown FALSE Reboot FALSE LockScreen FALSE Suspend`
 
 if [ -n &quot;${ACTION}&quot; ];then
   case $ACTION in
   Shutdown)
     zenity --question --text &quot;Are you sure you want to halt?&quot; &amp;&amp; gksudo halt
     ## или через ConsoleKit
     # dbus-send --system --dest=org.freedesktop.ConsoleKit.Manager \
     # /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Stop
     ;;
   Reboot)
     zenity --question --text &quot;Are you sure you want to reboot?&quot; &amp;&amp; gksudo reboot
     ## или через ConsoleKit
     # dbus-send --system --dest=org.freedesktop.ConsoleKit.Manager \
     # /org/freedesktop/ConsoleKit/Manager org.freedesktop.ConsoleKit.Manager.Restart
     ;;
   Suspend)
     #gksudo pm-suspend
     dbus-send --system --print-reply --dest=org.freedesktop.Hal \
     /org/freedesktop/Hal/devices/computer \
     org.freedesktop.Hal.Device.SystemPowerManagement.Suspend int32:0
     # HAL является устаревшим, сейчас используются UPower и т.д.
     # dbus-send --system --dest=org.freedesktop.UPower /org/freedesktop/UPower org.freedesktop.UPower.Suspend
     ;;
   LockScreen)
     slock
     # Или gnome-screensaver-command -l
     ;;
   esac
 fi

== Особенности ==

* Простой
* Приостановка не требует ввода пароля

== Добавляем это в меню ==

Добавляем это в вашу таблицу меню:
 {&quot;Log out&quot;, '/home/davide/bin/shutdown_dialog.sh'},

чтобы это выглядело примерно следующим оразом:
 mymainmenu = awful.menu({ items = { { &quot;awesome&quot;, myawesomemenu, beautiful.awesome_icon },
 				{&quot;Firefox&quot;, &quot;firefox&quot;},
 				{&quot;Thunderbird&quot;, &quot;thunderbird&quot;},
 				{&quot;Pidgin&quot;, &quot;pidgin&quot;},
 				{&quot;Log out&quot;, '/your/path/to/shutdown_dialog.sh'},
                                { &quot;open terminal&quot;, terminal }
                             }
                        })</text>
      <sha1>6h6u7nfqqx1lmal2bcd511njpg59fmc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Signals</title>
    <ns>0</ns>
    <id>530</id>
    <revision>
      <id>7401</id>
      <parentid>7400</parentid>
      <timestamp>2016-01-03T02:59:01Z</timestamp>
      <contributor>
        <username>Elv13</username>
        <id>375</id>
      </contributor>
      <comment>/* tag */</comment>
      <text xml:space="preserve" bytes="11842">{{Languages}}

Awesome 3.4 added signals as a new mechanism for managing events. It replaces the old hook system and some other functions like widget.mouse_enter.

Instead of:

  mytextbox.mouse_leave = function ()
      --CODE
  end

One now uses in Awesome 3.5:

  mytextbox:connect_signal(&quot;mouse::leave&quot;, function ()
      --CODE
  end)

Awesome 3.4 uses &quot;add_signal&quot; instead of &quot;connect_signal&quot; in 3.5.

You can add or remove handler functions to be called when a signal is emitted. Multiple handlers can be bound to the same signal. You can also tell objects to emit signals by hand, when appropriate. (Grep the awful library for &quot;emit_signal&quot; to see this in action.)

You can create your own custom signals, and tell your own objects when to emit them. But most of the time we'll want to be binding handlers to the signals already being emitted by the awesome core. I haven't found much documentation yet about which signals are used by the core, and what arguments their handlers get passed. There are several requests on the mailing list for a comprehensive list of these.

So I grepped through the C code and the awful library (awesome-git, post-3.4.3), and compiled this draft. The &quot;/1&quot; at the end of a signal name indicates that when the signal is emitted its handlers get passed one argument. Those annotations are sometimes speculative; I didn't painstakingly inspect every relevant part of the code. I was aiming more to get a general overview, that we can refine over time.

Please help update this list when you see something is missing or erroneous. Please also help add brief explanations of when the various signals are emitted.

'''Each signal, connected with any kind of object (like ''button'', ''client'', etc.) carry additional (first on parameter list) argument, object-originator instance (please correct me if im wrong).'''

== awesome ==
Signals emitted on the global &lt;code&gt;awesome&lt;/code&gt; object:
{|
! Name
! When emitted
! Arguments
|-
| exit
| Just before awesome exits
| Boolean value indicating if awesome is restarting or not
|-
| spawn::initiated
| When a new client is beginning to start
| Table which describes the spawn event
|-
| spawn::change
| When one of the fields from the spawn::initiated table changes
| Same as spawn::initiated
|-
| spawn::canceled
| For some reason the application aborted startup
| Table which only got the &quot;id&quot; key set
|-
| spawn::timeout
| An application started a spawn event but didn't start in time.
| Table which only got the &quot;id&quot; key set
|-
| spawn::completed
| An application finished starting
| Table which only got the &quot;id&quot; key set
|-
| debug::error
| A call into the lua code aborted with an error
| Lua error message
|-
| debug::deprecation
| A deprecated lua function was called
| The error message which also describes the new API to use
|-
| debug::index::miss
| An invalid key was read from an object (e.g. c.foo)
| The object and they key that was attempted to read
|-
| debug::newindex::miss
| An invalid key was written to an object (e.g. c.foo = &quot;bar&quot;)
| The object, the key being written and the value written to that key
|}


== button ==
Signals emitted on mouse &lt;code&gt;button&lt;/code&gt; binding objects:
{|
! Name
! When emitted
! Arguments
|-
| press
| When bound mouse button + modifiers are pressed.
| one or more args
|-
| release
| When bound mouse button + modifiers are released.
| one or more args
|-
| property::button
| When property changes.
| none
|-
| property::modifiers
| When property changes.
| none
|}

== client ==
Signals emitted on &lt;code&gt;client&lt;/code&gt; objects:
{|
! Name
! When emitted
! Arguments
|-
| new
|
| one arg
|-
| manage
|
| two args
|-
| unmanage
|
| one arg
|-
| list
| Before manage, after unmanage, and when clients swap.
| none
|-
| focus
| when a client gains focus
| the client object
|-
| unfocus
| when a client looses focus
| the client object
|-
| tagged
| when client is tagged
| new tag
|-
| untagged
| when client looses tag
| deleted tag
|-
| marked
|
| unknown
|-
| unmarked
|
| unknown
|-
| property::above
| When property changes.
| none
|-
| property::below
| When property changes.
| none
|-
| property::border_color
| When property changes.
| none
|-
| property::border_width
| When property changes.
| none
|-
| property::class
| When property changes.
| none
|-
| property::floating
| When property changes.
| unknown
|-
| property::fullscreen
| When property changes.
| none
|-
| property::geometry
| When height or width changes.
| none
|-
| property::group_window
| When property changes.
| none
|-
| property::height
| When property changes.
| none
|-
| property::hidden
| When property changes.
| none
|-
| property::icon
| When property changes.
| none
|-
| property::icon_name
| When property changes.
| none
|-
| property::instance
| When property changes.
| none
|-
| property::machine
| When property changes.
| none
|-
| property::maximized_horizontal
| When property changes.
| none
|-
| property::maximized_vertical
| When property changes.
| none
|-
| property::minimized
| When property changes.
| none
|-
| property::modal
| When property changes.
| none
|-
| property::name
| When property changes.
| none
|-
| property::ontop
| When property changes.
| none
|-
| property::opacity
| When property changes.
| none
|-
| property::pid
| When property changes.
| none
|-
| property::role
| When property changes.
| none
|-
| property::screen
| When property changes.
| unknown
|-
| property::size_hints_honor
| When property changes.
| none
|-
| property::skip_taskbar
| When property changes.
| none
|-
| property::sticky
| When property changes.
| none
|-
| property::struts
| When property changes.
| none
|-
| property::transient_for
| When property changes.
| none
|-
| property::type
| When property changes.
| none
|-
| property::urgent
| When property changes.
| none
|-
| property::width
| When property changes.
| none
|-
| property::window
| When property changes.
| none
|-
| property::x
| When property changes.
| none
|-
| property::y
| When property changes.
| none
|-
| property::buttons
| When property changes.
| none
|-
| property::keys
| When property changes.
| none
|}

== dbus ==
Signals emitted on &lt;code&gt;dbus&lt;/code&gt; objects:
{|
| Name
| When emitted
| Arguments
|-
| (interface name)
| 
| Table of this format:
&lt;P&gt;&lt;pre&gt;
	{
			type: [signal,method_call,method_return,error,unknown] -- one of those options
			interface: ...
			path: ...
			member: ...
			bus: [system,session] -- one of those options
	}
&lt;/pre&gt;&lt;/P&gt;
Handler should return even number of values.
|}

== key ==
Signals emitted on &lt;code&gt;key&lt;/code&gt; binding objects:
{|
! Name
! When emitted
! Arguments
|-
| press
|
| one arg+
|-
| release
|
| one arg+
|-
| property::modifiers
| When property changes.
| none
|-
| property::key
| When property changes.
| none
|}

== menu ==
Signals emitted on &lt;code&gt;menu&lt;/code&gt; objects:
{|
! Name
! When emitted
! Arguments
|-
| mouse::enter
|
| none
|-
| mouse::leave
|
| none
|}

== screen ==
Signals emitted on &lt;code&gt;screen&lt;/code&gt; objects:
{|
! Name
! When emitted
! Arguments
|-
| padding (from awful.screen)
|
| unknown
|-
| arrange (from awful.layout)
|
| unknown
|-
| tag::attach
|
| one arg
|-
| tag::detach
|
| one arg
|-
| tag::history::update
|
| unknown
|-
| property::screen
| When property changes.
| unknown
|-
| property::workarea
| When property changes.
| none
|}

== tag ==
Signals emitted on &lt;code&gt;tag&lt;/code&gt; objects:
{|
! Name
! When emitted
! Arguments
|-
| tagged
|
| the tag, a client
|-
| untagged
|
| the tag, a client
|-
| property::name
| When property changes.
| none
|-
| property::screen
| When property changes.
| none
|-
| property::selected
| When property changes.
| the tag object
|-
| property::filtered
| When property changes.
| unknown
|-
| property::hide
| When property changes.
| unknown
|-
| property::icon
| When property changes.
| unknown
|-
| property::layout
| when the layout of a tag changes
| the tag object
|-
| property::mwfact
| When property changes.
| the tag object
|-
| property::ncol
| When property changes.
| the tag object
|-
| property::nmaster
| When property changes.
| the tag object
|-
| property::windowfact
| When property changes.
|
|}

== timer ==
Signals emitted on &lt;code&gt;timer&lt;/code&gt; objects:
{|
! Name
! When emitted
! Arguments
|-
| timeout
|
| none
|-
| property::timeout
| When property changes.
| none
|}

== tooltip ==
Signals emitted on &lt;code&gt;tooltip&lt;/code&gt;:
{|
! Name
! When emitted
! Arguments
|-
| mouse::enter
|
| none
|-
| mouse::leave
|
| none
|}

== wibox ==
Signals emitted on &lt;code&gt;wibox&lt;/code&gt; objects:
{|
! Name
! When emitted
! Arguments
|-
| mouse::enter
|
| none
|-
| mouse::leave
|
| none
|-
| property::geometry
| When height or width changes? (not sure if this signal is emitted)
| unknown
|-
| property::bg
| When property changes.
| none
|-
| property::bg_image
| When property changes.
| none
|-
| property::border_color
| When property changes.
| none
|-
| property::border_width
| When property changes.
| none
|-
| property::buttons
| When property changes.
| none
|-
| property::cursor
| When property changes.
| none
|-
| property::fg
| When property changes.
| none
|-
| property::height
| When property changes.
| none
|-
| property::ontop
| When property changes.
| none
|-
| property::opacity
| When property changes.
| unknown
|-
| property::orientation
| When property changes.
| none
|-
| property::screen
| When property changes.
| none
|-
| property::shape_bounding
| When property changes.
| none
|-
| property::shape_clip
| When property changes.
| none
|-
| property::struts
| When property changes.
| none
|-
| property::visible
| When property changes.
| none
|-
| property::widgets
| When property changes.
| none
|-
| property::width
| When property changes.
| none
|-
| property::x
| When property changes.
| none
|-
| property::y
| When property changes.
| none
|}

== widget ==
Signals emitted on &lt;code&gt;widget&lt;/code&gt; objects:
{|
! Name
! When emitted
! Arguments
|-
| press
|
| one or more args
|-
| release
|
| one or more args
|-
| mouse::enter
|
| none
|-
| mouse::leave
|
| none
|-
| property::buttons
| When property changes.
| none
|-
| property::type
| When property changes.
| none
|-
| property::visible
| When property changes.
| none
|}

== &quot;early&quot; manage ==

By default there is a handler on &quot;manage&quot; signal - awful.rules.apply(c). And this handler sticks the client with current tag. 
One may want to perform some actions on client before this handler is run. Here is one possible solution of this problem - it adds an &quot;early_manage&quot; signal that is emitted when a new client is managed before awful.rules.apply(c) is run. Basically it is the same signal as manage, but its handlers are ran before &quot;manage&quot; signal handlers. Source: https://github.com/dobrover/myawesome/blob/master/awesome/utils/early_manage.lua

  local early_manage = {}
  
  -- Module that adds &quot;early_manage&quot; signal that is executed
  -- before default awesome &quot;manage&quot; signal handler (which is awful.rules.apply)
  -- Usage: put require('early_manage').setup() at the top of rc.lua
  -- And then just use &quot;early_manage&quot; signal as normal &quot;manage&quot;.
  
  local capi = {
      client = client,
  }
  local awful = require 'awful'
  
  function early_manage.on_before_manage(...)
      -- Relies on the fact that emit_signal simply calls every signal handler
      -- in the current event handler.
      capi.client.emit_signal(&quot;early_manage&quot;, ...)
  end
  
  function early_manage.setup()
      if not early_manage._setup then
          early_manage._setup = true
          capi.client.add_signal(&quot;early_manage&quot;)
          capi.client.disconnect_signal(&quot;manage&quot;, awful.rules.apply)
          capi.client.connect_signal(&quot;manage&quot;, early_manage.on_before_manage)
          capi.client.connect_signal(&quot;manage&quot;, awful.rules.apply)
      end
  end
  
  return early_manage</text>
      <sha1>532e0hwmi7g31m0q8llptbd8pra5iai</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Signals/ru</title>
    <ns>0</ns>
    <id>1117</id>
    <revision>
      <id>6772</id>
      <parentid>6771</parentid>
      <timestamp>2014-06-10T16:25:24Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <text xml:space="preserve" bytes="18708">{{Languages|Signals}}
{{DISPLAYTITLE:Сигналы}}

В Awesome 3.4 были добавлены signal(сигналы) в качестве нового механизма управления событиями(events). Сигналы заменяют старую систему hook и некоторые другие функции, такие как widget.mouse_enter.

Вместо того чтобы использовать:

  mytextbox.mouse_leave = function ()
      --КОД
  end

Теперь необходимо использовать в Awesome 3.5:

  mytextbox:connect_signal(&quot;mouse::leave&quot;, function ()
      --КОД
  end)

Awesome 3.4 использует &quot;add_signal&quot; вместо &quot;connect_signal&quot; в 3.5.

Например, можно использовать сигналы, для получения вашими виджетами информации о получении/потере ими фокуса мыши:
  mywidget:add_signal('mouse::leave', function () naughty.destroy(calendar[3]) end)
Здесь при получении виджетом сигнала 'mouse::leave' о том, что мышь покинула его пределы, вызывается функция 'naughty.destroy'

Вы можете добавлять или удалять обработчик функций вызываемый при поступлении сигнала. Несколько обработчиков могут быть связаны с одним сигналом. Также, при необходимости, вы можете заставить объекты генерировать сигналы вручную. (grep библиотеку awful чтобы найти &quot;emit_signal&quot; и увидеть возможные действия.)

Вы можете создавать свои собственные пользовательские сигналы, и объяснять вашим объектам когда генерировать их. Но большую часть времени мы хотели бы привязывать обработчики к уже существующим сигналам, генерируемым ядром Awesome. Мне не удалось найти достаточно документации о том, какие сигналы используются ядром, и какие аргументы посылает их обработчик. Существуют несколько запросов на рассылку полного их списка.

Поэтому я grepped код C и библиотеку awful (awesome-git, после-3.4.3), и написал эту статью. Значение &quot;/1&quot; в конце названия сигнала указывает, что когда генерируется сигнал, его обработчик принимает один аргумент. Эти аннотации порой умозрительны; я не слишком тщательно проверял каждую часть кода. Моей целью было получить общее представление, которое затем можно усовершенствовать со временем.

Пожалуйста, помогайте обновлять этот список, когда увидите, если что то упущено или ошибочно. Пожалуйста, также помогайте добавлять краткие описания, различным генерируемым сигналам.

'''Каждый сигнал, связан со всеми видами объектов (такими как ''button'', ''client'', и т.д.) и несет дополнительный (первый параметр в списке) аргумент, экземпляр объекта-инициатора (пожалуйста, поправьте меня, если я не прав).'''

== awesome ==
Сигналы генерируются глобальными объектами &lt;code&gt;awesome&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| exit
| Непосредственно перед выходом из awesome
| Boolean значение указывающее будет ли перезапущен awesome
|-
| spawn::initiated
| В начале запуска нового клиента
| Таблица которая описывает событие spawn
|-
| spawn::change
| Когда одно из полей таблицы spawn::initiated table изменяется
| То же, что и spawn::initiated
|-
| spawn::canceled
| По некоторым причинам запуск приложения прерывается
| Таблица которая только получает набор ключей &quot;id&quot;
|-
| spawn::timeout
| An application started a spawn event but didn't start in time.
| Таблица которая только получает набор ключей &quot;id&quot;
|-
| spawn::completed
| Завершение запуска приложения
| Таблица которая только получает набор ключей &quot;id&quot;
|-
| debug::error
| Вызывается когда код Lua завершается с ошибкой
| Сообщение об ошибке Lua
|-
| debug::deprecation
| Вызов устаревшей функции Lua
| Сообщение об ошибке, в котором также описан новый API
|-
| debug::index::miss
| Из объекта был считан неверный параметр (например c.foo)
| Объект и его ключ, который был считан
|-
| debug::newindex::miss
| Неверный параметр был записан в объект (например c.foo = &quot;bar&quot;)
| Объект, параметр, который будет записан и итоговое записанное значение
|}


== button ==
Генерируются сигналы связанные с &lt;code&gt;кнопками&lt;/code&gt; мыши:
{|
! Название
! Когда генерируется
! Аргументы
|-
| press
| При нажатии кнопки мыши + модификатора
| один или несколько аргументов
|-
| release
| Когда отпущена кнопка мыши + модификатор
| один или несколько аргументов
|-
| property::button
| При изменении свойства
| нет аргументов
|-
| property::modifiers
| При изменении свойства
| нет аргументов
|}

== client ==
Генерируются сигналы &lt;code&gt;клиентов&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| new
|
| один аргумент
|-
| manage
|
| два аргумента
|-
| unmanage
|
| один аргумент
|-
| list
| Перед manage, после unmanage, и при обмене(swap) клиентов
| нет
|-
| focus
| При получении клиентом фокуса
| объект клиента
|-
| unfocus
| при потере фокуса клиентом
| объект клиента
|-
| tagged
| когда клиент tagged(помечен)
| новый тег
|-
| untagged
| когда клиент убирается с тега
| удаляемый тег
|-
| marked
|
| неизвестно
|-
| unmarked
|
| неизвестно
|-
| property::above
| При изменении свойства
| нет
|-
| property::below
| При изменении свойства
| нет
|-
| property::border_color
| При изменении свойства
| нет
|-
| property::border_width
| При изменении свойства
| нет
|-
| property::class
| При изменении свойства
| нет
|-
| property::floating
| При изменении свойства
| неизвестно
|-
| property::fullscreen
| При изменении свойства
| нет
|-
| property::geometry
| Когда изменяется длина или ширина
| нет
|-
| property::group_window
| При изменении свойства
| нет
|-
| property::height
| При изменении свойства
| нет
|-
| property::hidden
| При изменении свойства
| нет
|-
| property::icon
| При изменении свойства
| нет
|-
| property::icon_name
| При изменении свойства
| нет
|-
| property::instance
| При изменении свойства
| нет
|-
| property::machine
| При изменении свойства
| нет
|-
| property::maximized_horizontal
| При изменении свойства
| нет
|-
| property::maximized_vertical
| При изменении свойства
| нет
|-
| property::minimized
| При изменении свойства
| нет
|-
| property::modal
| При изменении свойства
| нет
|-
| property::name
| При изменении свойства
| нет
|-
| property::ontop
| При изменении свойства
| нет
|-
| property::opacity
| При изменении свойства
| нет
|-
| property::pid
| При изменении свойства
| нет
|-
| property::role
| При изменении свойства
| нет
|-
| property::screen
| При изменении свойства
| неизвестно
|-
| property::size_hints_honor
| При изменении свойства
| нет
|-
| property::skip_taskbar
| При изменении свойства
| нет
|-
| property::sticky
| При изменении свойства
| нет
|-
| property::struts
| При изменении свойства
| нет
|-
| property::transient_for
| При изменении свойства
| нет
|-
| property::type
| При изменении свойства
| нет
|-
| property::urgent
| При изменении свойства
| нет
|-
| property::width
| При изменении свойства
| нет
|-
| property::window
| При изменении свойства
| нет
|-
| property::x
| При изменении свойства
| нет
|-
| property::y
| При изменении свойства
| нет
|-
| property::buttons
| При изменении свойства
| нет
|-
| property::keys
| При изменении свойства
| нет
|}

== dbus ==
Сигналы генерируются объектами &lt;code&gt;dbus&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| (interface name)
| 
| Таблица этого формата:
&lt;P&gt;&lt;pre&gt;
	{
			type: [signal,method_call,method_return,error,unknown] -- one of those options
			interface: ...
			path: ...
			member: ...
			bus: [system,session] -- one of those options
	}
&lt;/pre&gt;&lt;/P&gt;
Обработчик должен вернуть четное число значений.
|}

== key ==
Генерируются сигналы связанные с &lt;code&gt;клавишами&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| press
|
| один аргумент+
|-
| release
|
| один аргумент+
|-
| property::modifiers
| При изменении свойства
| нет
|-
| property::key
| При изменении свойства
| нет
|}

== menu ==
Генерируются сигналы связанные с объектами &lt;code&gt;меню&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| mouse::enter
|
| нет
|-
| mouse::leave
|
| нет
|}

== screen ==
Генерируются сигналы связанные с &lt;code&gt;экраном&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| padding (from awful.screen)
|
| неизвестно
|-
| arrange (from awful.layout)
|
| неизвестно
|-
| tag::attach
|
| один аргумент
|-
| tag::detach
|
| один аргумент
|-
| tag::history::update
|
| неизвестно
|-
| property::screen
| При изменении свойства
| неизвестно
|-
| property::workarea
| При изменении свойства
| неизвестно
|}

== tag ==
Генерируются сигналы связанные с &lt;code&gt;тегами&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| tagged
|
| неизвестно
|-
| property::name
| При изменении свойства
| нет
|-
| property::screen
| При изменении свойства
| нет
|-
| property::selected
| При изменении свойства
| объект тег
|-
| property::filtered
| При изменении свойства
| неизвестно
|-
| property::hide
| При изменении свойства
| неизвестно
|-
| property::icon
| При изменении свойства
| неизвестно
|-
| property::layout
| При изменении layout для тега
| объект тег
|-
| property::mwfact
| При изменении свойства
| объект тег
|-
| property::ncol
| При изменении свойства
| объект тег
|-
| property::nmaster
| При изменении свойства
| объект тег
|-
| property::windowfact
| При изменении свойства
|
|}

== timer ==
Генерируются сигналы связанные с &lt;code&gt;таймерами&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| timeout
|
| нет
|-
| property::timeout
| При изменении свойства
| нет
|}

== tooltip ==
Генерируются сигналы &lt;code&gt;tooltip&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| mouse::enter
|
| нет
|-
| mouse::leave
|
| нет
|}

== wibox ==
Сигналы генерируются объектами &lt;code&gt;wibox&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| mouse::enter
|
| нет
|-
| mouse::leave
|
| нет
|-
| property::geometry
| При изменении длины или ширины? (не уверен, что будет генерироваться)
| неизвестно
|-
| property::bg
| При изменении свойства
| нет
|-
| property::bg_image
| При изменении свойства
| нет
|-
| property::border_color
| При изменении свойства
| нет
|-
| property::border_width
| При изменении свойства
| нет
|-
| property::buttons
| При изменении свойства
| нет
|-
| property::cursor
| При изменении свойства
| нет
|-
| property::fg
| При изменении свойства
| нет
|-
| property::height
| При изменении свойства
| нет
|-
| property::ontop
| При изменении свойства
| нет
|-
| property::opacity
| При изменении свойства
| неизвестно
|-
| property::orientation
| При изменении свойства
| нет
|-
| property::screen
| При изменении свойства
| нет
|-
| property::shape_bounding
| При изменении свойства
| нет
|-
| property::shape_clip
| При изменении свойства
| нет
|-
| property::struts
| При изменении свойства
| нет
|-
| property::visible
| При изменении свойства
| нет
|-
| property::widgets
| При изменении свойства
| нет
|-
| property::width
| При изменении свойства
| нет
|-
| property::x
| При изменении свойства
| нет
|-
| property::y
| При изменении свойства
| нет
|}

== widget ==
Сигналы генерируются &lt;code&gt;widget&lt;/code&gt;:
{|
! Название
! Когда генерируется
! Аргументы
|-
| press
|
| один или более аргументов
|-
| release
|
| один или более аргументов
|-
| mouse::enter
|
| нет
|-
| mouse::leave
|
| нет
|-
| property::buttons
| При изменении свойства
| нет
|-
| property::type
| При изменении свойства
| нет
|-
| property::visible
| При изменении свойства
| нет
|}

== &quot;Раннее&quot; управление ==

По умолчанию есть обработчик &quot;управления&quot; сигналами - awful.rules.apply(c). И этот обработчик связывает приложение с текущим тегом.
Иногда может потребоваться выполнить какие то действия с приложением перед тем, как обработчик будет запущен. Вот один из возможных способов решения этой проблемы - он добавляет сигнал &quot;early_manage&quot; которые генерируется, для управления новым приложением до запуска awful.rules.apply(c). В основном это тот же сигнал управления, но его обработчик запускается до  &quot;управляющего&quot; сигнала обработчика. Исходник: https://github.com/dobrover/myawesome/blob/master/awesome/utils/early_manage.lua

  local early_manage = {}
  
  -- Module that adds &quot;early_manage&quot; signal that is executed
  -- before default awesome &quot;manage&quot; signal handler (which is awful.rules.apply)
  -- Usage: put require('early_manage').setup() at the top of rc.lua
  -- And then just use &quot;early_manage&quot; signal as normal &quot;manage&quot;.
  
  local capi = {
      client = client,
  }
  local awful = require 'awful'
  
  function early_manage.on_before_manage(...)
      -- Relies on the fact that emit_signal simply calls every signal handler
      -- in the current event handler.
      capi.client.emit_signal(&quot;early_manage&quot;, ...)
  end
  
  function early_manage.setup()
      if not early_manage._setup then
          early_manage._setup = true
          capi.client.add_signal(&quot;early_manage&quot;)
          capi.client.disconnect_signal(&quot;manage&quot;, awful.rules.apply)
          capi.client.connect_signal(&quot;manage&quot;, early_manage.on_before_manage)
          capi.client.connect_signal(&quot;manage&quot;, awful.rules.apply)
      end
  end
  
  return early_manage</text>
      <sha1>jg90z1yo80u0vjgz08l8ew7bw5p1air</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Simple Clock</title>
    <ns>0</ns>
    <id>15</id>
    <revision>
      <id>1291</id>
      <timestamp>2008-10-16T15:06:57Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="4357">These are simple instructions to add a clock to your Awesome status bar. Or, more basically, this example is used to create a simple widget using simple techniques. While the script used to populate the data isn't the best, it's functional. At the bottom of the page is a better script to be used to achieve the same results.

With these simple techniques, you can create widgets that update from virtually any source of data.

== Adding the text field to your .awesomerc ==

Edit your ~/.awesomerc and add to the &quot;screen/statusbar&quot; section - this is just a skeleton config file to make sure the code is put into the right spot:

 screen 0
 { 
  ... config file snipped ...
 statusbar mystatusbar {
    ...config file snipped ...
   taglist mytag {
     ...config file snipped ...
   }
   layoutinfo mylayout {
     ...config file snipped ...
   }
   #
   # Add the lines below to create the clock
   #
   textbox clock {
     text_align = &quot;right&quot;
     align = &quot;right&quot; 
     width = &quot;100&quot; # Note: Once you get this working, you may need to tweak the 'width' a bit depending on the font you're using.
   }
   #
   # Stop here
   #
 }


== Populate the data in the widget (awesome 2.2) ==

Create ~/bin/awesome-clock (You can add .sh if you would like)

 #!/bin/sh
 # this script is for awesome 2.2
 
 updateClock() {
   # See 'man date' to see the possible replacements for the % fields.
   echo &quot;0 widget_tell clock `date +\&quot;%a, %b %d %I:%M%p\&quot;`&quot; | awesome-client
 }
 
 while true; do
   updateClock
   sleep 10;
 done

Make it executable:

  $ chmod a+x ~/bin/awesome-clock

For awesome 2.3.x just change the piped echo command in the script above to:

    echo &quot;0 widget_tell mystatusbar clock text `date +\&quot;%a, %b %d %I:%M%p\&quot;`&quot; | awesome-client

== Populate the data in the widget (awesome-2.3) ==

Create ~/bin/awesome-clock (You can add .sh if you would like)

 #!/bin/sh
 # this script is for awesome 2.3
 
 # Point this to a directory you can write to. 
 #PID=~/var/run/awesome_clock.pid
 PID=~/bin/awesome_clock.pid
 
 updateClock() {
    # See 'man date' to see the possible replacements for the % fields.
    echo &quot;0 widget_tell mystatusbar clock text &quot;   &quot; `date +\&quot;%a, %b %d %I:%M %p\&quot;`&quot; | awesome-client
 }
 
 # This will prevent this script from running multiple times
 if [ -f $PID ] ; then
    kill -0 `cat $PID` 2&gt; /dev/null
    if [ $? -ne 0 ] ; then
        echo &quot;[&quot;`date`&quot;] $0 killed bogus lock file [&quot;`cat $PID`&quot;]&quot;
    else
        echo &quot;[&quot;`date`&quot;] $0 already running [&quot;`cat $PID`&quot;]&quot;
        exit
    fi
 fi
 echo $$ &gt; $PID
 
 while true; do
   updateClock
   sleep 10;
 done

Make it executable:

  $ chmod a+x ~/bin/awesome-clock

If you get a message like:
 W: awesome: send_msg:60: can't write to /home/username/.awesome_ctl.0

then just creat a blank file called &quot;.awesome_ctl.0&quot; in your home directory.

== Troubleshooting ==
Before adding to .xinitrc, doing a manual test to make sure everything is set up correctly is a good idea. To test or troubleshoot this setup, you can run (for awesome-2.3)

  echo &quot;0 widget_tell mystatusbar clock text &quot;   &quot; `date +\&quot;%a, %b %d %I:%M %p\&quot;`&quot; | awesome-client

From a terminal command line to verify the clock update function works properly

== Make the clock auto-start with X ==

Add the following lines to ~/.xinitrc if you want it to start up every time you start awesome

    ~/bin/awesome-clock &amp;
    exec awesome


== A Better Method for sending the data==
[[Category:awesome2]]
The above methods are to show the flexibility of using the awesome-client command. A better script to accomplish the same is the below:

Create ~/bin/better-awesome-clock

  #!/bin/sh
  #
  while true 
  do
        if [ -S ~/.awesome_ctl.0 ]; then
                while true
                do
                        # See 'man date' to see the possible replacements for the % fields.
                        # uncomment the following line for use with awesome 2.3
                        # echo &quot;0 widget_tell mystatusbar clock text &quot;   &quot; `date +\&quot;%a, %b %d %I:%M %p\&quot;`&quot;
                        echo &quot;0 widget_tell clock &quot;   &quot; `date +\&quot;%a, %b %d %I:%M %p\&quot;`&quot;
                        echo &quot;&quot; # an empty line flushes data inside awesome
                        sleep 1
                done | awesome-client
        else
            sleep 1
        fi
  done

[[Category:StatusBars]]
[[Category:Widgets]]</text>
      <sha1>mr57xp0scgr0qeg8mvuruvkhm24hx3g</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Simple Maildir Biff Widget</title>
    <ns>0</ns>
    <id>305</id>
    <redirect title="Simple Maildir Biff Widget (Pure Lua)" />
    <revision>
      <id>2456</id>
      <timestamp>2009-03-17T10:42:09Z</timestamp>
      <contributor>
        <username>Frax</username>
        <id>113</id>
      </contributor>
      <comment>[[Simple Maildir Biff Widget]] moved to [[Simple Maildir Biff Widget (Pure Lua)]]</comment>
      <text xml:space="preserve" bytes="51">#REDIRECT [[Simple Maildir Biff Widget (Pure Lua)]]</text>
      <sha1>cwheb8wa73fz7smdo88kg1g882xhxzx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Simple Maildir Biff Widget (Pure Lua)</title>
    <ns>0</ns>
    <id>144</id>
    <revision>
      <id>2457</id>
      <parentid>2455</parentid>
      <timestamp>2009-03-17T10:42:46Z</timestamp>
      <contributor>
        <username>Frax</username>
        <id>113</id>
      </contributor>
      <text xml:space="preserve" bytes="2173">by [[User:Frax|Fredrik Ax]] &lt;mailto:frax@axnet.nu&gt;
{|cellpadding=&quot;5&quot; cellspacing=&quot;0&quot; style=&quot;margin: 0em&quot; width=&quot;100%&quot;
|- style=&quot;background: #aea&quot;
| This widget is written entirely in LUA for awesome 3.0.
It requires you to have 'find' and 'wc' in your path.
|}

This widget uses a simple textbox widget to show the number of new and unread messages in a Maildir folder structure. It uses a timer hook to update the widget in intervals, but I might look into doing it with inotify in the next version. The update function uses find to recursively find new and &quot;old&quot; (lacking the Seen-flag) messages.

Everything is to be implemented in your awesome/lua.rc.

These globals are used for configuration:
 -- Root for Maildir tree to be checked
 mdbiffroot= &quot;$HOME/Mail&quot;
 
 -- Check interval (seconds)
 mdbiffint= 300


Creating the textbox, named mymdbiff:
 mymdbiff = widget({ type = &quot;textbox&quot;, name = &quot;mymdbiff&quot;, align = &quot;right&quot; })
Don't forget to add it to some statusbar for it to be useful ;-)

The function to be called by the timer hook:
 function hook_mdbiff ()
     local fh = io.popen(&quot;find &quot;..mdbiffroot..&quot; -type f -wholename '*/new/*' | wc -l&quot;)
     if fh == nil then
         mymdbiff.text = &quot;&amp;lt;b&amp;gt;ERR&amp;lt;/b&amp;gt; (&quot;
     else 
         mymdbiff.text = &quot;&amp;lt;b&amp;gt;&quot;	
         for l in fh:lines() do
             mymdbiff.text = mymdbiff.text .. l
         end
         io.close(fh)
         mymdbiff.text = mymdbiff.text .. &quot;&amp;lt;/b&amp;gt;&quot;
     end
     fh = io.popen(&quot;find &quot;..mdbiffroot..&quot; -type f -regex '.*/cur/.*2,[^S]*$' | wc -l&quot;)
     if fh == nil then
         mymdbiff.text = mymdbiff.text .. &quot; (ERR)&quot;
     else 
         mymdbiff.text = mymdbiff.text .. &quot; (&quot;	
         for l in fh:lines() do
             mymdbiff.text = mymdbiff.text .. l
         end
         io.close(fh)
         mymdbiff.text = mymdbiff.text .. &quot;)&quot;
     end
 end
 
Run the hook function from you rc.lua file once to initialize the widget.
 hook_mdbiff()

Register the timer hook:
 awful.hooks.timer.register(mdbiffint, hook_mdbiff)

Add mouse click action:
 mymdbiff:mouse_add(mouse({ }, 1, function () hook_mdbiff() end))


Enjoy&lt;br&gt;
-- frax

[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>0v96rz20ssuzmx9yawnw612qtvq3uj3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Skype</title>
    <ns>0</ns>
    <id>969</id>
    <revision>
      <id>6203</id>
      <parentid>6200</parentid>
      <timestamp>2014-01-08T16:51:26Z</timestamp>
      <contributor>
        <username>Y2kbugger</username>
        <id>3137</id>
      </contributor>
      <comment>/* Cause floating skype call windows to automatically follow to all workspaces */</comment>
      <text xml:space="preserve" bytes="1806">Sometimes you would like a skype video call to persist no matter what tags you select.
this was written for version 3.5

==Cause floating skype call windows to automatically follow to all workspaces==

add this to your rc.lua

--enable floating skype call windows to persist

local is_skype_call = function (c)
    return awful.rules.match(c, {class = &quot;Skype&quot; , role = &quot;CallWindow&quot; })
end
tag.connect_signal(&quot;property::selected&quot;,
    function(tag)
        if tag.selected then --not for the one that is being unselected
            for c in awful.client.iterate(is_skype_call) do
                if awful.client.floating.get(c) then
                    awful.client.movetotag (awful.tag.selected(), c)
                    c.ontop = true
                end
            end
        end
    end)

==set up skype call windows to start out floating==

insert these two rules after the preexisting rules in your rc.lua

-- {{{ Rules

awful.rules.rules = {
....snip....
    { rule = { class = &quot;Skype&quot; },
      properties = { tag = tags[1][9],
                     floating = false
                     } },
    { rule = { class = &quot;Skype&quot; , role = &quot;CallWindow&quot; },
      properties = { tag = tags[1][9],
                      floating = true
                     } },
}

==Resizing and Moving==
remember, by default you can move and resize floating windows via:

Mod4 + Button1 on client window: Move window

Mod4 + Button3 on client window: Resize window

since i am using a laptop, i changed Button3 to Button2:

....snip....
                awful.button({ }, 2, function()
                    client.focus = c
                    c:raise()
                    awful.mouse.client.resize(c)
                end)
....snip....

==Locking a skype call window==
use the default keybinding for toggling window floating</text>
      <sha1>bh575on5fw7rp29bgp1e0g9ctu7ehoj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Solutions For google adsense alternatives</title>
    <ns>0</ns>
    <id>1250</id>
    <revision>
      <id>7162</id>
      <timestamp>2014-12-18T06:18:59Z</timestamp>
      <contributor>
        <username>RebekahUUR</username>
        <id>4156</id>
      </contributor>
      <comment>Created page with &quot;If about to catch knowledgeable about Ad - Words, I advise you to show off of the content network first. When you wish to ascend this pyramid, the first thing to do would be t...&quot;</comment>
      <text xml:space="preserve" bytes="2574">If about to catch knowledgeable about Ad - Words, I advise you to show off of the content network first. When you wish to ascend this pyramid, the first thing to do would be to be sure that your website is optimised properly for SEO. Today Google has reached every town and small villages too perhaps every local person on national and international level identifies them with Google. Any marketer online should not be pleased with just finding the articles promoting their product or site classified by Google. &lt;br&gt;&lt;br&gt;As all internet communications likely to and from China traverses routers owned by the Chinese government, politically sensitive queries were blocked from making it to Google's servers, the service was made slow and unreliable, and infrequently unavailable for longer periods of time as search queries were re-routed to local Chinese search engines. First, the same as Facebook you have to build a following. It launched in June 2011, and is also simply called Google+. Finally, say I do have 3 offers who use the Ad Slot under consideration, by setting the Delivery Priority, CPM and Per User Frequency Cap correctly I should be in a position to offer all 3 of these inside the first 3 page loads, but let's say this user loads 5 pages. &lt;br&gt;&lt;br&gt;So what exactly are a lot of things to understand when designing a website. Honour the language used that got these potential customers for a site. While creating ads for Google Ad - Words, it can be imperative that you make certain that the ad is good enough to encourage the readers to click on it. You have several options to produce a header and logo. &lt;br&gt;&lt;br&gt;I should avoid using cross-country ski resorts unless I mention some. Once you've captured Google's attention, keeping it's another thing. For example, the Web Editor I use has a page view for &quot;Source&quot;, that can show each of the code to the page. Smaller directories still involve some importance on the net, but it really is not like it used to become. &lt;br&gt;&lt;br&gt;Except few from the features like Circles, privacy settings and editing a wall post, I didnt find other things much completely different from Facebook. Well as you know the Internet has changed the best way trading occurs. 00 to get a twelve months SEO service, revisit the situation. Google launched its most awaited and highly anticipated online community site and has 750 millions users all throughout the world in the development phase.&lt;br&gt;&lt;br&gt;Here's more information on [http://www.Lmgtfy.com/?q=create+google+plus+account google adsense alternatives] stop by our own web-site.</text>
      <sha1>cu50vb0p5a6k1c5d7sxnfj5lna4ygg8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Some problems/ru</title>
    <ns>0</ns>
    <id>1101</id>
    <revision>
      <id>6713</id>
      <timestamp>2014-06-06T08:46:01Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{Languages|Some problems}} {{DISPLAYTITLE:Известные проблемы и их устранение}}  == Баг в отличной от US раскладке ==  Н...&quot;</comment>
      <text xml:space="preserve" bytes="2132">{{Languages|Some problems}}
{{DISPLAYTITLE:Известные проблемы и их устранение}}

== Баг в отличной от US раскладке ==

На сегодняшний день есть баг, когда переключаешься например на Русский язык, перестают реагировать на мышь теги и виджеты.

=== Первый способ ===
Одним из способов решения проблемы это попробовать откатится на старую версию xkbcomp. Баг известен с xkbcomp 1.2.4, т.е откат нужно делать до версии 1.2.3. 
'''Примечание:''' Возможны проблемы с зависимостями.

=== Второй способ ===
Необходимо закомментировать следующие строки в файле /usr/share/X11/xkb/compat/basic (под root)
&lt;pre&gt;
group 2 = AltGr;
group 3 = AltGr;
group 4 = AltGr;
&lt;/pre&gt;
Правда в этом случае могут перестать работать горячие клавиши (связанные с буквами) в отличной от US раскладке. 
Для решения этой проблемы можно использовать не буквенные сочетания клавиш, а непосредственно коды этих клавиш, получить их можно использовав:
   xev | grep 'keycode'
Например у меня это настроено примерно так:
 awful.key({}, &quot;#122&quot;, function () awful.util.spawn(&quot;amixer set Master 3%-&quot;) end),

=== Третий способ ===
Нужно выполнить в терминале следующий код:
   xkbcomp $DISPLAY - | egrep -v &quot;group . = AltGr;&quot; | xkbcomp - $DISPLAY
В данном случае код будет работать до перезагрузке. Если хотите, чтобы работал постоянно, оформите в виде скрипта и поставьте в автозагрузку.</text>
      <sha1>roux3dw8skrx04w5bs9v4kgmfbdnan3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Space Invaders</title>
    <ns>0</ns>
    <id>165</id>
    <revision>
      <id>6671</id>
      <parentid>2397</parentid>
      <timestamp>2014-05-26T10:08:16Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="3492">{{Languages}}

= Awesome Invaders =

== Introduction ==
[[Image:Invaders-1224192643.png|thumb|Screenshot of Awesome Invaders]]
Awesome Invaders is, as the name says, an implementation of Space Invaders using Awesome 3's Lua interface. Everything is displayed using the new WiBox from Awesome 3 GIT, which allows arbitrary placement of widgets anywhere on the screen. On this page, I will walk you through setting it up and running.

== Setting it up ==

=== Prerequisites ===

* Awesome 3 GIT, get this from git with the following command:
  git clone git://git.naquadah.org/awesome.git

=== Editing the config file ===

Open up '''~/.config/awesome/rc.lua''' with your favourite editor. The top of the file should look like this (or similar):
  require('awful')
  require('beautiful')

Add the following line below the last line containing a '''require''', in this case, you would add it after '''require('beautiful')''':
  require('invaders')

The result should look similar to this:
  require('awful')
  require('beautiful')
  require('invaders')

Then, find the section of your configuration file where keybindings are set. It may look something like this:
  [...]
  keybinding({ modkey, &quot;Mod1&quot; }, &quot;c&quot;, function () client.focus:kill() end):add()
  keybinding({ modkey }, &quot;Up&quot;, function () awful.client.focus.byidx(-1); client.focus:raise() end):add()
  keybinding({ modkey }, &quot;Down&quot;, function () awful.client.focus.byidx(1);  client.focus:raise() end):add()
  keybinding({ modkey }, &quot;Left&quot;, function () awful.client.swap(1) end):add()
  [...]

Add a keybinding to start invaders like this:
  keybinding({ modkey, &quot;Mod1&quot; }, &quot;i&quot;, invaders.run):add()

=== Running the game with awesome-client / the lua prompt ===

You can also run the game without the need to edit your config file. Simply run awesome-client in a terminal, then run the following two commands:

  require('invaders')
  invaders.run()

The same can be done with the lua prompt if you are running Awesome from the next branch of the git repository.

=== Running the game without awesome-client ===

To start the game, press the keybinding you just specified. If you copied the above one, hit Modkey+Alt+i. Pressing left and right moves your spaceship, space fires. If you want to quit the game, press Q. Pressing S will create a screenshot in ~/.cache/awesome. For creating screenshots, you need ImageMagick installed.

Note #1: On some systems, X and awesome might eat a lot of ressources while running Space Invaders. This performance impact should vanish once you quit the game. If not, let me know about it.

Note #2: If you run the game on top of other windows, you will notice squares around the player and enemies. Through these squares, the screens background is shining through, therefore, it is the best if you run the game on a free tag with no windows behind it.

=== Running the game from the awesome menu ===

After requiring invaders from either your rc.lua file or awesome-client, you can launch the game from your awesome menu with this entry:

   { &quot;Invaders&quot;, invaders.run }

== Acknowledgements ==

[[User:Farhaven|I]] wrote the code for the game, while Garoth made the sprites. If you want to comment, complain, compliment on this piece of code, please keep in mind that this is more of a proof-of-concept than of a completely functioning game, and drop me a line in #awesome.

Also, if you are having problems, please make sure to grab the latest GIT checkout.

Have fun playing :)
[[Category:awesome3]]</text>
      <sha1>2dw9ctqtuc6nkb4q1wmvodafh1k1hnf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Space Invaders/ru</title>
    <ns>0</ns>
    <id>1090</id>
    <revision>
      <id>6673</id>
      <timestamp>2014-05-26T13:06:22Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Space Invaders (translating page)</comment>
      <text xml:space="preserve" bytes="5392">{{Languages|Space Invaders}}

= Awesome Invaders =

== Введение ==
[[Image:Invaders-1224192643.png|thumb|Скриншот Awesome Invaders]]
Awesome Invaders, как следует из название, это реализация Space Invaders с использованием интерфейса Awesome 3 Lua. Все что отображается использует новые Wibox из Awesome 3 GIT, который позволяет свободное размещение виджетов где угодна на экране. На этой странице, я расскажу о его установке и запуске.

== Установка ==

=== Требования ===

* Скачайте Awesome 3 GIT с помощью следующей команды:
  git clone git://git.naquadah.org/awesome.git

=== Редактирование конфигурационых файлов ===

Откройте в вашем любимом редакторе '''~/.config/awesome/rc.lua'''. В верхней части файла проверьте наличие следующиего кода (или похожего):
  require('awful')
  require('beautiful')

Добавьте следующую строку после последней строки содержащей '''require''', в нашем случае ее нужно добавить после '''require('beautiful')''':
  require('invaders')

В результате у вас должно получиться что то похожее на это:
  require('awful')
  require('beautiful')
  require('invaders')

Затем, найдите секцию с клавиатурными сочетаниями. Она может выглядесь следующим образом:
  [...]
  keybinding({ modkey, &quot;Mod1&quot; }, &quot;c&quot;, function () client.focus:kill() end):add()
  keybinding({ modkey }, &quot;Up&quot;, function () awful.client.focus.byidx(-1); client.focus:raise() end):add()
  keybinding({ modkey }, &quot;Down&quot;, function () awful.client.focus.byidx(1);  client.focus:raise() end):add()
  keybinding({ modkey }, &quot;Left&quot;, function () awful.client.swap(1) end):add()
  [...]

Добавьте слеюующее сочетание клавиш для запуска invaders:
  keybinding({ modkey, &quot;Mod1&quot; }, &quot;i&quot;, invaders.run):add()

=== Запуск игры через awesome-client/lua prompt ===

Вы можете также запустить игру без редактирования вашего конфигурационного файла. Просто запустите awesome-client в терминале, затем введите следующие две команды:

  require('invaders')
  invaders.run()

То же самое вы можете сделать без запуска терминала, из приглашения Lua prompt (обычно Mod+x по умолчанию)

=== Запуск игры без запуска awesome-client ===

Для запуска игры, нажмите клавиши, которые вы определили. Если вы сделали как описано выше, это будут Modkey+Alt+i. Нажимая влево и вправо вы перемещаете ваш корабль, пробел для стрельбы. Если вы хотите выйти из игры, нажмите Q. Нажатие S сделает скриншот в ~/.cache/awesome. Для создания скриншотов, вам требуется установленный ImageMagick.

Примечание #1: На некоторых системах, X и Awesome могут потреблять много ресурсов при запуске Space Invaders. Это влияние на производительность снижается когда вы выходите из игры. Если это не так, дайте мне знать об этом.

Примечание #2: Если вы запустили игру поверх всех окон, вы заметите квадраты вокруг игрока и врагов. Через эти квадраты, будет просвечивать фон, поэтому, будет лучше, если вы будете запускать игру без присвоения ей тега и без окон позади.

=== Запуск игры из меню awesome ===

После подключения invaders в вашем rc.lua или в awesome-client, вы можете запустить игру из меню с помощью этой записи:

   { &quot;Invaders&quot;, invaders.run }

== Уведомление ==

Пользователь [[User:Farhaven|Farhaven]] написал код для игры, пока Garoth делал спрайты. Если вы хотите прокоментировать, пожаловаться или поблагодарить за этот код, пожалуйста имейте в виду, что это скорее правильности концепции чем полноценно фунционирующая игра и напишите мне в #awesome.

Также, если у вас возникают проблемы, убедитесь, что вы скачали последнюю версию с GIT.

Приятной игры :)
[[Category:awesome3]]</text>
      <sha1>9v4pmpql762eazeyan2mvwi6j8z2xsp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Spawning Windows Where Launched</title>
    <ns>0</ns>
    <id>537</id>
    <redirect title="User:Garoth/Spawning Windows Where Launched" />
    <revision>
      <id>4016</id>
      <timestamp>2010-01-28T20:07:45Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Spawning Windows Where Launched]] to [[User:Garoth/Spawning Windows Where Launched]]:&amp;#32;Doesn't really belong into the main space, this is not even a work-in-progress.</comment>
      <text xml:space="preserve" bytes="57">#REDIRECT [[User:Garoth/Spawning Windows Where Launched]]</text>
      <sha1>rvyix3fown7lnk815hwy1thf5z6opti</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>SpeakerWidget</title>
    <ns>0</ns>
    <id>1206</id>
    <revision>
      <id>7068</id>
      <parentid>7067</parentid>
      <timestamp>2014-10-20T23:32:42Z</timestamp>
      <contributor>
        <username>Awaxx</username>
        <id>3762</id>
      </contributor>
      <comment>/* plugins for a shiny systray sound volume icon in your systray! works on awesome 3.4 */</comment>
      <text xml:space="preserve" bytes="7035">
== Heh, next time avoids to write shit like this ... == message by Awaxx

Using an awesome.widget.launcher, I've created a simple speaker widget, which will change its icon to muted, or high or low volume. Eventually I want to be able to click on the speaker icon and open alsamixer, but I cannot figure out how to do that, but I'm open to suggestions. You're going to want to down load and and untar the Faenza icon theme from https://code.google.com/p/faenza-icon-theme/downloads/list and put it in ~/.config/awesome/icons/Faenza/



Here is a youtube video to show you how the speaker widget works now:

https://www.youtube.com/watch?v=be7OwUsm6Y4&amp;list=UU8sTvGJGIMFPP48K7CNmx-Q


Here is the code that'll make the magic happen:

Create a file called ~/.config/awesome/speaker.lua and put in it:

&lt;pre&gt;
local awful = require ('awful')
--let's get the percent that the speakers are on
-- this code only works because amixer outputs whole numbers for percents

--define a global variable.
volume = &quot;off&quot;
--let's find out if the speakers are on
if os.execute(&quot;amixer get Master | grep '\\[on\\]'&quot;) then
   volume = &quot;on&quot;
else
   volume = &quot;off&quot;
end

-- let's find out what percent the speakers are on
percent = os.capture (&quot;amixer get Master | grep % | gawk '{ print $4 }' &quot;, raw)
if string.len(percent) == 4 then
   percent = 0
elseif string.len(percent) == 5 then
   percent = tonumber (string.sub (percent, 2, 3))
else
   percent = 100
end


if (percent &lt;= 30) then
   alsamixer_launcher   = awful.widget.launcher({ image = configd .. &quot;icons/Faenza/status/48/audio-volume-off.png&quot;,
						  command = awful.util.spawn_with_shell(terminal .. &quot; alsamixer&quot;) })
elseif (percent &gt;= 31) and (percent &lt; 61) then
   alsamixer_launcher   = awful.widget.launcher({ image = configd .. &quot;icons/Faenza/status/48/audio-volume-low.png&quot;,
						  command = awful.util.spawn_with_shell(terminal .. &quot; alsamixer&quot;) })
elseif (percent &gt;= 62) and (percent &lt; 92) then
   alsamixer_launcher   = awful.widget.launcher({ image = configd .. &quot;icons/Faenza/status/48/audio-volume-medium.png&quot;,
						  command = awful.util.spawn_with_shell(terminal .. &quot; alsamixer&quot;) })
else  -- p &gt;= 88
   alsamixer_launcher   = awful.widget.launcher({ image = configd .. &quot;icons/Faenza/status/48/audio-volume-high.png&quot;,
						  command = awful.util.spawn_with_shell(terminal .. &quot; alsamixer&quot;) })
end

&lt;/pre&gt;

In your rc.lua add this:

&lt;pre&gt;
beautiful.init(&quot;/home/joshua/.config/awesome/themes/zenburn/theme.lua&quot;)
--change this line next line to YOUR CONFIG PATH. My configd looks like:
configd = &quot;/home/joshua/.config/awesome/&quot;
editor_cmd = terminal .. &quot; -e &quot; .. editor

dofile (configd .. &quot;speaker.lua&quot;)

local right_layout = wibox.layout.fixed.horizontal()
   if s == 1 then right_layout:add(wibox.widget.systray()) end
   right_layout:add(alsamixer_launcher)
   right_layout:add(mytextclock)
   right_layout:add(mylayoutbox[s])
&lt;/pre&gt;

And that's all you need!


== plugins for a shiny systray sound volume icon in your systray! works on awesome 3.4 ==

[[File:Awaxx's laptop.png]]

Just put the volume.lua inside you $HOME/.config/awesome
be sure you have Faenza icons &amp; amixer installed on your system

the plugin work with your mouse (scroll increase/decrease volume and middle button to mute/unmute) but you may easily add a keybinding to:

increase sound : amixer set Master 3%+ 

decrease sound : amixer set Master 3%- 

unmute : amixer set Master unmute 

mute : amixer set Master mute

Look around Key binding inside you rc.lua
awful.key({ modkey, &quot;Control&quot; }, &quot;e&quot;,      function () awful.util.spawn(&quot;PROGRAM_NAME&quot;) end),

&lt;pre&gt;

-- by [Awaxx] for awesome community
local setmetatable = setmetatable
local io = io
local string = string
local tonumber = tonumber
local image = image
local awful = require(&quot;awful&quot;)
local widget = widget
local timer = timer

local icons_path = &quot;/usr/share/icons/Faenza-Dark&quot;
local sound = {
    high    = icons_path .. &quot;/status/16/audio-volume-high-panel.png&quot;, -- 66-100
    medium  = icons_path .. &quot;/status/16/audio-volume-medium-panel.png&quot;, -- 33-66
    low     = icons_path .. &quot;/status/16/audio-volume-low-panel.png&quot;, -- 0-33
    zero    = icons_path .. &quot;/status/16/audio-volume-low-zero-panel.png&quot;, -- 0
    mute    = icons_path .. &quot;/status/16/audio-volume-muted-blocked-panel.png&quot; -- mute
}

module(&quot;volume&quot;)

local devnull = &quot;&gt;/dev/null&quot;

local function update_icon()
    -- body
    f = io.popen(&quot;amixer get Master | tail -1 | awk '{print $4 $6}'&quot;)
    volume_data = f:read(11)
    f:close()

    volume_percent = tonumber(string.match(volume_data, &quot;(%d?%d?%d)%%&quot;))
    volume_state = string.match(volume_data, &quot;%[on]&quot;)

    if not volume_state then
        return sound.mute
    elseif not volume_percent then
        return sound.mute
    end

    if volume_percent == 0 then
        return sound.zero
    elseif volume_percent &lt;= 40 then
        return sound.low
    elseif volume_percent &lt;= 80 then
        return sound.medium
    else
        return sound.high
    end
end

local function mute()
    local f = io.popen(&quot;amixer get Master | tail -1 | awk '{print $4 $6}'&quot;)
    local data = f:read(11)
    f:close()
    local volstate = string.match(data, &quot;%[on]&quot;)
    if not volstate then
        awful.util.spawn_with_shell(&quot;amixer set Master unmute &quot; .. devnull, false)
    else
        awful.util.spawn_with_shell(&quot;amixer set Master mute &quot; .. devnull, false)
    end
end

function new()
    local w = widget({ type = &quot;imagebox&quot; })
    w.image = image(update_icon())
    w:buttons(awful.util.table.join(
      awful.button({ }, 4, function() awful.util.spawn_with_shell(&quot;amixer set Master 3%+ &quot; .. devnull, false) end), -- up --
      awful.button({ }, 5, function() awful.util.spawn_with_shell(&quot;amixer set Master 3%- &quot; .. devnull, false) end), -- down --
      awful.button({ }, 2, function() mute() end) -- mute -- amixer set Master unmute
    ))
    
    local recall = timer { timeout = 0.5 }
    recall:add_signal(&quot;timeout&quot;, function() w.image = image(update_icon()) end)
    recall:start()
    return w
end

setmetatable(_M, { __call = function(_, ...) return new(...) end })
------ end of volume.lua ------
&lt;/pre&gt;

and put :
&lt;pre&gt;
-- add it at the head of rc.lua after awful,beautiful requires()...
...
require('volume')
myvolume = volume()
...


-- then at the middle~~ of your rc.lua
-- add &quot;myvolume,&quot; to your wibox which handle your menus , taglists, taskbars...
-- i provide an example (you just need add myvolume,):
...
    -- Add widgets to the wibox - order matters -------------------------------
    mywibox[s].widgets = {
        {
            mylauncher,
            mytaglist[s],
            mypromptbox[s],
            layout = awful.widget.layout.horizontal.leftright
        },
        mylayoutbox[s],
        mytextclock,
        myvolume,                                      &lt;&lt;=============================== THERE 
        s == 1 and mysystray or nil,
        mytasklist[s],
        layout = awful.widget.layout.horizontal.rightleft
    }
...
&lt;/pre&gt;

By [Awaxx] you can contact me with irc:oftc/#awesome</text>
      <sha1>auhoqxc1u1drfsk3bwg88qfujvj1zdw</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Status Bar with Amazing</title>
    <ns>0</ns>
    <id>88</id>
    <revision>
      <id>1295</id>
      <timestamp>2008-10-16T15:08:19Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <comment>/* xinitrc */</comment>
      <text xml:space="preserve" bytes="4027">= HOW-TO: Awesome WM and Amazing scripts used for CPU load, memory usage, network traffic graphs etc. in status bar of Awesome WM =

Widgets in Awesome offer a flexible way of showing stuff like CPU load graph, memory usage progress bar or network usage... 
This was usually managed by piping the data to awesome-client, but there are Amazing ruby scripts which take care of that and make it simpler - mostly because number of pre-made widgets.

Awesome 2.3 and Amazing master (from git) should work.
 
Archlinux people can:
&lt;pre&gt;yaourt -S awesome-git amazing-git&lt;/pre&gt; 
(don't forget to change the branch in amazing-git pkgbuild).

== awesomerc ==

If you installed Awesome right now:
&lt;pre&gt;cp /usr/share/awesome/awesomerc ~/.awesomerc&lt;/pre&gt;

Now lets add some widgets. They are being added to the statusbar part of the configuration file (~/.awesomerc).

&lt;pre&gt;        emptybox &quot;spacea&quot; { width = 4 }
        progressbar &quot;batt&quot;
        {
           vertical = true
           height = 1
           width = 8
           data &quot;battdata&quot;
           {
               bordercolor = &quot;#222222&quot;
               fg = &quot;#333333&quot;
               bg = &quot;#000000&quot;
               fg_off = &quot;#000000&quot;
           }
        }
        emptybox &quot;space1&quot; { width = 4 }
        textbox &quot;eth&quot; 
        {
            style { font = &quot;DejaVu Sans Mono 9&quot; }
            text = &quot;eth0&quot;
        }

        emptybox &quot;space3&quot; { width = 4 }
        graph &quot;cpu_usage&quot;
        {
           height = 1
           bordercolor = &quot;#222222&quot;
           width = 20
           bg = &quot;#000000&quot;
           data &quot;cpudata1&quot;
           {
               scale = true
               max = 100
               fg = &quot;#eebb00&quot;
           }
           #data &quot;cpudata2&quot;
           #{
           #    scale = true
           #    max = 200
           #    fg = &quot;#ffb400&quot;
           #}
        }
        emptybox &quot;space4&quot; { width = 4 }
        progressbar &quot;memusage&quot;
        {
           vertical = true
           height = 1
           width = 8
           data &quot;memdata&quot;
           {
               bordercolor = &quot;#222222&quot;
               fg = &quot;#992200&quot;
               bg = &quot;#000000&quot;
               fg_off = &quot;#000000&quot;
           }
        }&lt;/pre&gt;

For information about widgets, well ~/.awesomerc overall, do:
&lt;pre&gt;man awesomerc&lt;/pre&gt;

After editing the ~/.awesomerc, always check if the configuration syntax is valid: 
&lt;pre&gt;awesome -k&lt;/pre&gt;

== Amazing configuration ==

Now lets create a file ~/.amazing/config.rb which would contain Amazing configuration and be automatically loaded by Amazing.

&lt;pre&gt;awesome {
  set :statusbar =&gt; &quot;mystatusbar&quot;
  #here you set the name of your statusbar
 
  widget(&quot;cpu_usage&quot;) {
    #because of good naming, amazing already know what module to use
    set :property =&gt; &quot;data cpudata1&quot;
    #here we write what part of the widget to modify - cpudata1 is the name of the data object in .awesomerc
    set :interval =&gt; 0.5
    #interval says, how many seconds wait before getting the data again
  }

  widget(&quot;eth&quot;) {
    set :module =&gt; :net_traffic
    #here because of non-standard naming we have to specify, which Amazing module (a.k.a. widget data-miner) to use
    property(&quot;text&quot;){ &quot;d:%3d u:%3d&quot; % [@download_rate, @upload_rate] }
    #here is where the transfer of data happens, different syntax then with the cpu graph
    #in the {} is the string which is sent (printf-like syntax)
    set :interval =&gt; 0.5
  }

  widget(&quot;batt&quot;) {
    set :module =&gt; :battery
    property(&quot;data battdata&quot;){@percentage}
    set :interval =&gt; 5
  }

  widget(&quot;memusage&quot;) {
    set :module =&gt; :memory
    property(&quot;data memdata&quot;){@usage}
    set :interval =&gt; 2
  }
}&lt;/pre&gt;

You can list Amazing modules by: &lt;pre&gt;amazing -w&lt;/pre&gt; and see information about it by: &lt;pre&gt;amazing -w net_traffic&lt;/pre&gt;
If you are using archlinux, you can do: &lt;pre&gt;yaourt -Ql amazing-git | grep widgets&lt;/pre&gt;

== xinitrc ==

That was the hard part. Now only add Awesome and Amazing into .xinitrc, so it is launched on X start:

&lt;pre&gt;amazing &amp;
awesome&lt;/pre&gt;

Thats it!


[[Category:awesome2]]</text>
      <sha1>jptsld54r5ubtgrkrujryihbd5i3r3r</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Subtle hacker theme</title>
    <ns>0</ns>
    <id>134</id>
    <revision>
      <id>1296</id>
      <timestamp>2008-10-16T15:08:44Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="894">&lt;pre&gt;
---------------------------------                                                                                            
-- subtle hacker awesome theme --                                                                                            
---------------------------------                                                                                            

font = terminus 8

bg_normal     = #000000
bg_focus      = #2f4f4f
bg_urgent     = #8b0000

fg_normal     = #f5deb3
fg_focus      = #ffa500
fg_urgent     = #ffff00

border_width  = 1
border_normal = #2f4f4f
border_focus  = #ffa500
border_marked = #8b0000

# You can use your own command to
# set your wallpaper
#wallpaper_cmd =

# You can add as many variables as
# you wish and access them by using
# beautiful.variable in your rc.lua
#bg_widget    = #cc0000
&lt;/pre&gt;


[[Category:awesome3]][[Category:themes]]</text>
      <sha1>597sx7p2d1optk4talznfvituq84twa</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Survey 2009</title>
    <ns>0</ns>
    <id>467</id>
    <revision>
      <id>3485</id>
      <parentid>3484</parentid>
      <timestamp>2009-08-18T14:22:23Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <minor/>
      <comment>/* Suggested usability improvement */</comment>
      <text xml:space="preserve" bytes="2731">== About ==

This is the first survey about awesome. It is available [http://www.survs.com/survey?id=8BVEV3FO&amp;channel=BH07CQ040D here].

== Results ==
Results are available [http://www.survs.com/shareResults?survey=8BVEV3FO&amp;rndm=TGJDF2V733 here].

== Analysis ==
* Most known awesome via forums, Google, friend IRC, and Planet Debian or Freedesktop.
* 50 % does not communicate with others awesome users, and 33% of them use mailing-lists.
* 75 % are up-to-date with the latest version (including git).
* More than 50 % are using awesome for more than 1 year. The other 50 % are less than one year. Only 5 % are using since the last 6 months.
* 75 % get awesome from their distros.
* Almost everyone is using GNU/Linux.
* A lot of our users were using GNOME, Fluxbox, KDE, Openbox or ion.
* 2/3 thinks awesome is easy to use, 1/3 not that easy.
* Wiki and manpages are the most used documentation to use awesome.
* Only 40 % find awesome easy to configure. 15 % thinks it's hard.
* Again, wiki and manpages are very used to configure awesome.
* 75 % of users are proficient with their configuration.
* 2/3 thinks awesome is getting easier to configure.
* tabulous, telak and invaders have almost no users.

Finally, only 1 % is unhappy with awesome, 16 % quite happy and 83 % totally happy.

=== Suggested usability improvements ===

Most relevant stuff have been counted. It may not be exact though, it's just an idea.

* 47 times: improve documentation and examples
* 24 times: do not break configuration file format / API
* 4 times: add tab support
* 3 times: integrate shifty into awesome

=== Suggested missing features ===

There is a lot of documentation request, etc, that I ignored. I already counted many above. If you are not happy with these answers or you want more, go deep in the results. I saved the one I found interesting.

* 4 times: coffee maker
* 4 times: tabs
* 3 times: more themes / color / pixmaps / prettier
* 2 times: Scratchpad
* 2 times: integrate shifty / dynamic tagging
* Pony
* Screen index with XRandR
* Freedesktop compatible menu system
* Help for debugging
* Desktop icons
* Wmii-like layouts, and all sort of layouts
* Subtiling
* Typing the name of a menu entry run it
* GNOME/KDE applets support

== Conclusion ==
* We probably need to be more visible.
* Mailing list is a good communication channel.
* Most of our users are using awesome for a long time, we do not get new users that much.
* Most of our users do not seem to come from the tiling window manager world.
* We still need to ease configuration.
* We need to get rid of tabulous, telak and invaders since they are not used.
* We need to remove almost unused feature from at least the default configuration files to lighten it up.</text>
      <sha1>kfa8fvr68tsqr15b90azdc55fsjp2oq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Symbolic tag names</title>
    <ns>0</ns>
    <id>578</id>
    <revision>
      <id>6518</id>
      <parentid>5341</parentid>
      <timestamp>2014-05-16T14:00:09Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1137">{{Languages}}

[[File:SymbolicTagNames.png]]

Try using unicode names for your tags in rc.lua:

&lt;pre&gt;
tags = {
    -- names = { &quot;☠&quot;, &quot;⌥&quot;, &quot;✇&quot;, &quot;⌤&quot;, &quot;⍜&quot;, &quot;✣&quot;, &quot;⌨&quot;, &quot;⌘&quot;, &quot;☕&quot; },
    names = { &quot;☭&quot;, &quot;⌥&quot;, &quot;✇&quot;, &quot;⌤&quot;, &quot;☼&quot;, &quot;⌘&quot; },
    layout = { layouts[2], layouts[2], layouts[2], layouts[2], layouts[2] , layouts[2] }
}
&lt;/pre&gt;


== Another Way ==

The above didn't work for me in Awesome 3.4.9. This did:

&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
tags = {}

for s = 1, screen.count() do
    -- Each screen has its own tag table.
    tags[s] = awful.tag({ &quot;♨&quot;, &quot;⌨&quot;, &quot;⚡&quot;, &quot;✉&quot;, &quot;☕&quot;, &quot;❁&quot;, &quot;☃&quot;, &quot;☄&quot;, &quot;⚢&quot; }, s, layouts[1])
--  tags[s] = awful.tag({ &quot;➊&quot;, &quot;➋&quot;, &quot;➌&quot;, &quot;➍&quot;, &quot;➎&quot;, &quot;➏&quot;, &quot;➐&quot;, &quot;➑&quot;, &quot;➒&quot;  }, s, layouts[1]) -- these are boring but I like them.  
end
&lt;/pre&gt;


Also, I found the images I'd chosen to be hard to see with my current font settings. So I edited theme.lua as well to make the taglist bigger:

&lt;pre&gt;
-- this is my default font
theme.font      = &quot;Inconsolata Medium 10&quot;
-- make tag list bigger
theme.taglist_font = &quot;Inconsolata Medium 14&quot;
&lt;/pre&gt;</text>
      <sha1>5ggx33iv2np9e6zgfenqh162my5t30p</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Symbolic tag names/ru</title>
    <ns>0</ns>
    <id>1050</id>
    <revision>
      <id>6520</id>
      <timestamp>2014-05-16T14:08:22Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{DISPLAYTITLE:Символические названия тегов}} {{Languages|Symbolic tag names}}   [[File:SymbolicTagNames.png]]  Вы можете использов...&quot;</comment>
      <text xml:space="preserve" bytes="1670">{{DISPLAYTITLE:Символические названия тегов}}
{{Languages|Symbolic tag names}}


[[File:SymbolicTagNames.png]]

Вы можете использовать названия из unicode для ваших тегов в rc.lua:

&lt;pre&gt;
tags = {
    -- names = { &quot;☠&quot;, &quot;⌥&quot;, &quot;✇&quot;, &quot;⌤&quot;, &quot;⍜&quot;, &quot;✣&quot;, &quot;⌨&quot;, &quot;⌘&quot;, &quot;☕&quot; },
    names = { &quot;☭&quot;, &quot;⌥&quot;, &quot;✇&quot;, &quot;⌤&quot;, &quot;☼&quot;, &quot;⌘&quot; },
    layout = { layouts[2], layouts[2], layouts[2], layouts[2], layouts[2] , layouts[2] }
}
&lt;/pre&gt;


== Другой способ ==

Вышеприведенный способ не работает в Awesome старше 3.4.9. Поэтому испльзуйте следующий код:

&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
tags = {}

for s = 1, screen.count() do
    -- Each screen has its own tag table.
    tags[s] = awful.tag({ &quot;♨&quot;, &quot;⌨&quot;, &quot;⚡&quot;, &quot;✉&quot;, &quot;☕&quot;, &quot;❁&quot;, &quot;☃&quot;, &quot;☄&quot;, &quot;⚢&quot; }, s, layouts[1])
--  tags[s] = awful.tag({ &quot;➊&quot;, &quot;➋&quot;, &quot;➌&quot;, &quot;➍&quot;, &quot;➎&quot;, &quot;➏&quot;, &quot;➐&quot;, &quot;➑&quot;, &quot;➒&quot;  }, s, layouts[1]) -- эти названия скучные, но мне нравяться.  
end
&lt;/pre&gt;


Также, я нашел интересные изображения. Но их было трудно увидеть с моим текущим шрифтом. Поэтому я отредактировал файл theme.lua для того чтобы увеличить размер taglist:

&lt;pre&gt;
-- это шрифт по умолчанию
theme.font      = &quot;Inconsolata Medium 10&quot;
-- Увеличенный шрифт для tag list
theme.taglist_font = &quot;Inconsolata Medium 14&quot;
&lt;/pre&gt;

[[Category:Awesome3]]</text>
      <sha1>93jukxg246uceupplonzb2voy0vkmcf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>System Tray</title>
    <ns>0</ns>
    <id>59</id>
    <revision>
      <id>1297</id>
      <timestamp>2008-10-16T15:09:08Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="661">In GNOME and KDE, the System Tray gives a place to display various items. Awesome doesn't directly have this capability, so some additional programs are needed to achieve this functionality.

* [http://developer.berlios.de/project/showfiles.php?group_id=1595 Trayer] is a part of fvwm-crystal that some people use to create a system tray.
* [http://stalonetray.sourceforge.net/ Stalonetray] is a standalone system tray implementation, complying to the freedesktop.org's specs.
* [http://www.xfce.org/projects/xfce4-panel/ Xfce-panel] is a full panel that support a system tray plugin. It's quite lightweight and will autohide if reqired.


[[Category:awesome2]]</text>
      <sha1>d87bcwzvpvs0aqw8t8xw44kbfga6j5h</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Systray Hide/Show</title>
    <ns>0</ns>
    <id>1023</id>
    <revision>
      <id>6627</id>
      <parentid>6376</parentid>
      <timestamp>2014-05-23T13:05:44Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1675">{{Languages}}

Here I will explain how to make a keybinding that toggles the visibility of the systray. I've only tested this in awesome v3.5.4. [http://thread.gmane.org/gmane.comp.window-managers.awesome/9659/focus=9662 Here's the thread I got the main bits from]

==The Code==

In the beginning of your rc.lua you'll want to add these lines:

 stupid_bug = drawin({})
 systrayvisible = true
 systray = wibox.widget.systray()
 container = wibox.layout.constraint()
 container:set_widget(systray)
 container:set_strategy(&quot;min&quot;)
 container:set_width(4)

Then in the main screen.count() loop, put these lines

 if s == 1 then
   left_layout:add(container)
 end

Where left_layout is whatever wibox or layout you want to put the systray.

Then in your global_keybindings table, you want to add this rule:

 awful.key({ modkey,           }, &quot;s&quot;, function () 
   if systrayvisible then
     awesome.systray(stupid_bug, 0, 0, 10, true, &quot;#000000&quot;)
     container:set_widget(nil)
     container:set_strategy(&quot;exact&quot;)
     systrayvisible = false
   else
     container:set_strategy(&quot;min&quot;)
     container:set_widget(systray)
     systrayvisible = true
   end
 end),

===How does it work???===

Essentially the systray is put into a dummy &quot;container&quot; layout, and taken out when hidden. The `awesome.systray(stupid_bug, 0, 0, 10, true, &quot;#000000&quot;)` line is some crazy voodoo that actually makes the widget go away. When the widget is hidden, the container becomes 4px wide thanks to container:set_width(4). You can set this to 1 if you want, I only have space because the icons I use for my taglist and and tasklist are the same. The padding prevents confusion when the systray is hidden.</text>
      <sha1>rsilzkvu03819fai1fs7ypb5x10urzt</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Systray Hide/Show/ru</title>
    <ns>0</ns>
    <id>1079</id>
    <revision>
      <id>6879</id>
      <parentid>6878</parentid>
      <timestamp>2014-07-26T12:46:26Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="2701">{{Languages|Systray Hide/Show}}
{{DISPLAYTITLE:Отображение/скрытие системного трея}}

Здесь я попытаюсь объяснить как привязать к сочетанию клавиш переключение видимости системного трея. Даный код тестировался только на Awesome v3.5.4. [http://thread.gmane.org/gmane.comp.window-managers.awesome/9659/focus=9662 Здесь поток, откуда был взят большой кусок]

== Код ==

В начале вашего rc.lua вам необходимо будет добавить следующие строки:

 stupid_bug = drawin({})
 systrayvisible = true
 systray = wibox.widget.systray()
 container = wibox.layout.constraint()
 container:set_widget(systray)
 container:set_strategy(&quot;min&quot;)
 container:set_width(4)

Затем, найдите инициализацию local right_layout, и добавьте после нее
&lt;pre&gt;
if s == 1 then right_layout:add(container) end
&lt;/pre&gt;
Стандартный вызов ''if s==1 then rigth_layout:add(wibox....)'' необходимо закомментировать

Где right_layout является wibox или layout который вы хотите поместить в трей.

Затем,  в таблице global_keybindings, вам необходимо добавить правила(rule):

 awful.key({ modkey,           }, &quot;s&quot;, function () 
   if systrayvisible then
     awesome.systray(stupid_bug, 0, 0, 10, true, &quot;#000000&quot;)
     container:set_widget(nil)
     container:set_strategy(&quot;exact&quot;)
     systrayvisible = false
   else
     container:set_strategy(&quot;min&quot;)
     container:set_widget(systray)
     systrayvisible = true
   end
 end),

=== Как это работает? ===

По существу systray помещается в фиктивный контейнер layout, и извлекает из него при скрытии. Строка `awesome.systray(stupid_bug, 0, 0, 10, true, &quot;#000000&quot;)` это несколько сумасшедшее вуду, которое на самом деле скрывает виджет. Когда виджет скрывается, контейнер становится в ширину 4 пикселя, благодаря строке container:set_width(4). Вы можете установить это значение на 1, если хотите, у меня есть место, т.к. иконки которые я использую для taglist и tasklist одинаковы. И это позволяет измежать беспорядка в systray когда он скрыт.</text>
      <sha1>9fnq545id0000cqj1zt8tcwm4v5wf7u</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tags Description/ru</title>
    <ns>0</ns>
    <id>1132</id>
    <revision>
      <id>6893</id>
      <parentid>6889</parentid>
      <timestamp>2014-07-29T15:03:14Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Изменение цветов тега */ added confirm about bug</comment>
      <text xml:space="preserve" bytes="28972">{{Languages}}
{{DISPLAYTITLE:Теги - описание и настройка}}

==Общие положения==

Тег - это расширенное понятие виртуальных рабочих столов. 
В переводе с английского означает ярлык, прикреплять ярлык, связывать. 

Для понятия того, что же такое тег, необходимо ввести понятие '''клиента''' - это окно приложения(а у одного приложения может быть несколько окон, ярким примером могут являться Интернет-мессенджеры, GIMP.).  В отличие от других WM, где окно помещается на рабочий стол, в Awesome Вам необходимо присвоить клиенту тег/теги на которых он будет отображаться. 

По умолчанию, все окна клиентов автоматически помечаются тегом на котором открыты. Но вот после этого Вы можете выбрав какое то одно окно приложения пометить еще одним тегом, в результате он будет отображаться на 2х тегах сразу, с учетом выбранной для этого тега [[Layout/ru| схемы]]. 

Например, я открыл Pidgin(IM) на 6 теге, но при его открытии, получается 2 и более окна(собственно чат и контакт-лист), а работаю я на 1м теге, и не хочу постоянно переключаться туда сюда. Если бы я привязал/открыл Pidgin к 1му тегу, у меня бы на нем было 2 окна, одно из которых мне сейчас не нужно, поэтому я просто делаю активным окно чата и помечаю его 1м тегом, в результате к основным рабочим окнам я могу еще и вести переписку. 

Сделать это можно следующим образом:
&lt;pre&gt;
Mod4 + Shift + Control + 1-9		Пометить/снять пометку клиента тегом по номеру.
Mod4 + Button3 на имени тега		Пометить текущий клиент этим тегом, либо убрать пометку этим тегом.
где Mod4 - это обычно Win клавиша
Button3 - правая клавиша мыши
&lt;/pre&gt;

А еще можно одновременно отобразить клиенты с 2х тегов. Например, пишите Вы код в редакторе и для этого необходимо смотреть историю из терминала, чтобы не ошибиться или посмотреть/скопировать что то из браузера. Чем открывать их еще раз в этом же теге, или постоянно переключаться туда сюда, проще временно отобразить 2-й тег.  При этом будут отображены все клиенты привязанные к этому тегу.
&lt;pre&gt;
Mod4 + Control + 1-9		Включить/выключить тег по номеру.
Button3 на имени тега	Включить/выключить тег по номеру.
&lt;/pre&gt;

==Управление==
&lt;pre&gt;
Button1 на имени тега				- Выбрать тег для отображения.
Button4, Button5 на имени тега  		- Выбрать предыдущий или следующий тег.
Mod4 + Button1 на имени тега			- Переместить текущий клиент на этот тег.
Mod4 + Button3 на имени тега			- Отобразить/скрыть текущий клиент на этом теге.
Button3 на имени тега				- Добавить текущий тег для просмотра.
Mod4 + 1-9					- Переключиться на тег по номеру (от 1 до 9).
Mod4 + Escape					- Выбрать предыдущий выбранный набор тегов.
Mod4 + Control + 1-9				- Включить/выключить тег по номеру.
Mod4 + Shift + 1-9				- Пометить клиента тегом по номеру.
Mod4 + Shift + Control + 1-9			- Пометить/снять пометку клиента тегом по номеру.
Mod4 + Shift + F1-9				- Пометить все отмеченные клиенты тегом по номеру.

Где Button1	- левая кнопка мыши
Button3		- правая кнопка мыши
Button4		- дополнительные кнопки мыши
Button5		- дополнительные кнопки мыши
&lt;/pre&gt;
==Изучаем rc.lua== 
[[File:Taglist.png|250px|thumb|right|Внеший вид тегов]]
Выглядят теги следующим образом:

Здесь, красным выделен taglist, зеленым - активный тег с открытыми клиентами, синим - неактивный тег на котором открыты клиенты. Все остальные это неактивные теги на которых не открыто ни одного приложения. Теги (по умолчанию) пронумерованы от 1 до 9.





===Переименование тегов===
Если изучить стандартный файл rc.lua, то мы увидим следующий код, инициализирующий теги (код идентичен в 3.4 и 3.5):
&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
tags = {}									--создаем таблицу
for s = 1, screen.count() do							--цикл помещает теги на все экраны
    -- Each screen has its own tag table.
    tags[s] = awful.tag({ 1, 2, 3, 4, 5, 6, 7, 8, 9 }, s, layouts[1])		--описание тегов (название, экран, схема)
end
-- }}}
&lt;/pre&gt;
Здесь мы можем настроить названия наших тегов, присвоить каждому тегу свою схему, или даже присвоить каждому экрану разные теги. Если вы не знаете что такое схемы(Layout) прочтите [[Layout/ru| эту статью]].

Для начала заменим цифры на что то более понятное для нас:
&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
  tags = {
    names  = { &quot;main&quot;, &quot;www&quot;, &quot;skype&quot;, &quot;gimp&quot;, &quot;office&quot;, &quot;im&quot; },		--замените цифры нужными вам названиями
    layout = { layouts[1], layouts[2], layouts[1], layouts[5], layouts[6],	--назначаем каждому тегу собственную схему
               layouts[12]}							--количество схем должно быть равно количеству схем
  }
  for s = 1, screen.count() do
      -- Each screen has its own tag table.
      tags[s] = awful.tag(tags.names, s, tags.layout)
  end
  -- }}}
 &lt;/pre&gt;
После внесения изменений, не забудьте перезапустить  Awesome (mod4+Ctrl+r).

===Символьные названия===
Если вас не устраивают длинные названия тегов(например вы экономите место для виджетов), то в этом случае можно использовать любые Unicode символы (подобрать можно [http://unicode-table.com/ru/ здесь]):
&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
tags = {}
for s = 1, screen.count() do
    -- Each screen has its own tag table.
    tags[s] = awful.tag({ &quot;♨&quot;, &quot;⌨&quot;, &quot;⚡&quot;, &quot;✉&quot;, &quot;☕&quot;, &quot;❁&quot;, &quot;☃&quot;, &quot;☄&quot;, &quot;⚢&quot; }, s, layouts[1])
--  tags[s] = awful.tag({ &quot;➊&quot;, &quot;➋&quot;, &quot;➌&quot;, &quot;➍&quot;, &quot;➎&quot;, &quot;➏&quot;, &quot;➐&quot;, &quot;➑&quot;, &quot;➒&quot;  }, s, layouts[1])		--раскоментируйте если
--  tags[s] = awful.tag({ &quot;☭&quot;, &quot;⌥&quot;, &quot;✇&quot;, &quot;⌤&quot;, &quot;☼&quot;, &quot;⌘&quot;,&quot;⍜&quot;, &quot;✣&quot;,&quot;☕&quot;  }, s, layouts[1])			--какой то из наборов
--  tags[s] = awful.tag({ &quot;  α  &quot;, &quot;  β  &quot;, &quot;  ζ  &quot;, &quot;  Θ  &quot;, &quot;  Ξ  &quot;, &quot;  ς  &quot;, &quot;  ψ  &quot;  }, s, layouts[1])	--вам приглянулся  
--  tags[s] = awful.tag({ &quot;⠐&quot;, &quot;⠡&quot;, &quot;⠪&quot;, &quot;⠵&quot;, &quot;⠻&quot;, &quot;⠿&quot; }, s, layouts[1])						--
end
&lt;/pre&gt;

===Работа с несколькими экранами===
Если вы используете несколько экранов и хотите, чтобы на каждом экране были свои собственные теги, переделайте код следующим образом:
&lt;pre&gt;
-- {{{ Tags
  tags = {
    settings = {
      { names  = { &quot;www&quot;, &quot;editor&quot;, &quot;mail&quot;, &quot;im&quot; },				--названия для 1го экрана
        layout = { layouts[2], layouts[1], layouts[1], layouts[4] } },		--схемы для 1го экрана      
      { names  = { &quot;rss&quot;,  &quot;music&quot;, 7,  &quot;video&quot; },				--названия тегов для 2го экрана
        layout = { layouts[3], layouts[2], layouts[2], layouts[5] } }		--схемы для 2го экрана
  }}  
  for s = 1, screen.count() do
      tags[s] = awful.tag(tags.settings[s].names, s, tags.settings[s].layout)
  end
  -- }}}
&lt;/pre&gt;

Подробнее по работе с несколькими экранами читайте [[Main Page/ru#Работа с несколькими экранами (screens)|раздел по настройке экранов]]

===Иконки вместо названий===
Если использование названий или символов вас не устраивает, то можно настроить отображение иконок вместо названий:
&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
tags = {
names = {&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;,&quot;&quot;},					--так как мы используем иконки, то названия нам не нужны
layout = {layouts[1], layouts[2], layouts[2], layouts[4], layouts[9], layouts[12]}
}
for s = 1, screen.count() do
    -- Each screen has its own tag table.
    tags[s] = awful.tag(tags.names, s, tags.layout)		--вызов стандартной функции, он необходим для установки количества тегов и схемы для них
    awful.tag.seticon(beautiful.mainicon, tags[s][1])	--устанавливаем иконку для 1го тега
    awful.tag.seticon(beautiful.wwwicon, tags[s][2])    --для 2го тега
    awful.tag.seticon(beautiful.officeicon, tags[s][3])	--для 3го тега
    awful.tag.seticon(beautiful.imicon, tags[s][4])	--для 4го тега
    awful.tag.seticon(beautiful.mediaicon, tags[s][5])	--для 5го тега
end
-- }}}
&lt;/pre&gt;
Для того, чтобы этот код мог работать необходимо назначить эти переменные в файле темы theme.lua, который должен находится в папке ~/.config/awesome/themes. Если у вас этой папки еще нет сделайте ее и скопируйте в нее стандартные темы, которые в дальнейшем будете изменять:
&lt;pre&gt;
mkdir -p ~/.config/awesome/themes
cp -R /usr/share/awesome/themes/* ~/.config/awesome/themes/
&lt;/pre&gt;
Затем откройте файл theme.lua из папки ~/.config/awesome/themes/default и добавьте переменные (только перед этим убедитесь, что эти файлы у вас существуют, или назначьте свои):
&lt;pre&gt;
--Tags Icon
theme.mainicon = &quot;/usr/share/icons//usr/share/icons/gnome/48x48/places/user-home.png&quot;
theme.wwwicon = &quot;/usr/share/icons//usr/share/icons/gnome/48x48/emblems/emblem-web.png&quot;
theme.officeicon = &quot;/usr/share/icons//usr/share/icons/gnome/48x48/apps/accessories-text-editor.png&quot;
theme.imicon = &quot;/usr/share/icons//usr/share/icons/gnome/48x48/emotes/face-smile.png&quot;
theme.mediaicon = &quot;/usr/share/icons//usr/share/icons/gnome/48x48/devices/audio-card.png&quot;
&lt;/pre&gt;
И замените код инициализации темы на следующий:
  beautiful.init(&quot;~/.config/awesome/themes/default/theme.lua&quot;)
Кстати, обратите внимание, что вы можете одновременно определить и иконки и текст, и они будут отображаться. Но если вы определите в theme.lua
  theme.taglist_disable_icon = true
то будет отображен только текст, а если установите в свойство '''каждого''' тега (по моему мнению здесь какая то недоработка), в rc.lua:
  awful.tag.setproperty(tags[s][i], &quot;icon_only&quot;, true)
Подробнее с настройкой тем и установке иконок для ваших нужд вы можете ознакомиться в статье [[Beautiful/ru|Темы Beautiful]].

===Изменение цветов тега===
По умолчанию для активного тега используется серый цвет, с белым текстом, а для неактивного белый текст на черном фоне. Но если вы настраиваете свою тему, или вам просто не нравятся стандартные цвета, то можно их переопределить. Для этого откройте файл theme.lua в вашей папке с темами (например ~/.config/awesome/themes/default) и добавьте туда код(по умолчанию эти переменные не определены):
&lt;pre&gt;
theme.taglist_bg_focus = &quot;#222222&quot;		--цвет фона активного тега
theme.taglist_fg_focus = &quot;#7FFF00&quot;		--цвет текста активного тега

theme.taglist_bg_occupied = &quot;#222222&quot;		--цвет фона неактивного тега в котором открыты приложения
theme.taglist_fg_occupied = &quot;#0000CD&quot;		--цвет текста неактивного тега в котором открыты приложения

theme.taglist_fg_urgent = &quot;#ffffff&quot;             --цвет текста &quot;срочного&quot; тега
theme.taglist_bg_urgent = &quot;#ff0000              --цвет фона &quot;срочного&quot; тега

&lt;/pre&gt;
В Awesome 3.5 появилась также возможность настраивать и цвета тегов в котором нет открытых приложений, для этого используются переменные:
  theme.taglist_bg_empty
  theme.taglist_fg_empty    --эту переменную лучше не использовать, есть небольшой [https://awesome.naquadah.org/bugs/index.php?do=details&amp;task_id=1289 баг]

Помимо всего, для настройки внешнего вида, можно настроить свой шрифт именно для тегов. По умолчанию используются настройки шрифта из переменной theme.font. Но если вы хотите использовать другой шрифт для тегов, не трогая все остальное, определите и назначьте переменную :
  theme.taglist_font = &quot;sans 8&quot;

===Убираем/изменяем квадраты на тегах===
[[File:Taglist squares.png|250px|thumb|right|Те самые квадраты]]
Для удаления квадратов, самый простой способ, это закомментировать следующие переменные в файле theme.lua
  theme.taglist_squares_sel
  theme.taglist_squares_unsel
В Awesome 3.5 появилась возможность устанавливать значки на теги в которых не запущенны приложения, для этого в файле theme.lua нужно определить переменные:
    theme.taglist_squares_sel_empty
    theme.taglist_squares_unsel_empty
А вообще, заменяя и/или устанавливая указанные выше файлы можно получить все что вы хотите. Ведь согласитесь, одними квадратами наша фантазия не ограничивается, это могут быть треугольники, подчеркивание и т.д., т.е. все ограничивается только вашей фантазией.

===Запуск приложения на определенном теге===
Иногда возникает необходимость привязать приложение к определенному тегу, например, чтобы браузер открывался на 2 теге, или мессенджер на 4, для этого можно использовать правила(rules). 

Для этого найдите секцию ''awful.rules.rules''. По умолчанию, там уже есть код, и добавьте в эту таблицу свои правила, например:
&lt;pre&gt;
  -- Устанавиваем Firefox на 2м теге 1го экрана
  { rule = { class = &quot;Firefox&quot; },  properties = {tag = tags[1][2]}},
   -- Устанавиваем VLC на 5й тег последнего экрана(например у нас там настроен полный экран)
  { rule = { name = &quot;Vlc&quot; },    properties = {tag = tags[screen.count()][5]}},
   -- Устанавиваем Thunar на 4й тег 1 экрана и сразу переключаемся на него
  { rule = { class = &quot;Thunar&quot; }, properties = { tag = tags[1][4], switchtotag = true } },
    -- Устанавиваем Xterm как плавающего окна с фиксируемой позицией
  { rule_any = { class = &quot;XTerm&quot;, &quot;UXTerm&quot; }, properties = {floating = true}, callback = function(c) c:geometry({x=0, y=0}) end},
&lt;/pre&gt;
Более подробно ознакомиться с правилами вы можете прочитав статью [[Understanding Rules/ru|awfu.rules]].
    
===Настройка схемы для определенного тега===
Иногда при настройке, хочется чтобы например мастер-зона занимала треть экрана, а не половину, или было 2 клиента в мастер-зоне, все этом можно легко настроить:
* awful.tag.setmwfact			--устанавливает ширину мастер-зоны
* awful.tag.setnmaster			--устанавливает число окон в мастер-зоне
* awful.tag.seticon			--устанавливает иконку тегу
* awful.tag.setncol			--устанавливает число колонок стек-зоны
* awful.tag.setproperty			--устанавливает любые из перечисленных  выше(напрямую)
&lt;pre&gt;
-- {{{ Tags
-- Define a tag table which hold all screen tags.
  tags = {
    names  = { &quot;main&quot;, &quot;www&quot;, &quot;skype&quot;, &quot;gimp&quot;, &quot;office&quot;, &quot;im&quot; },
    layout = { layouts[1], layouts[2], layouts[1], layouts[5], layouts[6],
               layouts[12]}
  }
  for s = 1, screen.count() do
      -- Each screen has its own tag table.
      tags[s] = awful.tag(tags.names, s, tags.layout)
      awful.tag.setmwfact(0.30, tags[s][1])			--ширина мастер зоны 30%
      awful.tag.setproperty(tags[s][2], &quot;mwfact&quot;, 0.20)		--ширина мастер зоны 20%
      
      awful.tag.setncol(2, tags[s][3])				--колличество колонок в стек-зоне 2
      awful.tag.setproperty(tags[s][4], &quot;ncol&quot;, 3)		--колличество колонок в стек-зоне 3
      
      awful.tag.setnmaster(2, tag[s][5])			--колличество клиентов в мастер-зоне 2
      awful.tag.setproperty(tags[s][6], &quot;nmaster&quot;, 2)		--колличество клиентов в мастер-зоне 2
      
      awful.tag.seticon(beautifu.www_icon, tag[s][7])
      awful.tag.setproperty(tags[s][8], &quot;icon&quot;, beautiful.media_icon)
  end
  -- }}}
 &lt;/pre&gt;
    
Понятия «стэк-зона» и «мастер-зона» используются в тайлинговых схемах и изначают:
* мастер-зона- область схемы tile куда по умолчанию открываются новые клиенты;
* стек-зона- область схемы tile куда сдвигаются уже открытые клиенты при запуске нового.

Полный перечень доступных функций приведен в официальном [http://awesome.naquadah.org/doc/api/modules/awful.tag.html API(eng)].

===Убираем лишние пробелы между тегами===
[[File:Taglist before.png|250px|thumb|right|Tags before]]
[[File:Taglist after.png|250px|thumb|right|Tags after]]
'''Код в этой части работает в Awesome 3.5''', его можно переделать и под 3.4, но изменений будет достаточно много.

Когда вы используете иконки вместо текста в названии тегов, то образуются пробелы сбоку от иконки, выглядящие не очень то красиво. По умолчанию при использовании текста в названии тега, слева и справа добавляется по 4 пикселя, для разделения текста, но вот для иконок, этот подход выглядит не лучшим образом. Поэтому эту проблему можно (и нужно ) решить. Заодно появится возможность редактировать расстояние в тексте между вашими виджетами.

Итак для решения вопроса нам потребуется 2 файла '''~/.config/awesome/awful/widget/common.lua''' и '''taglist.lua''' из этой же папки. 
Рекомендую скопировать файлы библиотек в пользовательский каталог, чтобы не работать по root. Да и если вы что то испортите, можно будет восстановить.
&lt;pre&gt;
cp -R /usr/share/awesome/lib ~/.config/awesome
&lt;/pre&gt;
Итак, для начала откройте ~/.config/awesome/awful/widget/common.lua, найдите в ней функцию ''common.list_update'', и переопределите ее следующим образом:
&lt;pre&gt;
function common.list_update(w, buttons, label, data, objects, left_margin, right_margin)	
&lt;/pre&gt;
Здесь мы добавили левый и правый отсупы. Затем найдите в этой же функции следующий код:
&lt;pre&gt;
else
            ib = wibox.widget.imagebox()
            tb = wibox.widget.textbox()
            bgb = wibox.widget.background()
            m = wibox.layout.margin(tb, 4, 4)
&lt;/pre&gt;
И замените его на:
&lt;pre&gt;
else
	    local m_left = left_margin or 4			--инициализируем левый отступ
	    local m_right = right_margin or 4			--инициализируем правый отступ
            ib = wibox.widget.imagebox()
            tb = wibox.widget.textbox()
            bgb = wibox.widget.background()
            m = wibox.layout.margin(tb, m_left, m_right)	--меняем здесь стандартный вызов
&lt;/pre&gt;
Здесь, мы подстраховываемся, если аргументы отступа не переданы функции, то они устанавливаются в стандартные значения. Актуально будет для вызовов из других, не переделанных функциях (мы ведь не хотим переделывать весь код )) ).

Открываем '''~/.config/awesome/awful/widget/taglist.lua'''. Затем находим функцию ''function taglist_update'' и заменяем ее определение на следующий код:
&lt;pre&gt;
local function taglist_update(s, w, buttons, filter, data, style, update_function, ml, mr)	--добавление переменных отступа
&lt;/pre&gt;
Затем в этой же функции, найдите вызов ''update_function(w, buttons, label, data, tags)'' и замените его на:
&lt;pre&gt;
update_function(w, buttons, label, data, tags, ml, mr)					--добавление к вызову переменных отсупа
&lt;/pre&gt;
Затем в этом же файле находим ''function taglist.new'' и добавляем в ее начало:
&lt;pre&gt;
local ml, mr = 0,0		--добавление переменных отступа и инициализация
&lt;/pre&gt;
И вот здесь вы можете установить свои отсупы, я для иконок выбрал 0, чтобы они были плотно друг к другу, если выбрать другие значения, то отступы появляются с правой стороны, игнорируя левую.

Затем найдите код:
&lt;pre&gt;
if s == screen then
            taglist_update(s, w, buttons, filter, data, style, uf)
&lt;/pre&gt;
И замените его на:
&lt;pre&gt;
if s == screen then
            taglist_update(s, w, buttons, filter, data, style, uf, ml, mr)	--добавление к вызову переменных отсупов тега
&lt;/pre&gt;
Все готово, перезапускам Awesome!

==Разное==

По умолчанию для хранения истории переключения между тегами используется переменная '''tag.history''' из файла awful/tag.lua.
История переключения ограничена 20. По большому счету обычно больше 3х и не нужно. Но если вам все же нужно больше переопределите переменную 
  tag.history.limit 
Кстати, переменная tag.history полностью сохраняется в памяти, т.е. при перезапуске Awesome история будет потеряна.
Для переключения по истории тегов используется комбинация клавиш:
  Mod4 + Escape					- Выбрать предыдущий выбранный набор тегов.

==Динамические теги==
Несмотря на то, что теперь Awesome поддерживает создание, удаление, переименование тегов на лету, работать с этими функциями не очень удобно (приходится писать просто море кода), для решения этой проблемы пользователями были созданы библиотеки динамических тегов:
* [[Shifty/ru|Shifty]] - простая в настройке библиотека для динамического присваивания тегов приложениям. 
* [[Eminent/ru|Eminent]] - Легкая библиотека динамических тегов(wmii подобная), не требующая каких либо изменений в rc.lua 
* [https://github.com/Elv13/tyrannical tyrannical] - Конфигурационная система для awful определяющая динамические теги и приложения(духовный наследник Shifty) 
 
Дополнительные настройки:
* [[WMII-like_tag_management/ru|Управление тегами в стиле WMII]] - имитация управления тегами, реализованного в WMII. 
* [[Keeping_multitags_persistent/ru|Сохранение мультитегового состояния]] - Позволяет вам запомнить мультитеговое отображение, и переключаться между тегами с сохранением этого состояния.</text>
      <sha1>be2vfe4y4gexuwog1w2560gknexan94</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tasklist Description/ru</title>
    <ns>0</ns>
    <id>1144</id>
    <revision>
      <id>6921</id>
      <parentid>6914</parentid>
      <timestamp>2014-08-12T04:03:35Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Список клиентов */</comment>
      <text xml:space="preserve" bytes="31956">{{Languages}}
{{DISPLAYTITLE:Tasklist - Панель задач}}

Панель задач - отображает по умолчанию клиенты с активного тега/тегов. 

Перед началом работы скопируйте библиотеки в домашний каталог, если до сих пор этого не сделали.
&lt;pre&gt;
mkdir -p ~/.config/awesome/themes
cp /etc/xdg/awesome/rc.lua ~/.config/awesome/rc.lua
cp -R /usr/share/awesome/lib/* ~/.config/awesome/
cp -R /usr/share/awesome/themes/* ~/.config/awesome/themes/
&lt;/pre&gt;

Вообще, за обработку панели задач отвечает файл awful/widget/tasklist.lua

Так что если возникнет желание ознакомится со всеми возможностями панели задач, изучите этот файл. Также для работы этого файла потребуются другие библиотеки lua (вызываемые оттуда функции и т.д.), они прописаны в начале файла, это те самые require. Имейте в виду, что код для 3.4 и 3.5 в библиотеке tasklist, как и названия функций в них довольно существенно отличается.

==Управление списком задач==
Для управления открытми клиентами существуют следующие клавиши:
&lt;pre&gt;
Mod4 + Shift + r		- Перерисовать активное окно.
Mod4 + m			- Развернуть на весь экран.
Mod4 + n			- Свернуть.
Mod4 + Control + n		- Восстановить.
Mod4 + f			- Полноэкранный режим.
Mod4 + Shift + c		- Убить выбранный клиент.
Mod4 + t			- Прикрепить поверх всех.
&lt;/pre&gt;
Кстати, если эти клавиши вас не устравивают, вы в любой момент можете их переопределить, для этого в rc.lua найдите функцию awful.key отвечающую за нужные вам клавиши и измените их.

==Разбираем rc.lua==

Разбирая rc.lua можно обнаружить следующий код, связанный с панелью задач
&lt;pre&gt;
mytasklist = {}									--создаем таблицу панели задач
mytasklist.buttons = awful.util.table.join(					--прикрепляем клавиши мыши к панели задач
                     awful.button({ }, 1, function (c)				--нажатие левой кнопки
                                              if c == client.focus then		--свернуть/развернуть приложение
                                                  c.minimized = true
                                              else
                                                  -- Without this, the following
                                                  -- :isvisible() makes no sense
                                                  c.minimized = false
                                                  if not c:isvisible() then
                                                      awful.tag.viewonly(c:tags()[1])
                                                  end
                                                  -- This will also un-minimize
                                                  -- the client, if needed
                                                  client.focus = c
                                                  c:raise()
                                              end
                                          end),
                     awful.button({ }, 3, function ()				--нажатие правой клавиши
                                              if instance then			--отображает список всех клиентов/приложений
                                                  instance:hide()
                                                  instance = nil
                                              else
                                                  instance = awful.menu.clients({
                                                      theme = { width = 250 }
                                                  })
                                              end
                                          end),
                     awful.button({ }, 4, function ()				--колесо прокрутки
                                              awful.client.focus.byidx(1)	--перейти на следующий клиент
                                              if client.focus then client.focus:raise() end
                                          end),
                     awful.button({ }, 5, function ()				--колесо прокрутки
                                              awful.client.focus.byidx(-1)	--перейти на предыдущий клиент
                                              if client.focus then client.focus:raise() end
                                          end))
....
    -- Create a tasklist widget  - создание виджета tasklist
    mytasklist[s] = awful.widget.tasklist(s, awful.widget.tasklist.filter.currenttags, mytasklist.buttons)
.... 
    layout:set_middle(mytasklist[s])						--Располагаем список задач в центре панели
&lt;/pre&gt;

Если вам не нужна прокрутка на панели задач, то закоментируйте/удалите код отвечающий за нее:
&lt;pre&gt;
--awful.button({ }, 4, function ()							--колесо прокрутки
--                      awful.client.focus.byidx(1)				        --перейти на следующий клиент
--                      if client.focus then client.focus:raise() end
--                     end),
--awful.button({ }, 5, function ()							--колесо прокрутки
--                      awful.client.focus.byidx(-1)			                --перейти на предыдущий клиент
--                      if client.focus then client.focus:raise() end
--                     end))
И добавьте завершающую скобку после закомментированного кода, иначе выдаст ошибку
)
&lt;/pre&gt;

===Варианты для правой кнопки мыши===
====Закрыть приложение====
Для того, чтобы при нажатии правой кнопки мыши мы могли закрывать приложение (как в OpenBox или Tint2), а не открывать список меню, переделайте код (или закомментируйте его, если вы не планируете использовать правую клавишу для панели задач).
&lt;pre&gt;
awful.button({ }, 3, function ()
                      if instance then
                        instance:hide()
                        instance = nil
                      else
                        instance = awful.menu.clients({
                        theme = { width = 250 }
                        })
                      end
                     end),
&lt;/pre&gt;
На следующий
&lt;pre&gt;
awful.button({ }, 3, function (c)
    c:kill()
end ),
&lt;/pre&gt;

====Альтернативное меню====
[[File:Tasklist_context_menu.png|250px|thumb|right|Альтернативное меню]]
Если вас не устраивает стандартное контекстное меню в панели задач, то вы можете его заменить, на то, которое нужно именно вам, далее приводится лишь один из возможных вариантов.
Для начала заменим стандартный вызов awful.button на следующий:
&lt;pre&gt;
awful.button({ }, 3, function (c)
          if instance then
              instance:hide()
              instance = nil
           else
              instance = context_menu(c)
           end
         end ),
&lt;/pre&gt;
Затем где нибудь в начале файла rc.lua добавьте функцию context_menu:
&lt;pre&gt;
function context_menu(c)
    if c.minimized then                               --меняем текст элемента меню в зависимости от состояния
         cli_min = &quot;Развернуть&quot;
    else
         cli_min = &quot;Свернуть&quot;
    end
    if c.ontop then
         cli_top = &quot;★ Поверх всех&quot;
     else
         cli_top = &quot;  Поверх всех&quot;
    end
    if awful.client.floating.get(c) then
         cli_float = &quot;★ Floating&quot;
     else
         cli_float = &quot;  Floating&quot;
     end
     --создаем список тегов(в виде подменю), для перемещения клиента на другой тег
     tag_menu = { }
     for i,t in pairs(tags.names) do
          if not tags[c.screen][i].selected then			--удаляем из списка выбранный тег/теги
              table.insert(tag_menu, { tostring(t), function() awful.client.movetotag(tags[c.screen][i]) end } )
          end
     end
     taskmenu = awful.menu({ items = { { &quot;Переместить на&quot;, tag_menu },
                                       { cli_min, function() c.minimized = not c.minimized end },
                                       { &quot;Fullscreen&quot;, function() c.fullscreen = not c.fullscreen end, beautiful.layout_fullscreen },
                                       { cli_float,  function() awful.client.floating.toggle(c) end },
                                       { cli_top, function() c.ontop = not c.ontop end },
                                       { &quot;Закрыть&quot;, function() c:kill() end },
                                     width = 150
                                     } )
     taskmenu:show()
     return taskmenu
end
&lt;/pre&gt;

==Отобразить только иконки или текст==
[[File:Tasklist_icon_only.png|250px|thumb|right|Отображаем только иконки]]
Если вас не устраивает отображение текста и иконок одновременно (например вы большой любитель Unity или Win7), то можно настроить Awesome для отображения только иконок или только текста у приложений. Есть один недостаток, если для приложения не назначено иконки, то соответсвенно и отображать будет нечего (у меня такая ситуация наблюдалась с терминалом xterm, если у вас похожая ситуация, то назначьте иконку по умолчанию для приложений не имеющих собственных иконок(описано ниже).

Откройте ~/.config/awesome/awful/widget/tasklist.lua и в функции widget_tasklist_label_common() (для 3.4) или tasklist_label (для 3.5)
замените ''return text, bg....'' на следующий код:
&lt;pre&gt;
return not theme.tasklist_only_icon and text or '', bg, status_image, not tasklist_disable_icon and c.icon or nil
&lt;/pre&gt;

Затем, создайте переменную в вашем theme.lua со следующим содержанием:
&lt;pre&gt;
--для отображения только иконок
theme.tasklist_only_icon = true
--для отображения только текста
tasklist_disable_icon = true
&lt;/pre&gt;
'''Примечание: '''Не определяйте как одновременно обе этих переменных, иначе вы вообще не увидите своих задач.

Есть еще один способ убрать текст в Awesome 3.4 (к сожалению в 3.5 код вызываемой функции был изменен и поэтому этот способ в нем не работает), но здесь все манипуляции мы будем производить только с файлом rc.lua. Найдите следующий код:
&lt;pre&gt;
mytasklist[s] = awful.widget.tasklist(function(c)
                        return awful.widget.tasklist.label.currenttags(c, s)
                end, mytasklist.buttons)
&lt;/pre&gt;
И замените его на :
&lt;pre&gt;
 mytasklist[s] = awful.widget.tasklist(function(c)
                              local task = { awful.widget.tasklist.label.currenttags(c, s) }
                              return '', task[2], task[3], task[4]
                          end, mytasklist.buttons)
&lt;/pre&gt;
В принципе данный код аналогичен первому, только здесь мы производим дополнительное действие.

Аналогичным способом можно удалить и иконки в Awesome 3.4. Откройте ваш rc.lua, найдите 
&lt;pre&gt;
mytasklist[s] = awful.widget.tasklist(function(c)
                      return awful.widget.tasklist.label.currenttags(c, s)
                end, mytasklist.buttons)
&lt;/pre&gt;
И замените его на :
&lt;pre&gt;
 mytasklist[s] = awful.widget.tasklist(function(c)
                              local task = { awful.widget.tasklist.label.currenttags(c, s) }
                              return task[1], task[2], task[3], nil
                          end, mytasklist.buttons)
&lt;/pre&gt;

==Иконка по умолчанию==
Для некоторых приложений не установлены иконки по умочанию (обычно это терминалы), и если вы, например, используете только иконки в панели задач, или используете отображение приложений в тегах, то приложения без иконок вы просто не увидите. Для решения этой проблемы отредактируйте функцию ''tasklist_update'' в файле ~/.config/awesome/awful/widget/tasklist.lua. 
&lt;pre&gt;
в функции tasklist_update перед строкой table.insert вставьте следующий код:
if not c.icon then
    c.icon = capi.image(&quot;path/to/icon/default_icon.png&quot;)
end
&lt;/pre&gt;

==Настройка внешнего вида==
Для настройки панели задач, в theme.lua вы можете определить следующие переменные:
===Awesome 3.5===
'''theme.tasklist_fg_normal''' - цвет текста панели задач, если значение не определено, то используется значение theme.fg_normal

'''theme.tasklist_bg_normal''' - цвет фона панели задач, если значение не определено, то используется значение theme.bg_normal

'''theme.tasklist_fg_focus''' - цвет текста активного приложения, если значение не определено, используется значение theme.fg_focus

'''theme.tasklist_bg_focus''' - цвет фона активного приложения, если значение не определено, то используется значение theme.bg_focus

'''theme.tasklist_fg_urgent''' - цвет текста &quot;срочного&quot; приложения, если не определено, то будет использоваться значение из theme.fg_urgent

'''theme.tasklist_bg_urgent''' цвет фона &quot;срочного&quot; приложения, если не определено, то будет использоваться значение theme.bg_urgent

''' theme.tasklist_fg_minimize''' - цвет текста свернутого приложения, если не определено, то будет использоваться значение из  theme.fg_minimize

'''theme.tasklist_bg_minimize''' - цвет фона свернутого приложения, если не определено, то будет использоваться значение из  theme.bg_minimize

'''theme.bg_image_normal''' - позволяет установить изображение для неактивных в данный момент клиентов

'''theme.bg_image_focus''' - позволяет установить фоновое изображение для активного клиента

'''theme.bg_image_urgent''' - позволяет установить фоновое изображения для &quot;срочного&quot; клиента

'''theme.bg_image_minimize''' - позволяет установить фоновое изображение для свернутого клиента

'''theme.tasklist_disable_icon''' - позволяет отключить отображение иконок, если значение равно true

Для следующих элементов можно использовать только символы (не иконки)
''' theme.tasklist_font''' - шрифт для панели задач, если не определено, то будет испльзоватся шрифт из theme.font

'''theme.tasklist_sticky''' - позволяет установить текст для &quot;липкого&quot; клиента, если значение не установлено, то используется &quot;▪&quot;

'''theme.tasklist_ontop''' - позволяет установить текст/символ для приложения &quot;поверх всех&quot;, если значение не установлено, то используется '⌃'

'''theme.tasklist_floating''' - текст для приложения в &quot;плавающем&quot; режиме, если значение не установлено, то используется '✈'

'''theme.tasklist_maximized_horizontal''' - текст для развернутого по горизонтали приложения, если на установлено, то используется '⬌'

'''theme.tasklist_maximized_vertical''' - текст для приложения развернутого по вертикали, если на установлено, то используется '⬍'

===Awesome 3.4===
Здесь возможностей по настройке намного меньше, это еще одна причина перейти на более новую версию.

'''theme.tasklist_fg_focus''' - цвет текста активного приложения, если значение не определено, используется значение theme.fg_focus

'''theme.tasklist_bg_focus''' - цвет фона активного приложения, если значение не определено, то используется значение theme.bg_focus

'''theme.tasklist_fg_urgent''' - цвет текста &quot;срочного&quot; приложения, если не определено, то будет использоваться значение из theme.fg_urgent

'''theme.tasklist_bg_urgent''' цвет фона &quot;срочного&quot; приложения, если не определено, то будет использоваться значение theme.bg_urgent

'''theme.tasklist_fg_minimize''' - цвет текста свернутого приложения, если не определено, то будет использоваться значение из  theme.fg_minimize

'''theme.tasklist_bg_minimize''' - цвет фона свернутого приложения, если не определено, то будет использоваться значение из  theme.bg_minimize

'''theme.tasklist_floating_icon''' -  иконка для приложения в &quot;плавающем&quot; режиме

'''theme.tasklist_font''' - шрифт для панели задач, если не определено, то будет испльзоватся шрифт из theme.font

===Высота панели ===
Если вас не устраивает стандартная высота панели задач, то ее можно изменить, для этого найдите в rc.lua код отвечающий за создание контейнера mywibox и измените его следующим образом:
&lt;pre&gt;
mywibox[s] = awful.wibox({ position = &quot;top&quot;, height = 24, screen = s })
&lt;/pre&gt;
Здесь вы можете изменить ее расположение, top - сверху, bottom - снизу. height - это высота панели. Или даже можете создать себе вторую панель, переместив панель задач сверху вниз(на примере 3.4):
&lt;pre&gt;
bottomwibox = {}
bottomwibox[s] =  awful.wibox({ position = &quot;bottom&quot;, height = 27, screen = s })
bottomwibox[s].widget = {
              {
                  mylauncher,
                  layout = awful.widget.layout.horizontal.leftright
              },
          mytasklist[s],
          layout = awful.widget.layout.horizontal.rightleft
      }
&lt;/pre&gt;

==Порядок открытых приложений==
По умолчанию новое приложение отображается слева от открытых ранее. Но если вы привыкли к другому, например в Gnome или KDE, то можно настроить, чтобы вновь открываемые приложения открывались справа, т.е. список задач был отсортирован по запуску, где первым в списке будет первое открытое приложение, а последним соответственно последнее.
Для этого необходимо открыть файл ~/.config/awesome/awful/widget/tasklist.lua. Все манипуляции с этими файлами лучше всего делать когда они находится в домашнем каталоге, чтобы если вы что-то испортите, можно было их легко восстановить.
Итак, найдите в этом файле функцию ''function tasklist_update'' в ней есть следующая строка:
'''Awesome 3.4'''
&lt;pre&gt;
table.insert(shownclients,c)
&lt;/pre&gt;
Замените ее на:
&lt;pre&gt;
table.insert(shownclients, 1, c)
&lt;/pre&gt;
'''Awesome 3.5'''
&lt;pre&gt;
table.insert(clients, c)
&lt;/pre&gt;
Замените ее на:
&lt;pre&gt;
table.insert(clients, 1, c)
&lt;/pre&gt;
Перезапустите Awesome.

==Ширина приложений в списке задач ==
Если вас не устраивает, то, что одно запущенное приложение можент занимать все доступное пространоство, на панели задач, то это поведение можно немного изменить. Для этого потребуется отредактировать файл ~/.config/awesome/awful/widget/tasklist.lua
===Awesome 3.4===
Найдите функцию new, в ней необхоидмо изменить 
&lt;pre&gt;
layout = layout.horizontal.flex
&lt;/pre&gt;
На тот вариант расположения виджетов, который вас устраивает. Их полный список находится в файлах awful/widget/layout horizontal.lua и vertical.lua
&lt;pre&gt;
layout = layout.horizontal.leftright
&lt;/pre&gt;
===Awesome 3.5===
Найдите функцию tasklist.new затем замените
&lt;pre&gt;
local w = base_widget or flex.horizontal()
&lt;/pre&gt;
Например следующим кодом:
&lt;pre&gt;
local w = base_widget or fixed.horizontal()
&lt;/pre&gt;
А в начало файла добавьте 
&lt;pre&gt;
local fixed = require(&quot;wibox.layout.fixed&quot;)
&lt;/pre&gt;
Если предоженный вариант вас не устраивает, можете поэкспериментировать с layout'ами, они находятся в каталоге ~/.config/awesome/wibox/layout

Правда ширина каждого клиента будет зависеть от названия, в принципе это тоже можно поправить если вам требуется фиксированная ширина клиентов, для этого нужно изменить в файле tasklist.lua функцию widget_tasklist_label_common (3.4) или tasklist_label (в 3.5):
В начало файла поместите
&lt;pre&gt;
local string = string
&lt;/pre&gt;
Затем перед строкой ''if capi.client.focus == c then''  поместите следующий код:
&lt;pre&gt;
if #name &gt;20 then
    name = string.sub(name,1,20)
end
&lt;/pre&gt;
Здесь мы ограничиваем название 20-ю символами, если вам требуется другое значение, измените его.

Есть еще один ньюанс, при изменении испльзуемой схемы(layout), приложения теперь перестают масштабироваться, и в результате их теперь на панель входит штук 5, конечно это можно изменить, но изменений потребуется достаточно много и они уже выходят за рамки данной статьи. 
==Список клиентов ==
По умолчанию в файле rc.lua для обработки списка клиентов для tasklist используется следующий код:
&lt;pre&gt;
Awesome 3.5
mytasklist[s] = awful.widget.tasklist(s, awful.widget.tasklist.filter.currenttags, mytasklist.buttons)

Awesome 3.4
mytasklist[s] = awful.widget.tasklist(function(c) 
                               return awful.widget.tasklist.label.currenttags(c,s)
                          end, mytasklist.button)
&lt;/pre&gt;
Т.е. изучив данный код, можно понять, что на панели задач, будут отображены клиенты для текущего тега. Если данное положение дел вас не устаривает, то вы можете например отобразить все клиенты со всех тегов, для этого нужно заменить соотвествующую функцию на одну из следующий:
&lt;pre&gt;
Awesome 3.4
awful.widget.tasklist.label.allscreen		- для отображения клиентов со всех экранов
awful.widget.tasklist.label.alltags		- для отображения клиентов со всех тегов текущего экрана
awful.widget.tasklist.label.currenttags		- для отображения клиентов с текущего тега
awful.widget.tasklist.label.focused		- для оторажения только клиентов в фокусе

Awesome 3.5
awful.widget.tasklist.filter.allscreen		- для отображения клиентов со всех экранов
awful.widget.tasklist.filter.alltags		- для отображения клиентов со всех тегов текущего экрана
awful.widget.tasklist.filter.currenttags		- для отображения клиентов с текущего тега
awful.widget.tasklist.filter.minimizedcurrenttags	- для отображения свернутых клиентов на текущем теге
awful.widget.tasklist.filter.focused			- для оторажения только клиентов в фокусе
&lt;/pre&gt;
Помимо этого, есть еще ряд приложений, которые не будут отображаться в списке клиентов, эта функция прописана в следующем коде:
&lt;pre&gt;
Awesome 3.5 - tasklist.lua - function tasklist_update
if not (c.skip_taskbar or c.hidden
            or c.type == &quot;splash&quot; or c.type == &quot;dock&quot; or c.type == &quot;desktop&quot;)
            and filter(c, s) then
            table.insert(clients, c)
        end
&lt;/pre&gt;
Похожий код используется и в 3.4, но без строки ''and filter(c, s)''. Т.е. здесь мы пропускаем часть клиентов, если какие то из них вам все же нужны, удалите код отвечающий за них.

==Сигналы==
Сигналы - это система сообщений которую рассылает ядро Awesome для управления виджетами, клиентами, тегами и т.д. Подробне ознакомится с системой сигналов вы можете [Signals/ru|здесь].
Итак, поддерживаются следующие сигналы:
&lt;pre&gt;
    tag.attached_connect_signal(screen, &quot;property::selected&quot;, u) 
    tag.attached_connect_signal(screen, &quot;property::activated&quot;, u)
    capi.client.connect_signal(&quot;property::urgent&quot;, u)
    capi.client.connect_signal(&quot;property::sticky&quot;, u)
    capi.client.connect_signal(&quot;property::ontop&quot;, u)
    capi.client.connect_signal(&quot;property::floating&quot;, u)
    capi.client.connect_signal(&quot;property::maximized_horizontal&quot;, u)	
    capi.client.connect_signal(&quot;property::maximized_vertical&quot;, u)
    capi.client.connect_signal(&quot;property::minimized&quot;, u)
    capi.client.connect_signal(&quot;property::name&quot;, u)
    capi.client.connect_signal(&quot;property::icon_name&quot;, u)
    capi.client.connect_signal(&quot;property::icon&quot;, u)
    capi.client.connect_signal(&quot;property::skip_taskbar&quot;, u)
    capi.client.connect_signal(&quot;property::screen&quot;, u)
    capi.client.connect_signal(&quot;property::hidden&quot;, u)
    capi.client.connect_signal(&quot;tagged&quot;, u)
    capi.client.connect_signal(&quot;untagged&quot;, u)
    capi.client.connect_signal(&quot;unmanage&quot;, u)
    capi.client.connect_signal(&quot;list&quot;, u)
    capi.client.connect_signal(&quot;focus&quot;, u)
    capi.client.connect_signal(&quot;unfocus&quot;, u)
&lt;/pre&gt;
Названия сигналов говорят сами за себя, единственное, первые 2 улавливают события от тегов, для того, чтобы при смене тега отобразить актуальный список клиентов на нем. После того, как будет принято данное событие будет вызвана функция u:
&lt;pre&gt;u = function () tasklist_update(screen, w, buttons, filter, data, style, uf) end&lt;/pre&gt;
Т.е. панель задач будет обновлена. Так что если вы где то будете менять какое то свойство для клиента, можете не беспокоиться, оно будет отловлено и корректно обработано. Если же нужного вам сигнала здесь нет, то вы всегда можете создать свой.

==Ссылки==
* [[Using Xephyr/ru|Xephyr]] - позволяет открывать Awesome  в новом Х-сервере. Т.е. если вы периодически экспериментируете с исходниками, то для экспериментов используйте Xephyr.
* [[Radical/ru|Radical]] - Мощная и расширяемя система меню 
* [[Hints/ru|Hints]] - Оконные подсказки для фокусировки на окне</text>
      <sha1>l3mbwg60x8wcxcpx531tjvadtxk3csx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tearing</title>
    <ns>0</ns>
    <id>1323</id>
    <revision>
      <id>7448</id>
      <parentid>7447</parentid>
      <timestamp>2016-02-29T14:14:31Z</timestamp>
      <contributor>
        <username>Henry</username>
        <id>4317</id>
      </contributor>
      <text xml:space="preserve" bytes="356">[https://en.wikipedia.org/wiki/Screen_tearing What is screen tearing]

You might experience tearing in 3d games and movie playback make sure to enable vsync and install compton.

To autostart compton add ''awful.util.spawn_with_shell(&quot;compton --opengl&quot;)'' to the end of your config file. 
To test it beforehand just type ''compton --opengl'' in a terminal.</text>
      <sha1>rcm5imjqr4hwbhhldc5jxvf6b5qjgyv</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Terminals</title>
    <ns>0</ns>
    <id>56</id>
    <revision>
      <id>7305</id>
      <parentid>5528</parentid>
      <timestamp>2015-01-25T17:48:39Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>update link for terminator</comment>
      <text xml:space="preserve" bytes="1459">{{Languages}}

There are various terminals available in most Linux distributions. This outlines some of the 'nicer' ones that have features you may be looking for to replace your Desktop terminal

* [[urxvt]] - nice terminal emulator that supports scripting (Perl), unicode, tabs, transparency and clickable URLs.
* [http://materm.sourceforge.net/wiki/ mrxvt] - offers tabs and transparency. (last release 2008)
* [http://roxterm.sourceforge.net/ ROXTerm] - terminal emulator intended to provide similar features to gnome-terminal, based on the same VTE library, but with a smaller footprint and quicker start-up time.
* [http://www.pleyades.net/david/projects/sakura sakura] - based on VTE, light and fast; unicode, tabs (but can be used like non-tabbed terminal), fake-transparency.
* [http://lilyterm.luna.com.tw/index_en.html Lilyterm]  - a light and easy to use libvte based X Terminal Emulator.
* [http://www.afterstep.org/aterm.php aterm] - an rxvt derivative with fast pseudo-transparency and text &quot;fading&quot;. (last release 2007)
* [https://github.com/nonstop/termit/wiki/ TermIt] - lightweight terminal emulator with embedded Lua
* [https://code.google.com/p/jessies/wiki/Terminator Terminator] - similar to ROXTerm but with advanced features not yet found elsewhere; logging, drag&amp;drop, find, horiz+vert scrolling...
* [http://www.calno.com/evilvte/ evilvte] - very small and fast tab-supporting terminal application based on the VTE terminal library.</text>
      <sha1>kdxklb5t0a587vt2uhruay3j2urqc7g</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Terminals/fr</title>
    <ns>0</ns>
    <id>419</id>
    <revision>
      <id>3341</id>
      <parentid>3209</parentid>
      <timestamp>2009-07-15T18:40:00Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use DISPLAYTITLE instead of Template:Title</comment>
      <text xml:space="preserve" bytes="1608">{{DISPLAYTITLE:Consoles virtuelles}}
{{Languages|Terminals}}

Il y a de nombreuses consoles virtuelles dans la plupart des distributions GNU–Linux. Cette liste propose les « plus sympas » qui ont des fonctionnalités que vous recherchez peut-être pour remplacer votre console de bureau :

* [[urxvt]] : console virtuelle sympa qui supporte le scriptage (Perl), les symboles unicode, la gestion d’onglets, la transparence et des liens hypertextes cliquables.
* [http://materm.sourceforge.net/wiki/ mrxvt] : offre des onglets et de la transparence
* [http://roxterm.sourceforge.net/ ROXTerm] : console virtuelle prévue pour fournir des fonctionnalités similaires à gnome-terminal, elle est fondée sur la même bibliothèque VTE library, mais avec un poids plus léger et un temps de démarrage plus court.
* [http://www.pleyades.net/david/sakura.php sakura] : fondée sur VTE, légère et rapide ; unicode, onglets (mais peut être utilisée comme console sans onglet), pseudo-transparence.
* [http://lilyterm.luna.com.tw/index_en.html Lilyterm] : console virtuelle légère et rapide, fondée sur libvte.
* [http://www.afterstep.org/aterm.php aterm] : dérivée d’rxvt avec de la pseudo-transparence rapide et des effets d’« estompement » de texte.
* [http://code.google.com/p/termit/wiki/TermIt TermIt] : console virtuelle légère embarquant du Lua.
* [http://software.jessies.org/terminator/ Terminator] : similaire à ROXTerm mais avec des fonctionnalités avancées qu’on ne trouve pas ailleurs ; connexion, glisser–déposer, recherche, défilements horizontal et vertical, etc.</text>
      <sha1>s8n8u86qsl7m2qvhj7mz7f113tolx52</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Terminals/ru</title>
    <ns>0</ns>
    <id>465</id>
    <revision>
      <id>7306</id>
      <parentid>6728</parentid>
      <timestamp>2015-01-25T17:49:54Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>Обновлена ссылка на Terminator</comment>
      <text xml:space="preserve" bytes="2753">{{DISPLAYTITLE:Эмуляторы терминала}}
{{Languages|Terminals}}

Существует множество различных эмуляторов терминала, доступных в большинстве дистрибутивов Linux. Вот список тех из них, которые не уступают по функциональности используемым в окружениях рабочего стола:

* [[urxvt]] - urxvt - отличный эмулятор терминала с поддержкой скриптов (на Perl), Unicode, вкладок, прозрачности и открытия URL в выбранном приложении.
* [http://materm.sourceforge.net/wiki/ mrxvt] - mrxvt поддерживает вкладки и прозрачность. (последнее обновление 2008 год)
* [http://roxterm.sourceforge.net/ ROXTerm] - ROXTerm - это эмулятор терминала, предоставляющий те же функции, что и gnome-terminal и основанный на той же библиотеке VTE. В отличие от gnome-terminal, ROXTerm занимает меньше памяти и быстрее запускается.
* [http://www.pleyades.net/david/sakura.php sakura] - основанный на VTE, лёгкий и быстрый; поддерживает Unicode, вкладки (хотя может использоваться и без них), псевдопрозрачность;
* [http://lilyterm.luna.com.tw/index_en.html Lilyterm]  - лёгкий и простой в использовании эмулятор терминала, основанный на libvte.
* [http://www.afterstep.org/aterm.php aterm] - производный от rxvt эмулятор терминала с псевдопрозрачностью и опциональным затемнением текста при потере фокуса. (последнее обновление 2007 год)
* [http://code.google.com/p/termit/wiki/TermIt TermIt] - легковесный эмулятор терминала со встроенным интерпретатором Lua.
* [https://code.google.com/p/jessies/wiki/Terminator Terminator] - похож на ROXTerm, но имеет ряд функций, отсутствующих в некоторых эмуляторах; ведение журнала, поддержка drag&amp;drop, поиск, горизонтальный и вертикальный скроллинг...
* [http://www.calno.com/evilvte/ evilvte] - очень легкий и быстрый терминал с поддержкой вкладок, основанный на VTE terminal library.</text>
      <sha1>s6r3uvz36hn85ed9vmj033tr5n0v3od</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>The briefest introduction to Lua</title>
    <ns>0</ns>
    <id>716</id>
    <revision>
      <id>7082</id>
      <parentid>7081</parentid>
      <timestamp>2014-10-25T06:08:48Z</timestamp>
      <contributor>
        <username>Macklenc</username>
        <id>3801</id>
      </contributor>
      <minor/>
      <comment>/* So far so good */</comment>
      <text xml:space="preserve" bytes="10711">In order to configure and extend Awesome you will need to know at least a little Lua. There are a lot of books, manuals and tutorials on the Web, but who's got time for that? The aim of this page is to provide a very terse introduction which will familiarize newcomers with just enough about Lua to use and configure Awesome. In order to learn more Lua than that, you should read [http://lua-users.org/wiki/TutorialDirectory a more comprehensive tutorial].

=== How to get started ===

If you have '''Awesome''' installed, then you already have '''Lua'''. Open your terminal and type &quot;lua&quot;. Here it is, your interactive lua environment.

=== What is Lua like? ===

* Lua has a mix of C-like and Pascal-like syntax.

* Lua is dynamically typed (like JavaScript).

=== General stuff ===

* Spaces don't matter - use as many as you like

* Linebreaks don't matter - use as many as you like

* Indentation doesn't matter - use as much as you like

* No semicolons - &lt;s&gt;use as much as you like&lt;/s&gt; don't use them

* On a given line, any text to the right of '''--''' is considered a comment

=== Types ===

* Numbers. '''123''' and '''0.456''' are numbers. Lua doesn't make a distinction between integer and real numbers, so don't worry, you can safely compare any number.

You can use the mathematical expressions +, -, * and / on numbers.

    &gt; print(2+2)
    4
    &gt; print ( 5 / 2 )
    2.5

* Booleans. '''true''' and '''false''' are booleans. '''==''', '''&gt;''', '''&lt;''', '''&gt;=''', '''&lt;=''' are comparison operators. '''~=''' is &quot;not equal&quot; operator (instead of !=). There are also: '''and''', '''or''', '''not'''.

  &gt; print(5 &gt;= 3 and not (3 &lt; 0))
  true
  &gt; print(2.5 == 2)
  false

* Strings. Strings represent a sequence of characters. They can be enclosed in '''&quot;''' (double quote) or '''&lt;nowiki&gt;'&lt;/nowiki&gt;''' (single quote) symbols (if you choose one, the other won't be considered a control symbol). You can also escape symbols with '''\'''. Concatenation operator is '''..''' (instead of + in some languages).

  &gt; print( &quot;I am printin' \&quot;My first string\&quot;\non two lines&quot; )
  I am printin' &quot;My first string&quot;
  on two lines

Note: numbers are automatically treated as strings when concatenated, but other types(such as the boolean (5 == 0) in the example below) are not - use '''tostring''' on them.

  &gt; print( &quot;This number is &quot; .. 5 .. &quot; and it equals zero: &quot; .. tostring(5 == 0))
  This number is 5 and it equals zero: false

* nil. '''nil''' (like null in many languages) means nothing. And equals nothing except itself. You'll learn more about nil later on.

* Tables. Tables are ubiquitous in Lua. A table is an array and a hashmap (dictionary) at the same time. It is an ad hoc data structure.  An empty table is defined like this: '''{}'''. Table keys can be of any type - integer, string, boolean or even another table.

  &gt; x = {}          -- Wow, we defined our first variable! Yes, it is simple like this.
  &gt; x[1] = &quot;our first item&quot;
  &gt; print(x[1])     -- This is how we get a value by key from the table
  our first item
  &gt; x[&quot;wm&quot;] = &quot;awesome&quot;
  &gt; print(x[&quot;wm&quot;])
  awesome

You can define a table and some initial key values simultaneously. This is done like: '''y = { key = &quot;somevalue&quot;, anotherkey = &quot;anothervalue&quot; }'''. Comma is a separator here. Only string keys (without quotes) are supported this way.

Lua offers one nifty mechanism for tables - you can access the values by the string key with following syntax: '''table.key'''. This creates an illusion of a data structure.

  &gt; x = {}
  &gt; x.color = &quot;white&quot;  -- Same as x[&quot;color&quot;] = &quot;white&quot;
  &gt; print(x.color)
  white
  &gt; x.wm_langs = { xmonad = &quot;Haskell&quot;, awesome = &quot;Lua&quot; }
  &gt; print(x.wm_langs.awesome) -- Same as x[&quot;wm_langs&quot;][&quot;awesome&quot;]
  Lua

If table doesn't have any value for the given key it means that the value equals '''nil'''.

  &gt; x = {}
  &gt; print(x.blahblah)
  nil

You can initialize tables without specifying keys, then it will act as an array with values mapped to number keys.

  &gt; x = { &quot;first&quot;, &quot;second&quot;, &quot;third&quot; }
  &gt; print(x[2])
  second
  &gt; print(x.2)     -- No, no! Only string keys can be referenced like this!
  stdin:1: `)' expected near `.2'
  &gt; print(x[&quot;2&quot;])  -- 2 and &quot;2&quot; are not equal, of course
  nil

* Function. We will talk about functions later, now you should know, that any function can be assigned to a variable, passed as an argument or be returned from another function.

  &gt; ourfunction = print
  &gt; ourfunction(2+2)
  4
  &gt; get_length = string.len
  &gt; ourfunction(get_length(&quot;some string&quot;))
  11

=== Variables ===

As was said earlier, Lua is dynamically typed. That means that you don't have to define the type explicitly - any variable can have any type.
Until variable gets declared it has the value '''nil'''. To declare a variable just assign value to it.

  &gt; print(a)  -- a wasn't declared yet
  nil
  &gt; a = 42
  &gt; print(a)
  42
  &gt; a = &quot;the answer is &quot; .. a
  &gt; print(a)
  the answer is 42

==== Local ====

Whenever you assign value to a variable, it becomes visible to the whole environment. It becomes global (you can avoid it by using modules, but we do not cover modules in this short tutorial). To keep your variables inside use the keyword '''local'''. With '''local''' your variable will be visible only to the block (function, control structure, file) where it is defined.

  &gt; a = 42
  &gt; if a == 42 then            -- If you press &quot;Return&quot; here, the next line will be 
  &gt;&gt; local a = 10              -- preceeded with &gt;&gt;. This means that you are currently
  &gt;&gt; print(&quot;Inside: &quot; .. a)    -- inside the block (in this case, if..then block)
  &gt;&gt; local b = 100
  &gt;&gt; end
  Inside: 10
  &gt; print(a)
  42                           -- See, local binding replaced a with 10 only inside the block
  &gt; print(b)
  nil                          -- And the variable b was never globally declared

==== Multiple assignment ====

In Lua you can assign many values to many variables at the same time. It looks like this:

  &gt; a, b, c = 1, &quot;and&quot;, 2
  &gt; print(a..b..c)
  1and2
  &gt; a, b, c = 1, &quot;and&quot;
  &gt; print(c)
  nil      -- c hadn't got its value pair, so it was assigned to nil
  &gt; a, b, c = 5, &quot;and&quot;, 6, &quot;and&quot;, 7
  &gt; print(a..b..c)
  5and6    -- all unused values just went to Limbo

=== Control structures ===

==== Conditions ====

The syntax is simple: 
'''if''' ''condition'' '''then''' ''code'' '''else''' ''code'' '''end'''.

  &gt; food = &quot;beans&quot;
  &gt; if food == &quot;cake&quot; then
  &gt;&gt; print(&quot;Yummy!&quot;)
  &gt;&gt; else
  &gt;&gt; print(&quot;Ew, I won't eat that!&quot;)
  &gt;&gt; end
  Ew, I won't eat that!

We can leave aside the '''else''' part if we are not interested in it.

  &gt; under_attack = true
  &gt; if under_attack then    -- Booleans can be used like this in conditions
  &gt;&gt; print(&quot;Alarm!&quot;)
  &gt;&gt; end
  Alarm!

If you want to analyze more conditions, use '''elseif''':

  &gt; n = -42
  &gt; if n &gt; 0 then
  &gt;&gt; print(&quot;Positive&quot;)
  &gt;&gt; elseif n &lt; 0 then
  &gt;&gt; print(&quot;Negative&quot;)
  &gt;&gt; else
  &gt;&gt; print(&quot;Zero&quot;)
  &gt;&gt; end
  Negative

==== Loops ====

* Conditional loop. Has the following syntax: '''while''' ''condition'' '''do''' ''code'' '''end'''.

  &gt; i, r = 0, &quot;&quot;
  &gt; while i &lt; 10 do
  &gt;&gt; r = r .. i
  &gt;&gt; i = i + 1
  &gt;&gt; end
  &gt; print(r)
  0123456789

* For loop. To loop through a range of numbers use the folowing construct: 
'''for''' ''var'' = ''start_num'',''end_num'' '''do''' ''code'' '''end'''.

  &gt; r = &quot;&quot;
  &gt; for i = 0, 9 do
  &gt;&gt; r = r .. i
  &gt;&gt; end
  &gt; print(r)
  0123456789

* Foreach loop. Lua allows you iterate through a table with the following syntax:
'''for''' ''key_var'', ''value_var'' '''in''' pairs(''table_name'') '''do''' ''code'' '''end'''.

  &gt; a = { red=&quot;#FF0000&quot;, yellow=&quot;#FFFF00&quot;, white=&quot;#FFFFFF&quot; }
  &gt; for name, color_code in pairs(a) do
  &gt;&gt; print(name .. &quot; is &quot; .. color_code)
  &gt;&gt; end
  yellow is #FFFF00
  white is #FFFFFF
  red is #FF0000

Note that the order of traversing is not guaranteed.

You can iterate through an &quot;array&quot; with ''ipairs''. In this case the order is guaranteed.

  &gt; a, caesar = { &quot;veni, &quot;, &quot;vidi, &quot;, &quot;vici&quot; }, &quot;&quot;
  &gt; for i, v in ipairs(a) do
  &gt;&gt; caesar = caesar .. v    -- We just don't use the key, only value
  &gt;&gt; end
  &gt; print(caesar)
  veni, vidi, vici
  
=== Functions ===

The basic syntax for defining a function is: ''function_name'' = '''function'''(''arguments'') ''code'' '''end'''. To return the value from a function use the keyword '''return'''.

  &gt; sum = function(a,b) return a + b end
  &gt; print( sum(2,2) )
  4

If you don't supply some arguments to a function, then they will just be assigned to '''nil'''.

  &gt; print_three_args = function(a, b, c)
  &gt;&gt; print(&quot;First: &quot; .. tostring(a))    -- We use tostring() here because 
  &gt;&gt; print(&quot;Second: &quot; .. tostring(b))   -- nil is not automatically cast
  &gt;&gt; print(&quot;Third: &quot; .. tostring(c))    -- when concatenated
  &gt;&gt; end
  &gt; print_three_args(10,20)
  First: 10
  Second: 20
  Third: nil

The function can return more than one value at once. You need to use multiple assignment to get all result values.

  &gt; sum_and_diff = function(a, b) 
  &gt;&gt; return a+b, a-b
  &gt;&gt; end
  &gt; x, y = sum_and_diff(5,3)
  &gt; print(x, y)   -- print() can actually handle more than one argument.
  8     2         -- It prints them separated by tab.

There is a more convenient way to define functions:
'''function''' ''function_name'' (''arguments'') ''code'' '''end'''

  &gt; function doubler (x)
  &gt;&gt; return x * 2
  &gt;&gt; end
  &gt; print( doubler(42) )
  84

=== Useful stuff ===

==== Nil in conditions ====

In conditions '''nil''' always evaluates to false. It allows to do such witty tricks:

  &gt; f = io.open(&quot;foo.txt&quot;)  -- Trying to open some file. If the file exists, than
  &gt; if f then               -- variable f will contain some table, else f will be nil.
  &gt;&gt; print(&quot;File exists&quot;)
  &gt;&gt; else print(&quot;File not found&quot;) end
  File not found

Or you can use this to supply default arguments to your function. Consider this example:

  &gt; function multiplicator (x, y)
  &gt;&gt; y = y or 2    -- If y is nil, then it will be assigned to 2
  &gt;&gt; return x * y
  &gt;&gt; end
  &gt; print(multiplicator(10, 3))
  30
  &gt; print(multiplicator(10))
  20

==== Useful libraries ====

If you plan to write something for Awesome, you'll need to learn how to use the following libraries: [http://lua-users.org/wiki/StringLibraryTutorial string], [http://lua-users.org/wiki/TableLibraryTutorial table], [http://lua-users.org/wiki/IoLibraryTutorial io].

=== So far so good ===

Now you know enough Lua to at least understand the mess in your '''rc.lua''' file. This is a beginning. The more you read and change your configuration file the more you'll learn about Lua. If you really want to explore every part of Awesome and write something yourself, you should consider reading the tutorial I mentioned at the beginning.

Good luck hacking Lua!</text>
      <sha1>9s9187p8ippaybcnjho6oy5fpt2htvo</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Thunderbird Task Widget</title>
    <ns>0</ns>
    <id>551</id>
    <revision>
      <id>4226</id>
      <parentid>4225</parentid>
      <timestamp>2010-04-27T12:30:08Z</timestamp>
      <contributor>
        <username>Boyska</username>
        <id>455</id>
      </contributor>
      <comment>/* A slightly more complex but SAFE way */</comment>
      <text xml:space="preserve" bytes="4651">This widget will display some info about your tasks in Thunderbird.

[[Image:Thundertask_preview_small.png‎|thumb|300px|The widget is the &lt;nowiki&gt;0/5/2&lt;/nowiki&gt; in &lt;nowiki&gt;red/cyan/white&lt;/nowiki&gt;]]

== Script ==

We have 2 scripts: task_reader.sh and task_summary.sh.
You can download it from pastie.org: http://pastie.org/932862 http://pastie.org/932863

The dirty job is done in task_reader.sh, however. task_summary is just an utility.
What task_reader does is giving a select command to thunderbird's local.sqlite

'''NOTE:''' if you have multiple thunderbird accounts the script will FAIL, because it uses ~/.thunderbird/*/
to workaround the profile name randomness. You can easily fix changing line 2 in task_summary.sh

You can try if that works for you running
 sh task_summary.sh

It should print the number of number of high, medium and low priority tasks you have.

== The awesome part ==

=== Creating the widget ===

We have to use [[bashets]] so remember to add require(&quot;bashets&quot;) at the top of your file and bashets.start() somewhere

Now, do this:
 taskw = widget({type = &quot;textbox&quot;, name = &quot;taskw&quot;, popup = nil })
 bashets.register_async(taskw, 
                '/your/path/to/task_summary.sh', 
                '&lt;nowiki&gt;&lt;b&gt;&lt;span color=&quot;red&quot;&gt;$1&lt;/span&gt;/&lt;span color=&quot;cyan&quot;&gt;$2&lt;/span&gt;/&lt;span color=&quot;white&quot;&gt;$3&lt;/span&gt;&lt;/b&gt;&lt;/nowiki&gt;&quot;', 
                20, 2)


Yes, we are using async because, unfortunately, task_reader.sh is a bit slow and it will make awesome lag.

=== Open thunderbird on click ===

We have a widget, so we want to make it powerful.
This opens thunderbird when clicked. Note that, if thunderbird is already running, it will only &quot;raise&quot; it.

 taskw:buttons(awful.util.table.join(
   awful.button({ }, 1, function () awful.util.spawn_with_shell('thunderbird') end)
 ))

=== Displaying a tooltip ===

[[Image:Thundertask preview tooltip.png|thumb|300px]]

I found two ways of implementing this; they do the same job (you can see it in the preview), but one is buggy, while the other is not.
YOU SHOULD FOLLOW THE FIRST!!
I include the buggy one just for the sake of completeness, and because it's a bit tidier

==== A slightly more complex but SAFE way ====
We have to create still another shell file [http://pastie.org/937131]
It will simply call task_reader.sh, add some HTML and, most important, '''cache it''' (it will simply put the contents in /tmp/thunder_task_cache ).
We'll then do this

 taskw_popup = nil
 function taskw_get_popup_text ()
   awful.util.spawn('/home/davide/coding/projects/cli_utils/thunder_task/task_cache.sh')
 end
 function taskw_show_popup ()
   taskw_popup = naughty.notify({
 	text = awful.util.pread('cat /tmp/thunder_task_cache'),
 	title = &quot;Tasks&quot; 
   }) 
 end
 function taskw_close_popup()
   if taskw_popup ~= nil then
 	naughty.destroy(taskw_popup)
 	taskw_popup = nil
   end
 end
 taskw:add_signal(&quot;mouse::enter&quot;, taskw_show_popup )
 taskw:add_signal(&quot;mouse::leave&quot;, taskw_close_popup )
 taskw_popup_text_timer = timer({timeout=10})
 taskw_popup_text_timer:add_signal('timeout', taskw_get_popup_text)
 taskw_popup_text_timer:start()

==== The easy (but buggy) way ====

'''You shouldn't use this. It's of course usable, but not optimal. It will make awesome lag when hovering the widget'''

It's a bit dirty, but that's it.
I'm sure there is a better way to do this, but I just can't find it. If you do, please write it here

Adding this to your rc.lua will result in a tooltip like the one in preview.
You have all your tasks displayed, highlighted with different colors (according to priority)

'''BUG''': showing the tooltip '''will block awesome'''. In fact, calling task_reader.sh is slow, and doing it three times is even slower. However, it just take 1 second on my computer; and when I'm hovering that widget, I'm not doing anything else, so that lagging is not so bad. Anyway, we should find a better way of doing this.

 taskw_popup = nil
 function taskw_show_popup ()
   taskw_popup = naughty.notify({
 	text = '&lt;span color=&quot;red&quot;&gt;' .. 
 	awful.util.pread('/home/davide/coding/projects/cli_utils/thunder_task/task_reader.sh high') ..
 	'&lt;/span&gt;&lt;span color=&quot;cyan&quot;&gt;' ..
 	awful.util.pread('/home/davide/coding/projects/cli_utils/thunder_task/task_reader.sh normal') ..
 	'&lt;/span&gt;&lt;span color=&quot;white&quot;&gt;' ..
 	awful.util.pread('/home/davide/coding/projects/cli_utils/thunder_task/task_reader.sh low') ..
 	'&lt;/span&gt;', 
 	title = &quot;Tasks&quot; 
   }) 
 end
 function taskw_close_popup()
   if taskw_popup ~= nil then
 	naughty.destroy(taskw_popup)
 	taskw_popup = nil
   end
 end
 taskw:add_signal(&quot;mouse::enter&quot;, taskw_show_popup )
 taskw:add_signal(&quot;mouse::leave&quot;, taskw_close_popup )</text>
      <sha1>dwqztai9xvco4x42ac7ghys6uf27bu7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Thèmes Beautiful</title>
    <ns>0</ns>
    <id>408</id>
    <redirect title="Beautiful themes/fr" />
    <revision>
      <id>3043</id>
      <timestamp>2009-06-25T20:27:10Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Thèmes Beautiful]] to [[Beautiful themes/fr]] over redirect: Fix for [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="33">#REDIRECT [[Beautiful themes/fr]]</text>
      <sha1>1lljs0waxfljgdx4r41u5deh02tskeq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Titlebar and Statusbar height</title>
    <ns>0</ns>
    <id>160</id>
    <revision>
      <id>5583</id>
      <parentid>4461</parentid>
      <timestamp>2012-09-01T20:08:45Z</timestamp>
      <contributor>
        <username>Jackarg</username>
        <id>1068</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="1596">{{Languages|Titlebar and Statusbar height}}

== Awesome version 3.4.1 or later ==

Edit the rc.lua file to add a height or width argument:
&lt;pre&gt;
    -- Create the wibox
    mywibox[s] = awful.wibox({ position = &quot;top&quot;, height = &quot;18&quot;, screen = s })
&lt;/pre&gt;
use width instead of height if position is left or right instead of top or bottom.

== Awsome 3 but less than 3.4.1 ==

''' Minimum requirements '''

* Awesome version 3.
* Your favorite text editor (like VIM).
* A few minutes.

''' Titlebar '''

You need patched version of &lt;b&gt;awful&lt;/b&gt; library. It's placed at /usr/share/awesome/lib/awful.lua

Edit function &lt;b&gt;titlebar.add(c, args)&lt;/b&gt; and add &quot;&lt;em&gt;if args.height then targs.height = args.height end&lt;/em&gt;&quot; like below:
&lt;pre&gt;
    -- Built args
    local targs = {}
    -- height attribute support
    if args.height then targs.height = args.height end
    if args.fg then targs.fg = args.fg end
    if args.bg then targs.bg = args.bg end
    local tb = capi.titlebar(targs)
&lt;/pre&gt;

Now we should edit rc.lua file.

Edit function &lt;b&gt;hook_manage(c)&lt;/b&gt; like below:
&lt;pre&gt;
    if use_titlebar then
        -- Add a titlebar
        awful.titlebar.add(c, { modkey = modkey, height = &quot;14&quot; })
    end
&lt;/pre&gt;


''' Statusbar '''

Like a Titlebar we should edit rc.lua file again. Look in file line
&lt;pre&gt;mystatusbar[s] = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; .. s,&lt;/pre&gt;
and change it to 
&lt;pre&gt;mystatusbar[s] = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; .. s, height = &quot;16&quot;,&lt;/pre&gt;


Now we ready to reload config. Press &lt;b&gt;Meta4+Ctrl+r&lt;/b&gt; and enjoy ;)





[[Category:awesome3]]</text>
      <sha1>8wvzql2eppjonfgip8o6udqkw50a82d</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Titlebar and Statusbar height/ru</title>
    <ns>0</ns>
    <id>460</id>
    <revision>
      <id>6409</id>
      <parentid>3456</parentid>
      <timestamp>2014-05-01T19:13:14Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <text xml:space="preserve" bytes="2386">{{Languages|Titlebar and Statusbar height}}
{{DISPLAYTITLE:Изменение высоты панелей и заголовков окон}}

== Для версии Awesome 3.4.1 или более поздней ==

Отредактируйте файл rc.lua чтобы добавить значение высоты или ширины:
&lt;pre&gt;
    -- Создание wibox
    mywibox[s] = awful.wibox({ position = &quot;top&quot;, height = &quot;18&quot;, screen = s })
&lt;/pre&gt;
используйте ширину вместо высоты, если wibox расположен слева или справа, вместо верха или низа.

== Awsome 3, но ниже 3.4.1 ==
''' Минимальные требования '''

* Awesome версии 3.
* Ваш любимый текстовый редактор (например, VIM).
* Несколько минут.


''' Заголовки окон '''

Вам потребуется модифицировать библиотеку &lt;b&gt;awful&lt;/b&gt;. Она находится в файле /usr/share/awesome/lib/awful.lua

Измените функцию &lt;b&gt;titlebar.add(c, args)&lt;/b&gt; и добавьте &quot;&lt;em&gt;if args.height then targs.height = args.height end&lt;/em&gt;&quot;, как показано в примере:
&lt;pre&gt;
    -- Built args
    local targs = {}
    -- height attribute support
    if args.height then targs.height = args.height end
    if args.fg then targs.fg = args.fg end
    if args.bg then targs.bg = args.bg end
    local tb = capi.titlebar(targs)
&lt;/pre&gt;

Теперь нужно отредактировать файл rc.lua.

Измените функцию &lt;b&gt;hook_manage(c)&lt;/b&gt;:
&lt;pre&gt;
    if use_titlebar then
        -- Добавление заголовка окна
        awful.titlebar.add(c, { modkey = modkey, height = &quot;14&quot; })
    end
&lt;/pre&gt;


''' Панели '''

Как и в случае с заголовками окон, отредактируйте файл rc.lua. Найдите в нём строку
&lt;pre&gt;mystatusbar[s] = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; .. s,&lt;/pre&gt;
и замените её на
&lt;pre&gt;mystatusbar[s] = statusbar({ position = &quot;top&quot;, name = &quot;mystatusbar&quot; .. s, height = &quot;16&quot;,&lt;/pre&gt;


Теперь можно перезагрузить файл конфигурации. Нажмите &lt;b&gt;Meta4+Ctrl+r&lt;/b&gt; и наслаждайтесь ;)

[[Category:awesome3]]</text>
      <sha1>0sznxeb1428u3eq6g3x50bztlhdourf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>TranslateIt</title>
    <ns>0</ns>
    <id>1121</id>
    <revision>
      <id>6892</id>
      <parentid>6891</parentid>
      <timestamp>2014-07-29T14:36:48Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>Script requires</comment>
      <text xml:space="preserve" bytes="2173">{{Languages}}
{{DISPLAYTITLE:Translate selected text}}

If you are sometime read site, man pages or other text on foreign languages, this article can help you. 

So, you are select text (don't copy), no matter browser, console or IM, press ''Mod4+Control+t'' and get notify with translating text. It's so simple!

''Note:''The script doesn't lead to hangup for Awesome, if no internet. It's use Google.Translate.

'''Script requires: curl, html2text, iconv, awk, sed, xclip'''

First, you need create bash script named ''gtranslate'' and put them to your script folder.
&lt;pre&gt;
#!/bin/bash

if [ -z &quot;$1&quot; ]
  then
    echo &quot;Exiting&quot;
fi
     
text=&quot;$1&quot;
 
l_source=&quot;auto&quot;
l_target=&quot;ru&quot;       #change to your language
     
result=$(curl --connect-timeout 1 -s -i --user-agent &quot;&quot; -d &quot;sl=$l_source&quot; -d &quot;tl=$l_target&quot; --data-urlencode &quot;text=$text&quot; https://translate.google.com)
encoding=$(awk '/Content-Type: .* charset=/ {sub(/^.*charset=[&quot;'\'']?/,&quot;&quot;); sub(/[ &quot;'\''].*$/,&quot;&quot;); print}' &lt;&lt;&lt;&quot;$result&quot;)
result=$(iconv -f $encoding &lt;&lt;&lt;&quot;$result&quot; |  awk 'BEGIN {RS=&quot;&lt;/div&gt;&quot;};/&lt;span[^&gt;]* id=[&quot;'\'']?result_box[&quot;'\'']?/' | html2text -utf8 | sed 's/&lt;[^&gt;]*&gt;//g')
#copy translated text to clipboard
echo $result | xclip -in -sel clip
result=`echo &quot;naughty.notify({title=\&quot;Перевод: \&quot;, text=\&quot; $result\&quot;, timeout = 20})&quot;`
echo $result | awesome-client -
     
exit
&lt;/pre&gt;
Give them rights for execute:
&lt;pre&gt;
chmod +x gtranslate
&lt;/pre&gt;

So, add in your ''rc.lua'' follow function:
&lt;pre&gt;
function clip_translate()
    local clip = nil
    clip = awful.util.pread(&quot;xclip -o&quot;)
    if clip then
       awful.util.spawn(&quot;/home/user/script/gtranslate \&quot;&quot; .. clip ..&quot;\&quot;&quot;,false)   --change path to script       
    end
end
&lt;/pre&gt;

And, finally, add keybinding on Standart program section:
&lt;pre&gt;
 awful.key ({modkey, &quot;Control&quot; }, &quot;t&quot;, function () clip_translate() end),
&lt;/pre&gt;

'''Awesome 3.5'''

Due to the fact that in Lua 5.2 introduced an explicit declaration of libraries as local variables, you need to remove local, ie make a call naughtly follows
Remove 'local' in your rc.lua befor naughtly:
&lt;pre&gt;
 naughty = require(&quot;naughty&quot;)
&lt;/pre&gt;

Restart Awesome, and enjoy!


[[Category:awesome3]]</text>
      <sha1>r97r3uu5acnrx8k7xr2go04udmj3mul</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>TranslateIt/ru</title>
    <ns>0</ns>
    <id>1130</id>
    <revision>
      <id>6890</id>
      <parentid>6888</parentid>
      <timestamp>2014-07-29T14:32:50Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>Now xclip getting only translated text</comment>
      <text xml:space="preserve" bytes="4199">{{Languages|TranslateIt}}
{{DISPLAYTITLE:Перевод текста}}
'''Работоспособность скрипта проверена на Awesome 3.4 и 3.5.5'''

Awesome 3.5
В связи с тем, что в Lua 5.2 введено явное объявление библиотек как локальных переменных, нужно удалить local, т.е. сделать вызов naughtly следующим образом:
&lt;pre&gt;
 naughty = require(&quot;naughty&quot;)
&lt;/pre&gt;

Периодически читая man, или знакомясь с очередной статьей в Интернете на английском, порой возникают сложности в понимании некоторых слов. Приходилось запускать какой-либо из переводчиков, копировать текст в буфер, переключаться на него, вставлять, и нажимать кнопку перевести. Слишком много действий, да и времени тоже.

И вот буквально на днях пользователь SLEDopit на сайте [http://unixforum.org/index.php?showtopic=137076&amp;view=findpost&amp;p=1263645 UnixForum] привел скрипт работающий с Google.Translate. А у меня как раз созрело решение, как объединить этот скрипт и Awesome.

Итак, теперь я просто выделяю текст, в браузере или консоли, или даже в Pidgin(не копирую, а просто выделяю - на самом деле так работает X буфер), нажимаю ''Mod4+Control+t'' и получаю уведомление с переведенным текстом. А также переведенный текст будет скопирован в буфер. Вот так это работает.
'''Примечание:''' Скрипт реализован таким образом, что даже при отсутствии интернета Awesome висеть не будет.

Для работы скрипта требуются установленный curl, html2text, iconv, awk, sed, xclip
Для начала создадим скрипт ''gtranslate'' и поместим его в папку со своими скриптами:
&lt;pre&gt;
#!/bin/bash
     
if [ -z &quot;$1&quot; ]
  then
     echo &quot;Exiting&quot;
fi
   
text=&quot;$1&quot;
l_source=&quot;auto&quot;

if [[ &quot;$text&quot; =~ ^[а-яА-ЯёЁ].* ]]
 then    
    l_target=&quot;en&quot;
  else    
    l_target=&quot;ru&quot;
fi
     
result=$(curl --connect-timeout 1 -s -i --user-agent &quot;&quot; -d &quot;sl=$l_source&quot; -d &quot;tl=$l_target&quot; --data-urlencode &quot;text=$text&quot; https://translate.google.ru)
encoding=$(awk '/Content-Type: .* charset=/ {sub(/^.*charset=[&quot;'\'']?/,&quot;&quot;); sub(/[ &quot;'\''].*$/,&quot;&quot;); print}' &lt;&lt;&lt;&quot;$result&quot;)
result=$(iconv -f $encoding &lt;&lt;&lt;&quot;$result&quot; |  awk 'BEGIN {RS=&quot;&lt;/div&gt;&quot;};/&lt;span[^&gt;]* id=[&quot;'\'']?result_box[&quot;'\'']?/' | html2text -utf8 | sed 's/&lt;[^&gt;]*&gt;//g')
echo $result | xclip -in -sel clip     #копируем перевод в буфер
result=`echo &quot;naughty.notify({title=\&quot;Перевод: \&quot;, text=\&quot; $result\&quot;, timeout = 20})&quot;`
echo $result | awesome-client -
     
exit
&lt;/pre&gt;

Даем файлу права на выполнение:
&lt;pre&gt;
chmod +x gtranslate
&lt;/pre&gt;

Теперь добавьте в ваш rc.lua функцию clip_translate:
&lt;pre&gt;
function clip_translate()
    local clip = nil
    clip = awful.util.pread(&quot;xclip -o&quot;)
    if clip then
       awful.util.spawn(&quot;/home/user/script/gtranslate \&quot;&quot; .. clip ..&quot;\&quot;&quot;,false)                
    end
end
&lt;/pre&gt;

Ну и напоследок, добавляем в секцию Standart program клавиши для вызова нашей функции:
&lt;pre&gt;
 awful.key ({modkey, &quot;Control&quot; }, &quot;t&quot;, function () clip_translate() end),
&lt;/pre&gt;

Перезапускаем Awesome, выделяем текст нажимаем Mod4+Ctrl+t и наслаждаемся переводом!

За помощь в отладке и модификации скрипта, моя благодарность '''masterslave89'''
[[Category:awesome3]]</text>
      <sha1>2o6x0ql53fyer7a71xm7eq1ie44mk1g</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Transparency</title>
    <ns>0</ns>
    <id>575</id>
    <revision>
      <id>7122</id>
      <parentid>6548</parentid>
      <timestamp>2014-12-04T04:31:39Z</timestamp>
      <contributor>
        <username>LiamMayfair</username>
        <id>4070</id>
      </contributor>
      <minor/>
      <comment>Typo.</comment>
      <text xml:space="preserve" bytes="5969">{{Languages}}

You will need to use a compositor to enable transparency. See [[Composite Managers]].

There are few compositors for X that aren't also window managers; three are xcompmgr, [http://cairo-compmgr.tuxfamily.org/ Cairo Composite Manager] and [http://unagi.mini-dweeb.org/ Unagi Compositing Manager]. xcompmgr is very simple and rather fast, but it does have [https://awesome.naquadah.org/bugs/index.php?do=details&amp;task_id=821 bugs regarding awesome's menus]. Unagi can be compared to xcompmgr from a resource usage and features point of view but is supposed to be faster and extensible. Cairo-compmgr is more full-featured and configurable and extensible, but also more resource-demanding. 

== Cairo Composite Manager ==

Cairo Composite Manager uses the cairo vector framework for compositing.

Installation instructions can be found on [http://cairo-compmgr.tuxfamily.org/ projects's website]. They provide debian packages [http://cairo-compmgr.tuxfamily.org/download/debian-packages/ here]. There is also a PPA for Ubuntu users.

To install under Ubuntu:
&lt;pre&gt;
sudo apt-add-repository ppa:gekkio/cairo-compmgr
sudo apt-get update
sudo aptitude install cairo-compmgr
&lt;/pre&gt;

Run cairo-compmgr somewhere near the top of your rc.lua or other initialization procedures, or start it manually by typing &lt;code&gt;cairo-compmgr &amp;&lt;/code&gt;
&lt;pre&gt;
 -- launch the Cairo Composite Manager
 awful.util.spawn_with_shell(&quot;cairo-compmgr &amp;&quot;)
&lt;/pre&gt;
By default, cairo-compmgr binds Mod4 + drag to a screenshot tool and enables some slow, grating menu animations. To disable these and other annoying &quot;features&quot;, right-click on the scarab icon in your notification area and select Preferences. If you are on a slower machine, or one without good graphics drivers, consider disabling some of cairo-compmgr's eyecandy features.

== Xcompmgr ==

Install xcompmgr. On Ubuntu: &lt;code&gt;sudo aptitude install xcompmgr&lt;/code&gt;

Open a terminal and run xcompmgr. It will immediately begin providing transparency support, allowing you to use any transparent programs. roxterm has been suggested as a transparency-enabled terminal emulator. You can go to preferences and hide the scollbars, menubars, and then configure transparency.

Near the top of your rc.lua:

  awful.util.spawn_with_shell(&quot;xcompmgr -cF &amp;&quot;)

Add it without the options if you don't want shadows.

=== Error-messages ===

If xcompmgr is giving error messages then it's because the utility for setting wallpapers in awesome (awsetbg) has fell back onto using the utility display for setting the wallpapers. There are two currently known ways to fix this:

==== Find a backend for awsetbg ====
If awsetbg has a working backend, it will happily start using that one instead. Backends currently confirmed to fix the issue are:
* feh
Simply install one of them with the package-manager of your choice and restart awesome.
&lt;pre&gt;awsetbg -i&lt;/pre&gt; will tell you which backend it is currently using or recommend some if none could be found.

==== habak (deprecated) ====

&lt;pre&gt;
genjix@l:~$ sudo aptitude search habak
i   habak                           - utility for creating multi-layered backgr
&lt;/pre&gt;

I then had to had to change my theme.lua:
&lt;pre&gt;
-- use habak instead
-- theme.wallpaper_cmd = { &quot;awsetbg /usr/share/awesome/themes/default/background.png&quot; }
theme.wallpaper_cmd = { &quot;habak mywallpaper.png&quot; }
&lt;/pre&gt;

I had to crop/resize my background wallpaper so it wasn't cropped.

== Unagi Compositing Manager ==

Like Awesome, [http://unagi.mini-dweeb.org Unagi] uses XCB library, is extensible through plugins and is lightweight compared to Cairo Composite Manager but also provides far less features at the moment. It is available officially in Debian (and thus Ubuntu): &lt;code&gt;sudo aptitude install unagi&lt;/code&gt; and on Arch through AUR. Installation instructions for other systems can be found in the [http://projects.mini-dweeb.org/projects/unagi/wiki#Installation project's wiki].

Open a terminal and run unagi. This will provide transparency support straightaway as long as you have set up Awesome properties properly as explained below.

Near the top of your rc.lua:

  awful.util.spawn_with_shell(&quot;unagi &amp;&quot;)

Note: If you are seeing black bars when unplugging/plugging a monitor or changing resolutions, try the following:

   awful.util.spawn_with_shell(&quot;killall unagi; sleep 5; unagi &amp;&quot;)

== Using built-in transparency support ==

Note: You need a running compositor such as xcompmgr or cairo-compmgr.

To automatically set transparency level for particular window class, you can add the following rule to awful.rules in rc.lua:
&lt;pre&gt;
{rule = {class = &quot;some-class&quot;}, 
 properties = {opacity = 0.8} }
&lt;/pre&gt;

(You are able to know the window class of particular app with the help of '''xprop''' utility.)

With such a rule for XTerm I have terminal windows of 80% opacity.

If you want transparent notifications, overwrite the default presets in your rc.lua.
The following lines sets a 80% opacity for each urgency level:
&lt;pre&gt;
naughty.config.presets.normal.opacity = 0.8
naughty.config.presets.low.opacity = 0.8
naughty.config.presets.critical.opacity = 0.8
&lt;/pre&gt;
The default options will be ignored, if a notification sets a custom opacity:
&lt;pre&gt;
naughty.notify{
  title=&quot;NaughtyNotifcation&quot;,
  text=&quot;Check, if everything works.&quot;,
  opacity=0.5
}
&lt;/pre&gt;

== Troubleshooting ==

=== RecordMyDesktop ===

To avoid dark borders do,

Fullscreen mode:

  recordmydesktop --no-frame

Or use a window id (see man recordmydesktop &amp; xwininfo)

  recordmydesktop --windowid 0xa00003

=== Gloobus-Preview ===

You need to add a special rule to your rc.lua for Gloobus-Preview. This rule floats Gloobus-preview and disables border-drawing around the window:
&lt;pre&gt;
    -- Make Gloobus behave as expected
    { rule = { class = &quot;Gloobus-preview-configuration&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;Gloobus-preview&quot; },
      properties = { floating = true,
      			 border_width = 0 } },
&lt;/pre&gt;</text>
      <sha1>9966feqk8iu9ykdp50qhkzlggpnep1c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Transparency/ru</title>
    <ns>0</ns>
    <id>1057</id>
    <revision>
      <id>7147</id>
      <parentid>6691</parentid>
      <timestamp>2014-12-15T05:27:23Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>typo</comment>
      <text xml:space="preserve" bytes="9602">{{DISPLAYTITLE:Прозрачность}}
{{Languages|Transparency}}

Вас необходимо использовать сторонние compositor для использования прозрачности. Смотрите раздел [[Composite Managers]].

Существует несколько композитных менеджеров для X которые в то же время, не являются оконными менеджерами; точнее их три: xcompmgr, [http://cairo-compmgr.tuxfamily.org/ Cairo Composite Manager] и [http://unagi.mini-dweeb.org/ Unagi Compositing Manager]. xcompmgr очень простой и довольно быстрый, но у него есть [https://awesome.naquadah.org/bugs/index.php?do=details&amp;task_id=821 bugs regarding awesome's menus]. Unagi может быть сравнен с xcompmgr по использованию ресурсов и возможностям, но он более быстрый и расширяемый. Cairo-compmgr более функциональный, настраиваемы и расширяемы, но в то же время и более ресурсоемкий.

== Композитный менеджер Cairo  ==

Композитный менеджер Cairo использует массив(vector) фреймворка cairo для композитинга(compositing).

Инструкцию по его установке вы можете найти на [http://cairo-compmgr.tuxfamily.org/ сайте проекта]. На сайте вы можете найти пакет debian [http://cairo-compmgr.tuxfamily.org/download/debian-packages/ здесь]. Также доступен PPA для пользователей Ubuntu.

Для установки в Ubuntu:
&lt;pre&gt;
sudo apt-add-repository ppa:gekkio/cairo-compmgr
sudo apt-get update
sudo aptitude install cairo-compmgr
&lt;/pre&gt;

Запуск cairo-compmgr производите в верхней части вашего rc.lua или других процедур инициализации, или запускайте его вручную, набрав &lt;code&gt;cairo-compmgr &amp;&lt;/code&gt;
&lt;pre&gt;
 -- запуск Cairo Composite Manager
 awful.util.spawn_with_shell(&quot;cairo-compmgr &amp;&quot;)
&lt;/pre&gt;
По умолчанию, cairo-compmgr привязывает к Mod4 + drag утилиту для скриншота и включает медленную(считается, что это красиво) анимацию меню. Для отключения этих и других раздражающих &quot;особенностей&quot;, щелкните правой кнопкой на иконке скарабея в области уведомлений и выберите Preferences. Если вы работаете на медленной машине, или без нормальных драйверов графики, рекомендуется отключить некоторые функции cairo-compmgr.

== Xcompmgr ==

Установите xcompmgr. В Ubuntu: &lt;code&gt;sudo aptitude install xcompmgr&lt;/code&gt;

Откройте терминал и запустите xcompmgr. Он немедленно включит поддержку прозачности, что позволит вам использовать любые программы с прозрачностью. rxterm можно предложить в качестве поддерживающего прозрачность эмулятора. Вы можете в настройках скрыть полосы прокрутки, меню, а также настроить прозрачность.

В начале вашего rc.lua разместите:

  awful.util.spawn_with_shell(&quot;xcompmgr -cF &amp;&quot;)

Можете запустить xcompmgr без аргументов, если вам не нужны тени.

=== Сообщения об ошибках ===

Если xcompmgr выдает сообщения об ошибках, то это происходит потому, что утилита для установки обоев в awesome(awsetbg) уже вернула обратно старую утилиту дисплея для установки обоев. Здесь существует два способа для исправления этой ситуации:

==== Поиск backend для awsetbg ====
Если awsetbg имеет рабочий backend, это позволяет с легкостью использовать именно его. Backends в настоящее время подтверждает, что проблема решена в:
* feh
Просто установите одни из пакетных менеджеров по вашему выбору(например feh) и перезапустите awesome.
&lt;pre&gt;awsetbg -i&lt;/pre&gt; 
подскажет вам, какой текущий backend используется или порекомендует, если не сможет их найти.

==== habak (не рекомендуется) ====

&lt;pre&gt;
$ sudo aptitude search habak
i   habak                           - utility for creating multi-layered backgr
&lt;/pre&gt;

В этом случае требуется изменить theme.lua:
&lt;pre&gt;
-- use habak instead
-- theme.wallpaper_cmd = { &quot;awsetbg /usr/share/awesome/themes/default/background.png&quot; }
theme.wallpaper_cmd = { &quot;habak mywallpaper.png&quot; }
&lt;/pre&gt;

Мне пришлось также подгонять размер фонового изображения, чтобы оно не было обрезано при отображении.

== Композитный менеджер Unagi ==

Как и Awesome, [http://unagi.mini-dweeb.org Unagi] использует библиотеку XCB, которая расширяется за счет плагинов и более легковесна по сравнению с Cairo Composite Manager, но обеспечивающая на данный момент намного меньшую функциональность. Официально доступна версия для Debian (и соответственно Ubuntu): &lt;code&gt;sudo apt-get install unagi&lt;/code&gt; и в Arch через AUR. Инструкции по установке в других системах вы можете найти на странице [http://projects.mini-dweeb.org/projects/unagi/wiki#Installation project's wiki].

Откройте терминал и запустите unagi. После этого поддержка прозрачности будет сразу доступна.

В верхней части rc.lua добавьте:

  awful.util.spawn_with_shell(&quot;unagi &amp;&quot;)

Примечание: Если вы видите черные полосы при подключении/подключении монитора или при изменении разрешения, попробуйте следующий код:

   awful.util.spawn_with_shell(&quot;killall unagi; sleep 5; unagi &amp;&quot;)

== Использование встроенной поддержки прозрачности ==

Примечание: Вам понадобится запущенный compositor такой как xcompmgr или cairo-compmgr.

Для автоматической установки прозрачности для определенного класса окон, вы можете добавить следующие правила в секцию awful.rules в rc.lua:
&lt;pre&gt;
{rule = {class = &quot;some-class&quot;}, 
 properties = {opacity = 0.8} }
&lt;/pre&gt;

(Вы можете узнать класс окна (window class) используя утилиту '''xprop''')

Например у меня сделано правило для XTerm с уровнем прозрачности в 80%.

Если вам необходимы прозрачный уведомления, перепишите настройки по умолчанию в rc.lua.
Следующие строки установят непрозрачность на 80% для каждого уровня срочности:
&lt;pre&gt;
naughty.config.presets.normal.opacity = 0.8
naughty.config.presets.low.opacity = 0.8
naughty.config.presets.critical.opacity = 0.8
&lt;/pre&gt;
Настройки по умолчанию будут игнорироваться, если уведомление устанавливает собственную непрозрачность:
&lt;pre&gt;
naughty.notify{
  title=&quot;NaughtyNotifcation&quot;,
  text=&quot;Check, if everything works.&quot;,
  opacity=0.5
}
&lt;/pre&gt;

== Известные проблемы ==

=== RecordMyDesktop ===

Чтобы избежать темных краев, сделайте следующее:

Установите полноэкранный режим:

  recordmydesktop --no-frame

Или испльзуйте идентификатор окна (смотрите man recordmydesktop &amp; xwininfo)

  recordmydesktop --windowid 0xa00003

=== Gloobus-Preview ===

Вам необходимо добавить специальное правило в ваш rc.lua для Gloobus-Preview. Это правило включает плавающий режим для Gloobus-preview и отключает отрисовку границ вокруг окна:
&lt;pre&gt;
    -- Make Gloobus behave as expected
    { rule = { class = &quot;Gloobus-preview-configuration&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;Gloobus-preview&quot; },
      properties = { floating = true,
      			 border_width = 0 } },
&lt;/pre&gt;</text>
      <sha1>cf6z49kd4to9406trr7hegrbbajklwu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tree File Menu</title>
    <ns>0</ns>
    <id>580</id>
    <revision>
      <id>6581</id>
      <parentid>5968</parentid>
      <timestamp>2014-05-21T14:17:35Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="2776">{{Languages}}

[[File:File_menu.jpg|300px|thumb|alt=screenshot with personalized tags|The file menu in action.]]
This python script creates a lua module that provides a file menu of any directory you want. It also allows you to assign programs to open the files in your menu.
[http://github.com/melanogaster42/File_tree_menu/raw/master/file_tree_menu.py The script.]

== Installing ==
Copy the script to some convenient file and then edit these lines: 

&lt;code&gt; 
#modify the lines below accordingly

path = '/home/your-user-name/'

filetosave = open('/home/your-user-name/.config/awesome/myplacesmenu.lua', 'w')
&lt;/code&gt; 

replace &lt;code&gt;your-user-name&lt;/code&gt; with your user name. Save and run the script. It will create a myplacesmenu.lua file in ~/.config/awesome/. To use your new file menu add:

&lt;code&gt;
require(&quot;myplacesmenu&quot;)
&lt;/code&gt;

near the top of your ~/.config/awesome/rc.lua file and then add this entry to your menu. 

&lt;pre&gt;

{ &quot;files&quot;, myplacesmenu.myplacesmenu()},
&lt;/pre&gt;

Example:
 
&lt;pre&gt;
myawesomemenu = { 
   { &quot;files&quot;, myplacesmenu.myplacesmenu()},
   { &quot;manual&quot;, &quot;urxvt -e man awesome&quot; },
   { &quot;edit config&quot;, &quot;urxvt -e vim /home/michaelmath/.config/awesome/rc.lua.new&quot; },
   { &quot;restart&quot;, awesome.restart },
   { &quot;make default&quot;, &quot;/home/michaelmath/scripts/rcmv.sh&quot;},
   {&quot;debug&quot;, &quot;urxvt -e /home/michaelmath/scripts/Awdebug.sh&quot;},
   { &quot;quit&quot;, awesome.quit },
   { &quot;Log out&quot;, &quot;/home/michaelmath/scripts/shutdown_dialog.sh&quot;} 
}

&lt;/pre&gt;

Whenever the script is run myplacesmenu.lua will be overwritten so calling the script from your .xinitrc file could potentially cause problems as the myplacesmenu.lua might be in the process of being written while awesome is starting.

== Lua Version ==
Here is a lua version of this script. You will need to install [https://github.com/keplerproject/luafilesystem luafilesystem] for it to work.
It doesn't work exactly in the same way since it doesn't store the menu into a file.
== Installation ==
I let you deal with the installation of luafilesystem (luarocks works great).
Then you need to download the lua script [https://bitbucket.org/nmiller/awesome/raw/7b2cb4809f63/lib/filesmenu.lua there], put it wherever you want in your config files. And then you need to require it from your rc.lua, assuming you put it in .config/awesome, you would have to add :
&lt;pre&gt; require('filesmenu') &lt;/pre&gt;
to your rc.lua.
Then just add entries in your awesome menu with the directory you want to appear in the file menu like this :
&lt;pre&gt; 
{ 'Documents', genMenu('/home/pata/Documents/')}
&lt;/pre&gt;
And here you go. Be aware that it might slow a bit awesome at start-up, especially with big folders.
Also in the script there are some defaults actions to do with the files, feel free to add yours or change the existing in the filters table.</text>
      <sha1>naae1wfyprxuthxzajr9986dny9ub5n</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tree File Menu/ru</title>
    <ns>0</ns>
    <id>1066</id>
    <revision>
      <id>6583</id>
      <timestamp>2014-05-21T16:39:07Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Tree File Menu (translating page)</comment>
      <text xml:space="preserve" bytes="4403">{{DISPLAYTITLE:Меню Файловое дерево}}
{{Languages|Tree File Menu}}

[[File:File_menu.jpg|300px|thumb|alt=screenshot with personalized tags|Файловое меню в действии.]]

&lt;b&gt;Примечание: Данный скрипт проверялся на работу с Lua 5.1 и awesome 3.4&lt;/b&gt;

Этот скрипт на python script создает модуль lua, который обеспечивает файловое меню для любого каталога, который вы хотите. Этот код также предоставляет возможность ассоциировать программы для открытия файлов в вашем меню,
[http://github.com/melanogaster42/File_tree_menu/raw/master/file_tree_menu.py Скрипт.]

== Установка ==
Скопируйте скрипт в какой либо файл, затем отредактируйте следующие строки: 

&lt;pre&gt; 
#Измените следующие строки в соотвествии с вашей конфигурацией
path = '/home/your-user-name/'
filetosave = open('/home/your-user-name/.config/awesome/myplacesmenu.lua', 'w')
&lt;/pre&gt; 

Замените &lt;code&gt;your-user-name&lt;/code&gt; своим именем пользователя. Сохраните и запустите скрипт. Он создаст файл myplacesmenu.lua в ~/.config/awesome/. Для использования нового файла меню сделайте следующее:

&lt;pre&gt;
require(&quot;myplacesmenu&quot;)
&lt;/pre&gt;

добавьте код в начале файла ~/.config/awesome/rc.lua и затем добавьте слудующую запись в меню 

&lt;pre&gt;
{ &quot;files&quot;, myplacesmenu.myplacesmenu()},
&lt;/pre&gt;

Пример:
 
&lt;pre&gt;
myawesomemenu = { 
   { &quot;files&quot;, myplacesmenu.myplacesmenu()},
   { &quot;manual&quot;, &quot;urxvt -e man awesome&quot; },
   { &quot;edit config&quot;, &quot;urxvt -e vim /home/michaelmath/.config/awesome/rc.lua.new&quot; },
   { &quot;restart&quot;, awesome.restart },
   { &quot;make default&quot;, &quot;/home/michaelmath/scripts/rcmv.sh&quot;},
   {&quot;debug&quot;, &quot;urxvt -e /home/michaelmath/scripts/Awdebug.sh&quot;},
   { &quot;quit&quot;, awesome.quit },
   { &quot;Log out&quot;, &quot;/home/michaelmath/scripts/shutdown_dialog.sh&quot;} 
}

&lt;/pre&gt;

Каждый раз при запуске скрипта, файл myplacesmenu.lua будет перезаписываться, поэтому вызов скипта из файла .xinitrc может потенциально привести к проблемам, так как myplacesmenu.lua может находится в процессе записи при старте awesome.

== Lua версия ==
Здесь приведена Lua версия этого скрипта. Вам необходимо установить [https://github.com/keplerproject/luafilesystem luafilesystem] для его работы.
Он работает немного по другому, например, он не сохраняет меню в файл.

== Установка ==
Для установки luafilesystem используйте luarocks:
  luarocks install luafilesystem
Затем вам необходимо скачать скрипт lua [https://bitbucket.org/nmiller/awesome/raw/7b2cb4809f63/lib/filesmenu.lua здесь], поместить его в папку с другими файлами конфигурации. И затем вам необходимо подключить его (require) в файле rc.lua, если вы поместите файл в .config/awesome, вам потребуется добавить :
&lt;pre&gt; require('filesmenu') &lt;/pre&gt;
в файл rc.lua.
Затем просто добавить записи в ваше меню awesome с каталогом, который вы хотите отобоазить в файловом меню, например так:
&lt;pre&gt; 
{ 'Documents', genMenu('/home/pata/Documents/')}
&lt;/pre&gt;
И это все. Помните, что это может несколько замедлить работу awesome при запуске, особенно для больших папок.
Также в скрипте есть несколько дефолтных действия с файлами, не стесняйтесь добавлять свои, или изменять существующую таблицу фильтров.</text>
      <sha1>j7e3136vev5h13xl5v4wpd5ks9ohdx9</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Twoism theme</title>
    <ns>0</ns>
    <id>65</id>
    <revision>
      <id>1298</id>
      <timestamp>2008-10-16T15:09:28Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="491">A fairly simple setup. Widgets are powered by conky and a modified version of awesome-client available [http://hg.cbxzcm.org/awtell/ here]. 

=== Screenshots ===

[[Image:twoism_theme_busy.png|thumb|none|Twoism busy theme]][[Image:twoism_theme_clean.png|thumb|none|Twoism clean theme]]

=== Config Files ===
[http://hg.cbxzcm.org/dotfiles/file/0d209f14a235/.awesomerc .awesomerc]

[http://hg.cbxzcm.org/dotfiles/file/0d209f14a235/.conkyrc .conkyrc]

[[Category:Themes]]
[[Category:awesome2]]</text>
      <sha1>dszw2qnkey57k0giaidduxfjg3t0jnu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Tyrannical</title>
    <ns>0</ns>
    <id>935</id>
    <revision>
      <id>5939</id>
      <timestamp>2013-04-10T20:11:20Z</timestamp>
      <contributor>
        <username>Mic92</username>
        <id>563</id>
      </contributor>
      <comment>Basic explanation of tyrannicle [will be continued soon...]</comment>
      <text xml:space="preserve" bytes="963">== Introduction ==

Tyrannicle is a dynamic tagging configuration system, which provides a similar features like [[shifty]].
The basic idea of tagging is to match clients by a set of rules and bind them to a specific tag.
Dynamic tagging extends this approach by allowing tags to be created and destroyed on-the-fly.
Tag creation can by controlled by configuration or by guessing tag names based on the launched application 

=== Example ===
Without a rule Firefox will create a tag called &quot;firefox&quot;. 
If you provide a rule you can alternate this behaviour to assign the firefox window always to the &quot;www&quot;-tag

== Installation ==
First switch to your awesome configuration directory and download the latest version of tyrannicle using [http://git-scm.com/ git]

&lt;pre&gt;
$ cd $XDG_CONFIG_HOME/awesome
$ git clone git://github.com/Elv13/tyrannical.git
&lt;/pre&gt;

A full example configuration example can be found on the [https://github.com/Elv13/tyrannical project page]</text>
      <sha1>3n8szvg1bp6m4om8r1ycm62boyq8yw5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ubuntu Gutsy</title>
    <ns>0</ns>
    <id>79</id>
    <revision>
      <id>1234</id>
      <timestamp>2008-10-15T16:08:08Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="2243">I believe that there is a Debian package for awesome, but I still build it from scratch. Here's what you need to do to make/install it from a fresh Ubuntu installation.

1) Make sure your system is up-to-date, then install the build-essential package.

&lt;pre&gt;
$ sudo apt-get install build-essential
&lt;/pre&gt;

2) Next, install the development packages required to build awesome.

&lt;pre&gt;
$ sudo apt-get install libx11-dev libxinerama-dev libxrandr-dev libcairo2-dev libpango1.0-dev libimlib2-dev
&lt;/pre&gt;

3) Download libconfuse from the [http://www.nongnu.org/confuse/ confuse website]. Confuse appears to have no dependencies beyond the pacakges installed in build-essential.

4) Build libconfuse and install it.

&lt;pre&gt;
tar -xvzf confuse-2.x.tar.gz
./configure
...bunch of output...
make
sudo make install
&lt;/pre&gt;

5) [http://awesome.naquadah.org/download/ Download awesome] and build and install it.

&lt;pre&gt;
tar -xvzf awesome-2.3.xxx.tar.g
./configure
...bunch of output...
make
sudo make install
&lt;/pre&gt;

6) Create an ~/.xinitrc file and link it to ~/.Xsession

Create ~/.xinitrc with the following contents:

&lt;pre&gt;
#!/usr/bin/env bash
xsetroot -solid black &amp;
exec /usr/local/bin/awesome
&lt;/pre&gt;

Create a link to ~/.xinitrc and link it to ~/.Xsession:

&lt;pre&gt;
ln -s ~/.xinitrc ~/.Xsession
&lt;/pre&gt;

7) Now, when you're in the login screen (aka gdm), select 'Sessions', and switch to 'Xsession' from the list. This will run your .xinitrc script.

== GNOME and awesome ==

Chances are, however, you still want to use some parts of GNOME with awesome. You can do this! I have the following entries in my ~/.xinitrc:
&lt;pre&gt;
gnome-screensaver &amp;
gnome-settings-daemon &amp;
gnome-power-manager &amp;
&lt;/pre&gt;

Note: when editing your .xinitrc, always make sure 'exec awesome' is last.

If you want to use NetworkManager, you need to get a tray. I've been using [http://stalonetray.sourceforge.net/ stalonetray] which is a lightweight tray to display applets. To build stalonetray, simply download the code, run './configure &amp;&amp; make &amp;&amp; sudo make install' to make and install it. Then add the following to your .xinitrc
&lt;pre&gt;
/usr/local/bin/stalonetray &amp;
nm-applet &amp;
&lt;/pre&gt;

Note: when editing your .xinitrc, always make sure 'exec awesome' is last.

[[Category:Awesome2]]</text>
      <sha1>ipuppv7v90ya8inct7tf1tniugo3zjr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Ubuntu Hardy</title>
    <ns>0</ns>
    <id>116</id>
    <revision>
      <id>1233</id>
      <timestamp>2008-10-15T16:07:40Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1988">This is based on the [[Ubuntu_Gutsy]] guide.

1) Make sure your system is up-to-date, then install the build-essential package.

&lt;pre&gt;
$ sudo apt-get install build-essential
&lt;/pre&gt;

2) Next, install the development packages required to build awesome.

&lt;pre&gt;
$ sudo apt-get install libx11-dev libxinerama-dev libxrandr-dev libcairo2-dev libpango1.0-dev libimlib2-dev
&lt;/pre&gt;

3)Get libconfuse from Ubuntu Intrepid (unreleased at the time of writing)

http://packages.ubuntu.com/intrepid/i386/libconfuse0/download

http://packages.ubuntu.com/intrepid/i386/libconfuse-dev/download

And install it
&lt;pre&gt;
$ sudo dpkg -i libconfuse*.deb
&lt;/pre&gt;

5) [http://awesome.naquadah.org/download/ Download awesome] and build and install it.

&lt;pre&gt;
tar -xvzf awesome-2.3.xxx.tar.g
./configure --enable-gtk
...bunch of output...
make
sudo make install
&lt;/pre&gt;

6) Create an ~/.xinitrc file and link it to ~/.Xsession

Create ~/.xinitrc with the following contents:

&lt;pre&gt;
#!/usr/bin/env bash
xsetroot -solid black &amp;
exec /usr/local/bin/awesome
&lt;/pre&gt;

Create a link to ~/.xinitrc and link it to ~/.Xsession:

&lt;pre&gt;
ln -s ~/.xinitrc ~/.Xsession
&lt;/pre&gt;

7) Now, when you're in the login screen (aka gdm), select 'Sessions', and switch to 'Xsession' from the list. This will run your .xinitrc script.

== GNOME and awesome ==

Chances are, however, you still want to use some parts of GNOME with awesome. You can do this! I have the following entries in my ~/.xinitrc:
&lt;pre&gt;
gnome-screensaver &amp;
gnome-settings-daemon &amp;
gnome-power-manager &amp;
&lt;/pre&gt;

Note: when editing your .xinitrc, always make sure 'exec awesome' is last.

If you want to use NetworkManager, you need to get a tray. I've been using [http://stalonetray.sourceforge.net/ stalonetray] which is a lightweight tray to display applets. You can simply apt-get it.
&lt;pre&gt;
$ sudo apt-get install stalonetray
&lt;/pre&gt;

&lt;pre&gt;
stalonetray &amp;
nm-applet &amp;
&lt;/pre&gt;

Note: when editing your .xinitrc, always make sure 'exec awesome' is last.

[[Category:Awesome2]]</text>
      <sha1>ekp1ghqkw9br9z366tauje6s18mqdje</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Understanding Rules</title>
    <ns>0</ns>
    <id>849</id>
    <revision>
      <id>7474</id>
      <parentid>7233</parentid>
      <timestamp>2016-07-29T11:27:35Z</timestamp>
      <contributor>
        <username>Greg Bell</username>
        <id>4325</id>
      </contributor>
      <minor/>
      <comment>Test wiki bug</comment>
      <text xml:space="preserve" bytes="20125">{{Languages|Understanding Rules}}

This page attempts to describe the 'rules' that appear in Awesome's config file and how they work.

== Getting Started ==

When you first opened &lt;code&gt;rc.lua&lt;/code&gt; to make your changes, you doubtless encountered this block of code:

 &lt;nowiki&gt;awful.rules.rules = {
    -- All clients will match this rule.
    { rule = { },
      properties = { border_width = beautiful.border_width,
                     border_color = beautiful.border_normal,
                     focus = true,
                     keys = clientkeys,
                     buttons = clientbuttons } },
    { rule = { class = &quot;MPlayer&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;pinentry&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;gimp&quot; },
      properties = { floating = true } },
    -- Set Firefox to always map on tags number 2 of screen 1.
    -- { rule = { class = &quot;Firefox&quot; },
    --   properties = { tag = tags[1][2] } },
}&lt;/nowiki&gt;

We can vaguely guess what this does, but if we want to truly customize Awesome to meet our needs, we'll need to know more to be able to create our own rules.

== The Basic Principle ==

Basically, &lt;code&gt;awful.rules.rules&lt;/code&gt; contains an array of instructions, each instruction having two parts.

The first part can be thought of as a &quot;search pattern&quot; which tells Awesome which window attributes you're interested in.  The second part can be thought of as the &quot;command&quot; which tells Awesome what to do to the window once it's found one that matches the search pattern you specified.

=== Matching Windows: &lt;code&gt;rule&lt;/code&gt;, &lt;code&gt;rule_any&lt;/code&gt;, &lt;code&gt;except&lt;/code&gt; and &lt;code&gt;except_any&lt;/code&gt; ===

Awesome can inspect windows for a variety of properties.  There are four ways you can match against these properties:

; &lt;code&gt;rule&lt;/code&gt;
:  To match a window, the window's properties must match ''all'' the properties specified in the array assigned to &lt;code&gt;rule&lt;/code&gt;.
; &lt;code&gt;rule_any&lt;/code&gt;
:  To match a window, the window's properties must match ''one or more'' of the properties specified in the array assigned to &lt;code&gt;rule_any&lt;/code&gt;.
; &lt;code&gt;except&lt;/code&gt;
:  Any window matching a &lt;code&gt;rule&lt;/code&gt; or &lt;code&gt;rule_any&lt;/code&gt; above is excluded if the window's properties match ''all'' of the properties specified in the array assigned to &lt;code&gt;except&lt;/code&gt;.
; &lt;code&gt;except_any&lt;/code&gt;
:  Any window matching a &lt;code&gt;rule&lt;/code&gt; or &lt;code&gt;rule_any&lt;/code&gt; above is excluded if the window's properties match ''one or more'' of the properties specified in the array assigned to &lt;code&gt;except_any&lt;/code&gt;.

The value of &lt;code&gt;rule&lt;/code&gt; ''et al'' is itself an array that names all the window properties you want Awesome to compare against.  This array may be any length, including zero length (empty).  Its syntax is as follows:

 { rule = { [ &lt;var&gt;property&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt; [, &lt;var&gt;property&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt;, ... ] ] } }

Where &lt;var&gt;property&lt;/var&gt; is the name of a [[#Window_Properties|window property]].

A &lt;code&gt;rule&lt;/code&gt; with zero properties (empty) will match all windows.  An &lt;code&gt;except&lt;/code&gt; with zero properties will exclude no windows.

Unlike, for example, rules in a network firewall, there is no early exit to rule processing.  All &lt;code&gt;rule&lt;/code&gt; tests are applied to all windows; a window may be matched by more than one &lt;code&gt;rule&lt;/code&gt;.  For each &lt;code&gt;rule&lt;/code&gt; that matches a window, the corresponding modifications are applied.

For window properties that are strings, the property values you supply to &lt;code&gt;rule&lt;/code&gt; ''et al'' are compared to the window properties using the Lua &lt;code&gt;string.match()&lt;/code&gt; function, which performs sub-string and pattern matching.  Thus, a &lt;code&gt;rule&lt;/code&gt; of the form &lt;code&gt;{ class = &quot;x&quot; }&lt;/code&gt; would match all windows where the character &quot;x&quot; appeared anywhere in the window's &lt;code&gt;class&lt;/code&gt; property.

=== Modifying Windows: &lt;code&gt;properties&lt;/code&gt; and &lt;code&gt;callback&lt;/code&gt; ===

Once we've matched a window, we'll want to do things to it.  There are two ways to tell Awesome how to alter a window.

==== &lt;code&gt;properties&lt;/code&gt; ====

By far the most common method, the &lt;code&gt;properties&lt;/code&gt; element is an array of window properties and values.  For each value in the &lt;code&gt;properties&lt;/code&gt; array, Awesome assigns the value to the corresponding property in the matched window.

The syntax for &lt;code&gt;properties&lt;/code&gt; is as follows:

 { properties = { &lt;var&gt;property&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt; [, &lt;var&gt;property&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt;, ... ] } }

Where &lt;var&gt;property&lt;/var&gt; is the name of a [[#Window_Properties|window property]].

&lt;var&gt;property&lt;/var&gt; can also be the name of a Lua function.  The function is called with the Awesome client object as the first argument, and &lt;var&gt;value&lt;/var&gt; as the second argument.

==== &lt;code&gt;callback&lt;/code&gt; ====

(It is unclear whether the &lt;code&gt;callback&lt;/code&gt; feature is deprecated.)

You can specify a Lua function to call when a window is matched; the window client is passed to the Lua function as an argument.  This can be used to perform more complex operations than are possible using simple property assignment.  Like &lt;code&gt;properties&lt;/code&gt;, &lt;code&gt;callback&lt;/code&gt; takes an array, so you can specify any number of functions to be called against the matched window.

The syntax for &lt;code&gt;callback&lt;/code&gt; is as follows:

 { callback = { &lt;var&gt;function&lt;/var&gt; [, &lt;var&gt;function&lt;/var&gt;, ... ] }

Where &lt;var&gt;function&lt;/var&gt; is any Lua function that accepts an Awesome client object as an argument.

== Window Properties ==

[http://awesome.naquadah.org/doc/api/modules/client.html  A complete list of all the window properties that Awesome knows how to look for and change] may be found at the end of the client page in the [http://awesome.naquadah.org/doc/api Lua API documentation].  Many of these property names are self-explanatory.

Unfortunately, some of these properties directly expose internal X Windows property values, some of which are relatively obscure, and the descriptions on the Lua API page are unhelpfully terse.  To craft useful rules, however, you will need to understand some of them.  The program &lt;code&gt;xprop&lt;/code&gt;, which is standard on all X Windows-based systems, can be enormously helpful in understanding some of this mish-mash.  To use &lt;code&gt;xprop&lt;/code&gt;:
* Open a command line window.
* Type the command &lt;code&gt;xprop&lt;/code&gt; and press Enter.  Your mouse cursor will change to a cross-hair.
* Using the mouse, point at the window you're interested in and click on it.  The X Windows properties of that window will be printed to the command terminal.

In particular, &lt;code&gt;xprop&lt;/code&gt; can be extremely useful in understanding the distinction between the &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;name&lt;/code&gt;, and &lt;code&gt;instance&lt;/code&gt; properties.

Here's a brief list of window properties supported by Awesome and some hopefully enlightening descriptions.

==== &lt;code&gt;name&lt;/code&gt;==== 

This is generally the contents of the window's titlebar at any given instant.  The &lt;code&gt;name&lt;/code&gt; of a window is a string, and may be changed at any time by the program.  Since many programs are known to change this frequently (Firefox being an obvious example), this may be of limited use in &lt;code&gt;rule&lt;/code&gt; matching.

In the &lt;code&gt;xprop&lt;/code&gt; output, this is the value of the &lt;code&gt;WM_NAME&lt;/code&gt; property.

==== &lt;code&gt;class&lt;/code&gt; ====

This is a name unique to the program -- usually a camel-cased version of the program's name.  The &lt;code&gt;class&lt;/code&gt; of a window is a string, is read-only, and is hard-coded by the program that created it -- that is, the program decides what its class value is, and it can't be changed after the fact.  No matter how many copies of xterm you've launched, or what their window titles have been changed to, all those windows will have the same class value (&quot;XTerm&quot;).  Thus, a window's class may be used to uniquely associate with a particular program.

In the &lt;code&gt;xprop&lt;/code&gt; output, the class is the '''second''' value of the &lt;code&gt;WM_CLASS&lt;/code&gt; property.

==== &lt;code&gt;instance&lt;/code&gt; ====

The Weird One.  The &lt;code&gt;instance&lt;/code&gt; of a window is a string, and can be set to any value at program startup.

&lt;code&gt;instance&lt;/code&gt; is an obscure feature of X Windows that sees little use these days.  It provides a way to differentiate between windows that may be the same underlying executable, but are being used in different roles.  For example, if you had a an xterm window that was exclusively used to read your mail, you may wish to change its &lt;code&gt;instance&lt;/code&gt; property so that it could be distinguished from every other xterm window.

Most X Windows programs let you change the value of &lt;code&gt;instance&lt;/code&gt; by using the (unhelpfully named) command line argument &lt;code&gt;-name&lt;/code&gt;.  If you don't otherwise specify a value for &lt;code&gt;instance&lt;/code&gt;, it typically takes the value of argv[0] (the name you used to launch the program).

There are exceptions to this rule, however -- most notably, Firefox.  The &lt;code&gt;class&lt;/code&gt; of Firefox is &quot;Firefox&quot;.  However, the &lt;code&gt;instance&lt;/code&gt; of all of Firefox's browser windows is &quot;Navigator&quot;.  This is probably a historical left-over from when Mozilla (Firefox's progenitor) was not just a Web browser, but also a mail reader and HTML editor.  All of Mozilla's open windows would have the class &quot;Mozilla&quot;, but the mail reader and HTML editor windows would each have different &lt;code&gt;instance&lt;/code&gt; values.  So if you wanted to change the properties of the Web browser windows, but leave the mail reader windows alone, you'd match against an &lt;code&gt;instance&lt;/code&gt; value of &quot;Navigator&quot;.

Another notable example is Chrome (or Chromium). Windows on e.g. Chromium will have the class &quot;Chromium-Browser&quot;. The instance is used to distinguish different extensions (or apps). If the windows is a plain browser window, it will have the same instance as class. If it belongs to a plugin/extension/app (e.g. the Hangout plugin) it will have the plugin id (in this case &quot;crx_nckgahadagoaajjgafhacjanaoiihapd&quot;) as the instance.

In the &lt;code&gt;xprop&lt;/code&gt; output, the instance is the '''first''' value of the &lt;code&gt;WM_CLASS&lt;/code&gt; property.

You can play with this using &lt;code&gt;xprop&lt;/code&gt; and see how &lt;code&gt;instance&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; interrelate.  As an example, open a command line shell and launch an xterm normally:

 $ xterm

Then inspect it with &lt;code&gt;xprop&lt;/code&gt;:

 WM_CLASS(STRING) = &quot;xterm&quot;, &quot;XTerm&quot;

Now launch xterm with a different &lt;code&gt;instance&lt;/code&gt; using the &lt;code&gt;-name&lt;/code&gt; argument:

 $ xterm -name farkleberry

&lt;code&gt;xprop&lt;/code&gt; will report the following:

 WM_CLASS(STRING) = &quot;farkleberry&quot;, &quot;XTerm&quot;

Finally, just for laughs, create a softlink that points to xterm, and then launch xterm using the softlink:

 $ ln -s /usr/bin/xterm barfoo
 $ ./barfoo

&lt;code&gt;xprop&lt;/code&gt; will report the following:

 WM_CLASS(STRING) = &quot;barfoo&quot;, &quot;XTerm&quot;

==== &lt;code&gt;type&lt;/code&gt; ====

The type of the window.  The window's &lt;code&gt;type&lt;/code&gt; is a string, and may have one of the following values:
* &lt;code&gt;desktop&lt;/code&gt;
* &lt;code&gt;dock&lt;/code&gt;
* &lt;code&gt;splash&lt;/code&gt;
* &lt;code&gt;dialog&lt;/code&gt;
* &lt;code&gt;menu&lt;/code&gt;
* &lt;code&gt;toolbar&lt;/code&gt;
* &lt;code&gt;utility&lt;/code&gt;
* &lt;code&gt;dropdown_menu&lt;/code&gt;
* &lt;code&gt;popup_menu&lt;/code&gt;
* &lt;code&gt;tooltip&lt;/code&gt;
* &lt;code&gt;notification&lt;/code&gt;
* &lt;code&gt;combo&lt;/code&gt;
* &lt;code&gt;dnd&lt;/code&gt; (drag &amp; drop)
* &lt;code&gt;normal&lt;/code&gt;

A window's type may be changed, but doing so may cause unexpected behavior.

==== &lt;code&gt;window&lt;/code&gt; ====

A unique ID number identifying '''that window''' and no other.  The &lt;code&gt;window&lt;/code&gt; value is an integer, is read-only, and is uniquely assigned to the window on its creation.  The ID persists for the life of the window, and is destroyed when the window is closed.  Window IDs are never reused during a given login session.

==== &lt;code&gt;role&lt;/code&gt; ====

Sometimes set by applications, but typically unused by Awesome.  (Other windows managers may use this property in conjuction with &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; to uniquely identify windows such that they can be saved and restored across login sessions.)

In the &lt;code&gt;xprop&lt;/code&gt; output, the &lt;code&gt;role&lt;/code&gt; is the value of the WM_WINDOW_ROLE property, if present.

=== Additional Properties ===

In addition to the window properties listed on the Lua API documentation page, there are properties provided by awful directly:

; &lt;code&gt;floating&lt;/code&gt;
:  Boolean; changes the floating attribute of the window.
; &lt;code&gt;tag&lt;/code&gt;
:  String; changes the window's tag to the specified value.
; &lt;code&gt;switchtotag&lt;/code&gt;
:  String; switches the desktop to the tag of the specified value.
; &lt;code&gt;x&lt;/code&gt;
; &lt;code&gt;y&lt;/code&gt;
; &lt;code&gt;width&lt;/code&gt;
; &lt;code&gt;height&lt;/code&gt;
:  Integer; changes the window's location/dimensions.
; &lt;code&gt;focus&lt;/code&gt;
:  Boolean; when true, gives the input focus to the matched window.  This property is always applied last, regardless of the order it appears in the &lt;code&gt;properties&lt;/code&gt; array.

== Interpreting &lt;code&gt;rc.lua&lt;/code&gt; ==

So now that we have a basic understanding of rules, we can better interpret the default set of rules that ships with Awesome.  Let's look at them again:

 &lt;nowiki&gt;awful.rules.rules = {
    -- All clients will match this rule.
    { rule = { },
      properties = { border_width = beautiful.border_width,
                     border_color = beautiful.border_normal,
                     focus = true,
                     keys = clientkeys,
                     buttons = clientbuttons } },
    { rule = { class = &quot;MPlayer&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;pinentry&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;gimp&quot; },
      properties = { floating = true } },
    -- Set Firefox to always map on tags number 2 of screen 1.
    -- { rule = { class = &quot;Firefox&quot; },
    --   properties = { tag = tags[1][2] } },
}&lt;/nowiki&gt;

Let's work through them in order.  Again, each rule is composed of two parts -- the matching part and the command part.  The first rule's matching part is as follows:

 &lt;nowiki&gt;    { rule = { },&lt;/nowiki&gt;

As mentioned above, a &lt;code&gt;rule&lt;/code&gt; with an empty property array will match all windows.  Thus, the following command part will be applied to all windows:

 &lt;nowiki&gt;      properties = { border_width = beautiful.border_width,
                     border_color = beautiful.border_normal,
                     focus = true,
                     keys = clientkeys,
                     buttons = clientbuttons } },&lt;/nowiki&gt;

This is a &lt;code&gt;properties&lt;/code&gt; operation, so the array of property values it contains will be assigned to the matched window (which in this case is all windows):

; &lt;code&gt;border_width = beautiful.border_width&lt;/code&gt;
; &lt;code&gt;border_color = beautiful.border_normal&lt;/code&gt;
:  The window's border width and color are set to the values in the theme currently loaded into &lt;code&gt;beautiful&lt;/code&gt;.
; &lt;code&gt;focus = true&lt;/code&gt;
:  The input focus is given to the window.  This may seem slightly confusing until you consider that the rule set is applied not just at Awesome startup, but also to every new window as it is created.  Since we want newly opened windows to have the input focus, we put this property here.
; &lt;code&gt;keys = clientkeys&lt;/code&gt;
; &lt;code&gt;buttons = clientbuttons&lt;/code&gt;
:  We bind the set of &lt;code&gt;clientkeys&lt;/code&gt; and &lt;code&gt;clientbuttons&lt;/code&gt; we created earlier to the window.  This makes all windows have the same UI behavior.

The rest of the rules are fairly simple.  As mentioned above, there is no early exit in rule processing.  All rules are tested against all windows.  So just because a window matched the &lt;code&gt;rule&lt;/code&gt; above doesn't mean we're done.  The next &lt;code&gt;rule&lt;/code&gt; is:

 &lt;nowiki&gt;    { rule = { class = &quot;MPlayer&quot; },
      properties = { floating = true } },&lt;/nowiki&gt;

For all windows whose &lt;code&gt;class&lt;/code&gt; contains &quot;MPlayer&quot;, set the floating attribute on the window.  This prevents Awesome from automatically resizing it.

 &lt;nowiki&gt;    { rule = { class = &quot;pinentry&quot; },
      properties = { floating = true } },&lt;/nowiki&gt;

For all windows whose &lt;code&gt;class&lt;/code&gt; contains &quot;pinentry&quot; (usually a utility that asks for your password), set the floating attribute on the window.

 &lt;nowiki&gt;    { rule = { class = &quot;gimp&quot; },
      properties = { floating = true } },&lt;/nowiki&gt;

For all windows whose &lt;code&gt;class&lt;/code&gt; contains &quot;gimp&quot;, set the floating property on the window.

But...  Hang on a second; this looks weird to me.  By convention, most &lt;code&gt;class&lt;/code&gt; names are capitalized.  Let's actually launch GIMP 2.8.0 and inspect it using &lt;code&gt;xprop&lt;/code&gt;.  GIMP actually opens three windows by default, so let's first look at the main image window:

 &lt;nowiki&gt;WM_CLASS(STRING) = &quot;gimp&quot;, &quot;Gimp&quot;&lt;/nowiki&gt;

Interesting.  The &lt;code&gt;instance&lt;/code&gt; of GIMP is &quot;gimp&quot;, but the &lt;code&gt;class&lt;/code&gt; is actually &quot;Gimp&quot; (capitalized).  The other two windows also have the same &lt;code&gt;instance&lt;/code&gt; and &lt;code&gt;class&lt;/code&gt; values.  That means the &lt;code&gt;rule&lt;/code&gt; as specified above ''won't work.''

Okay, let's fix it:

 &lt;nowiki&gt;    { rule = { class = &quot;Gimp&quot; },
      properties = { floating = true } },&lt;/nowiki&gt;

There, all better.

Incidentally, it turns out that GIMP uses the &lt;code&gt;role&lt;/code&gt; property to differentiate its windows, so you can use it in your rules:

 &lt;nowiki&gt;Main Image Window:
WM_WINDOW_ROLE(STRING) = &quot;gimp-image-window&quot;

Toolbox Window:
WM_WINDOW_ROLE(STRING) = &quot;gimp-toolbox&quot;

Dock Window:
WM_WINDOW_ROLE(STRING) = &quot;gimp-dock&quot;&lt;/nowiki&gt;

BTW, it may have occurred to you that, except for the &lt;code&gt;class&lt;/code&gt; name, all of the previous three rules are identical.  As such, they can be collapsed into a single &lt;code&gt;rule_any&lt;/code&gt; entry as follows:

 &lt;nowiki&gt;    { rule_any = { class = {&quot;MPlayer&quot;, &quot;pinentry&quot;, &quot;Gimp&quot;} },
      properties = { floating = true } },&lt;/nowiki&gt;

== Examples ==

This section lists some more complex examples along with explanations about how they work, to help provide a starting point for more complex setups.

=== Using &lt;tt&gt;except&lt;/tt&gt; ===

&lt;pre&gt;
{ rule_any = { class = { &quot;psi&quot;, &quot;Psi&quot; } }, except = { instance = &quot;main&quot; },
  callback = awful.client.setslave },
&lt;/pre&gt;

This rule is for the Psi IM client.  It makes sure every Psi window is set as a slave window, except the contact list which is left as master.  This allows the contact list to always remain visible and in the same place, even as chat windows are opened and closed, providing the tag has been [[IM tips|configured correctly]].

In this case, the rule is required to affect these three windows:

{|class=&quot;wikitable&quot;
! Window type !! Properties
|-
| Contact list || &lt;pre&gt;
WM_NAME(STRING) = &quot;Psi&quot;
WM_CLASS(STRING) = &quot;main&quot;, &quot;psi&quot;
&lt;/pre&gt;
|-
| Chat windows || &lt;pre&gt;
WM_NAME(STRING) = &quot;SomePerson&quot;
WM_CLASS(STRING) = &quot;chat&quot;, &quot;psi&quot;
&lt;/pre&gt;
|-
| History windows || &lt;pre&gt;
WM_NAME(STRING) = &quot;SomePerson (someone@somewhere.net)&quot;
WM_CLASS(STRING) = &quot;psi&quot;, &quot;Psi&quot;
&lt;/pre&gt;
|}

You can see here the &lt;tt&gt;class&lt;/tt&gt; (second WM_CLASS string) is &quot;psi&quot; for the first two, but &quot;Psi&quot; with a capital P for the third.  So in order to match all these windows, we need to use &lt;tt&gt;rule_any&lt;/tt&gt; with both variants, so the rule will match any of the given class names.

However we don't want the rule to match the contact list, so we specify an &lt;tt&gt;except&lt;/tt&gt; value and use the &lt;tt&gt;instance&lt;/tt&gt; (first WM_CLASS string) of the contact list.  We use this value since it is not shared by any of the other windows, so we will only exclude the contact list and nothing else.

We now have a rule which will match all Psi windows except for the contact list, so the action we specify for this rule is to call the &lt;tt&gt;awful.client.setslave&lt;/tt&gt; function.  This will make the Psi windows slaves, leaving the contact list set to master.

== Related Pages ==

; [http://awesome.naquadah.org/doc/api/modules/awful.rules.html awful.rules]
:  Lua documentation for the module awful.rules, which implements the rule processing functionality.

; [[Example of applications rules]]
: Various rules for common applications mostly to mark floating windows as such when necessary.

[[Category: Awesome3]]</text>
      <sha1>h6ukxszhp4ol69i3li2c8bjxcj1xsjk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Understanding Rules/ru</title>
    <ns>0</ns>
    <id>1036</id>
    <revision>
      <id>7297</id>
      <parentid>6864</parentid>
      <timestamp>2015-01-25T16:16:41Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* instance */ translated of new text</comment>
      <text xml:space="preserve" bytes="32644">{{Languages|Understanding Rules}}
{{DISPLAYTITLE:Разбираем правила(rules)}}

Примечания переводчика, для полного понимания материала приведенного на этой странице рекомендуется знание основ языка Lua. Для ознакомления с Lua на русском языке, есть [[http://www.lua.ru/doc/ руководство]].


В этой статье описываются правила(''rules'') которые появились в Awesome и способы работы с ними.

== Приступая к работе ==

Когда вы впервые открыли ''rc.lua'' для ознакомления или редактирования, вы наверняка обратили внимание на следующий код:

 &lt;nowiki&gt;awful.rules.rules = {
    -- All clients will match this rule.
    { rule = { },
      properties = { border_width = beautiful.border_width,
                     border_color = beautiful.border_normal,
                     focus = true,
                     keys = clientkeys,
                     buttons = clientbuttons } },
    { rule = { class = &quot;MPlayer&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;pinentry&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;gimp&quot; },
      properties = { floating = true } },
    -- Set Firefox to always map on tags number 2 of screen 1.
    -- { rule = { class = &quot;Firefox&quot; },
    --   properties = { tag = tags[1][2] } },
}&lt;/nowiki&gt;

Вы конечно можете догадываться, что этот код делает, но если вы по настоящему хотите настроить Awesome, в соответсвии с вашими потребностями, вам необходимо узнать больше как создавать свои собственные правила. 

== Основные принципы ==

В своей основе, 'awful.rules.rules' содержит массив инструкций, где каждая инструкция состоит из двух частей.

Первая часть используется как &quot;поисковый шаблон&quot; который говорит Awesome, какие атрибуты окон нас интересуют. Вторую часть можно описать, как &quot;команды&quot;, которые говорят Awesome, что нужно делать при нахождении окна, которое соотвествует заданному шаблону поиска.

=== Выбор окна ===

Awesome может проверять различные свойства''(properties)'' окон, чтобы найти нужное нам окно для дальнейших действий над ним. Существует четыре способа, которыми вы можете выйти на нужное вам окно:

==== rule ====
:  При сравнении окон, они должны соотвестовать ''всем'' свойствам, определенным в массиве''(array)'' данного правила''(rule)''.
 { rule = { class = {&quot;MPlayer&quot;, &quot;pinentry&quot;, &quot;Gimp&quot;} },   
''в данном случае не будет выбрано ни одно окно, так как не может быть 3х приложений являющихся родителями одного окна ''
==== rule_any ====
:  При сравнении окон, они должны соответсвовать ''одному или более'' свойствам определенным в массиве данного правила, т.е. по принципу &quot;любое из&quot;
 { rule_any = { class = {&quot;MPlayer&quot;, &quot;pinentry&quot;, &quot;Gimp&quot;} },   
''в данном случае будет выбрано любое из окон, родителями которого являются указанные в списке приложения ''
==== except ====
:  Из найденных окон, попадающие под правило ''rule'' или ''rule_only'' исключаются окна, которые попадают под ''все ''свойства которые прописаны в массиве ''except'', т.е. по принципу &quot;все кроме ...всех перечисленных&quot;.
 { rule_any = { class = { &quot;psi&quot;, &quot;Psi&quot; } }, except = { instance = &quot;main&quot; },   
''в данном случае будут выбраны все окна приложения Psi, кроме главного''
==== except_any ====
:  Из найденных окон, попадающие под правило ''rule'' или ''rule_any'' исключаются окна, которые попадают под ''одно или более ''свойств которые прописаны в массиве ''except'', т.е. по принципу &quot;все кроме одного/нескольких из перечисленных&quot;
 { rule = { class = { &quot;XTerm&quot; } }, except_any = { instance = &quot;mail&quot;, instance = &quot;vim&quot; },  
''в этом примере будут выбраны окна всех терминалов, кроме имеющих свойство mail или vim''

Значения 'rule' ''и другие'' являются множеством(array), в которых перечисляются все необходимые вам свойства окон Awesome для их сравнения. Этот массив(array) может быть любой длинны, включая нулевую(пустое). И имеет следующий синтаксис:

 { rule = { [ &lt;var&gt;property&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt; [, &lt;var&gt;property&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt;, ... ] ] } }

Где  &lt;b&gt;property&lt;/b&gt; это имя из списка [[#Свойства окон|свойства окон]].

Если правило(''rule'') имеет нулевое(пустое) значение, то оно соотвествует всем окнам.  А 'except' с нулевыми значениями вообще не исключает окна.

При сравнении, каждое правило, сравнивается с каждым окном, без завершения при нахождении первого подходящего значения.  Все ''rule'' сравниваются со всеми окнами; окно может соотвестовать более чем одному ''rule''.  Для каждого подходящего 'rule'(правила) соотвествующему окну посылаются указанные модификации. До тех пор пока не будет пройден весь список правил.

Для свойств окна, являющихся строками, значения свойств установленные в ''rule  и прочих'' сравниваются со свойствами окон используя функцию Lua ''string.match()'', которая производит сравнение подстроки и шаблона. Таким образом ''rule''(правилу) содержащему '{ class = &quot;x&quot; }' будут соответсвовать все окна у которых символ &quot;x&quot; присутсвует где либо в свойстве окна 'class'.

=== Модификация окон ===

После того, как нужное нам окно найдено, обычно мы хотим сделать с ним что либо. Для этого существует 2 способа указать Awesome как изменить окно.

==== ''properties'' ====

На сегодняшний день, наиболее распространным способом является массив(array) свойств(''properties'') и значений окна. Для каждого значнения в массиве свойств(''properties'') Awesome присваивает значение соответсвующему свойству в найденных окнах.

Синтаксис для ''properties'' следующий:

 { properties = { &lt;var&gt;property&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt; [, &lt;var&gt;property&lt;/var&gt; = &lt;var&gt;value&lt;/var&gt;, ... ] } }

Где  &lt;var&gt;property&lt;/var&gt; это название [[#Свойства окон|свойств окна]].

&lt;b&gt;property&lt;/b&gt; также можется являться и функция Lua. Функция вызывается Awesome как первый аргумент, а &lt;var&gt;value&lt;/var&gt; это второй аргумент. 

==== callback ====

(Функция &lt;b&gt;callback&lt;/b&gt; считается устаревшей.)

Вы можете определить функцию Lua, которая будет вызвана когда окно будет подходить по параметрам; в этом случае клиентское окно передается в функцию как аргумент. Это можно использовать для создания более сложных операций с окном, чем при использовании простых свойст. Как &lt;var&gt;properties&lt;/var&gt;, так и &lt;var&gt;callback&lt;/var&gt; принимает масссив, в котором вы можете определить любое колличество функций, которые вызываются при нахождении соотвествующего окна.

Синтаксис для  &lt;var&gt;callback&lt;/var&gt; слудующий:

 { callback = { &lt;b&gt;function&lt;/b&gt; [, &lt;b&gt;function&lt;/b&gt;, ... ] }

Где &lt;b&gt;function&lt;/b&gt; это любые функции Lua которые Awesome принимает в качестве аргументов.

== Свойства окон ==

[http://awesome.naquadah.org/doc/api/modules/client.html Полный список всех properties которые известны Awesome и могут быть изменены], также их можно найти конце страницы [http://awesome.naquadah.org/doc/api Документация Lua API].  Имена большинства этих свойств интуитивно понятны.

К сожалению, некоторые из этих свойств, являются встроенными значениями X Windows, некоторые из которых сравнительно мало понятны и описание на странице Lua API довольно скудное. Однако для создания эффективных правил(''rule''), вам необходимо понимать некоторые из них. Программа ''xprop'', которая является стандартной, для всех X Windows-based систем, может быть полезной для понимания некоторых из них. Для использвания 'xprop' необходимо:
* Откройте терминал.
* Наберите команду ''xprop'' и нажмите Enter.  Переместите курсор мыши на нужное вам окно.
* Используя мышь, щелкните на заинтересовавшей вас точке окна. После этого, свойства X Windows для этого окна будут напечатаны в терминале.

В частности 'xprop', может быть чрезычайно полезен для понимания разницы между &lt;var&gt;class&lt;/var&gt;, &lt;var&gt;name&lt;/var&gt;, и &lt;var&gt;instance&lt;/var&gt; свойствами.

Ниже описан небольшой список поддерживаемых в Awesome window properties, а также их краткое описание.

==== &lt;code&gt;name&lt;/code&gt;==== 

Как правило содержит заголовок окна, в любой заданный момент.  Свойство &lt;var&gt;name&lt;/var&gt; окна, это строка, которая может быть изменена программой в любое время.  Поскольку многие программы, как известно, часто изменяют это свойство (наглядным примером может являться Firefox), это ''rule''(правило) имеет ограниченное применение.

В выводе ''xprop'', значением соответсвующим этому свойству(property) будет &lt;b&gt;WM_NAME&lt;/b&gt;.

==== &lt;code&gt;class&lt;/code&gt; ====

Это имя является уникальным для программы -- обычно это имя программы записанное в ''Camel(верблюжей/горбатой)-версии'' (Firefox, XTerm, Nm-manager, Keepassx и т.д.). &lt;b&gt;class&lt;/b&gt; - этот параметр является строкой, только для чтения, и жестко определяется программой создавшей его -- это значит, что программа определяет какое значение ''class'' у нее будет, и после этого значение не может быть изменено. Т.е. независимо от того, сколько экзепмляров терминала XTerm вы запустили, и какие они имеют заголовки, все его окна будут иметь одинаковое значение ''class'' (&quot;XTerm&quot;). Таким образом, ''class'' можно использовать, для того чтобы однозначно ассоциировать 'rule'(правило) с конкретной программой.

В выводе &lt;b&gt;xprop&lt;/b&gt;, свойству ''class'' будет соответствовать '''второе''' значение &lt;b&gt;WM_CLASS&lt;/b&gt;.

==== &lt;code&gt;instance&lt;/code&gt; ====

Довольно интересный параметр. &lt;b&gt;instance&lt;/b&gt; - также является строкой. Может быть установлено любое значение при запуске программы.

&lt;b&gt;instance&lt;/b&gt; является особенностью системы X Windows. В настоящее время данный параметр практически не используется.  Он позволяет разделять окна, которые имеют общий исполняемый файл, но используются в различных целях/ролях. Например, у вас есть окно XTerm, которое вы испльзуете только для чтения почты, поэтому вы можете изменить его ''property''(свойство) &lt;b&gt;instance&lt;/b&gt;, таким образом, чтобы отличать его от других окон XTerm.

Большинство программ X Windows, позволяют изменять значение 'instance' используя аргумент командной строки ''-name''. Если вы не измените значение ''instance'', оно по умолчанию будет установлено как argv[0] (имя используемое вами для запуска программы).

Есть исключения из этого правила, в первую очередь, Firefox. &lt;var&gt;class&lt;/var&gt; для Firefox &quot;Firefox&quot;. Тем не менее, ''instance'' для всех окон браузера Firefox установлен &quot;Navigator&quot;. Вероятно, это историческое отступление от Mozilla (прародителя Firefox), когда он был не только браузером, но также и почтовым клиетом и редактором HTML. Все окна открытые в Mozilla, будут иметь ''class'' Mozilla, но окна почтовика и редактора HTML, будут иметь другие значения в 'instance'. Так что, если вы хотите изменить ''properties'' для окон браузера, но не трогать почтовик, вы должны использовать значение ''instance'' равным &quot;Navigator&quot;.

Другим ярким примером, может служить Chrome (или Chromium). Например, окна в Chromium будут иметь ''class'' &quot;Chromium-Browser&quot;. Но в нем ''instance'' используется чтобы отличать различные расширения или приложения друг от друга. Если открытое окно/вкладка является просым окном браузера, то его значение ''instance'' будет равно значению''class''. Если же оно принадлежит плагину/расширению/приложения (например плагину Hangout), то значение ''instance'' будет иметь название идентификатора плагина(в нашем случае &quot;crx_nckgahadagoaajjgafhacjanaoiihapd&quot;).

В выводе &lt;b&gt;xprop&lt;/b&gt;, свойству ''class'' будет соответсвовать '''первое''' значение &lt;b&gt;WM_CLASS&lt;/b&gt;.

Вы можете поиграться с ''xprop'' и посмотреть как взаимосвязаны между собой &lt;b&gt;instance&lt;/b&gt; и &lt;b&gt;class&lt;/b&gt;. В качестве примера, откройте командную оболочку и запустите xterm:

 $ xterm

Затем, посмотрите его используя &lt;code&gt;xprop&lt;/code&gt;:

 WM_CLASS(STRING) = &quot;xterm&quot;, &quot;XTerm&quot;

Теперь запустите xterm с другим значением ''instance'' используя аргумент &lt;b&gt;-name&lt;/b&gt;:

 $ xterm -name vim

Теперь ''xprop'' выведет следующее:

 WM_CLASS(STRING) = &quot;vim&quot;, &quot;XTerm&quot;

В завершение, просто для смеха, создайте ссылку на xtrerm, а затем запустите xterm используя ссылку:

 $ ln -s /usr/bin/xterm barfoo
 $ ./barfoo

И ''xprop'' выведет следующее:

 WM_CLASS(STRING) = &quot;barfoo&quot;, &quot;XTerm&quot;

==== &lt;code&gt;type&lt;/code&gt; ====
Типы окон. &lt;b&gt;type&lt;/b&gt; это строка, которая может принимать одно из слудующих значений:
* &lt;code&gt;desktop&lt;/code&gt;
* &lt;code&gt;dock&lt;/code&gt;
* &lt;code&gt;splash&lt;/code&gt;
* &lt;code&gt;dialog&lt;/code&gt;
* &lt;code&gt;menu&lt;/code&gt;
* &lt;code&gt;toolbar&lt;/code&gt;
* &lt;code&gt;utility&lt;/code&gt;
* &lt;code&gt;dropdown_menu&lt;/code&gt;
* &lt;code&gt;popup_menu&lt;/code&gt;
* &lt;code&gt;tooltip&lt;/code&gt;
* &lt;code&gt;notification&lt;/code&gt;
* &lt;code&gt;combo&lt;/code&gt;
* &lt;code&gt;dnd&lt;/code&gt; (drag &amp; drop)
* &lt;code&gt;normal&lt;/code&gt;

''type'' окон можно менять, но это может привести к непредсказуемым последствиям, поэтому делать это не рекомендуется.

==== &lt;code&gt;window&lt;/code&gt; ====

Уникальный идентификационный номер (ID) '''именно этого окна'' и никакого другого. Значение 'window' является целым уникальным числом, только для чтения, и  оно присваивается окну при его создании. ID существует на протяжении всей жизни окна, и уничтожается при его закрытии. ID окна, никогда повторно не выделяется в течении одной сессии.

==== &lt;code&gt;role&lt;/code&gt; ====

Иногда устанавливается приложением, но как правило не используется в Awesome. (Другие оконные менеджеры могут использвать это property(свойство) совместно с ''name'' и ''class'', для уникальной идентификации окон, чтобы использовать их для сохранения и восстановления после восстановления сессии).

В выводе ''xprop'', свойству ''role'' соотвествует значение WM_WINDOW_ROLE, если оно существует.

=== Дополнительные свойства ===

В дополнение к properties окон описанных в документации Lua API, существуют также properties обеспечиваемые библиотекой awful:

; &lt;code&gt;floating&lt;/code&gt;
:  Boolean; изменяет атрибут плавающего окна.
; &lt;code&gt;tag&lt;/code&gt;
:  Строка; изменяет tag окна на заданное значение.
; &lt;code&gt;switchtotag&lt;/code&gt;
:  Строка; изменяет рабочий стол на заданный tag.
; &lt;code&gt;x&lt;/code&gt;
; &lt;code&gt;y&lt;/code&gt;
; &lt;code&gt;width&lt;/code&gt;
; &lt;code&gt;height&lt;/code&gt;
:  Целое; изменяет положение и/или размер окон.
; &lt;code&gt;focus&lt;/code&gt;
:  Boolean; когда установленно true, передает фокус на заданное окно. Это свойство всегда определяется последним, независимо от порядка, должно быть описано в массиве ''properties''.

== Разбираем rc.lua ==

Теперь мы имеем базовое понимание ''rules''(правил), и мы можем лучше интерпретировать правила''(rule)'', установленные по умолчанию в Awesome. Давайте вглянем на них еще раз:

 &lt;nowiki&gt;awful.rules.rules = {
    -- Все приложения будут соотвествовать следующему правилу
    { rule = { },
      properties = { border_width = beautiful.border_width,
                     border_color = beautiful.border_normal,
                     focus = true,
                     keys = clientkeys,
                     buttons = clientbuttons } },
    -- Правила для других классов окон
    { rule = { class = &quot;MPlayer&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;pinentry&quot; },
      properties = { floating = true } },
    { rule = { class = &quot;gimp&quot; },
      properties = { floating = true } },
    -- Устанавливаем Firefox, на tags номер 2 экрана 1.
    -- { rule = { class = &quot;Firefox&quot; },
    --   properties = { tag = tags[1][2] } },
}&lt;/nowiki&gt;

Давайте разберем этот код по порядку. Опять же, повторим, что каждое правило(''rule'') состоит из двух частей -- часть сравнения и командная чать. Первая сравнительная часть следующая:

 { rule = { },

Как уже упоминалось выше, ''rule'' с пустым массивом свойств(''properties'') соотвествует всем окнам. Поэтому, следующая, командная часть будет применена ко всем окнам:

&lt;pre&gt;properties = { border_width = beautiful.border_width,
                    border_color = beautiful.border_normal,
                    focus = true,
                    keys = clientkeys,
                    buttons = clientbuttons } },&lt;/pre&gt;

Здесь устанавливаются ''properties''(свойства), поэтому массив содержащий значения свойств будет присвоен соотвествующим окнам (в нашем случае всем окнам):

; &lt;code&gt;border_width = beautiful.border_width&lt;/code&gt;
; &lt;code&gt;border_color = beautiful.border_normal&lt;/code&gt;
:  Толщина границы и цвет окон, устанавливаются равные значениям текущей темы, загруженные библиотекой &lt;code&gt;beautiful&lt;/code&gt;.
; &lt;code&gt;focus = true&lt;/code&gt;
:  Фокус воода передается окну. Это может показаться немного запутанным, пока вы считаете, что эти правила('rule') применяются только при запуске Awesome. Также эти правила применяются и при создании новых окон. Т.к. мы хотим, чтобы вновь открываемые окна, также получали фокус ввода, мы вставляем это 'propery'(свойство) здесь.
; &lt;code&gt;keys = clientkeys&lt;/code&gt;
; &lt;code&gt;buttons = clientbuttons&lt;/code&gt;
:  Здесь мы привязываем созданные ранее &lt;code&gt;clientkeys&lt;/code&gt; и &lt;code&gt;clientbuttons&lt;/code&gt; к окну. Это делает пользовательский интерфейс(UI) всех окон единым.

Остальные правила(rule) довольно просты. Как уже упоминалось ранее, досрочный выход из обработки правил(rule) отсутсвует. Все правила(rule) последовательно проверяются для всех окон. Так, что, соотвествие предыдущего правила окну, не означает конец обработки списка правил. Следующее  &lt;code&gt;rule&lt;/code&gt;:

 &lt;nowiki&gt;    { rule = { class = &quot;MPlayer&quot; },
      properties = { floating = true } },&lt;/nowiki&gt;

Для всех окон у которых &lt;code&gt;class&lt;/code&gt; содержат &quot;MPlayer&quot;, устанавливается плавающий атрибут для окна. Это предотвращает от автоматического измения размера, который может произовдить Awesome.

 &lt;nowiki&gt;    { rule = { class = &quot;pinentry&quot; },
      properties = { floating = true } },&lt;/nowiki&gt;

Для всех окон у которых &lt;code&gt;class&lt;/code&gt; содержит &quot;pinentry&quot; (обычно это утилиты, которые запрашивают пароль), устанавливаем плавающий атрибут для окна.

 &lt;nowiki&gt;    { rule = { class = &quot;gimp&quot; },
      properties = { floating = true } },&lt;/nowiki&gt;

Для всех окон у которых &lt;code&gt;class&lt;/code&gt; содержит &quot;gimp&quot;, устанавливаем свойство плавающих окон.

Но... Подождите секунду; это выглядит странным для меня. По соглашению описанному выше, большинство названий в &lt;code&gt;class&lt;/code&gt; начинаются с заглавной буквы. Давайте на самом деле запустим GIMP и проверим его с помощью &lt;b&gt;xprop&lt;/b&gt;. GIMP фактически открывает 3 окна, поэтому сначала мы проверим главное окно:

 &lt;nowiki&gt;WM_CLASS(STRING) = &quot;gimp&quot;, &quot;Gimp&quot;&lt;/nowiki&gt;

Интересно.  Свойство &lt;code&gt;instance&lt;/code&gt; в GIMP - &quot;gimp&quot;, но &lt;code&gt;class&lt;/code&gt; соответствует &quot;Gimp&quot; (с заглавной).  Другие два окна, имеют те же значения &lt;code&gt;instance&lt;/code&gt; и &lt;code&gt;class&lt;/code&gt;.  Это означает, что &lt;code&gt;rule&lt;/code&gt; указанное выше ''не будет работать''.

Хорошо, давайте исправим его:

 &lt;nowiki&gt;    { rule = { class = &quot;Gimp&quot; },
      properties = { floating = true } },&lt;/nowiki&gt;

Теперь лучше.

Кстати, оказывается, что GIMP использует свойство &lt;code&gt;role&lt;/code&gt; для различия собсвенных окон, поэтому вы может испльзовать в своих правилах(rule):

 &lt;nowiki&gt;Main Image Window:
WM_WINDOW_ROLE(STRING) = &quot;gimp-image-window&quot;

Toolbox Window:
WM_WINDOW_ROLE(STRING) = &quot;gimp-toolbox&quot;

Dock Window:
WM_WINDOW_ROLE(STRING) = &quot;gimp-dock&quot;&lt;/nowiki&gt;

Кстати, обратите внимание, что за исключением названия &lt;code&gt;class&lt;/code&gt;, предыдущие три правила идентичны. Поэтому они могут быть объединены в общую запись &lt;code&gt;rule_any&lt;/code&gt; следующим образом:

 &lt;nowiki&gt;    { rule_any = { class = {&quot;MPlayer&quot;, &quot;pinentry&quot;, &quot;Gimp&quot;} },
      properties = { floating = true } },&lt;/nowiki&gt;

== Примеры ==

В этом разделе приводятся некоторые, более сложные примеры, с описанием, как они работают, чтобы обеспечить вам базу для более сложных примеров.

=== Использование &lt;tt&gt;except&lt;/tt&gt; ===

&lt;pre&gt;
{ rule_any = { class = { &quot;psi&quot;, &quot;Psi&quot; } }, except = { instance = &quot;main&quot; },
  callback = awful.client.setslave },
&lt;/pre&gt;

Это правило('rule') для клиента Psi IM. Оно указывает, что каждое окно Psi, будет установлено как вторичное, за исключением списка контактов, которое устанавливается главным. Это позволяет списку контактов всегда оставатся видимым и на том же месте, в то время как окна чатов будут открываться и закрываться, при условии, что tag был [[IM tips|правильно настроен]].

В этом случае, правило будет воздейстовать на эти три окна:

{|class=&quot;wikitable&quot;
! Window type !! Properties
|-
| Contact list || &lt;pre&gt;
WM_NAME(STRING) = &quot;Psi&quot;
WM_CLASS(STRING) = &quot;main&quot;, &quot;psi&quot;
&lt;/pre&gt;
|-
| Chat windows || &lt;pre&gt;
WM_NAME(STRING) = &quot;SomePerson&quot;
WM_CLASS(STRING) = &quot;chat&quot;, &quot;psi&quot;
&lt;/pre&gt;
|-
| History windows || &lt;pre&gt;
WM_NAME(STRING) = &quot;SomePerson (someone@somewhere.net)&quot;
WM_CLASS(STRING) = &quot;psi&quot;, &quot;Psi&quot;
&lt;/pre&gt;
|}

Здесь вы можете видеть, что &lt;tt&gt;class&lt;/tt&gt; (вторая строка WM_CLASS) равна &quot;psi&quot; для первых двух, но &quot;Psi&quot; с заглавной P для третьего. Так что для того, чтобы соответствовать всем этим окнам, мы должны использовать &lt;tt&gt;rule_any&lt;/tt&gt; с обоими вариантами, поэтому правило будет соответствовать любому из указанных названий классов(class).

Однако, мы бы не хотели, чтобы правило соответсвовало списку контактов, поэтому мы определяем значение как &lt;tt&gt;except&lt;/tt&gt; и используем &lt;tt&gt;instance&lt;/tt&gt; (первая строка WM_CLASS ) для обозначения списка контактов.  Мы используем это значение, так как оно не совпадает с другими окнами, поэтому мы исключаем только список контактов.

Теперь у нас есть правило, которое будет соотвестовать всех окнам Psi, за исключением списка контактов, и которое будет вызывать функцию &lt;tt&gt;awful.client.setslave&lt;/tt&gt;. Она устанавливает окна Psi вторичными, за исключением списка контактов, которое остается главным.

== Похожие страницы ==

; [http://awesome.naquadah.org/doc/api/modules/awful.rules.html awful.rules]
:  Документация Lua для модуля awful.rules, которая описывает функциональность правил(rule).

; [[Example of applications rules|Примеры правил для приложений]]
: Несколько правил для основных приложений, в основном помечаются плавающим режимом, в случае необходимости. 
[[Category: Awesome3]]</text>
      <sha1>fdwe8cu5fnd47ah3gob29l420ukjl5v</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Uptime Widget</title>
    <ns>0</ns>
    <id>50</id>
    <redirect title="Woffles Uptime Widget" />
    <revision>
      <id>292</id>
      <timestamp>2008-04-02T10:32:19Z</timestamp>
      <contributor>
        <username>Rowanjl</username>
        <id>20</id>
      </contributor>
      <comment>[[Uptime Widget]] moved to [[Woffles Uptime Widget]]</comment>
      <text xml:space="preserve" bytes="35">#REDIRECT [[Woffles Uptime Widget]]</text>
      <sha1>hujrtav4whb6qpr2wu47g92455t000h</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Urxvt</title>
    <ns>0</ns>
    <id>57</id>
    <revision>
      <id>4547</id>
      <parentid>4118</parentid>
      <timestamp>2010-11-01T19:34:44Z</timestamp>
      <contributor>
        <username>Trevorgreid</username>
        <id>542</id>
      </contributor>
      <text xml:space="preserve" bytes="2711">[http://software.schmorp.de/pkg/rxvt-unicode.html rxvt-unicode] (''urxvt'' for short) is a clone of the ''rxvt'' terminal emulator. It is packaged for just about every major GNU/Linux and BSD distribution, and it's an excellent terminal emulator, lightweight and fast, as its name suggests it has full unicode support and it's fully extendable with Perl. Some of the Perl extensions distributed with urxvt add tabs, quake-like terminal behaviour, clipboard integration, clickable URL's... You can find some tips for using rxvt-unicode and awesome on the [[Urxvt tips]] wiki page.

* '''NOTE:''' If you often work on remote hosts with SSH that don't have urxvt installed you can ''scp'' your local ''terminfo'' entry for rxvt-unicode to the ''&quot;~/.terminfo/r&quot;'' directory.


In order to get the most out of urxvt, you will want to modify its X resources. You can configure them in your ''.Xdefaults'' file. Here is an example to get you started:

  ! General
  !urxvt*termName:  rxvt-256color
  urxvt*loginShell:         true
  urxvt*scrollBar:         false
  urxvt*secondaryScroll:    true
  urxvt*saveLines:         65535
  urxvt*cursorBlink:       false
  urxvt*urgentOnBell:       true
  !urxvt*override-redirect:false
  !urxvt*borderLess:       false
  !urxvt*internalBorder:       0
  !urxvt*externalBorder:       0
  
  ! Extensions
  urxvt*perl-lib:        /usr/lib/urxvt/perl/
  urxvt*perl-ext-common: default,matcher,searchable-scrollback
  urxvt*urlLauncher:     /usr/bin/firefox
  urxvt*matcher.button:  1
  !  - catch ugly URLs
  urxvt.cutchars:        `()'*&lt;&gt;[]{|}&quot;
  
  ! Appearance
  !  - use a bitmap font
  urxvt*font:        -xos4-terminus-medium-*-*-*-12-*-*-*-*-*-*-*
  urxvt*boldFont:    -xos4-terminus-bold-*-*-*-12-*-*-*-*-*-*-*
  !  - use xft for drawing fonts
  !urxvt*font:       xft:Terminus:8
  !  - cursor
  urxvt*cursorColor: #DCDCCC
  !  - pseudo transparency
  !urxvt*shading:    50
  !urxvt*transparent:true
  !
  !  - color scheme
  urxvt.background:  #000000
  urxvt.foreground:  #EBEBFF
  ! black + red
  !urxvt*color0:     #3f3f3f
  urxvt*color0:      #000000
  urxvt*color1:      #e01010
  ! green + yellow
  urxvt*color2:      #00AA00
  urxvt*color3:      #FFFF00
  ! blue + purple
  urxvt*color4:      #112037
  urxvt*color5:      #A020F0
  ! cyan + white
  urxvt*color6:      #5B5BC7
  urxvt*color7:      #fefefe
  ! bright-black + bright-red
  urxvt*color8:      #6a6a6a
  urxvt*color9:      #FF5555
  ! bright-green + bright-yellow
  urxvt*color10:     #90EE90
  urxvt*color11:     #ffff2f
  ! bright-blue + bright-purple
  urxvt*color12:     #5B5BC7
  urxvt*color13:     #e628ba
  ! bright-cyan + bright-white
  urxvt*color14:     #7D7DFB
  urxvt*color15:     #ffffff</text>
      <sha1>pjfg3tisyg9z010jd9h01d5ct58m8qs</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Urxvt Hints</title>
    <ns>0</ns>
    <id>330</id>
    <revision>
      <id>2805</id>
      <parentid>2716</parentid>
      <timestamp>2009-05-27T07:59:21Z</timestamp>
      <contributor>
        <username>Yogan</username>
        <id>246</id>
      </contributor>
      <minor/>
      <comment>moved [[Hints]] to [[Urxvt Hints]]:&amp;#32;This should help others to actually find this page. Just &quot;Hints&quot; does not help much.</comment>
      <text xml:space="preserve" bytes="842">When using urxvt (rxvt-unicode) without hints you can get artifacts on the buttom of the screen.
[[Image:Urxvt-resize-artifacts.png|thumb|300px|Part of a screenshot showing the issue]]

&lt;span style=&quot;clear:both&quot;&gt;&amp;nbsp;&lt;/span&gt;
To fix this you can apply this patch of urxvt and recompile it. Copy this to a file called urxvt.patch :
&lt;pre&gt;
Index: src/main.C
===================================================================
RCS file: /schmorpforge/rxvt-unicode/src/main.C,v
retrieving revision 1.303
diff -u -r1.303 main.C
--- src/main.C	27 Jan 2008 22:48:33 -0000	1.303
+++ src/main.C	1 Feb 2008 16:27:59 -0000
@@ -644,6 +644,8 @@
 
   ncol = width / fwidth;
   nrow = height / fheight;
+  width = ncol * fwidth;
+  height = nrow * fheight;
 }
 
 /*----------------------------------------------------------------------*/
&lt;/pre&gt;

Now patch it.</text>
      <sha1>ob2imt67jmlo2xm1vh7s8ct0bc8y4pf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Urxvt tips</title>
    <ns>0</ns>
    <id>485</id>
    <revision>
      <id>6095</id>
      <parentid>5187</parentid>
      <timestamp>2013-08-28T13:08:51Z</timestamp>
      <contributor>
        <username>Monotypical</username>
        <id>3060</id>
      </contributor>
      <minor/>
      <comment>fixed config file names and minor grammar changed in the Mutt section</comment>
      <text xml:space="preserve" bytes="2612">{{DISPLAYTITLE:Urxvt tip}}
{{Languages|Urxvt tips}}

= Preparations =
You can edit ''~/.Xdefaults'' or ''~/.Xresources'' or other places to configure urxvt. If you never did this read the basic [[Urxvt]] page. Confirm that the following configuration items are defined:
 URxvt.urgentOnBell: True
After adding the above configuration items, update the running database with either:
 xrdb ~/.Xdefaults or xrdb ~/.Xresources
You can confirm it with 
 listres

If you do not want to hear the beep sound, you can run:
 /usr/bin/xset b off
Consider adding it to your .xsession or .xinitrc to run on login

= The new e-mail reminder  Mutt =
You can use ''~/.Muttrc'' or ''~/.mutt/muttrc'' to configure mutt, to confirm beep_new be defined; check_new and the default timeout has been defined, confirming that they are not undefined.
 set beep_new = yes
 set check_new = yes
 set timeout = 600
In a tag label (assumed to be tag4) where open urxvt and run''mutt'', switch to the other tag label to do something you're interested. Before you leave tag4 more than 10 minutes later, when there are new messages, labels tag4 will be highlighted.

= Weechat private / highlight message reminding =
In the [http://www.weechat.org Weechat official website] Download [http://www.weechat.org/files/scripts/beep.pl beep] plug-in, save it to ''~/.weechat/perl/'' directory.
 cd ~ / .weechat / perl
 wget http://www.weechat.org/files/scripts/beep.pl
 cd autoload
 ln-sf .. / beep.pl.
In a tag label (assumed to be tag2) where open urxvt and run''weechat-curses'', switch to the other tag label to do something you're interested. When you are in the irc channel when you receive private or highlight the message, the label tag2 will be highlighted.

= Shell Job completed to remind =
Bash, zsh, and tcsh support displaying the PS1 prompt before commands. Test with:
 echo -ne '\a'
* Bash through the environment variable'' 'PROMPT_COMMAND'''
 export PROMPT_COMMAND = &quot;echo -ne '\a'&quot;
* Zsh through a function'' 'precmd ()'''
 precmd () (
     # Your commands
     # ...
     echo -ne '\a'
 )
* Tcsh through a special alias &lt;code&gt;precmd&lt;/code&gt;:
 alias precmd 'echo -n \\a'

In a tag label (assumed to be tag1) inside urxvt and to open a more time-consuming to run a command (for example, a ''configure'' or ''make''), to switch to the other tag label to do something you're interested. When you are finished running that last command, the label tag1 will be highlighted.

= End =
The default shortcut keys Mod u can jump to the current focus on highlighting the incident happened the last time the window.

= Reference =
* [[Irssi tips]]</text>
      <sha1>pzv5qb6ph5ogtfx9io1sndny5agurk2</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Urxvt tips/ru</title>
    <ns>0</ns>
    <id>1059</id>
    <revision>
      <id>6555</id>
      <timestamp>2014-05-19T07:35:39Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода urxvt tips (translating page)</comment>
      <text xml:space="preserve" bytes="4035">{{DISPLAYTITLE:Советы Urxvt}}
{{Languages|Urxvt tips}}

= Подготовка =
Вы можете редактировать ''~/.Xdefaults'' или ''~/.Xresources'' или другие места для настройки urxvt.Если вы никогда не делали этого, ознакомьтесь с основами по [[Urxvt]]. Убедитесь, что следующие элементы конфигурации работают:
 URxvt.urgentOnBell: True
После добавления вышеуказанных элементов конфигурации, обновление работающей базы данных можно осуществить с помощью:
 xrdb ~/.Xdefaults или xrdb ~/.Xresources
Вы можете подтвердить это с помощью
 listres

Если вы не хотите слушать звуковой сигнал, вы можете использовать:
 /usr/bin/xset b off
Попробуйте добавить этот код в .xsession или .xinitrc для запуска при входе в систему.

= Напоминание о новых письмах Mutt =
Вы можете использовать ''~/.Muttrc'' или ''~/.mutt/muttrc'' для настройки mutt, для подтверждения определите beep_new; check_new и timeout по умолчанию были определены ранее.
 set beep_new = yes
 set check_new = yes
 set timeout = 600
Откройте тег (предполагаем, что это будет tag4) откройте в нем urxvt и запустите ''mutt'', теперь можете переключиться на другой тег, чтобы заняться своими делами.. После того, как вы оставите tag4 на более чем 10 минут, при получении нового сообщения, ярлык tag4 будет подствечен.

= Weechat private / напоминание подсветкой сообщений highlight message reminding =
На [http://www.weechat.org официальном сайте Weechat] загрузите [http://www.weechat.org/files/scripts/beep.pl beep] плагин, сохраните его в каталог ''~/.weechat/perl/''.
 cd ~ / .weechat / perl
 wget http://www.weechat.org/files/scripts/beep.pl
 cd autoload
 ln-sf .. / beep.pl.
В теге (предполагаем, что это будет tag2) откройте urxvt и запустите ''weechat-curses'', переключитесь на другой тег и занимайтесь своими делами. Когда вы получите сообщение в irc канале, ярлык tag2 будет подствечен.

= Напоминание о завершении работы через Shell =
Bash, zsh, и tcsh поддерживают отображение строки PS1 перед команами. Попробуйте это:
 echo -ne '\a'
* Bash через переменную окружения '''PROMPT_COMMAND'''
 export PROMPT_COMMAND = &quot;echo -ne '\a'&quot;
* Zsh через функцию '''precmd ()'''
 precmd () (
     # Your commands
     # ...
     echo -ne '\a'
 )
* Tcsh через специальный алиас &lt;code&gt;precmd&lt;/code&gt;:
 alias precmd 'echo -n \\a'

В теге (предположим это будет tag1) в urxvt запустим несколько занимающих много времени команд (например, ''configure'' или ''make''), затем переключившись на другой тег займемся своими делами. Когда завершится последняя команда, ярлык тега будет подсвечен.

= Завершение =
Клавиатурное сочетание Mod+u перенесет фокус на подсвеченное в последнем событии окно.

= Ссылки =
* [[Irssi tips/ru]]</text>
      <sha1>3xrzavcuia9yvkug5ujc0tw8z30831p</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Urxvt tips/zh-hans</title>
    <ns>0</ns>
    <id>327</id>
    <revision>
      <id>5337</id>
      <parentid>3639</parentid>
      <timestamp>2012-02-07T09:34:42Z</timestamp>
      <contributor>
        <username>Fanzeyi</username>
        <id>781</id>
      </contributor>
      <minor/>
      <comment>Better Translate</comment>
      <text xml:space="preserve" bytes="2228">{{DISPLAYTITLE:Urxvt提示}}
{{Languages|Urxvt tips}}

= 准备工作 =
你可以在 ~/.Xdefaults 或者 ~/.Xresources 或者其它地方配置 urxvt，确认以下配置项被定义。
 URxvt.urgentOnBell: True
添加完以上配置项后，执行命令
 xrdb ~/.Xdefaults
或者
 xrdb ~/.Xresources

如果你不喜欢听 beep 声，你可以在 ~/.xinitrc 或者 ~/.Xsession 中关闭它，确认以下命令被执行。
 /usr/bin/xset b off

= Mutt 新邮件提醒 =
你可以在 ~/.muttrc 或者 ~/.mutt/muttrc 中配置 mutt，确认 beep_new 被定义；check_new 和 timeout 默认已定义，确认它们未被取消定义。
 set beep_new=yes
 set check_new=yes
 set timeout=600
在某 tag 标签(假设为 tag4)里打开 urxvt 并运行 ''mutt''，切换至其它 tag 标签做些你感兴趣的事。在你离开 tag4 超过 10 分钟后，一旦有新邮件，标签 tag4 会高亮显示。

= Weechat 私人/高亮消息提醒 =
在 [http://weechat.flashtux.org Weechat 官方网站] 下载 [http://weechat.flashtux.org/scripts/beep.pl beep] 插件，保存至 ~/.weechat/perl/ 目录。
 cd ~/.weechat/perl
 wget http://weechat.flashtux.org/scripts/beep.pl
 cd autoload
 ln -sf ../beep.pl .
在某 tag 标签(假设为 tag2)里打开 urxvt 并运行 ''weechat-curses''，切换至其它 tag 标签做些你感兴趣的事。当你在 irc 频道中收到 private 或者 highlight 消息时，标签 tag2 会高亮显示。

= Shell Job 完成时提醒 =
据我所知的两种 Shell(bash/zsh) 都支持在显示提示符 PS1 之前执行命令的功能，我们要做的就是在那个时刻简单的执行一条命令:
 echo -ne '\a'
* bash 通过环境变量 '''PROMPT_COMMAND'''
 export PROMPT_COMMAND=&quot;echo -ne '\a'&quot;
* zsh 通过函数 '''precmd()'''
 precmd()  {
     # your commands
     # ...
     echo -ne '\a'
 }
在某 tag 标签(假设为 tag1)里打开 urxvt 并运行一个比较耗时的命令(例如一次 ''configure'' 或者 ''make'')，切换至其它 tag 标签做些你感兴趣的事。当你刚才那条命令执行完成时，标签 tag1 会高亮显示。

= 最后 =
默认快捷键 Mod+u 可以把当前焦点跳转至最后一次发生高亮事件的窗口。

= 参考 =
* [[Irssi tips]]</text>
      <sha1>c1476m0a6jxm6gpiwjb5b4y93qjlwab</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Urxvt tips (Simplified Chinese)</title>
    <ns>0</ns>
    <id>484</id>
    <redirect title="Urxvt tips" />
    <revision>
      <id>3628</id>
      <timestamp>2009-09-29T09:57:18Z</timestamp>
      <contributor>
        <username>S5unty</username>
        <id>244</id>
      </contributor>
      <comment>moved [[Urxvt tips (Simplified Chinese)]] to [[Urxvt tips]]</comment>
      <text xml:space="preserve" bytes="24">#REDIRECT [[Urxvt tips]]</text>
      <sha1>oqhxnnt8tugn1cdg2prlos8ex8b86ig</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>User Configuration Files</title>
    <ns>0</ns>
    <id>153</id>
    <revision>
      <id>7476</id>
      <parentid>7475</parentid>
      <timestamp>2016-08-02T01:22:05Z</timestamp>
      <contributor>
        <username>Tdy</username>
        <id>300</id>
      </contributor>
      <minor/>
      <comment>/* List of user configuration files */</comment>
      <text xml:space="preserve" bytes="18097">{{Languages}}

= List of user configuration files =

{{Config
| Name = mrzapp
| Image = [[Image:mrzapp.png|200px]]
| Features = If you like Gnome, you'll like this:
* Volume, wifi and battery widgets based on Gnome svg icons
* Optimised use of tasklist space
* Modified layout icons for a more Gnomie-ish look
| Screenshot = , [https://raw.githubusercontent.com/mrzapp/awesomerc/master/screenshot.png] 
| Version = 3.5.5
| Config = [https://github.com/mrzapp/awesomerc github page]
| Theme = Gnome-ish
| Files = Depends on Gnome assets
| Notes = -
}}

{{Config
| Name = pengw
| Image = [[File:Pengw-awesome-screenshot-20150215.png|200px]]
| Features = features
* '''persistent dynamic tagging across (both regular and randr-induced) restarts'''
* confirmation before quit/restart to minimize data loss accidents
* keybindings for tuning transparency (using xcompmgr)
* detailed usage doc (including detailed specification of external dependencies and autostarts) on the Github repo
| Screenshot = [https://www.youtube.com/watch?v=jC-aaIewNkc] 
| Version = 3.5.5
| Config = [https://github.com/pw4ever/awesome-wm-config github repo with detailed usage doc]
| Theme = theme
* zenburn
* randomly pick one of the included wallpapers (can extend by dropping your wallpapers in the &quot;wallpaper&quot; directory) every 15 seconds (tunable in &quot;rc.lua&quot;)
| Files = Some public domain wallpapers (mostly natural themed).
| Notes = -
}}

{{Config
| Name = jbranso
| Image = [[Image:AoeAoeDefault.png|200px]]
| Features = can use eject, volume, mute, screen brightness buttons, vicious widgets, and a naughty notification when your battery is low
| Screenshot = , [https://github.com/jbranso/config-files/tree/master/.config/awesome/pictures/screenshot.png] 
| Version = 3.5.5
| Config = [https://github.com/jbranso/config-files/tree/master/.config/awesome github page]
| Theme = default, theme-pack (optional)
| Files = I'm using some of the Faenza icons.
| Notes = -
}}

{{Config
| Name = tpruzina
| Image = [[Image:AoeAoeDefault.png|200px]]
| Features = modular, minimal dependencies, run-once, keyboard layout changer, based on Gentoo's rc.lua
| Screenshot = [https://raw.github.com/tpruzina/awesomerc/master/screenshot/default.png]
| Version = 3.5.1
| Config = [https://github.com/tpruzina/awesomerc.git github page]
| Theme = default, theme-pack (optional)
| Files = 
| Notes = optionally integrates (via git-submodules) [https://github.com/mikar/awesome-themes awesome-themes], [https://github.com/alexander-yakushev/Orglendar orglendar]
}}

{{Config
| Name = romockee
| Image = [[Image:screen-21-50-15.png|200px]]
| Features = powerline-like panel with system monitor, Blingbling and Vicious widgets: pop-up top, udisk-glue, TaskWarroir and binary clock
| Screenshot = [https://github.com/romockee/powerarrow/tree/master/screenshots]
| Version = 3.4.13
| Config = [https://github.com/romockee/powerarrow github page] -&gt; [https://github.com/esn89/powerarrow github page of this theme for Awesome 3.5]
| Theme = [https://github.com/romockee/powerarrow github page] -&gt; [https://github.com/esn89/powerarrow github page of this theme for Awesome 3.5]
| Files =
| Notes = Uses [http://awesome.naquadah.org/wiki/Blingbling Blingbling] and [https://github.com/gorlowski/couth Couth] (for Alsa plugin)
}}

{{Config
| Name = tdy
| Image = [[Image:Tdy_desktop_1680x1050.png|200px]]
| Features = Vicious widgets, Dust theme, [https://6xq.net/pianobar/ pianobar] integration
| Screenshot = [https://github.com/tdy/screenshots]
| Version = 3.5+
| Config = [https://github.com/tdy/awesome tdy/awesome.git] ([https://github.com/tdy/dots tdy/dots.git])
| Theme = [https://github.com/tdy/awesome/tree/master/themes/dust Dust] (based on the GTK theme)
| Files = [[Vicious|Vicious]]
| Notes = —
}}

{{Config
| Name = Elbereth
| Image = [[Image:elbereth_clean.png|200px]]
| Features = Vi-based keybindings, uses blingbling, LOTR themed, Tengwar font, modal conky, causes monsters to flee.
| Screenshot = [https://github.com/ardagnir/Elbereth]
| Version = 3.4.11
| Config = [https://github.com/ardagnir/Elbereth]
| Theme = [https://github.com/ardagnir/Elbereth])
| Files = —
| Notes = —
}}

{{Config
| Name =tony
| Image = [[Image:Awesome_3.4.10_full_by_git-pull.png|200px]]
| Features = personal.vim config file for per-computer settings, [[vicious]] widgets (cpu, temp, mpd, diskspace, up/down, volume, battery), random wallpaper (needs feh), multi-language numeral taglists. Scans for apps, wallpaper dir, etc.
|Screenshot = [[media:Awesome_3.4.10_full_by_git-pull.png|Screenshot 1]]
| Version = 3.4.10
| Config = [https://github.com/tony/awesome-config github page]

Installation = &lt;code&gt;git clone https://github.com/tony/awesome-config.git ~/.config/awesome &amp;&amp; cd ~/.config/awesome &amp;&amp; git submodule init &amp;&amp; git submodule update &amp;&amp; less ~/.config/awesome/README.md&lt;/code&gt;
| Theme = [https://github.com/tony/awesome-config/tree/master/themes/zhongguo Zhongguo] - A modified version of zenburn
| Files = Vicious (&lt;code&gt;git submodule init &amp;&amp; git submodule update&lt;/code&gt;), curl, feh
| Notes = Using personal.vim will allow you to git-pull updates of the config later.
}}

{{Config
| Name =cedlemo
| Image = [[Image:blingbling_laptop_full.png|200px]]
| Features = [[blingbling]] widgets (graph, value text box, mpd, udisks-glue, task warrior, calendar, net), freedesktop menu; themes menu; run_once function;
|Screenshot = [[media:blingbling_laptop_full.png|Screenshot 1]] [[media:blingbling_laptop_empty.png|Screenshot 2]]
| Version = 3.4.11
| Config = [https://github.com/cedlemo/blingbling/blob/master/examples_of_rc.lua/laptop_1280x800_rc.lua rc.lua]
| Theme = — 
| Files = —
| Notes = —
}}

{{Config
| Name = tj
| Image = [[Image:Glossy.png|200px]]
| Features = freedesktop menu; themes menu; autostarting of applications; additional host specific configuration file; [[Delightful]] support; almost default keybindings
|Screenshot = [[media:Glossy.png|Screenshot 1]] [[media:Darklooks.png|Screenshot 2]]
| Version = 3.4.3
| Config = — 
| Theme = — 
| Files = —
| Notes = Download and installation instructions at http://solitudo.net/software/awesome/config/
}}


{{Config
| Name = ierton
| Image = [[Image:ierton-screenshot-large.png|200px]]
| Features = Modular config; freedesktop menu; themes menu; ability to memorize client's floating/titlebar/centered state; client context menu; no shifty; simple bash-based widgets;
|Screenshot = —
| Version = 3.4.10
| Config = [http://github.com/ierton/awesomerc-ierton/blob/laptop/rc.lua Git head].
| Theme = — 
| Files = —
| Notes = See [http://github.com/ierton/awesomerc-ierton README] for install instructions.
}}


{{Config
| Name = JackH79
| Image = [[Image:Jackh79-screen.png|200px]]
| Features = Conditionalised widgets (colour changes), Coloured &quot;Remind&quot; output through naughty.notify (requires colour coded '.reminders' file), fuzzy clock (inspired by KDE's widget), no icons.
|Screenshot = [https://github.com/JackH79/.dotfiles/raw/master/clean.png clean]  [https://github.com/JackH79/.dotfiles/raw/master/dirty.png dirty]
| Version = 3.4.11
| Config = [https://github.com/JackH79/.dotfiles/tree/master/.config/awesome git]
| Theme = Custom
| Files = —
| Notes = Uses shifty. (Use [http://awesome.naquadah.org/wiki/Talk:Shifty patched version] to work with 3.4.8 (3.4.9 works normal again).
}}

{{Config
| Name = alte
| Image = [[Image:alte-screenshot.png|200px]]
| Features = Special small screen mode; floating status bar updating on dbus events; key remapping module; modular config
| Screenshot = [http://www.alte.ru/awesome/screenshot.png]
| Version = 3.4
| Config = [http://www.alte.ru/awesome/config/rc.lua.html]
| Theme = Custom, dark with highlights derived from Ubuntu colors 
| Files = mod-smallscreen: [http://www.alte.ru/awesome/config/mod-smallscreen.lua.html], mod-statusbar: [http://www.alte.ru/awesome/config/mod-statusbar.lua.html], mod-keymapper: [http://www.alte.ru/awesome/config/mod-keymapper.lua.html]
| Notes = See [http://www.alte.ru/awesome/] for detailed description, full list of features and complete config dowload.
}}

{{Config
| Name = anrxc
| Image = [[Image:Screenshot-anrxc.png|200px]]
| Features = Highly personalized key bindings, Vicious widgets, Zenburn colors.
| Screenshot = [http://sysphere.org/gallery/snapshots]
| Version = 3.4
| Config = [http://git.sysphere.org/awesome-configs/]
| Theme = [[Zenburn Theme|Zenburn]]
| Files = [[Vicious|Vicious]]
| Notes = —
}}


{{Config
| Name = dunz0r
| Image = [[Image:Dunz0r-2.png|200px]]
| Features = mpd widget, mpd-playlist, keybindings for mpd, dynamic tagging with shifty, pasting xbuffer to filename chosen in prompt or a predefined value, weather info, devtodo-integration, modal keybindings
| Screenshot = -
| Version = 3.4.3
| Config =  http://git.hax0r.se/?p=configs/.git;a=tree;f=.config/awesome;h=9d49607d8de74f120d9d3d8b6e4a7eb01f9b7240;hb=refs/heads/master
| Theme = homemade
| Files = rc.lua, theme.lua
| Notes = config full of unused functions(fortunately nothing that causes problems)
}}


{{Config
| Name = ctaf
| Image = [[File:ctaf-screenshot.png|200px]]
| Features = scratchpad, tab, tabwidget in titlebar, apps on the im tag are ontop and floating, failsafe start (revert to default rc.lua on error) ...
| Screenshot = [http://www.ctaf.free.fr/awesome/awesome-3-4-tab.png]
| Version = awesome 3.4-git
| Config = [http://gitorious.org/awesome-config/]
| Theme = zenburn
| Files = —
| Notes = —
}}


{{Config
| Name = shikamaru
| Image = [[File:Shikamaru-screenshot.png|200px]]
| Features = freedesktop menu, vicious widgets (net, mpd, proc, mem, battery), teardrop
| Screenshot = [http://shikamaru.fr/attachments/download/28/awesome-3.4-rc3.png]
| Version = 3.4 rc3
| Config = [http://shikamaru.fr/repositories/browse/awesome/.config/awesome]
| Theme = Konoha Forest
| Files = —
| Notes = You can clone the git repo at this adress : git clone git://shikamaru.fr/config.git
}}


{{Config
| Name = kAworu
| Image = [[Image:kaworu-scrot1.png|200px]]
| Features = beautiful / naughty / mpd lib / lua FreeBSD sysctl
| Screenshot = [http://files.kaworu.ch/awesome-scrot.png]
| Version = 3.0, 3.1.2, 3.2, 3.3, 3.4
| Config = [http://hg.kaworu.ch/config-awesome]
| Theme = —
| Files = —
| Notes = —
}}


{{Config
| Name = bioe007
| Image = [[File:  bioe007_sshot.png|200px|thumb|center]] 
| Features = Shifty, Revelation, Mocp scrolling text widget, fs, battery widgets, pretty modular config. Move tags across screens, Fancy taglist and tasklist widget menus
| Screenshot = —
| Version = 3.4
| Config = [http://github.com/bioe007/awesome-configs/tree/master]
| Theme = [http://github.com/bioe007/awesome-configs/tree/master]
| Files = —
| Notes = —
}}


{{Config
| Name = JoeD84
| Image = [[Image:Screenshot_JoeD84_2.png|288px]]
| Features = Split config, failsafe load, autostart once with sorta lockfile, windowplacement calculated by Master/Slave (Work in progress), rulesets, Menu with Icons(Icons not Included
|Screenshot = [http://github.com/JoeD84/awesome/raw/master/Screenshot_2.png]
| Version = 3.4.8
| Config = [http://github.com/JoeD84/awesome/]
| Theme = Custom
| Files = All in the git
| Notes = Creepy code style. But I will try to explain if you ask. 
}}


{{Config
| Name = admiral0
| Image = [[Image:admiral0config.png|200px]]
| Features = Modular config; Vicious widgets; Pulseaudio with naughty-osd; Battery power consumed
| Screenshot = —
| Version = 3.5.x, check previous commits for 3.4.x
| Config = [http://github.com/admiral0/awesome-config Git head].
| Theme = local, based on zenburn
| Files = —
| Notes = To install this config, type &quot;git clone git://github.com/admiral0/awesome-config.git ~/.config/awesome&quot;
}}


{{Config
| Name = nberth
| Image = [[Image:nberth-screenshot.png|200px]]
| Features = Custom keychains with infoline helpers &quot;à la&quot; emacs; Emacs Multimedia System integration; Mouse goes to the top left hand corner of any newly focused client window when this focus is changed using the keyboard (ion3 inspired); Plus classic features such as Vicious widgets and dynamic tagging with Shifty.
| Screenshot = —
| Version = v3.4.10
| Config = [http://gitorious.org/berthome/berthome].
| Theme = —
| Files = —
| Notes = Note the key feature here is the `keychain' library, associated with the `infoline' helpers for &quot;forgotten prefix keys&quot; notification (heum... try it, and you'll see what I mean).
It also includes various hacks allowing quick access to language tools. For instance, typing `S-e f' (`S' standing for `Super' key, aka `Mod4') prompts for an English word and then opens w3m in a terminal (of course, the browser is customizable) with the WordReference page of the corresponding translation into French. Similarly, `S-e s' retrieves English synonyms. Finally, `S-f e', `S-f s' and `S-f c' behave likewise, but the other way around (with conjugations).
}}

{{Config
| Name = unlogic
| Image = [[Image:Unlogic-conscience-screenshot.png|200px]]
| Features = Onscreen widgets, menubar, quick launch bar.
| Screenshot = [http://i.imgur.com/O9KTh.png 1]
| Version = v3.4.10
| Config = [http://dotshare.it/dots/310/]
| Theme = [https://github.com/alexander-yakushev/conscience-awesome-theme Conscience]
| Files = —
| Notes = Please, read the Requirements section on the dotshare.it.
}}

{{Config
| Name = unlogic
| Image = [[Image:Unlogic-devotion-theme.png|200px]]
| Features = Onscreen MPD widget, Unity-style sidebar.
| Screenshot = —
| Version = v3.5
| Config = [https://github.com/alexander-yakushev/awesomerc]
| Theme = Devotion (see themes/ folder)
| Files = —
| Notes = —
}}

{{Config
| Name = wlourf
| Image = [[Image:cairowidgets.png|200px]]
| Features = Cairowidgets : Awesome icons &amp; layouts icons are drawn when awesome starts. Multiple widgets made with cairo, easy customizable with rc.lua theme.lua (rings bars graphs text battery mpd)
|Screenshot = —
| Version = 3.4.6
| Config = [http://wlourf.deviantart.com/art/widgets-for-awesome-wm-v1-2-269061228].
| Theme = — 
| Files = —
| Notes = See README for install instructions.
}}

{{Config
| Name = vincentbernat
| Image = [[Image:Awesome_3.4.12_vincent_bernat.jpg|200px]]
| Features = modular, [[Autostart#The_X_way|xrun]], [[Drop-down terminal#Another_solution|quake console]], [[Shared_tags|shared tags]], [[Document keybindings|documentation of key bindings]], random wallpaper, transparency, vicious widgets, [[Using Multiple Screens#Static_configuration|xrandr integration]]
| Screenshot = [[media:Awesome_3.4.12_vincent_bernat.jpg|Screenshot 1]]
| Version = 3.4.12
| Config = [https://github.com/vincentbernat/awesome-configuration github page]
| Theme = —
| Files = —
| Notes = Do not use as is! Use it as a source of inspiration. Be sure to check the [https://github.com/vincentbernat/awesome-configuration/blob/master/README.md README file].
}}

{{Config
| Name = oxmoz
| Image =
| Features = Vicious widgets, org-awesome.
| Screenshot = [http://www.oxmoz.eu/awesome/awesome.png]
| Version = 3.4
| Config = [http://www.oxmoz.eu/awesome/rc.lua]
| Theme = zenburn
| Files = —
| Notes = —
}}

{{Config
| Name = yogan
| Image = 
| Features = focus following transparency (needs xcompmgr or similar), debugging mode (naughty popups for new/existing clients), application settings table for: screen/tag, float, ontop, master, maximized, fullscreen, titlebar, ...
| Screenshot = [http://yogan.meinungsverstaerker.de/awesome/shot_2009-02-05.png]
| Version = 3.1-235-ga13f3fe (2009-02-03)
| Config = [http://yogan.meinungsverstaerker.de/awesome/rc.lua]
| Theme = [http://yogan.meinungsverstaerker.de/awesome/theme]
| Files = —
| Notes = some other stuff copied from other configs (mpd, volume, net, cpu, load, ... widgets)
}}


{{Config
| Name = peikk0
| Image = 
| Features = beautiful / naughty / kAworu's MPD lib and Lua FreeBSD sysctl / home made functions for widgets / no images at all
| Screenshot = —
| Version = 3.4
| Config = [https://github.com/peikk0/dotfiles/tree/master/.config/awesome]
| Theme = —
| Files = —
| Notes = —
}}


{{Config
| Name = koniu
| Image = 
| Features = [[Shifty]] with some advanced settings (see gittags [http://silenceisdefeat.com/~koniu/awesome/video/gittags.avi video]), preliminary inline documentation (awful.doc) [http://silenceisdefeat.com/~koniu/awesome/shots/2009-04-19-042807_1024x768_scrot.png shot], scrolling clients too big for the workspace [http://silenceisdefeat.com/~koniu/awesome/video/awsumscrolling.avi video], custom widgets: wifi, mounts, cputemp, fan, apt, battery, calendar, custom prompts: calc, dict, kill, log watcher with naughty output
| Screenshot = [http://silenceisdefeat.com/~koniu/awesome/shots/]
| Version = git ''master''
| Config = [http://github.com/koniu/awesome-configs/]
| Theme = —
| Files = —
| Notes = —
}}


{{Config
| Name = farhaven
| Image = 
| Features = Conservative setup with a few advanced things like a stats wibox
| Screenshot = —
| Version = —
| Config = [http://github.com/farhaven/awesome-configs/tree/master]
| Theme = [http://github.com/farhaven/awesome-configs/tree/master]
| Files = —
| Notes = —
}}


{{Config
| Name = jinleileiking
| Image = 
| Features = Simple, Calendar, Mostly from Mic92, autoruns, slock, restart, shutdown
|Screenshot = [https://github.com/jinleileiking/DotFiles/raw/master/awesome_screenshot.png].
| Version = 3.4.9r1
| Config = [https://github.com/jinleileiking/DotFiles].
| Theme = — 
| Files = —
| Notes = 
}}

{{Config
| Name = actionless
| Image = [[File:Monovedek_master.png|200px]]
| Features = music widget with multiple backends (mpd, cmus, spotify, clementine), widget to show current keybindings, rest of widgets was made async, rc.lua splited to multiple files
|Screenshot = [https://github.com/actionless/awesome_config/blob/devel/README.md].
| Version = git 'master'
| Config = [https://github.com/actionless/awesome_config].
| Theme = few themes included: can use your .Xresources values to color up the things, themes have different widget decorations and icons
| Files = —
| Notes = -
}}

[[Category:awesome3]]</text>
      <sha1>sjxuqnwb5l2r1n3bjs0f9e2u6ewtyn8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>User Configuration Files/fr</title>
    <ns>0</ns>
    <id>401</id>
    <revision>
      <id>4321</id>
      <parentid>3507</parentid>
      <timestamp>2010-06-21T12:56:22Z</timestamp>
      <contributor>
        <username>Ierton</username>
        <id>332</id>
      </contributor>
      <minor/>
      <comment>/* Fichiers de configuration avec détails */</comment>
      <text xml:space="preserve" bytes="8472">{{DISPLAYTITLE:Fichiers de configuration d’utilisateurs}}
{{Languages|User Configuration Files}}

Cette page propose des fichiers de configuration pour awesome. Certains disposent de renseignements complémentaires sur leur contenu, et parfois même une capture d’écran. D’autres [[Beautiful themes/fr|fichiers de thème beautiful]] sont disponibles sur ce wiki.
__NOTOC__
== Fichiers de configuration avec détails ==
{{Config/fr
| Nom = dunz0r
| Image = [[Image:Dunz0r-2.png|200px]]
| Fonctionnalités = bibliothèque kawourous de MPD, widget MPD fait maison, affichage liste de lecture MPD, charge moyenne et température CPU, raccourcis pour MPD, barre de batterie, possibilité de bouger tout un onglet vers l’écran suivant, deux wiboxes : une avec info et l’autre pour liste des fenêtres et boîte à dispositions, gestion dynamique des onglets avec [[shifty/fr|shifty]].
| Capture = [http://omploader.org/vMXYwNQ]
| Version = 3.3
| Config = [http://github.com/dunz0r/awesome-configs/tree]
| Thème = [http://github.com/koniu/awesome-configs/tree/master celui de Koniu]
| Fichiers = —
| Remarques = —
}}


{{Config/fr
| Nom = ierton
| Image = [[Image:Ierton-screenshot-small.jpg|200px]]
| Fonctionnalités = Configuration modulaire ; menu Freedesktop ; possibilité de sauvegarde et chargement automatiques (!) ; état flottant, barre de titre ou centré du client ; menu de thèmes ; menu contextuel de client ; ajout, suppression et renommage dynamiques des onglets ; pas de wigdet ; pas d’utilisation de shifty
| Capture = [http://robot.ierton.homelinux.net/screenshot.png]
| Version = 3.4.5
| Config = [http://git.ierton.ru/?p=awesomerc.git;a=blob_plain;f=rc.lua;hb=master]
| Thème = — 
| Fichiers = —
| Remarques = git clone git://ierton.ru/awesomerc
}}


{{Config/fr
| Nom = Calmar
| Image = [[Image:Screenshot-calmar.png|200px]]
| Fonctionnalités = Configuration standard, quelques widgets, widget de volume
| Capture = ci-contre et [http://awesome.naquadah.org/w/images/Calmar.png ici]
| Version = —
| Config = [http://www.calmar.ws/dotfiles/dotfiledir/dot_awesomerc.lua]
| Thème = — 
| Fichiers = Script de remplissage des widgets : [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status.lua]
| Remarques = Normallement, ''awesome-status'' d’[http://udvzsolt.extra.hu/news.php Uzsolt] est utilisé avec le fichier de configuration [http://www.calmar.ws/dotfiles/dotfiledir/dot_awesome-status.rc ici], mais il n’est plus compatible avec la version actuelle d’awesome.
}}


{{Config/fr
| Nom = Rhaamo
| Image = [[Image:desktop-rhaamo.png|200px]]
| Fonctionnalités = un script dans la barre de statut pour afficher la RAM et le CPU utilisés par le client au premier plan. Configuration sans wicked, juste beautiful et une bibliothèque MPD.
| Capture = ci-contre
| Version = —
| Config = [http://tux-atome.fr/?p=rhaamo_config-files.git;a=tree;f=configs/awesome3/dot_config/awesome;hb=HEAD]
| Thème = [[rhaamo_theme|« rhaamo »]]
| Fichiers = —
| Remarques = —
}}


{{Config/fr
| Nom = Kooky
| Image = [[Image:Screenshot-kooky.png|200px]]
| Fonctionnalités = widget de batterie utilisant Hal, widget de calendrier qui interprète le fichier d’Emacs, complétion Wikipédia
| Capture = ci-contre
| Version = —
| Config = [http://www.markurashi.de/dotfiles/awesome/]
| Thème = [[Zenburn Theme|« zenburn »]] d’anrxc
| Fichiers = —
| Remarques = —
}}


{{Config/fr
| Nom = anrxc
| Image = 
| Fonctionnalités = nombreux raccourcis claviers personnalisés (''tout'' est fait au clavier). Nombreux widgets : CPU, batterie, mémoire, système de fichiers, réseau, sans fil, e-mail, OrgMode, volume, date, calendrier. Nombreuses invites de commande : dictionnaire, calculatrice, ssh, pages de manuel, recherches sur Internet, et plein d’autres trucs
| Capture = [http://sysphere.org/gallery/snapshots/awesome]
| Version = 3.3.1
| Config = [http://sysphere.org/~anrxc/local/scr/dotfiles/awesomerc.lua.html]
| Thème = [http://sysphere.org/~anrxc/local/scr/dotfiles/awesome-zenburn.lua.html]
| Fichiers = Lire la FAQ dans le fichier awesomerc.lua
| Remarques = couleurs « zenburn » partout pour un meilleur confort visuel, 
}}


{{Config/fr
| Nom = yogan
| Image = 
| Fonctionnalités = transparence suivant le focus (nécessite ''xcompmgr'' ou similaire), mode débogage (popups par naughty pour les clients), tableau de paramètres d’application pour : écran ou onglet, flottement, maître, maximisée, plein écran, barre de titre, etc.
| Capture = [http://yogan.meinungsverstaerker.de/awesome/shot_2009-02-05.png]
| Version = 3.1-235-ga13f3fe (3 février 2009)
| Config = [http://yogan.meinungsverstaerker.de/awesome/rc.lua]
| Thème = [http://yogan.meinungsverstaerker.de/awesome/theme]
| Fichiers = —
| Remarques = d’autres choses copiées d’autres configurations : MPD, volume, net, cpu, charge, widgets, …
}}


{{Config/fr
| Nom = koniu
| Image = 
| Fonctionnalités = [[shifty/fr|shifty]] avec paramètres avancés (voir la [http://silenceisdefeat.com/~koniu/awesome/video/gittags.avi vidéo gittags]), documentation préliminaire en ligne (awful.doc — [http://silenceisdefeat.com/~koniu/awesome/shots/2009-04-19-042807_1024x768_scrot.png capture]), défilement entre les clients trop grand pour l’espace de travail ([http://silenceisdefeat.com/~koniu/awesome/video/awsumscrolling.avi vidéo]), widgets personnalisés (wifi, montage, température cpu, ventilateurs, ''apt'', batterie, calendrier), invites de commande personnalisées (calculatrice, dictionnaire, arrêt brutal), visionneur de journaux avec sortie naughty
| Capture = [http://silenceisdefeat.com/~koniu/awesome/shots/]
| Version = git ''master''
| Config = [http://github.com/koniu/awesome-configs/]
| Thème = —
| Fichiers = —
| Remarques = —
}}


{{Config/fr
| Nom = geekounet
| Image = 
| Fonctionnalités = beautiful, naughty, bibliothèque MPD et kAworu et ''sysctl'' Lua de FreeBSD, fonctions faites maison pour les widgets, pas d’image du tout
| Capture = [http://foo.poildetroll.net/screenshots/awesome-090406-013616.png]
| Version = 3.3
| Config = [https://hg.poildetroll.net/hg/config/awesome/]
| Thème = —
| Fichiers = —
| Remarques = —
}}


{{Config/fr
| Nom = Wolgri
| Image = 
| Fonctionnalités = Modifications de séparation de la configuration par défaut par souci de simplicité d’utilisation
| Capture = [http://img145.imageshack.us/img145/3271/200902211353471280x800s.png]
| Version = 3.2
| Config = [http://github.com/wolgri/wolgri.config/tree/master/.config/awesome/]
| Thème = —
| Fichiers = —
| Remarques = —
}}


{{Config/fr
| Nom = kAworu
| Image = 
| Fonctionnalités = beautiful, naugthy, bibliothèque MPD, ''systcl'' Lua de FreeBSD, Space Invaders (évidemment)
| Capture = [http://files.kaworu.ch/awesome-scrot.png]
| Version = 3.0, 3.1.2, 3.2
| Config = [http://hg.kaworu.ch/config-awesome]
| Thème = —
| Fichiers = —
| Remarques = —
}}


{{Config/fr
| Nom = Oxmoz
| Image = 
| Fonctionnalités = configuration standard, thème changeant dynamiquement depuis un menu, quelques widgets.
| Capture = [http://www.oxmoz.eu/awesome/awesome.png]
| Version = —
| Config = [http://www.oxmoz.eu/awesome/rc.lua]
| Thème = —
| Fichiers = —
| Remarques = —
}}

== Fichiers de configuration divers ==
* [http://github.com/stxza/arch-linux-configs/tree/master/.config/awesome Galerie de thèmes] et [http://balancest.deviantart.com/gallery/ captures d’écran]
* http://milkybox.ath.cx/myhg/dotfiles/file/tip/awesome/rc.lua (fichier principal) et thème : http://milkybox.ath.cx/myhg/dotfiles/file/tip/awesome/themes/pyrho ([http://pyrho.deviantart.com/art/Linux-desktop-Dec-08-106312210 capture d’écran])
* http://github.com/gigamo/config/tree/master/.config/awesome/rc.lua (fichier principal) et thème : http://github.com/gigamo/config/tree/master/.config/awesome/themes/gigamo
* [[User:Farhaven#My_rc.lua|configuration]] et [[User:Farhaven#My_current_theme|thème]] de Frahaven
* https://hg.poildetroll.net/hg/config/awesome/summary (version 3.0)

== Autres fichiers de configuration sans information==
* http://git.glacicle.com/other/configs.git/.config/awesome/rc_31.lua
* http://github.com/BaSh/config/tree/master/.config/awesome/rc.lua
* http://github.com/dmj/dotfiles/tree/master/.config/awesome/
* http://dev.chrissearle.net/git/espenhw-awesome-config.git
* http://worldofmodcraft.com/forum/Dreadlorde/~awesome

[[Category:awesome3]]</text>
      <sha1>d4ryc99oxpnc7d2md8h8e0vnxixlehu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>User Configuration Files/ru</title>
    <ns>0</ns>
    <id>474</id>
    <revision>
      <id>4990</id>
      <parentid>4989</parentid>
      <timestamp>2011-07-30T19:10:00Z</timestamp>
      <contributor>
        <username>Ierton</username>
        <id>332</id>
      </contributor>
      <comment>/* Список файлов */</comment>
      <text xml:space="preserve" bytes="9631">{{DISPLAYTITLE:Пользовательские конфигурациооные файлы}}
{{Languages|User Configuration Files}}

На этой странице Вы найдёте конфигурационные файлы различных пользователей Awesome. К некоторым из них прилагаются краткие описания и скриншоты.

= Список файлов =

{{Config/ru
| Name = ierton
| Image = [[Image:ierton-screenshot-large.png|200px]]
| Features = Модульная конфигурация; меню Freedesktop; меню выбора темы; контекстное меню окон; запоминает настройки окон; меню манипуляции с тегами; никакого shifty; [http://awesome.naquadah.org/wiki/Bashets виджеты на bash-скриптах].
| Screenshot = [http://awesome.naquadah.org/w/images/Ierton-screenshot-large.png] (старый, сейчас всё круче)
| Version = 3.4.10
| Config = [http://github.com/ierton/awesomerc-ierton]
| Theme = — 
| Files = —
| Notes = Инструкция по установке доступна [http://github.com/ierton/awesomerc-ierton  в README]. 
}}


{{Config/ru
| Name = Calmar
| Image = [[Image:Screenshot-calmar.png|200px]]
| Features = Стандартная конфигурация, добавлены несколько виджетов, в том числе виджет громкости.
| Screenshot = [http://www.calmar.ws/tmp/052-Thu-screen.png]
| Version = —
| Config = [http://www.calmar.ws/dotfiles/dotfiledir/dot_awesomerc.lua]
| Theme = — 
| Files = Скрипт для заполнения виджетов данными: [http://www.calmar.ws/dotfiles/dotfiledir/awesome-status.lua]
| Notes = Обычно awesome-status от [http://udvzsolt.extra.hu/news.php Uzsolt] используется с конфигурационным файлом [http://www.calmar.ws/dotfiles/dotfiledir/dot_awesome-status.rc awesome-status.rc], но он несовместим с последней версией Awesome.
}}


{{Config/ru
| Name = Rhaamo
| Image = [[Image:desktop-rhaamo.png|200px]]
| Features = Используется скрипт для отображения потребления текущим клиентом памяти и процессора. Не используется 'wicked', только 'beautiful' и библиотека 'mpd'.
| Screenshot = [https://tux-atome.fr/~marc/screenshots/08-11-12-224510-mercuryrays_messenger_awesome.png]
| Version = —
| Config = [http://tux-atome.fr/?p=rhaamo_config-files.git;a=tree;f=configs/awesome3/dot_config/awesome;hb=HEAD]
| Theme = [[rhaamo_theme|rhaamo]]
| Files = —
| Notes = —
}}


{{Config/ru
| Name = Kooky
| Image = [[Image:Screenshot-kooky.png|200px]]
| Features = Виджет заряда аккумулятора, использующий hal, календарь, обрабатывающий diary-файл emacs, автозавершение для Wikipedia
| Screenshot = ci-contre
| Version = —
| Config = [http://www.markurashi.de/dotfiles/awesome/]
| Theme = [[Zenburn Theme|zenburn]] от anrxc
| Files = —
| Notes = —
}}


{{Config/ru
| Name = dunz0r
| Image = [[Image:Dunz0r-2.png|200px]]
| Features = mpd-библиотека kawourous, собственный виджет mpd, отображающий список воспроизведения, средняя загрузка и температура процессора, сочетания клавиш для mpd, индикатор заряда аккумулятора, возможность перемещать целый тег на следующий экран, два wibox'а: один с информацией, другой со списком задач/методов компоновки окон, динамическое присваивание тегов с использованием shifty
| Screenshot = [http://omploader.org/vMXYwNQ]
| Version = 3.3
| Config = [http://github.com/dunz0r/awesome-configs/tree]
| Theme = blatently stole koniu's
| Files = rc.lua, theme.lua
| Notes = -
}}

{{Config/ru
| Name = ctaf
| Image = [[File:ctaf-screenshot.png|200px]]
| Features = скратчпад (scratchpad), вкладки (tabs) в заголовках окон, окна приложений с тегом im являются плавающими и располагаются поверх остальных, безопасный запуск (при ошибках в rc.lua используется стандартный) ...
| Screenshot = [http://www.ctaf.free.fr/awesome/awesome-3-4-tab.png]
| Version = awesome 3.4-git
| Config = [http://gitorious.org/awesome-config/]
| Theme = zenburn
| Files = —
| Notes = —
}}

{{Config/ru
| Name = anrxc
| Image = [[Image:Screenshot-anrxc.png|200px]]
| Features = Множество пользовательских сочетаний клавиш (управление всем с клавиатуры). Большое количество виджетов: CPU, аккумулятор, память, файловые системы, сеть, беспроводные сети, E-mail, OrgMode, громкость, дата и календарь. Множество пользовательских приглашений (prompts): словарь, калькулятор, SSH, man-страницы, Web-поиск... и многое другое.
| Screenshot = [http://sysphere.org/gallery/snapshots]
| Version = 3.4-git
| Config = [http://git.sysphere.org/awesome-configs/]
| Theme = [[Zenburn Theme|Zenburn]]
| Files = Read the FAQ in my rc.lua
| Notes = —
}}

{{Config/ru
| Name = Oxmoz
| Image = 
| Features = Стандартная конфигурация, меню для динамического изменения тем, добавлены виджеты.
| Screenshot = [http://www.oxmoz.eu/awesome/awesome.png]
| Version = —
| Config = [http://www.oxmoz.eu/awesome/rc.lua]
| Theme = —
| Files = —
| Notes = —
}}


{{Config/ru
| Name = Wolgri
| Image = 
| Features = Отдельные изменения в стандартной конфигурации для удобства и простоты использования.
| Screenshot = [http://img145.imageshack.us/img145/3271/200902211353471280x800s.png]
| Version = 3.2
| Config = [http://github.com/wolgri/wolgri.config/tree/master/.config/awesome/]
| Theme = —
| Files = —
| Notes = —
}}


{{Config/ru
| Name = kAworu
| Image = 
| Features = beautiful / naughty / библиотека mpd / lua FreeBSD sysctl / invaders (разумеется)
| Screenshot = [http://files.kaworu.ch/awesome-scrot.png]
| Version = 3.0, 3.1.2, 3.2
| Config = [http://hg.kaworu.ch/config-awesome]
| Theme = —
| Files = —
| Notes = —
}}


{{Config/ru
| Name = yogan
| Image = 
| Features = прозрачность окон зависит от наличия фокуса (требуется xcompmgr или что-то подобное), режим отладки (всплывающие уведомления naughty для новых и существующих клиентов), таблица параметров для приложений, задающая: экран/тег, является ли окно плавающим/располагается поверх всех окон, является ли оно главным (master), развёрнутым или полноэкранным, имеет ли заголовок, ...
| Screenshot = [http://yogan.meinungsverstaerker.de/awesome/shot_2009-02-05.png]
| Version = 3.1-235-ga13f3fe (2009-02-03)
| Config = [http://yogan.meinungsverstaerker.de/awesome/rc.lua]
| Theme = [http://yogan.meinungsverstaerker.de/awesome/theme]
| Files = —
| Notes = кое-что скопировано из других конфигурационных файлов (виджеты mpd, настройка громкости, сеть, процессор, загрузка, ...)
}}

{{Config/ru
| Name = geekounet
| Image = 
| Features = beautiful / naughty / kAworu's MPD lib и Lua FreeBSD sysctl / собственные функции для виджетов / отсутствуют изображения
| Screenshot = [http://foo.poildetroll.net/screenshots/awesome-090406-013616.png]
| Version = 3.3
| Config = [https://hg.poildetroll.net/hg/config/awesome/]
| Theme = —
| Files = —
| Notes = —
}}

{{Config/ru
| Name = koniu
| Image = 
| Features = [[Shifty]] с дополнительными настройками (смотрите gittags [http://silenceisdefeat.com/~koniu/awesome/video/gittags.avi видео]), встроенная документация (awful.doc) [http://silenceisdefeat.com/~koniu/awesome/shots/2009-04-19-042807_1024x768_scrot.png скриншот], скроллинг для клиентов, не помещающихся на экранe [http://silenceisdefeat.com/~koniu/awesome/video/awsumscrolling.avi видео], собственные виджеты: wifi, точки монтирования, температура процессора, скорость кулера, apt, аккумулятор, календарь, собственные приглашения: калькулятор, словарь, kill, просмотр логов с использованием naughty
| Screenshot = [http://silenceisdefeat.com/~koniu/awesome/shots/]
| Version = git ''master''
| Config = [http://github.com/koniu/awesome-configs/]
| Theme = —
| Files = —
| Notes = —
}}

[[Category:awesome3]]</text>
      <sha1>etmjtte4zg2xiajx7bnzzaruw798cyq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>User Contributed Themes</title>
    <ns>0</ns>
    <id>61</id>
    <revision>
      <id>3135</id>
      <parentid>1301</parentid>
      <timestamp>2009-06-26T12:26:32Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <text xml:space="preserve" bytes="1185">{{Languages}}

Here is a list of user-contributed themes for awesome 2.3. Click the image to view a larger version of the image, or the link below the image to read the details of the config.


== 2.3 Themes: ==


[[Image:Awesome_2.3_default.png|thumb|none|Awesome 2.3 default theme]]
* [[Default 2.3 Theme]] - The default awesome 2.3 theme.

[[Image:Mortini_green_screenshot.png|thumb|none|Mortini Simple Laptop Theme Screenshot]]
* [[Mortini Simple Laptop Theme]] - A simple laptop theme with the two widgets from awesomerc.5.txt.

[[Image:gigamo_current_ss.png|thumb|none|Gigamo's Theme]]
* [[Gigamos Theme]] - Gigamo's theme with a number of widgets and using Amazing to populate them.

[[Image:twoism_theme_busy.png|thumb|none|Twoism busy theme]][[Image:twoism_theme_clean.png|thumb|none|Twoism clean theme]]
* [[Twoism theme]] - Simple theme with a few widgets.


== awesome-3 branch Themes: ==


[[Image:calmar.png|thumb|none|calmar theme]]
* [[calmar theme|Calmar theme]]

[[Image:desktop-rhaamo.png|thumb|none|rhaamo_theme]]
* [[rhaamo_theme|Rhaamo theme]]
[[Category:Themes]]


== awesome-3 beautiful themes ==

[[Beautiful themes]]
[[Category:awesome3]][[Category:awesome2]]</text>
      <sha1>18hnrz0vq67v3eycm5f15x9y0jap7uj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>User Contributed Themes/fr</title>
    <ns>0</ns>
    <id>420</id>
    <redirect title="Beautiful themes/fr" />
    <revision>
      <id>3134</id>
      <timestamp>2009-06-26T12:26:15Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>Redirected page to [[Beautiful themes/fr]]</comment>
      <text xml:space="preserve" bytes="32">#REDIRECT[[Beautiful themes/fr]]</text>
      <sha1>5cvdo3yajz9pu2wvja54jbh602oujs4</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>User Contributed Widgets</title>
    <ns>0</ns>
    <id>44</id>
    <revision>
      <id>7393</id>
      <parentid>7371</parentid>
      <timestamp>2015-11-19T19:10:38Z</timestamp>
      <contributor>
        <username>Cmotc</username>
        <id>4311</id>
      </contributor>
      <text xml:space="preserve" bytes="4235">{{Languages}}

Below are some user-contributed widgets. Some of these might be for development versions of awesome and others might be outdated.

== Awesome 3 ==

{| width=&quot;100%&quot;
|- valign=&quot;top&quot;
|
;Sound and multimedia:
* Media Player Status/Control
** [[MPD Widgets|MPD widgets]] - here you can find all existing MPD widgets for awesome
** [[Banshee Widgets|Banshee widgets]]
** [[bioe007 moc widget (scrolling text)]]
** [[uzsolt moc widget]]
* Volume Status/Control
** [[Farhavens volume widget]]
** [[Ghost1227 volume widget for oss]]
** [[Rman's Simple Volume Widget]] (ALSA)
** [[Volume Widget icon]] (ALSA)
** [[Davids volume widget]] (PulseAudio, but easy to modify)
** [http://io.kodfabrik.com/2010/05/11/volume-widget-for-awesomewm.html azer's volume widget]
|
;System and power management:
* Battery Monitoring
** [[kAworu FreeBSD ACPI Widget]]
** [[Gizmoguy's super-easy acpi battery widget]]
** [[Battery Widget using powersave]]
** [[Another battery widget]] (wicked)
** [[Gigamo Battery Widget]]
** [[Closured Battery Widget]]
** [[acpitools-based battery widget]]
** [https://github.com/NuckChorris/assault/ Assault, a super-customizable battery widget]
** [[Klaus_Dieter volume widget FreeBSD]]
* System Monitoring
** [[Active_RAM | IceBrain Ram Usage widget]]
** [[Analog Gages | Rd's Analog Gages widget]]
** [[CPU Usage | Rd's CPU Usage widget]]
** [[Absurd-Mind Diskusage Widget]]
** [[Nvidia-settings Widget]]
* Keyboard Management
** [[Change keyboard maps]]
** [[Keyboard layouts with kbdd]]
** [[Persian keyboard layout]]
|- valign=&quot;top&quot;
|
;Network and Internet:
* Network Status Indicators
** [[Gigamo Wifi Widget]] - Wifi link status quality monitor using /sys/class/net.
** [[Net widgets|Net widgets]] - WiFi widget and network interfaces indicator
** [[Networkmanager/Wifi Widget]] - Drop-down NetworkManager interface.
** [https://gist.github.com/thatarchguy/c7ca4f89b324ac0d0e22#file-vpnwidget-lua, i3-like VPN status].
* Mail Notifications
** [[asmer imap mail widget|EMail notification: uses python to watch IMAP]].
** [[Email notification with mutt integration|Email notification: watches Maildir and provides a menu with mutt integration]].
** [[EMail notification widget|EMail notification: watches IMAP and notifies when inbox message arrives]].
** [[Maic imap checker|E-mail notification widget for multiple IMAP accounts]].
** [[Email maildir naughty hoover|Maildir summary mouseover]].
** [[Check for new mail in a maildir folder]].
** [[Check for new mail in a mbox]].
** [[Notmuch mail integration]].
* Feed Readers
** [http://github.com/olcc/aware aware, a RSS reader for awesome].
** [[google reader widget]].
** [[bzed's awesome newsticker]].
** [[uzsolt newsreader (newsbeuter, liferea) information]].
** [[calendar widget]].
|
;Other:
* [[Familiar Alt Tab]] 
* [[Farhavens fish widget]]
* [[uzsolt TaskCoach information]]
* [[Anrxcs Widget Set]]
* [[Anrxcs OrgMode Widget]]
* [http://dleone.fensalir.fr/index.php?tag/org-awesome An org-mode widget]
* [[Orglendar_widget | Orglendar]]  - calendar with org-mode schedule list
* [[Thunderbird Task Widget]]
* [[Alternative Menu]]
* [[Volume control and display]]
* [[Quick launch bar widget]]
* [[Delightful]] widget set
* [[Weather]] widgets
* [[Binary Clock widget]]
* [https://github.com/francois2metz/pomodoro-awesome Pomodoro widget]
* [[Another pomodoro widget]]
* [[Bitcoin Price Widget]]
* [[Blingbling]]  - set of widgets graph, text box, popups, clock, system menus ...
* [https://github.com/artyom-poptsov/awesome_space Awesome Space Widget] -- A widget that shows the current state of a chosen [http://hackerspaces.org/ hackerspace].
|}

== Awesome 2 ==

* [[Music Player Daemon (MPD)]]
* [[News reader in Status Bar]]
* [[Volume in Status Bar]]
* [[Volume in Status Bar (simpler way)]]
* [[Weather]]
* [[Making a Status Bar (Lua script)]]
* [[Making a Status Bar III]]
* [[Making a Status Bar IV]]
* [[Making a Status Bar V | Making a Status Bar V (aka Working Conky!!)]]
* [[Status Bar with Amazing]]
* [[Gmail Widget]]
* [[Gmail Widget-2]]
* [[Xmms2 Widgets]]
* [[OpenBSD Volume Control Widget]]
* [[Woffles Rhythmbox Widget]]
* [[Woffles Uptime Widget]]
* [[Woffles Volume Widget]]

[[Category:awesome3]][[Category:awesome2]]</text>
      <sha1>6v1vkdl3g29p6vkren6qdpsvkljjksf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>User Contributed Widgets/fr</title>
    <ns>0</ns>
    <id>415</id>
    <revision>
      <id>5585</id>
      <parentid>5584</parentid>
      <timestamp>2012-09-02T12:55:37Z</timestamp>
      <contributor>
        <username>Roultabie</username>
        <id>1069</id>
      </contributor>
      <text xml:space="preserve" bytes="3857">{{DISPLAYTITLE:Widgets proposés par les utilisateurs}}
{{Languages|User_Contributed_Widgets}}

Vous trouverez ci-dessous des widgets proposés par les utilisateurs. Certains d’entre eux peuvent être prévus pour des versions de développement d’awesome.

== Awesome 3 ==
{| width=&quot;100%&quot; style=&quot;background:#eee;&quot; cellpadding=&quot;3&quot; cellspacing=&quot;0&quot;
|- align=&quot;left&quot; valign=&quot;top&quot;
| style=&quot;border:3px solid #fff;&quot;|
;Widgets d’utilisation mémoire, cpu, etc. :
* [[kAworu FreeBSD ACPI Widget|widget utilisant l’ACPI sous FreeBSD]]
* [[Analog Gages|compteurs analogiques d’utilisation système]]
* [[CPU Usage|utilisation du CPU utilisant '''/proc/stat''']]
* [[Active_RAM|utilisation mémoire utilisant '''/proc/meminfo''']]
* [[Gigamo Wifi Widget|puissance d’un réseau Wi-Fi]]
| style=&quot;border:3px solid #fff;&quot;|
;Widgets de « musique en cours »
* [[kAworu MPD Widget|informations de MPD]]
* [[Antel MPD-Ruby|idem avec Ruby]]
* [[uzsolt moc widget|gestion de ''moc'']]
* [[bioe007 moc widget (scrolling text)|idem avec texte défilant]]
|- align=&quot;left&quot; valign=&quot;top&quot;
| style=&quot;border:3px solid #fff;&quot;|
;Widgets de batterie :
* [[Battery Widget using powersave|widget utilisant powersave]]
* [[Gigamo Battery Widget|widget utilisant '''/sys/class/power_supply''']]
* [[Another battery widget|widget similaire à Ion3]]
| style=&quot;border:3px solid #fff;&quot;|
;Widgets d’« informations » :
* [[Check for new mail in a maildir folder|vérifier des nouveaux mails dans un dossier]]
* [[asmer imap mail widget|nombre de mails dans la boîte de réception]]
* [[bzed's awesome newsticker|lecteur de flux RSS]]
* [[uzsolt newsreader (newsbeuter, liferea) information|lecteur de news Newsbeuter ou Liferea]]
|- align=&quot;left&quot; valign=&quot;top&quot;
| style=&quot;border:3px solid #fff;&quot;|
;Widgets de volume :
* [[Farhavens volume widget|volume Alsa]]
* [[Ghost1227 volume widget for oss|volume OSS]]
* [[Klaus_Dieter volume widget FreeBSD|volume pour FreeBSD]]
* [[Roultabie volume widget for PulseAudio|volume pour PulseAudio]]
| style=&quot;border:3px solid #fff;&quot;|
;Widgets « org-mode » d’emacs :
* [http://dleone.fensalir.fr/index.php?tag/org-awesome widget originel]
* [[Anrxcs OrgMode Widget|widget d’Anrxcs modifiant le précédent]]
|- align=&quot;left&quot; valign=&quot;top&quot;
| style=&quot;border:3px solid #fff;&quot;|
;Widgets « vie de tous les jours »
* [[Change keyboard maps|changer la disposition de clavier]]
* [[calendar widget|calendrier à ajouter à l’emplacement « date et heure »]]
| style=&quot;border:3px solid #fff;&quot;|
;Widgets divers
* [[Anrxcs Widget Set|liste des widgets d’Anrxcs]]
* [[Farhavens fish widget|poisson affichant des messages de « fortune »]]
* [[uzsolt TaskCoach information|récupération des informations de TaskCoach]]
|}

== Awesome 2 ==
Les widgets décrits ci-dessous ont été conçus pour la version 2 d’awesome. Nombreux sont ceux qui peuvent être réalisés plus simplement avec la version actuelle d’awesome, mais vous pouvez toujours vous reporter à ces widgets plus anciens pour des idées ou des astuces pour coder les vôtres.

{| width=&quot;100%&quot;
|- align=&quot;left&quot; valign=&quot;top&quot; cellpadding=&quot;3&quot;
|
;Barre de statut :
* [[Making a Status Bar (Lua script)]]
* [[Making a Status Bar III]]
* [[Making a Status Bar IV]]
* [[Making a Status Bar V | Making a Status Bar V (aka Working Conky!!)]]
* [[Status Bar with Amazing]]
|
;Widgets de volume :
* [[Volume in Status Bar]]
* [[Volume in Status Bar (simpler way)]]
* [[Woffles Volume Widget]]
* [[OpenBSD Volume Control Widget]]
|- align=&quot;left&quot; valign=&quot;top&quot;
|
;Widgets de « lecture en cours » :
* [[Woffles Rhythmbox Widget]]
* [[Xmms2 Widgets]]
* [[Music Player Daemon (MPD)]]
|
;Widgets d’« informations »
* [[Gmail Widget]]
* [[Gmail Widget-2]]
* [[News reader in Status Bar]]
* [[Weather]]
|}
;Widgets divers
*[[Woffles Uptime Widget]]


[[Category:awesome2]]
[[Category:awesome3]]</text>
      <sha1>1crdstg15blm77e9hnmgstu9oqfe0zd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using Cairo within Awesome</title>
    <ns>0</ns>
    <id>186</id>
    <revision>
      <id>6103</id>
      <parentid>5082</parentid>
      <timestamp>2013-09-20T20:27:16Z</timestamp>
      <contributor>
        <username>Cedlemo</username>
        <id>719</id>
      </contributor>
      <comment>/* Blingbling :a module of graphical widgets based on oocairo */</comment>
      <text xml:space="preserve" bytes="3412">== Note ==

The following is only needed for Awesome 3.2.1 and earlier. The upcoming 3.3 release will contain functions to draw on images without the need of external modules. The functions are called

  img:draw_pixel(x, y, color)
  img:draw_line(x1, y1, x2, y2, color)
  img:draw_rectangle(x, y, width, height, fill, color)
  img:draw_circle(x, y, width, height, fill, color)

x{1, 2}?, y{1, 2}?, width and height are integer values, fill is a boolean value indicating whether the drawn object should be filled and color is the color to draw and is either 3 (RGB) or 4 (RGBA) bytes long (i.e. &quot;#FF0020&quot; and &quot;#FF0020BB&quot; are valid colors).
Images can be initialized like this:
  local img = image(nil, width, height)
which returns an empty image with width and height set to the respective values.

== Introduction ==

This guide will explain how to use Awesome3's support for Cairo to create widgets.
First, you need a recent version of Awesome3, or the latest one from git. Obtain it via
 git clone git://git.naquadah.org/awesome
then compile and install it.

After installing the latest version of Awesome3, you need to get oocairo, which is a library 
containing Lua bindings to Cairo. Grab it from
 http://luaforge.net/frs/download.php/3884/lua-oocairo-1.2.tar.gz

Before compiling, you may need to edit the Makefile ([http://aur.archlinux.org/packages/lua-oocairo/lua-oocairo/Makefile.diff Other patches from arch linux AUR])

 LIBTOOL := libtool --quiet

to 

 LIBTOOL := libtool --quiet --tag CC

== Integrating oocairo with Awesome3 ==
    
Integrating oocairo with Awesome3 is pretty straightforward. Just include 
'''oocairo''' into your widget module rc.lua like this:

  Cairo = require &quot;oocairo&quot;

For your widget, you first need to create an imagebox to hold your widgets 
image. Then use oocairo to create an image surface which has its color-mode
set to &quot;argb32&quot; like this:

  cs = Cairo.image_surface_create(&quot;argb32&quot;, w, h)

Then you need a graphics context, which can be created from the image surface 
as follows:

  cr = Cairo.context_create(cs)

Now draw onto that surface as you please. The drawing functions for oocairo are
the same as for using Cairo with C/C++, except their first parameter, the 
graphics context, gets discarded and the functions are called as methods of the
context like this:

  cr:new_path()
  cr:move_to(10, 10)
  cr:line_to(40, 40)
  cr:set_source_rgb(0, 0, 0)
  cr:set_line_width(3)
  cr:stroke()

The above code will draw a 3 pixel wide line from (10, 10) to (40, 40) on the 
drawing context cr.

When you are done drawing, it's time to transfer the content of your image 
surface to the imagebox. This works by calling the function 
image.argb32(w, h, sd), which returns a valid image for imageboxes. The code 
looks similar to this:

  ib.image = image.argb32(w, h, cs:get_data())

That is basically all.

Please note that for widgets which update regularly, it is most of the time 
easier and faster to not create a new drawing context for each redrawing step 
but to clear the context with the following code which will reset the color of 
a w x h pixel drawing context to white:

  cr:new_sub_path()
  cr:move_to(0, 0)
  cr:line_to(w, 0)
  cr:line_to(w, h)
  cr:line_to(0, h)
  cr:close_path()
  cr:set_source_rgb(1, 1, 1)
  cr:fill()

==[[Blingbling#Blingbling_v1.0|Blingbling v1.0]] :a module of graphical widgets based on oocairo==

[[Category:awesome3]]</text>
      <sha1>s162uqreaarga6h5eurykyqciqgkyyf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using DBus/ru</title>
    <ns>0</ns>
    <id>1188</id>
    <revision>
      <id>7088</id>
      <parentid>6998</parentid>
      <timestamp>2014-10-27T19:44:35Z</timestamp>
      <contributor>
        <username>Medar</username>
        <id>3000</id>
      </contributor>
      <comment>/* Что такое DBus */</comment>
      <text xml:space="preserve" bytes="25902">{{Languages}}
{{DISPLAYTITLE:Использование D-Bus}}

Я думаю ни для кого не будет секретом, что у Awesome есть &quot;узкое место&quot;, если мы запускаем внешний скрипт, который например должен считать данные из файла, или интернета и вернуть результат в виджет или саму систему, то мы периодически можем наблюдать явление &quot;фриза&quot;, т.е. когда система перестает реагировать на нажатия клавиш и мыши до получения результата обработки (правда активный клиент при этом продолжает работать). Чаще всего это происходит при использовании ''io.popen'' или ''awful.util.pread''

У меня такая ситуация случалась не однократно, например, при прослушивании музыки в moc/mocp при смене трека у меня вызывается внешний скрипт который получает данные о треке и загружает обложку альбома, если она есть и отображает их. Но периодически (т.к. скрипт тестировался на ноутбуке) система &quot;зависала&quot;. Долго не мог понять почему же это происходит, а затем выяснил, что если в этот момент диск сильно нагружен чем нибудь, то данные на чтение ставятся в очередь и в результате, т.к. вывод результата зависит от ответа, система &quot;подвисала&quot;. Проблему удалось частично решить через &quot;костыли&quot; в виде вешнего скрипта, который через ''echo $result | awesome-client -'' пересылал данные. 

Или другой вариант, есть виджеты отображающие свободное место на диске (например раздела /), работающие чаще всего через ''df -h'', но если у нас есть на диске раздел ntfs, то периодически он может &quot;отваливаться&quot;, и в этот момент система перестает реагировать. Одним из решений является сохранение вывода команды в файл, а затем его чтение оттуда. Но опять же это тот еще &quot;костыль&quot;. Согласитесь, очень неприятно, когда для простейших действий приходится изобретать костыли. 

А тем временем, в Awesome, существует такая замечательная вещь как DBus, которая позволяет осуществлять взаимодействие различных компонентов системы и приложений. 

==Что такое DBus==
[https://www.linux.org.ru/wiki/en/D-Bus D-Bus] — это система межпроцессного взаимодействия, которая предоставляет приложениям несколько шин для передачи сообщений. Она обеспечивает беспроблемную связь десктопных приложений между собой и связь между десктопными приложениями и системными сервисами. Поддерживается не только широковещательная рассылка сообщений (сигналов), но и удалённый вызов методов.

Т.е. возможно из Awesome или вашего виджета послать запрос на обработку каких либо данных, а получить результат обработки через шину DBus, и наконец вызвать функцию обработчик этого события. И при этом никаких &quot;зависаний&quot;, ведь мы не заставляем Awesome ожидать результат.

Для работы с Dbus можно использовать стандартные утилиты 'dbus-send' - для отправки сигналов в приложения из скриптов или оболочки, и 'dbus-monitor' - которая позволяет отслеживать все сигналы посылаемые между приложениями и/или системой. Если же вы хотите получить более полные данные о том какие приложения зарегистрированы в dbus, какие методы они могут вам предоставить, можно воспользоваться сторонней утилитой из комплекта KDE 'qdbus' - это консольная утилита имеющая минимальные зависимости и занимающая чуть менее 1Мб.

Если вы запустите dbus-monitor, то будете отслеживать все сигналы пересылаемые приложениями и системой. Но если вас интересует какой либо конкретный сигнал, то можно отфильтровать вывод:
&lt;pre&gt;
dbus-monitor &quot;interface='ru.gentoo.kbdd' &quot;
&lt;/pre&gt;
В данном случае мы будем получать сигналы о смене раскладки клавиатуры посылаемые kbdd. За более подробными сведениями обращайтесь [https://www.linux.org.ru/wiki/en/D-Bus Dbus LOR].  В принципе dbus-monitor удобно использовать для отладки ваших скриптов. 

Но нас то интересует возможность взаимодействия наших скриптов и Awesome.

Для посылки сигнала в Awesome вы можете использовать следующий код:
&lt;pre&gt;
dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/mocp ru.console.mocp.songChanged
&lt;/pre&gt;
Разберем, что здесь и к чему. 
--session - указывает на то что используется сессионная (а не системная) шина передачи данных. Т.е. сессионная шина это пользовательская шина, к которой подключаются запущенные от имени пользователя приложения, в то время как системная шина чаще всего не имеет своего пользователя (сервисы HAL, сетевой стек, bluetooth и т.д.)
--dest=org.naquadah.awesome.awful - здесь мы указываем кто будет являться получателем нашего сигнала, в данном случае это Awesome
/ru/console/mocp - уникальное имя объекта (обычно имя сервиса, путь к объекту и интерфейс), в нашем случае создаем его сами.
ru.console.mocp.songChanged - используемый метод, по сути вызываемая функция которая и порождает сигнал, в случае если используется прилоежние.

Также аналогично можно использовать и посылку сигналов из Awesome различным приложениям, например, чтобы переключить трек в различных плеерах, поменять статус в Pidgin и т.д. При этом преимуществом данного способа будет то, что не требуется запускать копию терминала, и передавать ему команду для обработки, что пусть и не сильно, но нагружает ресурсы системы, на создание терминала, обработку команды в нем, а потом и уничтожение этого терминала.  Об этом способе и примерах поговорим чуть позже. 

Как видите все достаточно просто. Но ведь этого недостаточно. Одно дело послать сообщение, что отработала такая то функция, а другое передать еще и результат в сигнале. Такая возможность есть, вы можете через Dbus сигналы передавать данные для ваших виджетов или функций.
Например тот же kbdd передает помимо самого сигнала еще и выбранную раскладку ( в виде числа, а в другой функции и ее название, поэкспериментируйте). Если же вы используете другой менеджер раскладки, то и там та же ситуация. Наиболее тяжелый сигнал в KDE, там передается очень много информации, в том числе и двоичной. 

Поддерживаемые типы данных: string, byte, boolean, int16, uint16, int32, uint32, int64, uint64, dooble, object_path

==Практическая реализация==
===Работа с файловой системой===
Все изменения мы будем вносить только в rc.lua. 

Сначала создадим виджет который будет отображать информацию:
&lt;pre&gt;
--Awesome 3.4
fs_root = widget({type = &quot;textbox&quot;})
fs_root.text = &quot;Занято:&quot;
--Awesome 3.5
fs_root = wibox.widget.textbox()
fs_root:set_text(&quot;Занято:&quot;)
&lt;/pre&gt;

Затем создадим таймер, который будет запрашивать данные:
&lt;pre&gt;
fs_timer = timer ({timeout = 600}) --раз в 10 минут
fs_timer:add_singal (&quot;timeout&quot;, function () awful.util.spawn_with_shell(&quot;dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/df ru.console.df.fsValue string:$(df -h --output='pcent' /home | sed '1d;s/ //g' )&quot; ) end )
fs_timer:start()
&lt;/pre&gt;
если вы испльзуете Awesome 3.5, то просто замените add_singal на connect_signal

И обновляем значение, при получении сигнала:
&lt;pre&gt;
dbus.request_name(&quot;session&quot;, &quot;ru.console.df&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='ru.console.df', member='fsValue' &quot; )
dbus.add_singal(&quot;ru.console.df&quot;, function (...)
      local data = {...}
      local dbustext = data[2]
      fs_root.text = &quot;Занято: &quot; .. dbustext     --для 3.5 fs_root:set_text(&quot;Занято:&quot; .. dbustext)
   end )
&lt;/pre&gt;
Все, перезапускаем Awesome!

Преимуществом данного способа будет то, что Awesome  не будет ждать (и соответственно висеть) пока обрабатывается вызванный код.

В случае если вы вызываете одну и ту же команду с разными параметрами, можно вернуть вторым значением этот параметр, и соответсвенно в самом Awesome его проверить и вызывать нужный обработчик. На нашем примере чуть чуть модифицируем функцию таймера:
&lt;pre&gt;
path = '/home'
fs_timer:add_singal (&quot;timeout&quot;, function () awful.util.spawn_with_shell(&quot;dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/df ru.console.df.fsValue string:$(df -h --output='pcent' &quot; ..path.. &quot; | sed '1d;s/ //g' )&quot; string:&quot;..path) end )

dbus.request_name(&quot;session&quot;, &quot;ru.console.df&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='ru.console.df', member='fsValue' &quot; )
dbus.add_singal(&quot;ru.console.df&quot;, function (...)
      local data = {...}
      local dbustext = data[2]
      local dbuspath = data[3] 
      if dbustext == '/' then
        fs_root.text = &quot;Занято: &quot; .. dbustext          --для 3.5 fs_root:set_text(&quot;Занято:&quot; .. dbustext)
      elseif dbustext == '/home' then
        fs_home.text = &quot;Занято: &quot; .. dbustext        --для 3.5 fs_home:set_text(&quot;Занято:&quot; .. dbustext) 
      end
   end )
&lt;/pre&gt;

===Взаимодействие с mocp===
К сожалению сам mocp не поддерживает dbus, но он может вызывать внешнюю команду при смене трека (и не только, за подробоностями к документации).

В конфиге для mocp я добавил свой обработчик:
&lt;pre&gt;
OnSongChange = &quot;/home/user/script/changesong.sh %f %a %t %d %r %n&quot;
&lt;pre&gt;
Здесь мы передаем все необходимые значения: путь к файлу, исполнитель, название, время, альбом, для того, чтобы потом не дергать mocp еще раз, чтобы получить эти данные, как указано в изначальных версиях [https://awesome.naquadah.org/wiki/Coverart_display/ru этих скриптов].

Затем, создаем скрипт (changesong.sh) для получения обложки и формирования текста:
&lt;pre&gt;
#!/bin/bash
# changesong.sh

#файл с обложкой по умолчанию
DEFAULT_COVER=&quot;/home/user/Images/no-cover.jpg&quot;

[ -n &quot;$1&quot; ] &amp;&amp; FULLDIR=`dirname &quot;$1&quot;`

[ -n &quot;$FULLDIR&quot; ] &amp;&amp; COVERS=`ls &quot;$FULLDIR&quot; | grep &quot;\.jpg\|\.png\|\.gif&quot;`

if [ -z &quot;$COVERS&quot; ]; then
	COVERS=&quot;$DEFAULT_COVER&quot;
else
	TRYCOVERS=`echo &quot;$COVERS&quot; | grep -i &quot;cover\|front\|folder\|albumart&quot; | head -n 1`

	if [ -z &quot;$TRYCOVERS&quot; ]; then
		TRYCOVERS=`echo &quot;$COVERS&quot; | head -n 1`
		if [ -z &quot;$TRYCOVERS&quot; ]; then
			TRYCOVERS=&quot;$DEFAULT_COVER&quot;
		else
			TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
		fi
	else
		TRYCOVERS=&quot;$FULLDIR/$TRYCOVERS&quot;
	fi

	COVERS=&quot;$TRYCOVERS&quot;
fi

MTITLE= &quot;

	Исполнитель:	$2
	Название:	$3
	Альбом: 	$5
	Трек:	$6
	Время:  	$4&quot;

dbus-send --session --dest=org.naquadah.awesome.awful /ru/console/mocp ru.console.mocp.songChanged \
		  string:&quot;$MTITLE&quot; \
		  string:&quot;$COVERS&quot;
#обязательно помещаем переменную в кавычки, т.к. иначе некорректно передается строка (особенность bash)
&lt;/pre&gt;
Даем скрипту права на исполнение:
&lt;pre&gt;
chmod +x changesong.sh
&lt;/pre&gt;
Добавляем обработчик в Awesome:
&lt;pre&gt;
dbus.request_name(&quot;session&quot;, &quot;ru.console.mocp&quot;
dbus.add_match(&quot;session&quot;, &quot;interface='ru.console.mocp', member='songChanged' &quot;)
dbus.add_signal(&quot;ru.console.mocp&quot;, function(...)
    local data = {...}
    coverart_nf = naughty.notify({icon = data[3], icon_size = 100, text = data[2], position = &quot;bottom_left&quot;})
    end )
&lt;/pre&gt;
Хотя результат и будет тем же самым, что и в изначальном варианте, но разница будет в том, что система не зависнет если жесткий диск будет занят, плюс мы используем один скрипт вместо 2х в первоначальной версии. Также в скрипте мы не производим проверку на состояние mocp (переключение состояния пауза/воспроизведения) и запущенно ли вообще приложение, если вам это необходимо, добавьте соотвествующий код.

==Посылка сигнала из Awesome==
Стандартный Awesome к сожалению не имеет функции для отправки сигналов dbus, по крайней мере на wiki нет ни слова об этой возможности. Поэтому приходится использовать отправку сигналов через shell, например это можно сделать следующим образом (на примере переключателя клавиатуры kbdd):
&lt;pre&gt;
--виджет клавиатуры
kbdwidget = widget({type = &quot;textbox&quot;, name = &quot;kbdwidget&quot;})
kbdwidget.border_color = beautiful.fg_normal
kbdwidget.border_width = 1
kbdwidget.text = '&lt;span color=&quot;#F8EC5D&quot;&gt;&lt;b&gt; Eng &lt;/b&gt;&lt;/span&gt;'
next_layout=1
function changeKeyboardLayout(keyboard_layout)
    awful.util.spawn( &quot;dbus-send --type=method_call --session --dest=ru.gentoo.KbddService /ru/gentoo/KbddService ru.gentoo.kbdd.set_layout uint32:&quot;.. keyboard_layout )
end
dbus.request_name(&quot;session&quot;, &quot;ru.gentoo.kbdd&quot;) 
dbus.add_match(&quot;session&quot;, &quot;interface='ru.gentoo.kbdd',member='layoutChanged'&quot;) 
dbus.add_signal(&quot;ru.gentoo.kbdd&quot;, function(...) 
        local data = {...} 
        local layout = data[2] 
        lts = {[0] = '&lt;span color=&quot;#F8EC5D&quot;&gt;&lt;b&gt; Eng &lt;/b&gt;&lt;/span&gt;', [1] = '&lt;span color=&quot;#FF3000&quot;&gt;&lt;b&gt; Рус &lt;/b&gt;&lt;/span&gt;'} 
         kbdwidget.text = &quot; &quot;..lts[layout]..&quot; &quot; 
         if layout == 1
             then next_layout = 0
         else
             next_layout = 1
        end 
    end
                ) 
kbdwidget:buttons(awful.util.table.join(awful.button({}, 1, function ()
                changeKeyboardLayout(next_layout)
        end)))
&lt;/pre&gt;
Здесь мы через нажатие на виджет левой кнопкой мыши меняем раскладку клавиатуры, посылая сообщение об этом через dbus. Также необходимо добавить в автозагрузку сам kbdd, иначе ничего не будет работать.

Также необходимо добавить в автозагрузку сам kbdd, иначе ничего не будет работать. Кстати если у вас не работают виджеты в русской раскладке(например после изменения раскладки на русскую при нажатии на виджет не меняется раскладка на английскую) прочтите статью [https://awesome.naquadah.org/wiki/Some_problems/ru известные проблемы.]

==Поиск нужных сигналов приложений==
Большинством приложений можно напрямую управлять через dbus, т.е. можно переключать треки, переводить приложения в полноэкранный режим, менять статусы и т.д. Для получения списка всех возможных сигналов и методов запустите приложение (без этого не произойдет регистрации доступных событий), после чего запустите qdbus, найдите нужный интерфейс, например:
&lt;pre&gt;
qdbus | grep clementine
Получим следующий вывод:
 org.mpris.MediaPlayer2.clementine
 org.mpris.clementine
Затем, запустим:
qdbus org.mpris.clementine 
Получим следующиее:
/
/Player
/TrackList
/org
/org/mpris
/org/mpris/MediaPlayer2
А затем вызовем:
qdbus org.mpris.clementine /Player
&lt;/pre&gt;
И получим все возможные методы и сигналы для данного приложения. Например, нас интересует переключение на следующий трек, метод для этого выглядит следующим образом:
&lt;pre&gt;
method void org.freedesktop.MediaPlayer.Next()
&lt;/pre&gt;
В данном случае метод не требует каких либо параметров, поэтому просто вызываем его:
&lt;pre&gt;
dbus-send --type=method_call --session --dest=org.mpris.clementine /Player org.freedesktop.MediaPlayer.Next
&lt;/pre&gt;

Собственно, все. Дальше экспериментируйте и ищите сами. 

==Отслеживание сигналов из скриптов==

Если вы хотите выполнить более сложные задания, чем вызов отдельных методов, то вы можете написать скрипт командной оболочки, содержащий dbus-send команды, или используйте язык более высокого уровня, для упрощения задачи. Существуют D-Bus привязки для Python, Ruby и Java языков.

В следующем примере, будет показан скрипт на Python, который меняет статус в Pidgin на “Away from keyboard”, при активизации скринсейвера. Здесь имеются два аспекта D-Bus: скрипт ждет сигнала от скринсейвера, и затем он вызывает метод в Pidgin.  

Сразу оговорюсь, скрипт не мой, ссылка на оригинал приведена ниже, но не описать эту возможность взаимодействия я просто не мог.
[http://rus-linux.net/MyLDP/algol/Control-Your-Linux-Desktop-with-D-Bus.html pidgin_screensaver.py]
&lt;pre&gt;
#!/usr/bin/env python def pidgin_status_func(state): 
obj = bus.get_object(&quot;im.pidgin.purple.PurpleService&quot;, 
&quot;/im/pidgin/purple/PurpleObject&quot;) 
pidgin = dbus.Interface(obj, &quot;im.pidgin.purple.PurpleInterface&quot;) 
status = pidgin.PurpleSavedstatusFind(&quot;afk&quot;) 
if status == 0: 
status = pidgin.PurpleSavedstatusNew(&quot;afk&quot;, 5) 
if state: 
pidgin.PurpleSavedstatusSetMessage(status, 
&quot;Away from keyboard&quot;) 
pidgin.PurpleSavedstatusActivate(status) 

import dbus, gobject 
from dbus.mainloop.glib import DBusGMainLoop 

dbus.mainloop.glib.DBusGMainLoop(set_as_default=True) 
bus = dbus.SessionBus() 

bus.add_signal_receiver(pidgin_status_func, 
dbus_interface=&quot;org.gnome.ScreenSaver&quot;, 
signal_name=&quot;ActiveChanged&quot;) 

loop = gobject.MainLoop() 
loop.run() 
&lt;/pre&gt;
Давайте разберем этот скрипт. Функция pidgin_status_func устанавливает ваш статус в Pidgin. Она получает объект im/pidgin/purple/PurpleObject и интерфейс im.pidgin.purple.PurpleInterface из сессионной шины. Далее, вызывается метод интерфейса. Он создает новый “saved status” тип, после проверки существования типа статус с именем “afk” (“afk” означает “Away From Keyboard”, и 5 - это вид “away” статуса).

Далее функция проверяет переменную state, которая является аргументом функции pidgin_status_func (я объясню, что означает этот аргумент далее). Если аргумент правдив, то сообщению нового статуса “afk” присваивается значение “Away from keyboard”, и статус активируется. В результате Pidgin показывает ваш статус как “afk&quot;, с сообщением “Away from keyboard”.

Теперь мы должны вызвать эту функцию вместе с активизацией скринсейвера. Поэтому, запускаем dbus.mainloop и соединяемся к сессионной шине. Далее добавляем приемник сигнала, который слушает сигнал ActiveChanged от интерфейса org.gnome.ScreenSaver. Если/когда сигнал срабатывает, он вызывает функцию pidgin_status_func. Так как сигнал ActiveChanged имеет булев аргумент, обозначающий текущее состояние заставки (1 - активная, 0 - не активная), то мы используем только один аргумент (state) в функции pidgin_status_func. Для постоянного прослушивания запускаем бесконечный цикл, работающий пока работает скрипт.

Вообще, у многих приложений есть интерфейс dbus, поэтому возможности по их управлению очень обширны, и ограничены только Вашей фантазией и желанием!

==Ссылки по теме==
* [http://habrahabr.ru/post/235231/ Обсуждение темы на Habr'е]
* [http://www.opennet.ru/base/sys/dbus_intro.txt.html Введение в DBus OpenNET]
* [http://dbus.freedesktop.org/doc/dbus-tutorial.html D-Bus Tutorial]
* [https://www.linux.org.ru/wiki/en/D-Bus LOR]
* [http://rus-linux.net/MyLDP/algol/Control-Your-Linux-Desktop-with-D-Bus.html Управление Linux десктопом через D-Bus]</text>
      <sha1>d6fxzn56l9vuwzsvfegv5ohicdixn72</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using Multiple Screens</title>
    <ns>0</ns>
    <id>285</id>
    <revision>
      <id>7337</id>
      <parentid>7010</parentid>
      <timestamp>2015-07-20T13:21:53Z</timestamp>
      <contributor>
        <username>Martin-ueding</username>
        <id>3122</id>
      </contributor>
      <comment>/* XRandR */ Fix stupid.sh Link to the revision where it still exists</comment>
      <text xml:space="preserve" bytes="18427">{{Languages}}

People often ask how to configure X to use multiple monitors on [[IRC|&lt;i&gt;awesome&lt;/i&gt; IRC]] channel. So here is a brief document that covers a few different drivers and methods of achieving that on GNU/Linux.

If you are interested in how to utilize multiple monitors after you have set them up then you can take a look at [[Awesome_3.x#DEFAULT_KEY_BINDINGS|awesome 3 key bindings]] (look for ones that deal with screens, you can also do man awesome from a terminal) and if you want to control widgets (such as the system tray) for each screen then you may want to look at the [[Widgets in awesome]] page, especially the [[Widgets_in_awesome#Controlling_Widgets|controlling widgets]] section

== Basics ==
The easiest way is by using &lt;b&gt;XRandR&lt;/b&gt; (X Resize and Rotate) extension which allows dynamic control over our outputs, resolutions, orientation... and adding new displays on-the-fly without reseting the X server. But not all drivers support it yet. Ones that do are: &lt;b&gt;intel&lt;/b&gt;, &lt;b&gt;ati&lt;/b&gt; (OpenSource driver), &lt;b&gt;radeonhd&lt;/b&gt; (OpenSource driver), &lt;b&gt;nv&lt;/b&gt; (nvidia 2D driver) and &lt;b&gt;nouveau&lt;/b&gt; (OpenSource nvidia driver). I will also cover the &lt;b&gt;nvidia&lt;/b&gt; driver, as that is probably the most common driver people use, using both &lt;b&gt;TwinView&lt;/b&gt; and &lt;b&gt;Xinerama&lt;/b&gt; (which can be used with other drivers too, i.e. &lt;b&gt;fglrx&lt;/b&gt;).

Besides the fact that awesome has: &lt;i&gt;Real multihead support (XRandR, Xinerama or Zaphod mode) with per screen desktops (tags)&lt;/i&gt;; Awesome is distributed with a sample configuration file (/etc/xdg/awesome/rc.lua with v3.0 and above) which is already setup for multiple displays; regarding wiboxes, taskbars and widgets but also has keybindings which allow you to move clients between multiple screens and switch focus between them.

== XRandR ==
First I will show you a few examples of using xrandr for dynamic and on-the-fly setup and (re)configuration.

With the first command we will query our hardware: 
    $ xrandr -q

After checking the output, let's suppose that you have a laptop which panel is &lt;b&gt;LVDS&lt;/b&gt; and an external VGA port which we will regard as &lt;b&gt;VGA&lt;/b&gt;, we execute: 
    $ xrandr --output VGA --mode 1280x1024 --right-of LVDS
The above command is straightforward, your VGA monitor is initialised using 1280x1024 resolution and it's placement is Right Of your LVDS screen (let's say that LVDS is 1280x800). The important thing to remember is that you will then have one big screen whose size will then be &lt;b&gt;2560x1024&lt;/b&gt;. If the above command failed then you probably didn't take this into account when setting up your &lt;b&gt;xorg.conf&lt;/b&gt; (you need to configure your &lt;b&gt;Virtual&lt;/b&gt; size), more about this a few lines below.

It happens quite frequently that xrandr can not find the 'best' resolution for your external monitor. Let alone the correct refresh rate. When this happens, you need to create a modeline (gtf), then add it to the appropriate output. Here are a couple simple commands that would create a new 1280x800 at 68Hz refresh and attach it to the VGA output:
    $ xrandr --newmode $(gtf 1280 800 68 | grep Modeline | sed s/Modeline\ // | tr -d '&quot;')
    $ xrandr --addmode VGA 1280x800_68.00
For other uses of xrandr read the manual page. I will show just one other example, disabling your external display: 
    $ xrandr --output VGA --off
Here is a simple script that somewhat simplifies the task of picking the correct refresh rate and then setting up your screens [https://github.com/bioe007/bioe007configs/blob/d1e847fbc61edb1eb3c1f14aec2421d096517139/.bin/stupid.sh stupid.sh]
=== Cycling through possible configurations ===

It is possible to cycle through different configurations with some key (for example XF86Display). Here is a snippet of code which uses notification to display the proposed configuration. Each time the key is pressed, another configuration is proposed depending on the active outputs. Once we have proposed all possible configurations, we propose to not change anything. To accept a configuration, the user should not switch to another configuration:

* Only LVDS1
* Only VGA1
* LVDS1 + VGA1
* VGA1 + LVDS1
* No change
* Only LVDS1
* ...

&lt;pre&gt;
-- Get active outputs
local function outputs()
   local outputs = {}
   local xrandr = io.popen(&quot;xrandr -q&quot;)
   if xrandr then
      for line in xrandr:lines() do
	 output = line:match(&quot;^([%w-]+) connected &quot;)
	 if output then
	    outputs[#outputs + 1] = output
	 end
      end
      xrandr:close()
   end

   return outputs
end

local function arrange(out)
   -- We need to enumerate all the way to combinate output. We assume
   -- we want only an horizontal layout.
   local choices  = {}
   local previous = { {} }
   for i = 1, #out do
      -- Find all permutation of length `i`: we take the permutation
      -- of length `i-1` and for each of them, we create new
      -- permutations by adding each output at the end of it if it is
      -- not already present.
      local new = {}
      for _, p in pairs(previous) do
	 for _, o in pairs(out) do
	    if not awful.util.table.hasitem(p, o) then
	       new[#new + 1] = awful.util.table.join(p, {o})
	    end
	 end
      end
      choices = awful.util.table.join(choices, new)
      previous = new
   end

   return choices
end

-- Build available choices
local function menu()
   local menu = {}
   local out = outputs()
   local choices = arrange(out)

   for _, choice in pairs(choices) do
      local cmd = &quot;xrandr&quot;
      -- Enabled outputs
      for i, o in pairs(choice) do
	 cmd = cmd .. &quot; --output &quot; .. o .. &quot; --auto&quot;
	 if i &gt; 1 then
	    cmd = cmd .. &quot; --right-of &quot; .. choice[i-1]
	 end
      end
      -- Disabled outputs
      for _, o in pairs(out) do
	 if not awful.util.table.hasitem(choice, o) then
	    cmd = cmd .. &quot; --output &quot; .. o .. &quot; --off&quot;
	 end
      end

      local label = &quot;&quot;
      if #choice == 1 then
	 label = 'Only &lt;span weight=&quot;bold&quot;&gt;' .. choice[1] .. '&lt;/span&gt;'
      else
	 for i, o in pairs(choice) do
	    if i &gt; 1 then label = label .. &quot; + &quot; end
	    label = label .. '&lt;span weight=&quot;bold&quot;&gt;' .. o .. '&lt;/span&gt;'
	 end
      end

      menu[#menu + 1] = { label,
			  cmd,
                          &quot;/usr/share/icons/Tango/32x32/devices/display.png&quot;}
   end

   return menu
end

-- Display xrandr notifications from choices
local state = { iterator = nil,
		timer = nil,
		cid = nil }
local function xrandr()
   -- Stop any previous timer
   if state.timer then
      state.timer:stop()
      state.timer = nil
   end

   -- Build the list of choices
   if not state.iterator then
      state.iterator = awful.util.table.iterate(menu(),
					function() return true end)
   end

   -- Select one and display the appropriate notification
   local next  = state.iterator()
   local label, action, icon
   if not next then
      label, icon = &quot;Keep the current configuration&quot;, &quot;/usr/share/icons/Tango/32x32/devices/display.png&quot;
      state.iterator = nil
   else
      label, action, icon = unpack(next)
   end
   state.cid = naughty.notify({ text = label,
				icon = icon,
				timeout = 4,
				screen = mouse.screen, -- Important, not all screens may be visible
				font = &quot;Free Sans 18&quot;,
				replaces_id = state.cid }).id

   -- Setup the timer
   state.timer = timer { timeout = 4 }
   state.timer:connect_signal(&quot;timeout&quot;,
			  function()
			     state.timer:stop()
			     state.timer = nil
			     state.iterator = nil
			     if action then
				awful.util.spawn(action, false)
			     end
			  end)
   state.timer:start()
end

config.keys.global = awful.util.table.join(
   config.keys.global,
   awful.key({}, &quot;XF86Display&quot;, xrandr))
&lt;/pre&gt;

=== Static configuration ===
If you want to do a static setup for your displays then you could follow the next example. You already have one &lt;b&gt;Section &quot;Monitor&quot;&lt;/b&gt; for your first display (and for this example let's say that it's identifier is &lt;b&gt;LCD-Monitor&lt;/b&gt; and our VGA will be &lt;b&gt;CRT-Monitor&lt;/b&gt;), the first step is to add another one, with settings for your second display (we continue with the VGA example): 
    # This is for a static setup of the external display
    #
    Section &quot;Monitor&quot;
        Identifier   &quot;CRT-Monitor&quot;
        VendorName   &quot;FUS&quot;
        ModelName    &quot;19P4&quot;
        HorizSync    30-96
        VertRefresh  50-160
        Option       &quot;DPMS&quot;
        Option       &quot;PreferredMode&quot; &quot;1280x1024&quot;
        Option       &quot;RightOf&quot;       &quot;LVDS&quot;
        ##Option     &quot;Position&quot;      &quot;1280 0&quot;
    EndSection

Then in your &lt;b&gt;Section &quot;Device&quot;&lt;/b&gt; you do the actual setup: 
    # Graphics configuration
    # 
    Section &quot;Device&quot;
        Identifier   &quot;intel&quot;
        Driver       &quot;intel&quot;
        VendorName   &quot;Intel Corporation&quot;
        BoardName    &quot;Mobile GM965/GL960 Integrated Graphics Controller&quot;
        # VGA display options
        Option       &quot;monitor-VGA&quot;     &quot;CRT-Monitor&quot;
        ##Option     &quot;MonitorLayout&quot;   &quot;CRT,LFP&quot;
        ##Option     &quot;MonitorLayout&quot;   &quot;NONE,CRT+LFP&quot;
    EndSection

These are the most basic settings, some other that are worth mentioning are: &lt;b&gt;CheckLid&lt;/b&gt;, &lt;b&gt;DevicePresence&lt;/b&gt; and &lt;b&gt;Clone&lt;/b&gt;. You can find all options with explanations listed in the manual page of the intel driver (to read it you can execute: &lt;b&gt;man intel&lt;/b&gt; or replace intel with the name of the driver you use).

The last step involves setting up your &lt;b&gt;Virtual&lt;/b&gt; size as I mentioned earlier. In your &lt;b&gt;Section &quot;Screen&quot;&lt;/b&gt; subsection &lt;b&gt;&quot;Display&quot;&lt;/b&gt; you need to configure the virtual size of your desktop (usually placed below the &lt;b&gt;Modes&lt;/b&gt; line). So, following our earlier examples this is how Section &quot;Screen&quot; would look like: 
    # Screen configuration
    #
    Section &quot;Screen&quot;
        Identifier  &quot;LCD Screen&quot;
        Device      &quot;intel&quot;
        Monitor     &quot;LCD-Monitor&quot;
        DefaultDepth 24
        Subsection &quot;Display&quot;
            Depth       24
            Modes       &quot;1280x800&quot; &quot;1280x768&quot; &quot;1280x720&quot; &quot;1024x768&quot; &quot;800x600&quot; &quot;640x480&quot;
            ViewPort    0 0
            &lt;b&gt;Virtual     2560 1024&lt;/b&gt;
        EndSubsection
    EndSection

== nvidia ==
So, &lt;b&gt;nvidia&lt;/b&gt; does not support XRandR yet. What they did up to this point is use their own technology called &lt;b&gt;TwinView&lt;/b&gt; which in it's simplest configuration is not so great for us in the classic sense, as awesome will see the screen as one big desktop (thus you will not be able to move clients between screens etc. as there is &quot;no&quot; other screen to move them to). But, I suppose there might be some use cases where this would be the &lt;b&gt;desired&lt;/b&gt; behaviour, so I will cover that too. Then with a little tweaking we could get the same behaviour as usually expected. Our last example will be using &lt;b&gt;Xinerama&lt;/b&gt; which will also have the same effect as our earlier examples.

=== TwinView ===
With TwinView you will only have one Section &quot;Monitor&quot;, for the first display. Complete setup of the second display is done in &lt;b&gt;Section &quot;Device&quot;&lt;/b&gt;. The easiest way to do this is with &lt;b&gt;nvidia-settings&lt;/b&gt;, and if that doesn't seem to work you can edit your Xorg.conf manually. So let's see how one such could look like (in this example I am using two identical CRT monitors):
    Section &quot;Device&quot;
        Identifier  &quot;Card0&quot;
        Driver      &quot;nvidia&quot;
        VendorName  &quot;nVidia Corporation&quot;
        BoardName   &quot;NV34 [GeForce FX 5500]&quot;
        #
        Option      &quot;ConnectedMonitor&quot;     &quot;CRT-0, CRT-1&quot;
        ##Option    &quot;IgnoreDisplayDevices&quot; &quot;TV-0&quot;
        #
        # This is the important part
        Option      &quot;TwinView&quot;            &quot;true&quot;
        # Possible options are: Right-Of, Left-Of, Above, Below, Clone
        Option      &quot;TwinViewOrientation&quot; &quot;Right-Of&quot;
        #
        Option      &quot;SecondMonitorHorizSync&quot;   &quot;30-96&quot;
        Option      &quot;SecondMonitorVertRefresh&quot; &quot;50-160&quot;
        #
        # Metamodes tell us when: 
        # monitor A is using resolution X then monitor B will use resolution Y; second lower A reolution, second lower B resolution...
        Option      &quot;MetaModes&quot; &quot;1280x1024, 1280x1024; 1024x768, 1024x768; 800x600, 800x600; 640x480, 640x480&quot;
        # Example when monitor B is using a lower resolution
        #Option     &quot;MetaModes&quot; &quot;1280x1024, 1024x768@1280x1024; 1024x768, 1024x768; 800x600, 800x600&quot;
    EndSection

Now let's see a different example contributed by another user, where he got two displays to behave independantly under awesome using TwinView. Here we will shuffle the options a bit, delegate them to other sections, but don't let it confuse you. In this example we will be using two identical LCD monitors (referenced as &lt;b&gt;DFP-0&lt;/b&gt; and &lt;b&gt;DFP-1&lt;/b&gt;):
     Section &quot;Monitor&quot;
         Identifier    &quot;Monitor0&quot;
         HorizSync     30-100
         VertRefresh   60
         ModeLine      &quot;1680x1050&quot; 147.1 1680 1784 1968 2256 1050 1051 1054 1087 +Hsync -Vsync
     EndSection
     
     Section &quot;Monitor&quot;
         Identifier    &quot;Monitor1&quot;
         HorizSync     30-100
         VertRefresh   60
         ModeLine      &quot;1680x1050&quot; 147.1 1680 1784 1968 2256 1050 1051 1054 1087 +Hsync -Vsync
     EndSection
     
     Section &quot;Device&quot;
         Identifier      &quot;Card0&quot;
         Driver          &quot;nvidia&quot;
         VendorName      &quot;nVidia&quot;
         BoardName       &quot;NVIDIA GeForce 7800GS&quot;
         
         Option          &quot;AllowDDCCI&quot;            &quot;true&quot;
         Option          &quot;FlatPanelProperties&quot;   &quot;Scaling = aspect-scaled&quot;
         Option          &quot;RandRRotation&quot;         &quot;true&quot;
         Option          &quot;TripleBuffer&quot;          &quot;true&quot;
         
         # Multiple display configuration
         ##Option        &quot;ConnectedMonitor&quot;          &quot;DFP-0, DFP-1&quot;
         Option          &quot;PrimaryMonitor&quot;            &quot;DFP-0&quot;
         Option          &quot;UseDisplayDevice&quot;          &quot;DFP-0, DFP-1&quot;
         # According to their docs, this is what makes the difference
         #   http://us.download.nvidia.com/XFree86/Linux-x86/180.29/README/chapter-13.html
         Option          &quot;TwinViewOrientation&quot;       &quot;DFP-0  LeftOf DFP-1&quot;
         Option          &quot;TwinViewXineramaInfoOrder&quot; &quot;DFP-0, DFP-1&quot;
     EndSection
     
     
     Section &quot;Screen&quot;
         Identifier    &quot;Screen0&quot;
         Device        &quot;Card0&quot;
         Monitor       &quot;Monitor0&quot;
         DefaultDepth  24
         Subsection    &quot;Display&quot;
             Modes            &quot;1680x1050&quot;
         EndSubsection
         Option &quot;MetaModes&quot;   &quot;DFP-0: 1680x1050 +0+0, DFP-1: 1680x1050 +1680+0;&quot;
         Option &quot;HorizSync&quot;   &quot;DFP-0: 30-100; DFP-1: 30-100&quot;
         Option &quot;VertRefresh&quot; &quot;DFP-0: 60; DFP-1: 60&quot;
         Option &quot;TwinView&quot;    &quot;true&quot;
     EndSection
     
     Section &quot;ServerLayout&quot;
         Identifier    &quot;TwinView Screen&quot;
         Screen        0 &quot;Screen0&quot; 0 0
         Option        &quot;Xinerama&quot;  &quot;false&quot;
     EndSection

For more information about TwinView (naming the devices (CRT, DFP, TV...), which pipes can be used at the same time and for everything else) refer to the latest nvidia &lt;b&gt;README&lt;/b&gt; file which is distributed with their drivers but can also be read online: http://www.nvidia.com/object/unix.html

=== Xinerama ===
Xinerama is an X extension which enables multi-headed X applications and window managers to use two or more physical displays as one large virtual display. Note that you can use Xinerama in the same way with other drivers too (&lt;b&gt;fglrx&lt;/b&gt; for example). When using Xinerama we will need to have a section for each &lt;b&gt;Monitor&lt;/b&gt;, two &lt;b&gt;Device&lt;/b&gt; sections, two &lt;b&gt;Screen&lt;/b&gt; sections (each using it's own Device and Monitor) and we will setup orientation of our screens in the main &lt;b&gt;ServerLayout&lt;/b&gt; section (where we will also enable Xinerama). This is the most basic example showing what I'm talking about (using two identical LCD displays):
     # Out Monitor sections
     #
     Section &quot;Monitor&quot;
         Identifier   &quot;Monitor0&quot;
         VendorName   &quot;Monitor Vendor&quot;
         ModelName    &quot;Monitor Model&quot;
     EndSection
 
     Section &quot;Monitor&quot;
         Identifier   &quot;Monitor1&quot;
         VendorName   &quot;Monitor Vendor&quot;
         ModelName    &quot;Monitor Model&quot;
     EndSection
     
     
     # Our Device sections
     # 
     Section &quot;Device&quot;
         Identifier  &quot;Card0&quot;
         Driver      &quot;nvidia&quot;
         VendorName  &quot;nVidia Corporation&quot;
         BoardName   &quot;G70 [GeForce 7800 GS]&quot;
         Screen      0
     EndSection
     
     Section &quot;Device&quot;
         Identifier  &quot;Card1&quot;
         Driver      &quot;nvidia&quot;
         VendorName  &quot;nVidia Corporation&quot;
         BoardName   &quot;G70 [GeForce 7800 GS]&quot;
         Screen      1
     EndSection
     
     
     # Our Screen sections
     #
     Section &quot;Screen&quot;
         Identifier    &quot;Screen0&quot;
         Device        &quot;Card0&quot;
         Monitor       &quot;Monitor0&quot;
         DefaultDepth  24
         SubSection    &quot;Display&quot;
             Viewport  0 0
             Depth     24
             Modes     &quot;1680x1050&quot;
         EndSubSection
     EndSection
 
     Section &quot;Screen&quot;
         Identifier    &quot;Screen1&quot;
         Device        &quot;Card1&quot;
         Monitor       &quot;Monitor1&quot;
         DefaultDepth  24
         SubSection    &quot;Display&quot;
             Viewport  0 0
             Depth     24
             Modes     &quot;1680x1050&quot;
         EndSubSection
     EndSection
     
     
     # Finally our ServerLayout that does the work
     # 
     Section &quot;ServerLayout&quot;
         Identifier     &quot;Xinerama Screen&quot;
         Screen         0  &quot;Screen0&quot; 0 0
         Screen         1  &quot;Screen1&quot; RightOf &quot;Screen0&quot;
         Option         &quot;Xinerama&quot;   &quot;true&quot;
     EndSection

You will also have your Keyboard and Mouse configuration in this file, and reference them in your server layout etc. (if you are not already using HAL enabled X.org). You should already know all that. I'm only writing about displays. Speaking of which there are even more ways of using multiple displays, such as running two independant X sessions each on it's own monitor, there are also &lt;b&gt;Zaphod&lt;/b&gt; and &lt;b&gt;MergedFB&lt;/b&gt;, last to mention is that &lt;b&gt;ATi&lt;/b&gt;, like nVidia, has it's own thing called &lt;b&gt;BigDesktop&lt;/b&gt; (fglrx driver). Researching into those is up to you, reader. With that said I am wraping up this document, I hope it was clear enough and you have your huge desktop operational (and awesome controling it :).

=== Disper ===

A simplified utility: allowing command line switching of monitor configurations is http://willem.engen.nl/projects/disper/

This also helps work around the issue of the nvidia-settings confirmation dialog being hidden by awesome's restart when nvidia-settings changes the monitor mode.</text>
      <sha1>bo6d3x0nwcqh0sj8l39cudx08hc1pqx</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using Multiple Screens/ru</title>
    <ns>0</ns>
    <id>1109</id>
    <revision>
      <id>6741</id>
      <timestamp>2014-06-09T13:08:38Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Using Multiple Screens (tranlating page)</comment>
      <text xml:space="preserve" bytes="24996">{{Languages|Using Multiple Screens}}
{{DISPLAYTITLE:Использование нескольких экранов}}

Люди часто спрашивают, как настроить X для использования на нескольких мониторах на IRC канале. Поэтому здесь приведено краткое руководство охватывающее несколько различных драверов и методов доступных в GNU/Linux.

Если вас интересует как управлять несколькими монитормаи, после того как вы их настроите смотрите [[Awesome_3.x#DEFAULT_KEY_BINDINGS|awesome 3 key bindings]] (смотрите те, которые управляют экранами, также вы можете открыть man страницу в терминале) и если вы хотите управлять виджетами(например системным треем) на каждом экране, то вам необходимо изучить страницу [[Widgets in awesome/ru|Виджеты в Awesome]], конкретно [[Widgets_in_awesome/ru#Управление виджетами|Управление виджетами]] секцию.

== Основы ==
Самым простым способом является использование &lt;b&gt;XRandR&lt;/b&gt; (X Resize и Rotate) расширения, которое позволяет динамически контролировать ваши выходы, разрешения, ориентацию... и добавлять новые дисплеи на лету, без перезапуска X-сервера. Но пока еще не все драйверы поддерживаются в нем. Вот список поддерживаемых драйверов:  &lt;b&gt;intel&lt;/b&gt;, &lt;b&gt;ati&lt;/b&gt; (OpenSource driver), &lt;b&gt;radeonhd&lt;/b&gt; (OpenSource driver), &lt;b&gt;nv&lt;/b&gt; (nvidia 2D driver) и &lt;b&gt;nouveau&lt;/b&gt; (OpenSource nvidia driver). Я также захвачу драйвер &lt;b&gt;nvidia&lt;/b&gt;, как наиболее часто используемый людьми, использующий  &lt;b&gt;TwinView&lt;/b&gt; и &lt;b&gt;Xinerama&lt;/b&gt; (которые могут быть использованы также и с другими драйверами, например с &lt;b&gt;fglrx&lt;/b&gt;).

Помиом этого, Awesome имеет: &lt;i&gt;Реальную поддержку нескольких экранов (XRandR, Xinerama и Zaphod режимы) на десктопных экранах (tags)&lt;/i&gt;; Awesome поставляется с примером конфигурационного файла (/etc/xdg/awesome/rc.lua начиная с v3.0 и старше) которая уже настроена на несколько дисплеев; касающаяся wiboxes, taskbars и widgets, но также имеет и клавиатурные сочетания, которые позволяют вам перемещать клиенты между несколькими экранами и переключать фокус между ними.

== XRandR ==
Для начала я покажу вам несколько примеров использования xrandr для динамической настройки на лету (и перенастройки).

Итак первой командой мы запросим список нашего оборудования:
    $ xrandr -q

После получения вывода, давайте предположим, что у вас есть ноутбук с панелью &lt;b&gt;LVDS&lt;/b&gt; и внешним портом VGA, который мы будем рассматривать как  &lt;b&gt;VGA&lt;/b&gt;, мы выполним: 
    $ xrandr --output VGA --mode 1280x1024 --right-of LVDS

Команда приведенная выше проста, ваш VGA монитор инициализируется с разрешением 1280х1024 и размещается и размещается с права от вашего экрана LVDS screen (допустим что разрешение LVDS равно 1280x800). Важно помнить, что у вас теперь одни большой экран, размер которого будет &lt;b&gt;2560x1024&lt;/b&gt;. Если команда выше завершится с ошибкой, то вы вероятно не примете это в расчет когда будете настраивать ваш &lt;b&gt;xorg.conf&lt;/b&gt; (вам необходимо настроить ваш &lt;b&gt;Virtual&lt;/b&gt; размер), подробнее об этом чуть ниже.

Довольно часто случается, что Xrandr не может найти 'наилучшее' разрешение для вашего внешнего монитора. Не говоря уже о правильно частоте его обновления. Когда это происходит, вам необходимо создать modeline (gtf), затем добавить его к выводу. Вот несколько простых команд, которые создадут новую конфигурацию 1280x800 с частотой обновления 68Hz и прикрепят его к выводу VGA:
    $ xrandr --newmode $(gtf 1280 800 68 | grep Modeline | sed s/Modeline\ // | tr -d '&quot;')
    $ xrandr --addmode VGA 1280x800_68.00

Для других способов использования Xrandr прочитайте man. Здесь я покажу только один пример, отключения внешнего монитора: 
    $ xrandr --output VGA --off

Здесь вы можете найти простой скрипт который несколько упрощает задачу правильного выбора частоты обновления, а затем настраивает ваши экраны [http://github.com/bioe007/bioe007configs/blob/master/.bin/stupid.sh stupid.sh]

=== Циклическое переключение возможных конфигураций ===

Есть возможность циклически переключаться между различными конфигурациями с помощью клавиатуры (например XF86Display). Вот фрагмент кода, который использует уведомления для отображения предложенной конфигурации. Каждый раз при нажатии клавиш, предлагается другая конфигурация в зависимости от активных выходов. После обхода всех возможных конфигурация, мы предполагаем что менять нечего. Чтобы принять конфигурацию, пользователь просто не должен переключаться на другие конфигурации:

* Only LVDS1
* Only VGA1
* LVDS1 + VGA1
* VGA1 + LVDS1
* No change
* Only LVDS1
* ...

&lt;pre&gt;
-- Get active outputs
local function outputs()
   local outputs = {}
   local xrandr = io.popen(&quot;xrandr -q&quot;)
   if xrandr then
      for line in xrandr:lines() do
	 output = line:match(&quot;^([%w-]+) connected &quot;)
	 if output then
	    outputs[#outputs + 1] = output
	 end
      end
      xrandr:close()
   end

   return outputs
end

local function arrange(out)
   -- We need to enumerate all the way to combinate output. We assume
   -- we want only an horizontal layout.
   local choices  = {}
   local previous = { {} }
   for i = 1, #out do
      -- Find all permutation of length `i`: we take the permutation
      -- of length `i-1` and for each of them, we create new
      -- permutations by adding each output at the end of it if it is
      -- not already present.
      local new = {}
      for _, p in pairs(previous) do
	 for _, o in pairs(out) do
	    if not awful.util.table.hasitem(p, o) then
	       new[#new + 1] = awful.util.table.join(p, {o})
	    end
	 end
      end
      choices = awful.util.table.join(choices, new)
      previous = new
   end

   return choices
end

-- Build available choices
local function menu()
   local menu = {}
   local out = outputs()
   local choices = arrange(out)

   for _, choice in pairs(choices) do
      local cmd = &quot;xrandr&quot;
      -- Enabled outputs
      for i, o in pairs(choice) do
	 cmd = cmd .. &quot; --output &quot; .. o .. &quot; --auto&quot;
	 if i &gt; 1 then
	    cmd = cmd .. &quot; --right-of &quot; .. choice[i-1]
	 end
      end
      -- Disabled outputs
      for _, o in pairs(out) do
	 if not awful.util.table.hasitem(choice, o) then
	    cmd = cmd .. &quot; --output &quot; .. o .. &quot; --off&quot;
	 end
      end

      local label = &quot;&quot;
      if #choice == 1 then
	 label = 'Only &lt;span weight=&quot;bold&quot;&gt;' .. choice[1] .. '&lt;/span&gt;'
      else
	 for i, o in pairs(choice) do
	    if i &gt; 1 then label = label .. &quot; + &quot; end
	    label = label .. '&lt;span weight=&quot;bold&quot;&gt;' .. o .. '&lt;/span&gt;'
	 end
      end

      menu[#menu + 1] = { label,
			  cmd,
                          &quot;/usr/share/icons/Tango/32x32/devices/display.png&quot;}
   end

   return menu
end

-- Display xrandr notifications from choices
local state = { iterator = nil,
		timer = nil,
		cid = nil }
local function xrandr()
   -- Stop any previous timer
   if state.timer then
      state.timer:stop()
      state.timer = nil
   end

   -- Build the list of choices
   if not state.iterator then
      state.iterator = awful.util.table.iterate(menu(),
					function() return true end)
   end

   -- Select one and display the appropriate notification
   local next  = state.iterator()
   local label, action, icon
   if not next then
      label, icon = &quot;Keep the current configuration&quot;, &quot;/usr/share/icons/Tango/32x32/devices/display.png&quot;
      state.iterator = nil
   else
      label, action, icon = unpack(next)
   end
   state.cid = naughty.notify({ text = label,
				icon = icon,
				timeout = 4,
				screen = mouse.screen, -- Important, not all screens may be visible
				font = &quot;Free Sans 18&quot;,
				replaces_id = state.cid }).id

   -- Setup the timer
   state.timer = timer { timeout = 4 }
   state.timer:connect_signal(&quot;timeout&quot;,
			  function()
			     state.timer:stop()
			     state.timer = nil
			     state.iterator = nil
			     if action then
				awful.util.spawn(action, false)
			     end
			  end)
   state.timer:start()
end

config.keys.global = awful.util.table.join(
   config.keys.global,
   awful.key({}, &quot;XF86Display&quot;, xrandr))
&lt;/pre&gt;

=== Постоянная конфигурация ===

Если вы хотите использовать постоянные настройки для ваших дисплеев, то вы можете сделать по следующему примеру. У вас уже есть одна &lt;b&gt;Section &quot;Monitor&quot;&lt;/b&gt; для вашего первого дисплей (и в этом примере, предполагается, что его идентификатор &lt;b&gt;LCD-Monitor&lt;/b&gt; и наш VGA будет &lt;b&gt;CRT-Monitor&lt;/b&gt;). И первым шагом нам необходимо добавить еще одну, с настройками для второго дисплея (мы продолжим пример с VGA): 
    # This is for a static setup of the external display
    #
    Section &quot;Monitor&quot;
        Identifier   &quot;CRT-Monitor&quot;
        VendorName   &quot;FUS&quot;
        ModelName    &quot;19P4&quot;
        HorizSync    30-96
        VertRefresh  50-160
        Option       &quot;DPMS&quot;
        Option       &quot;PreferredMode&quot; &quot;1280x1024&quot;
        Option       &quot;RightOf&quot;       &quot;LVDS&quot;
        ##Option     &quot;Position&quot;      &quot;1280 0&quot;
    EndSection

Затем в вашей &lt;b&gt;Section &quot;Device&quot;&lt;/b&gt; вы делаете актуальные настройки: 
    # Graphics configuration
    # 
    Section &quot;Device&quot;
        Identifier   &quot;intel&quot;
        Driver       &quot;intel&quot;
        VendorName   &quot;Intel Corporation&quot;
        BoardName    &quot;Mobile GM965/GL960 Integrated Graphics Controller&quot;
        # VGA display options
        Option       &quot;monitor-VGA&quot;     &quot;CRT-Monitor&quot;
        ##Option     &quot;MonitorLayout&quot;   &quot;CRT,LFP&quot;
        ##Option     &quot;MonitorLayout&quot;   &quot;NONE,CRT+LFP&quot;
    EndSection

Это самые основные настройки, некоторые другие, которые заслуживают упоминания это: &lt;b&gt;CheckLid&lt;/b&gt;, &lt;b&gt;DevicePresence&lt;/b&gt; и &lt;b&gt;Clone&lt;/b&gt;. Вы можете найти все опции с объяснениями на странице руководства драйвера intel (для ознакомления с ней вы можете набрать в терминале: &lt;b&gt;man intel&lt;/b&gt; или заменить intel на название драйвера, которым пользуетесь вы).

Последний шаг включает настройку вашего &lt;b&gt;Virtual&lt;/b&gt; размера, как я упоминал ранее. В вашей &lt;b&gt;Section &quot;Screen&quot;&lt;/b&gt; подразделе &lt;b&gt;&quot;Display&quot;&lt;/b&gt; вам необходимо настроить виртуальный размер вашего desktop (обычно его размещают после строк &lt;b&gt;Modes&lt;/b&gt;). Итак, после наших действий, раздел &quot;Screen&quot; будет выглядеть следующим образом:

    # Screen configuration
    #
    Section &quot;Screen&quot;
        Identifier  &quot;LCD Screen&quot;
        Device      &quot;intel&quot;
        Monitor     &quot;LCD-Monitor&quot;
        DefaultDepth 24
        Subsection &quot;Display&quot;
            Depth       24
            Modes       &quot;1280x800&quot; &quot;1280x768&quot; &quot;1280x720&quot; &quot;1024x768&quot; &quot;800x600&quot; &quot;640x480&quot;
            ViewPort    0 0
            &lt;b&gt;Virtual     2560 1024&lt;/b&gt;
        EndSubsection
    EndSection

== nvidia ==
Итак, &lt;b&gt;nvidia&lt;/b&gt; все еще не поддерживается XRandR. Все что они сделали, это разработали собственную технологию называемую  &lt;b&gt;TwinView&lt;/b&gt; которая в его простейшей конфигурации, не так уж хороша для нас в стандартном виде, так как Awesome видит экран как один большой desktop (таким образом вы не сможете перемещать приложения между экранами, поскольку нет другого экрана, куда можно было бы переместить их). Но я полагаю, здесь могут быть некоторые случаи использования, где это будет востребовано, поэтому я также опишу это. Тогда, немного настроив, мы получим то поведение, которое ожидаем. Наш последний пример будет использовать &lt;b&gt;Xinerama&lt;/b&gt; который будет иметь тот же результат, как и в наших предыдущих примерах.

=== TwinView ===
Используя TwinView у вас будет только один Section &quot;Monitor&quot;, для первого дисплея. Полная настройка второго дисплея осуществляется в &lt;b&gt;Section &quot;Device&quot;&lt;/b&gt;. Простейший способ сделать это, это &lt;b&gt;nvidia-settings&lt;/b&gt;, и если это не будет работать, вы можете отредактировать ваш Xorg.conf вручную. Давайте посмотрим, как она может выглядеть (в этом случае я использую два одинаковых CRT монитора):
    Section &quot;Device&quot;
        Identifier  &quot;Card0&quot;
        Driver      &quot;nvidia&quot;
        VendorName  &quot;nVidia Corporation&quot;
        BoardName   &quot;NV34 [GeForce FX 5500]&quot;
        #
        Option      &quot;ConnectedMonitor&quot;     &quot;CRT-0, CRT-1&quot;
        ##Option    &quot;IgnoreDisplayDevices&quot; &quot;TV-0&quot;
        #
        # This is the important part
        Option      &quot;TwinView&quot;            &quot;true&quot;
        # Possible options are: Right-Of, Left-Of, Above, Below, Clone
        Option      &quot;TwinViewOrientation&quot; &quot;Right-Of&quot;
        #
        Option      &quot;SecondMonitorHorizSync&quot;   &quot;30-96&quot;
        Option      &quot;SecondMonitorVertRefresh&quot; &quot;50-160&quot;
        #
        # Metamodes tell us when: 
        # monitor A is using resolution X then monitor B will use resolution Y; second lower A reolution, second lower B resolution...
        Option      &quot;MetaModes&quot; &quot;1280x1024, 1280x1024; 1024x768, 1024x768; 800x600, 800x600; 640x480, 640x480&quot;
        # Example when monitor B is using a lower resolution
        #Option     &quot;MetaModes&quot; &quot;1280x1024, 1024x768@1280x1024; 1024x768, 1024x768; 800x600, 800x600&quot;
    EndSection

Теперь давайте рассмотрим другой пример предоставленый другим пользователем, где он использует два дисплея ведущих себя независимо под Awesome с использованием TwinView. Здесь мы перемещаем несколько опций, делегируя их другим секциям, но не позволяйте этому сбить себя с толку. В данном примере, мы будет использовать два одинаковых LCD монитора (назовем их &lt;b&gt;DFP-0&lt;/b&gt; и &lt;b&gt;DFP-1&lt;/b&gt;):
     Section &quot;Monitor&quot;
         Identifier    &quot;Monitor0&quot;
         HorizSync     30-100
         VertRefresh   60
         ModeLine      &quot;1680x1050&quot; 147.1 1680 1784 1968 2256 1050 1051 1054 1087 +Hsync -Vsync
     EndSection
     
     Section &quot;Monitor&quot;
         Identifier    &quot;Monitor1&quot;
         HorizSync     30-100
         VertRefresh   60
         ModeLine      &quot;1680x1050&quot; 147.1 1680 1784 1968 2256 1050 1051 1054 1087 +Hsync -Vsync
     EndSection
     
     Section &quot;Device&quot;
         Identifier      &quot;Card0&quot;
         Driver          &quot;nvidia&quot;
         VendorName      &quot;nVidia&quot;
         BoardName       &quot;NVIDIA GeForce 7800GS&quot;
         
         Option          &quot;AllowDDCCI&quot;            &quot;true&quot;
         Option          &quot;FlatPanelProperties&quot;   &quot;Scaling = aspect-scaled&quot;
         Option          &quot;RandRRotation&quot;         &quot;true&quot;
         Option          &quot;TripleBuffer&quot;          &quot;true&quot;
         
         # Multiple display configuration
         ##Option        &quot;ConnectedMonitor&quot;          &quot;DFP-0, DFP-1&quot;
         Option          &quot;PrimaryMonitor&quot;            &quot;DFP-0&quot;
         Option          &quot;UseDisplayDevice&quot;          &quot;DFP-0, DFP-1&quot;
         # According to their docs, this is what makes the difference
         #   http://us.download.nvidia.com/XFree86/Linux-x86/180.29/README/chapter-13.html
         Option          &quot;TwinViewOrientation&quot;       &quot;DFP-0  LeftOf DFP-1&quot;
         Option          &quot;TwinViewXineramaInfoOrder&quot; &quot;DFP-0, DFP-1&quot;
     EndSection
     
     
     Section &quot;Screen&quot;
         Identifier    &quot;Screen0&quot;
         Device        &quot;Card0&quot;
         Monitor       &quot;Monitor0&quot;
         DefaultDepth  24
         Subsection    &quot;Display&quot;
             Modes            &quot;1680x1050&quot;
         EndSubsection
         Option &quot;MetaModes&quot;   &quot;DFP-0: 1680x1050 +0+0, DFP-1: 1680x1050 +1680+0;&quot;
         Option &quot;HorizSync&quot;   &quot;DFP-0: 30-100; DFP-1: 30-100&quot;
         Option &quot;VertRefresh&quot; &quot;DFP-0: 60; DFP-1: 60&quot;
         Option &quot;TwinView&quot;    &quot;true&quot;
     EndSection
     
     Section &quot;ServerLayout&quot;
         Identifier    &quot;TwinView Screen&quot;
         Screen        0 &quot;Screen0&quot; 0 0
         Option        &quot;Xinerama&quot;  &quot;false&quot;
     EndSection

Чтобы получить больше информации о TwinView (называя устройства (CRT, DFP, TV...), которые объединены, могут быть использованы в то же время и для чего то еще) ссылки на последний nvidia &lt;b&gt;README&lt;/b&gt; файл, который который распространяется со всеми драйверами, но с ним также можно ознакомиться и онлайн: http://www.nvidia.com/object/unix.html

=== Xinerama ===
Xinerama это расширения для X, которое позволяет multi-headed X приложениям и оконным менеджерам использовать два или больше физических дисплея как один большой виртуальный дисплей. Обратите внимание, что вы можете использовать Xinerama таким же способом также и с другими драйверам (например с &lt;b&gt;fglrx&lt;/b&gt;). Когда используется Xinerama нам необходимо иметь секцию для каждого &lt;b&gt;Monitor&lt;/b&gt;, две секции &lt;b&gt;Device&lt;/b&gt;, две секции &lt;b&gt;Screen&lt;/b&gt; (каждая из которых использует свой собственный Device и Monitor) и поэтому мы настраиваем ориентацию наших экранов в главной секции  &lt;b&gt;ServerLayout&lt;/b&gt; (где мы также разрешаем использовать Xinerama). Это наиболее простой пример, показывающий о чем я говорю (используются два однинаковых LCD дисплея):
     # Out Monitor sections
     #
     Section &quot;Monitor&quot;
         Identifier   &quot;Monitor0&quot;
         VendorName   &quot;Monitor Vendor&quot;
         ModelName    &quot;Monitor Model&quot;
     EndSection
 
     Section &quot;Monitor&quot;
         Identifier   &quot;Monitor1&quot;
         VendorName   &quot;Monitor Vendor&quot;
         ModelName    &quot;Monitor Model&quot;
     EndSection
     
     
     # Our Device sections
     # 
     Section &quot;Device&quot;
         Identifier  &quot;Card0&quot;
         Driver      &quot;nvidia&quot;
         VendorName  &quot;nVidia Corporation&quot;
         BoardName   &quot;G70 [GeForce 7800 GS]&quot;
         Screen      0
     EndSection
     
     Section &quot;Device&quot;
         Identifier  &quot;Card1&quot;
         Driver      &quot;nvidia&quot;
         VendorName  &quot;nVidia Corporation&quot;
         BoardName   &quot;G70 [GeForce 7800 GS]&quot;
         Screen      1
     EndSection
     
     
     # Our Screen sections
     #
     Section &quot;Screen&quot;
         Identifier    &quot;Screen0&quot;
         Device        &quot;Card0&quot;
         Monitor       &quot;Monitor0&quot;
         DefaultDepth  24
         SubSection    &quot;Display&quot;
             Viewport  0 0
             Depth     24
             Modes     &quot;1680x1050&quot;
         EndSubSection
     EndSection
 
     Section &quot;Screen&quot;
         Identifier    &quot;Screen1&quot;
         Device        &quot;Card1&quot;
         Monitor       &quot;Monitor1&quot;
         DefaultDepth  24
         SubSection    &quot;Display&quot;
             Viewport  0 0
             Depth     24
             Modes     &quot;1680x1050&quot;
         EndSubSection
     EndSection
     
     
     # Finally our ServerLayout that does the work
     # 
     Section &quot;ServerLayout&quot;
         Identifier     &quot;Xinerama Screen&quot;
         Screen         0  &quot;Screen0&quot; 0 0
         Screen         1  &quot;Screen1&quot; RightOf &quot;Screen0&quot;
         Option         &quot;Xinerama&quot;   &quot;true&quot;
     EndSection

У вас также будут собственные настройки Keyboard и Mouse в этом файле,  и ссылаться на них в вашем server layout и т.д.. (если вы все еще не испльзуете HAL разрещите X.org). Вы уже должны знать все это. Я пишу только о дисплеях. Говоря об этом, существует еще несколько способов использования нескольких дисплеев, такие как запуск двух независимых X сессий, каждой на своем мониторе, также можно упомянуть о , &lt;b&gt;Zaphod&lt;/b&gt; и &lt;b&gt;MergedFB&lt;/b&gt;, последний используется для &lt;b&gt;ATi&lt;/b&gt;, а у nVidia, есть свой собственный, называемый &lt;b&gt;BigDesktop&lt;/b&gt; (драйвер fglrx). Researching into those is up to you, reader. Этим я завершаю эту статью, я надеюсь вы немного просветились и теперь у вас есть огромный рабочий стол (и Awesome контролирует его :).

=== Disper ===

Простейшая утилита: позволяющая переключать конфигурации мониторов через командную строку http://willem.engen.nl/projects/disper/

Это также позволяет работать в обход запроса диалога перезагрузки nvidia-settings, которое будет скрыто awesome's, когда nvidia-settings изменяет режим монитора.</text>
      <sha1>ezgkvu40olhxnxxet4xa8pj6z67sfpm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using Xephyr</title>
    <ns>0</ns>
    <id>284</id>
    <revision>
      <id>6538</id>
      <parentid>6138</parentid>
      <timestamp>2014-05-18T06:25:35Z</timestamp>
      <contributor>
        <username>Enmar Abrams</username>
        <id>3302</id>
      </contributor>
      <comment>Change shell script so if awesome is killed zephyr will also die (and not hang around uselessly)</comment>
      <text xml:space="preserve" bytes="8161">{{Languages}}

Here's a brief howto on running nested X servers (X session inside client window of another X session) using Xephyr. This comes handy when testing things without disturbing your normal awesome desktop.

I prefer to run Xephyr and awesome in terminals of their own to see real-time stdout/stderr output.

== Get Xephyr ==

=== Archlinux ===

''/usr/bin/Xephyr'' is provided by ''xorg-server-xephyr'' package. Install it using:

 pacman -S xorg-server-xephyr

=== Gentoo ===

''/usr/bin/Xephyr'' is provided by the ebuild x11-base/xorg-server. The USE-Flag ''kdrive'' has to be enabled for Xephyr to be built.

=== Debian/Ubuntu ===

''/usr/bin/Xephyr'' is provided by ''xserver-xephyr'' package. You can get it using :

  # apt-get install xserver-xephyr

=== Fedora ===

''/usr/bin/Xephyr'' is provided in the ''xorg-x11-server-Xephyr'' package.

== Run Xephyr ==

This runs new X server in X client window:

  $ Xephyr -ac -br -noreset -screen 800x600 :1

; -ac : disable access control restrictions
; -br : create root window with black background
; -noreset : don't reset after last client exists
; -screen 800x600 : Specify screen characteristics

Once running, you can change value of ''DISPLAY'' envirnomental variable to '':1.0'' and run X apps inside your slave X:

  $ DISPLAY=:1.0
  $ xterm

New xterm window will appear inside slave X.

== Run awesome in Xephyr ==

Set the DISPLAY variable:

  $ DISPLAY=:1.0

And run awesome in slave X:

  $ awesome -c ~/.config/awesome/rc.lua.new

This is good to test modifications of ''rc.lua''. In case of errors, you don't spoil your top-level instance of awesome (resulting in blank root window and no keys bound to do something).

You may also create a shell file to allow quick iterations:

  Xephyr -ac -br -noreset -screen 1024x768 :1.0 &amp;
  ZEPHYR_PID=$!
  sleep 1
  DISPLAY=:1.0 awesome -c rc.lua
  kill $ZEPHYR_PID

(invoke awesome using the original startup-file, or a copy of this file)

== More ==

=== Having Xephyr Grab and Release Input ===

One thing you'll quickly notice is that Awesome will not pass keypresses for keybindings down to the Xephyr session. To make this work, the Xephyr session should grab the keyboard. While the Xephyr window has focus, press '''Control-mod3-shift''' to have Xephyr grab focus. You will now see that the mouse can't leave the window. If you want Xephyr to let go, press '''control-shift''' (note: on some systems it should be RIGHT control-shift). If your modifiers are still not working, then there is some Xephyr wackiness going on. You can use xmodmap and xev to see what the errors are. For me, it was not recognizing the &quot;windows key&quot; as Super_L. I bound it within the Xephyr session using xmodmap:

  $ xmodmap -
  keycode 133 = Super_L    # Your keycode might be different. See what it is using xev.
  # Press Control-D here to finish xmodmap input.

It is also somewhat likely that you are not using the default keymap for your system. You will have to rebind that too.

  $ setxkbmap us dvorak

=== Remotely restart awesome ===

Get pid of slave awesome and send it ''SIGHUP'' signal:

  $ pgrep awesome
  $ kill -s SIGHUP &lt;pid_of_awesome_in_xephyr&gt;

Considering that your main awesome always starts before one in xephyr, you can write the command as an one-liner and wrap into a script.

  $ pgrep awesome | tail -1 | xargs kill -s SIGHUP

Or if you'd rather like to use awesome-client:

  $ export DISPLAY=:1.0
  $ echo 'awesome.restart()' | awesome-client

=== Script I use to debug rc.lua ===

 #!/bin/bash
 # script xepyhr-awesome
 # author: dante4d &lt;dante4d@gmail.com&gt;
 Xephyr -ac -br -noreset -screen 800x600 :1 &amp;
 sleep 1
 DISPLAY=:1.0 awesome -c ~/.config/awesome/rc.lua.new

=== Another script ===


 #!/bin/bash
 # Run Awesome in a nested server for tests
 #
 # Requirements: (Debian)
 #
 #  apt-get install xserver-xephyr
 #  apt-get install -t unstable awesome
 #
 # Based on original script by dante4d &lt;dante4d@gmail.com&gt;
 # See: http://awesome.naquadah.org/wiki/index.php?title=Using_Xephyr
 #
 # URL: http://hellekin.cepheide.org/awesome/awesome_test
 #
 # Copyright (c) 2009 Hellekin O. Wolf &lt;hellekin@cepheide.org&gt;
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 # 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 # 
 
 function usage() 
 {
   cat &lt;&lt;USAGE
 awesome_test start|stop|restart|run
 
   start    Start nested Awesome in Xephyr
   stop     Stop Xephyr
   restart  Reload nested Awesome configuration
   run      Run command in nested Awesome
 
 USAGE
   exit 0
 }
 
 # WARNING: the following two functions expect that you only run one instance
 # of Xephyr and the last launched Awesome runs in it
 
 function awesome_pid() 
 {
   /bin/pidof awesome | cut -d\  -f1
 }
  
 function xephyr_pid()
 
 {
   /bin/pidof Xephyr | cut -d\  -f1
 }
 
 [ $# -lt 1 ] &amp;&amp; usage
 
 # If rc.lua.new is missing, make a default one.
 RC_LUA=~/.config/awesome/rc.lua.new
 test -f $RC_LUA || /bin/cp /etc/xdg/awesome/rc.lua $RC_LUA
 
 # Just in case we're not running from /usr/bin
 AWESOME=`which awesome`
 XEPHYR=`which Xephyr`
 
 test -x $AWESOME || { echo &quot;Awesome executable not found. Please install Awesome&quot;; exit 1; }
 test -x $XEPHYR || { echo &quot;Xephyr executable not found. Please install Xephyr&quot;; exit 1; }
 
 case &quot;$1&quot; in
   start)
     $XEPHYR -ac -br -noreset -screen 800x600 :1 &amp;
     sleep 1
     DISPLAY=:1.0 $AWESOME -c $RC_LUA &amp;
     sleep 1
     echo Awesome ready for tests. PID is $(awesome_pid)
     ;;
   stop)
     echo -n &quot;Stopping Nested Awesome... &quot;
     if [ -z $(xephyr_pid) ]; then
       echo &quot;Not running: not stopped :)&quot;
       exit 0
     else
       kill $(xephyr_pid)
       echo &quot;Done.&quot;
     fi
     ;;
   restart)
     echo -n &quot;Restarting Awesome... &quot;
     kill -s SIGHUP $(awesome_pid)
     ;;
   run)
     shift
     DISPLAY=:1.0 &quot;$@&quot; &amp;
     ;;
   *)
     usage
     ;;
 esac
 #
 #{
 #  /bin/pidof Xephyr | cut -d\  -f1
 #}
 #
 #[ $# -lt 1 ] &amp;&amp; usage
 #
 ## If rc.lua.new is missing, make a default one.
 #RC_LUA=~/.config/awesome/rc.lua.new
 #test -f $RC_LUA || /bin/cp /etc/xdg/awesome/rc.lua $RC_LUA
 #
 ## Just in case we're not running from /usr/bin
 #AWESOME=`which awesome`
 #XEPHYR=`which Xephyr`
 #
 #test -x $AWESOME || { echo &quot;Awesome executable not found. Please install Awesome&quot;; exit 1; }
 #test -x $XEPHYR || { echo &quot;Xephyr executable not found. Please install Xephyr&quot;; exit 1; }
 #
 #case &quot;$1&quot; in
 #  start)
 #    $XEPHYR -ac -br -noreset -screen 800x600 :1 &amp;
 #    sleep 1
 #    DISPLAY=:1.0 $AWESOME -c $RC_LUA &amp;
 #    sleep 1
 #    echo Awesome ready for tests. PID is $(awesome_pid)
 #    ;;
 #  stop)
 #    echo -n &quot;Stopping Nested Awesome... &quot;
 #    if [ -z $(xephyr_pid) ]; then
 #      echo &quot;Not running: not stopped :)&quot;
 #      exit 0
 #    else
 #      kill $(xephyr_pid)
 #      echo &quot;Done.&quot;
 #    fi
 #    ;;
 #  restart)
 #    echo -n &quot;Restarting Awesome... &quot;
 #    kill -s SIGHUP $(awesome_pid)
 #    ;;
 #  run)
 #    shift
 #    DISPLAY=:1.0 &quot;$@&quot; &amp;
 #    ;;
 #  *)
 #    usage
 #    ;;
 # esac

Then

 awesome_test start|stop|restart|run

   start    Start nested Awesome in Xephyr
   stop     Stop Xephyr
   restart  Reload nested Awesome configuration
   run      Run command in nested Awesome

=== Yet another script ===
This script is loosely based on the above by dante4d. It adds functionality to spawn and control multiple instances of Xephyr with -D as well as using different configuration files with -C or window sizes with -S. You may also use it to change themes but there's no warranty attached to the regular expressions.

You can find the script on GitHub: https://github.com/mikar/awmtt</text>
      <sha1>gnmem0fqfih5fxdexr3g2j4hy6tx990</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using Xephyr/ru</title>
    <ns>0</ns>
    <id>469</id>
    <revision>
      <id>6544</id>
      <parentid>6539</parentid>
      <timestamp>2014-05-18T16:00:24Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Обновление перевода(update translating)</comment>
      <text xml:space="preserve" bytes="10977">{{Languages|Using Xephyr}}
{{DISPLAYTITLE:Использование Xephyr}}

На этой странице приведено краткое руководство по запуску вложенных X-серверов (т.е. запуск X-сессии в клиентском окне другой X-сессии) при помощи Xephyr. Это может оказаться полезным для тестирования, например, конфигурационных файлов, не затрагивая работающий Awesome.

Лучше всего запускать Xephyr и Awesome в эмуляторах терминала, чтобы можно было следить за стандартными потоками вывода и ошибок в реальном времени.

== Установка Xephyr ==

=== Archlinux ===

''/usr/bin/Xephyr'' находится в пакете ''xorg-server-xephyr''. Установить его можно следующим образом:

 pacman -S xorg-server-xephyr

=== Gentoo ===

''/usr/bin/Xephyr'' находится в пакете x11-base/xorg-server. Для успешной сборки Xephyr в списке USE-флагов должен присутствовать ''kdrive''.

=== Debian/Ubuntu ===

''/usr/bin/Xephyr'' находится в пакете ''xserver-xephyr''. Его можно установить командой:

  # apt-get install xserver-xephyr

=== Fedora ===

''/usr/bin/Xephyr'' находится в пакете ''xorg-x11-server-Xephyr''.

== Запуск Xephyr ==

Следующая команда запускает новый X-сервер в клиентском окне текущего:

  $ Xephyr -ac -br -noreset -screen 800x600 :1

; -ac : disable access control restrictions
; -br : create root window with black background
; -noreset : don't reset after last client exists
; -screen 800x600 : Specify screen characteristics

Теперь можно запускать приложения внутри клиентской X-сессии, изменяя значение переменной окружения ''DISPLAY'' на '':1.0'':

  $ DISPLAY=:1.0
  $ xterm

Новое окно xterm появится внутри клиентской X-сессии.

== Запуск Awesome в Xephyr ==

Установите переменную DISPLAY:

  $ DISPLAY=:1.0

И запустите Awesome в клиентской X-сессии:

  $ awesome -c ~/.config/awesome/rc.lua.new

Этот способ хорошо подходит для тестирования изменений в ''rc.lua''. В случае наличия каких-либо ошибок Вы не испортите работающий Awesome и не останетесь перед пустым корневым окном, не реагирующим на нажатия каких-либо клавиш.

Вы также можете создать shell скрипт для быстрого запуска:

  Xephyr -ac -br -noreset -screen 1024x768 :1.0 &amp;
  ZEPHYR_PID=$!
  sleep 1
  DISPLAY=:1.0 awesome -c rc.lua
  kill $ZEPHYR_PID

(вызывает awesome использующий оригинальный файл или его копию)

== Дополнительно ==

=== Получение фокуса ввода Xephyr и передача ввода ===

Одна вещь, которую вы быстро заметите, заключается в том, что Awesome не обрабатывает нажатия клавиш для сессии Xephyr. Для исрпавления этой проблеммы, сессия Xephir, должна перехватывать клавиатуру. Пока окно Xephyr имеет фокус ввода, нажмите '''Control-mod3-shift''' для захвата Xephyr фокуса ввода. Теперь вы увидите, что мышь не сможет покинуть это окно. Если вы хотите, чтобы Xephyr отключил фокус ввода, нажмите '''control-shift''' (примечание: на некоторых системах, это может быть ПРАВЫЙ control-shift). Если ваши модификаторы по прежнему не работают, что ж, на некоторых системах Xephir может глючить. Вы можете использовать xmodmap и xev чтобы увидеть в чем ошибка. В моем случае, не была определена &quot;windows key&quot; как Super_L. Я привязал ее для сессии Xephyr испльзуя xmodmap:

  $ xmodmap -
  keycode 133 = Super_L    # Ваш keycode может отличаться. Проверьте код используя xev.
  # Нажмите Control-D для завершения ввода в xmodmap.

Также возможно, что вы не используете раскладку клавиатуры по уполчанию в вашей системе. Поэтому вам придется переделать также и ее.

  $ setxkbmap us dvorak

=== Удалённый перезапуск Awesome ===

Получите идентификатор процесса (pid) вторичного Awesome и отправьте ему сигнал ''SIGHUP'':

  $ pgrep awesome
  $ kill -s SIGHUP &lt;идентификатор_awesome_в_xephyr&gt;

Учитывая то, что ваш основной awesome всегда запускался до xephyr, вы можете записать эти команду в одну строку и оформить ее в виде скрипта.

  $ pgrep awesome | tail -1 | xargs kill -s SIGHUP

Или, если Вы предпочитаете использовать awesome-client:

  $ export DISPLAY=:1.0
  $ echo 'awesome.restart()' | awesome-client

=== Скрипт для отладки rc.lua ===

 #!/bin/bash
 # script xepyhr-awesome
 # author: dante4d &lt;dante4d@gmail.com&gt;
 Xephyr -ac -br -noreset -screen 800x600 :1 &amp;
 sleep 1
 DISPLAY=:1.0 awesome -c ~/.config/awesome/rc.lua.new

=== Другой скрипт ===

 #!/bin/bash
 # Run Awesome in a nested server for tests
 #
 # Requirements: (Debian)
 #
 #  apt-get install xserver-xephyr
 #  apt-get install -t unstable awesome
 #
 # Based on original script by dante4d &lt;dante4d@gmail.com&gt;
 # See: http://awesome.naquadah.org/wiki/index.php?title=Using_Xephyr
 #
 # URL: http://hellekin.cepheide.org/awesome/awesome_test
 #
 # Copyright (c) 2009 Hellekin O. Wolf &lt;hellekin@cepheide.org&gt;
 #
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 # 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
 # 
 
 function usage() 
 {
   cat &lt;&lt;USAGE
 awesome_test start|stop|restart|run
 
   start    Start nested Awesome in Xephyr
   stop     Stop Xephyr
   restart  Reload nested Awesome configuration
   run      Run command in nested Awesome
 
 USAGE
   exit 0
 }
 
 # WARNING: the following two functions expect that you only run one instance
 # of Xephyr and the last launched Awesome runs in it
 
 function awesome_pid() 
 {
   /bin/pidof awesome | cut -d\  -f1
 }
  
 function xephyr_pid()
 
 {
   /bin/pidof Xephyr | cut -d\  -f1
 }
 
 [ $# -lt 1 ] &amp;&amp; usage
 
 # If rc.lua.new is missing, make a default one.
 RC_LUA=~/.config/awesome/rc.lua.new
 test -f $RC_LUA || /bin/cp /etc/xdg/awesome/rc.lua $RC_LUA
 
 # Just in case we're not running from /usr/bin
 AWESOME=`which awesome`
 XEPHYR=`which Xephyr`
 
 test -x $AWESOME || { echo &quot;Awesome executable not found. Please install Awesome&quot;; exit 1; }
 test -x $XEPHYR || { echo &quot;Xephyr executable not found. Please install Xephyr&quot;; exit 1; }
 
 case &quot;$1&quot; in
   start)
     $XEPHYR -ac -br -noreset -screen 800x600 :1 &amp;
     sleep 1
     DISPLAY=:1.0 $AWESOME -c $RC_LUA &amp;
     sleep 1
     echo Awesome ready for tests. PID is $(awesome_pid)
     ;;
   stop)
     echo -n &quot;Stopping Nested Awesome... &quot;
     if [ -z $(xephyr_pid) ]; then
       echo &quot;Not running: not stopped :)&quot;
       exit 0
     else
       kill $(xephyr_pid)
       echo &quot;Done.&quot;
     fi
     ;;
   restart)
     echo -n &quot;Restarting Awesome... &quot;
     kill -s SIGHUP $(awesome_pid)
     ;;
   run)
     shift
     DISPLAY=:1.0 &quot;$@&quot; &amp;
     ;;
   *)
     usage
     ;;
 esac
 #
 #{
 #  /bin/pidof Xephyr | cut -d\  -f1
 #}
 #
 #[ $# -lt 1 ] &amp;&amp; usage
 #
 ## If rc.lua.new is missing, make a default one.
 #RC_LUA=~/.config/awesome/rc.lua.new
 #test -f $RC_LUA || /bin/cp /etc/xdg/awesome/rc.lua $RC_LUA
 #
 ## Just in case we're not running from /usr/bin
 #AWESOME=`which awesome`
 #XEPHYR=`which Xephyr`
 #
 #test -x $AWESOME || { echo &quot;Awesome executable not found. Please install Awesome&quot;; exit 1; }
 #test -x $XEPHYR || { echo &quot;Xephyr executable not found. Please install Xephyr&quot;; exit 1; }
 #
 #case &quot;$1&quot; in
 #  start)
 #    $XEPHYR -ac -br -noreset -screen 800x600 :1 &amp;
 #    sleep 1
 #    DISPLAY=:1.0 $AWESOME -c $RC_LUA &amp;
 #    sleep 1
 #    echo Awesome ready for tests. PID is $(awesome_pid)
 #    ;;
 #  stop)
 #    echo -n &quot;Stopping Nested Awesome... &quot;
 #    if [ -z $(xephyr_pid) ]; then
 #      echo &quot;Not running: not stopped :)&quot;
 #      exit 0
 #    else
 #      kill $(xephyr_pid)
 #      echo &quot;Done.&quot;
 #    fi
 #    ;;
 #  restart)
 #    echo -n &quot;Restarting Awesome... &quot;
 #    kill -s SIGHUP $(awesome_pid)
 #    ;;
 #  run)
 #    shift
 #    DISPLAY=:1.0 &quot;$@&quot; &amp;
 #    ;;
 #  *)
 #    usage
 #    ;;
 # esac

Затем:

 awesome_test start|stop|restart|run

   start    Запуск вложенного Awesome в Xephyr
   stop     Завершение Xephyr
   restart  Перезапуск вложенного Awesome
   run      Запуск команд во вложенном Awesome

=== Еще один скрипт ===

Этот скрипт базируется на работе dante4d. Он содержит дополнительную функциональность для запуска нескольких экземпляров Xephyr с помощью флага -D, использования нескольких конфигураций (-C) и размеров окон (-S). Вы также можете использовать его для смены тем, но корректность работы не гарантируется.

Скрипт находится здесь: https://github.com/mikar/awmtt</text>
      <sha1>qdl1ziww2xbb9859zwhm6pn1ttafprp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using awesome-client outside X (dbus)</title>
    <ns>0</ns>
    <id>718</id>
    <revision>
      <id>6263</id>
      <parentid>6262</parentid>
      <timestamp>2014-02-22T17:45:21Z</timestamp>
      <contributor>
        <username>Mrmew</username>
        <id>3177</id>
      </contributor>
      <comment>added script to allow root user to use awesome-client-wrapper</comment>
      <text xml:space="preserve" bytes="2598">''Original solution here: [http://permalink.gmane.org/gmane.comp.window-managers.awesome/4591]''

=== Problem ===

As you may know awesome-client uses '''dbus''' to send messages to existing instance of awesome running. It works perfectly when you run it from your X session, but sometimes you want more than that. For example, send a message to your Awesome from a ssh-session. Or setup a daemon that notifies Awesome about some events.

=== Solution ===

'''Dbus''' relies on a parameter called '''DBUS_SESSION_BUS_ADDRESS'''. In your X session you have this parameter defined, outside of it this parameter is blank. Fortunately dbus stores the parameters for its session in directory $HOME/.dbus/session-bus.

What you do now is you create a wrapper-script somewhere and put this code there:

  #!/bin/bash 
  if &lt;nowiki&gt;[[ -z &quot;$DBUS_SESSION_BUS_ADDRESS&quot; ]]&lt;/nowiki&gt;; then # Looks like we are outside X
      dbus_file=$(ls $HOME/.dbus/session-bus/ -t1 | head -1) # Get the latest file in session-bus directory
      . &quot;$HOME/.dbus/session-bus/$dbus_file&quot; &amp;&amp; export DBUS_SESSION_BUS_ADDRESS # and export a variable from it
  fi
  /usr/bin/awesome-client

Alternatively, if you get spawned without any environment (e.g. udevil's validate_exec does this, '''HOME''' is not even defined), you can copy the enviroment from the awesome process), like so:

  #!/bin/bash 
  if &lt;nowiki&gt;[[ -z &quot;$DBUS_SESSION_BUS_ADDRESS&quot; ]]&lt;/nowiki&gt;; then # Looks like we are outside X
      eval $(tr '\0' '\n' &lt; /proc/$(pgrep awesome | head -1 )/environ | sed -e 's/^/export /') #export all environment variables
  fi
  /usr/bin/awesome-client

Or, if you want to allow root to use awesome-client also, you would have to impersonate the user:

  #!/bin/bash 
  AWESOME_CLIENT=awesome-client
  AWESOME_PID=$(pgrep awesome | head -1 )
  if &lt;nowiki&gt;[[ -z &quot;$DBUS_SESSION_BUS_ADDRESS&quot; ]]&lt;/nowiki&gt;; then # Looks like we are outside X
      eval $(tr '\0' '\n' &lt; /proc/${AWESOME_PID}/environ | sed -e 's/^/export /') #export all environment variables
  fi
  AWESOME_PID_OWNER=$(stat -c %U /proc/${AWESOME_PID})
  if [[ &lt;nowiki&gt;$EUID&lt;/nowiki&gt; -ne 0 ]]; then # we are not root
      eval &lt;nowiki&gt;$AWESOME_CLIENT&lt;/nowiki&gt;
  else
      su &lt;nowiki&gt;$AWESOME_PID_OWNER&lt;/nowiki&gt; -c &lt;nowiki&gt;$AWESOME_CLIENT&lt;/nowiki&gt;
  fi


Now you can call this script just like you call the original awesome-client, but this script works also in none-X sessions.

Give it a try, try executing this from your tty1, for example:

  echo 'naughty.notify({ text = &quot;hello from tty&quot; })' | ~/myawesomeclient.sh

On your X screen a naughty box should pop up.</text>
      <sha1>ficktx1p8bijaypxapivk8c9ju8swjf</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using dmenu</title>
    <ns>0</ns>
    <id>546</id>
    <revision>
      <id>6568</id>
      <parentid>6193</parentid>
      <timestamp>2014-05-20T14:11:57Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="3226">{{Languages}}

=== Using dmenu ===
I prefer dmenu because of its search style( searching for 'dc' will bring up all the words that contain 'dc', like 'linuxdcpp' and not just 'dcgui' or 'dc2k' )
* Using dmenu in its default avatar is as simple as adding the following key binding.
 awful.key({modkey }, &quot;p&quot;, function() awful.util.spawn( &quot;dmenu_run&quot; ) end)
* Dmenu offers a wide range of options to customize its look and feel. To pass the customization options to dmenu, use awful.util.spawn_with_shell. The color options have been taken from wmii's script.
 awful.key({modkey }, &quot;p&quot;, function()
   awful.util.spawn_with_shell( &quot;exe=`dmenu_path | dmenu -b -nf '#888888' -nb '#222222' -sf '#ffffff' -sb '#285577'` &amp;&amp; exec $exe&quot;)
 end)
* When customizing the font, be sure to use the full name for the font (XLFD), as given by the 'xfontsel' application. E.g.: &quot;-xos4-terminus-medium-r-*-*-22-*-*-*-*-*-*-*&quot; (using &quot;Terminus-22&quot; seems to work in shellscripts, but not when calling from awesome's rc.lua)

=== Integrating with your awesome theme ===
dmenu is a simple tool, but it can be well customized. I did it using [[Beautiful]] values:
 awful.key({ modkey },            &quot;r&quot;,     function ()
     awful.util.spawn(&quot;dmenu_run -i -p 'Run command:' -nb '&quot; .. 
  		beautiful.bg_normal .. &quot;' -nf '&quot; .. beautiful.fg_normal .. 
 		&quot;' -sb '&quot; .. beautiful.bg_focus .. 
 		&quot;' -sf '&quot; .. beautiful.fg_focus .. &quot;'&quot;) 
 	end),

=== Run or raise with dmenu ===
Instead of directly launching dmenu_run, you can get the result of the command and let awesome run command itself. This allow to check if the command is already launched, and show the application instead of launching a new one :

 -- Run or raise applications with dmenu
 awful.key({ modkey }, &quot;r&quot;, function ()
     local f_reader = io.popen( &quot;dmenu_path | dmenu -b -nb '&quot;.. beautiful.bg_normal ..&quot;' -nf '&quot;.. beautiful.fg_normal ..&quot;' -sb '#955'&quot;)
     local command = assert(f_reader:read('*a'))
     f_reader:close()
     if command == &quot;&quot; then return end
 
     -- Check throught the clients if the class match the command
     local lower_command=string.lower(command)
     for k, c in pairs(client.get()) do
         local class=string.lower(c.class)
         if string.match(class, lower_command) then
             for i, v in ipairs(c:tags()) do
                 awful.tag.viewonly(v)
                 c:raise()
                 c.minimized = false
                 return
             end
         end
     end
     awful.util.spawn(command)
 end)

=== Elevated privileges dmenu using gksudo ===
Add this in addition to a regular dmenu to allow running as root

 -- Run or raise applications with dmenu with elevated privileges
 awful.key({ modkey , &quot;Shift&quot;}, &quot;r&quot;, function ()
     local f_reader = io.popen( &quot;dmenu_path | dmenu -i -nb '&quot;.. beautiful.bg_urgent ..&quot;' -nf '&quot;.. beautiful.fg_urgent ..&quot;' -sb '#955'&quot;)
     local command = assert(f_reader:read('*a'))
     f_reader:close()
     if command == &quot;&quot; then return end
     awful.util.spawn(&quot;gksudo &quot; .. command)
 end)


see [http://man.suckless.org/tools/1/dmenu man dmenu] for more info

=== External Links ===
[http://en.wikipedia.org/wiki/Dmenu Wikipedia on dmenu]

[http://tools.suckless.org/dmenu/ Dmenu home page]</text>
      <sha1>dsrospf519w36fy9alm5fko0gv171in</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using dmenu/ru</title>
    <ns>0</ns>
    <id>1063</id>
    <revision>
      <id>6574</id>
      <parentid>6571</parentid>
      <timestamp>2014-05-20T18:12:02Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>correct tag &amp; link</comment>
      <text xml:space="preserve" bytes="4224">{{DISPLAYTITLE:Использование dmenu}}
{{Languages|Using dmenu}}

=== Использование dmenu ===
Я предпочитаю dmenu из-за его поискового стиля (поиск 'dc' выведет все слова содержащие 'dc', такие как 'linuxdcpp', а не только and not 'dcgui' или 'dc2k' )
* Использование dmenu в его реализации по умочанию также просто как добавление клавиатурных сочетаний.
 awful.key({modkey }, &quot;p&quot;, function() awful.util.spawn( &quot;dmenu_run&quot; ) end)
* Dmenu предлагает широкий спектр опций для настройки его внешнего вида. Чтобы передать параметры настройки в dmenu, испльзуйте awful.util.spawn_with_shell. Опции цветов были взяты из скриптов wmii.
 awful.key({modkey }, &quot;p&quot;, function()
   awful.util.spawn_with_shell( &quot;exe=`dmenu_path | dmenu -b -nf '#888888' -nb '#222222' -sf '#ffffff' -sb '#285577'` &amp;&amp; exec $exe&quot;)
 end)
* При настройке шрифтов, обязательно используйте полное название шрифта (XLFD), как указано в приложении 'xfontsel'. Например: &quot;-xos4-terminus-medium-r-*-*-22-*-*-*-*-*-*-*&quot; (используется &quot;Terminus-22&quot; кажется для работы в shellscripts, но не когда вызывается из awesome в rc.lua)

=== Интеграция с вашими темами awesome ===
dmenu это простая утилита, но в то же время отлично настраиваемая. Я использую эти значения [[Beautiful/ru|Beautiful]]:
 awful.key({ modkey },            &quot;r&quot;,     function ()
     awful.util.spawn(&quot;dmenu_run -i -p 'Run command:' -nb '&quot; .. 
  		beautiful.bg_normal .. &quot;' -nf '&quot; .. beautiful.fg_normal .. 
 		&quot;' -sb '&quot; .. beautiful.bg_focus .. 
 		&quot;' -sf '&quot; .. beautiful.fg_focus .. &quot;'&quot;) 
 	end),

=== Запуск или скрытие с dmenu ===
Вместо прямого запуска dmenu_run, вы можете получить результат выполнения команды и позволить awesome самостоятельно запустить команду. Это позволяет проверить запущена ли уже команда, и отобразить прилоежние вместо запуска новой копии:

 -- Run or raise applications with dmenu
 awful.key({ modkey }, &quot;r&quot;, function ()
     local f_reader = io.popen( &quot;dmenu_path | dmenu -b -nb '&quot;.. beautiful.bg_normal ..&quot;' -nf '&quot;.. beautiful.fg_normal ..&quot;' -sb '#955'&quot;)
     local command = assert(f_reader:read('*a'))
     f_reader:close()
     if command == &quot;&quot; then return end
 
     -- Check throught the clients if the class match the command
     local lower_command=string.lower(command)
     for k, c in pairs(client.get()) do
         local class=string.lower(c.class)
         if string.match(class, lower_command) then
             for i, v in ipairs(c:tags()) do
                 awful.tag.viewonly(v)
                 c:raise()
                 c.minimized = false
                 return
             end
         end
     end
     awful.util.spawn(command)
 end)

=== Необходимые привелегии dmenu используя gksudo ===
Добавьте это в дополнение к обычному dmenu, чтобы запускать от имени root

 -- Run or raise applications with dmenu with elevated privileges
 awful.key({ modkey , &quot;Shift&quot;}, &quot;r&quot;, function ()
     local f_reader = io.popen( &quot;dmenu_path | dmenu -i -nb '&quot;.. beautiful.bg_urgent ..&quot;' -nf '&quot;.. beautiful.fg_urgent ..&quot;' -sb '#955'&quot;)
     local command = assert(f_reader:read('*a'))
     f_reader:close()
     if command == &quot;&quot; then return end
     awful.util.spawn(&quot;gksudo &quot; .. command)
 end)


Смотрите [http://man.suckless.org/tools/1/dmenu man dmenu] для получения большей инфомрации.

=== Внешние ссылки ===
[http://en.wikipedia.org/wiki/Dmenu Wikipedia on dmenu]</text>
      <sha1>6ohggjj99kk8rpyuym19g7bledj7dz3</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using redshift with awesome</title>
    <ns>0</ns>
    <id>953</id>
    <revision>
      <id>6522</id>
      <parentid>6276</parentid>
      <timestamp>2014-05-16T14:30:13Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1277">{{Languages}}

[http://jonls.dk/redshift/ Redshift] is a Linux program that adjusts the color temperature of your screen to make it easier on your eyes. The [https://github.com/YoRyan/awesome-redshift awesome-redshift] library integrates it with awesome and offers a small API for controlling redshift and working around some of its limitations, such as the dependency on xrandr. Note, however, that this approach means you can't use the gtk-redshift applet.

=Installation=

Download:
 git clone git://github.com/YoRyan/awesome-redshift.git redshift

rc.lua:
 local redshift = require(&quot;redshift&quot;)
 
 -- set binary path (optional)
 redshift.redshift = &quot;/usr/bin/redshift&quot;
 -- set additional redshift arguments (optional)
 redshift.options = &quot;-c ~/.config/redshift.conf&quot;
 -- 1 for dim, 0 for not dimmed
 redshift.init(1)

=Examples=

Map Super+D to toggle redshift (add this to the ''globalkeys'' section):
 awful.key({modkey}, &quot;d&quot;, redshift.toggle)

Create a menu item that starts gimp and automatically reverts the monitor color:
 mymainmenu = awful.menu({ items = {
     ...
     { &quot;gimp&quot;, function()
         redshift.undim()
         awful.util.spawn(&quot;/usr/bin/gimp&quot;)
     end }
 }})

For more information, see the [https://github.com/YoRyan/awesome-redshift project page].</text>
      <sha1>99lyjlbjtug3cbf6aw8r1wupl1rkfaa</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Using redshift with awesome/ru</title>
    <ns>0</ns>
    <id>1051</id>
    <revision>
      <id>6524</id>
      <timestamp>2014-05-16T14:48:20Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Created page with &quot;{{DISPLAYTITLE:Использование redshift в awesome}} {{Languages|Using redshift with awesome}}  [http://jonls.dk/redshift/ Redshift] это Linux программа...&quot;</comment>
      <text xml:space="preserve" bytes="2011">{{DISPLAYTITLE:Использование redshift в awesome}}
{{Languages|Using redshift with awesome}}

[http://jonls.dk/redshift/ Redshift] это Linux программа, которая регулирует цветовую темпертуру экрана, что снижает нагрузку на глаза. Библиотека [https://github.com/YoRyan/awesome-redshift awesome-redshift] интегрирует ее в awesome  и добавляет небольшое API для контроля и работы в обход его ограничений, таких как зависимость от xrandr. Однако следует отметить, что этот подход означает, что вы не сможете использовать аплет gtk-redshift.

=Установка=

Загрузите:
 git clone git://github.com/YoRyan/awesome-redshift.git redshift

Затем добавьте в rc.lua:
 local redshift = require(&quot;redshift&quot;)
 
 -- установка пути до программы(опционально)
 redshift.redshift = &quot;/usr/bin/redshift&quot;
 -- установка дополнительных аргументов redshift(опционально)
 redshift.options = &quot;-c ~/.config/redshift.conf&quot;
 -- 1 for dim, 0 for not dimmed
 redshift.init(1)

=Пример=

Назначьте Super+D для переключения режимов redshift (добавьте этот код в секцию ''globalkeys''):
 awful.key({modkey}, &quot;d&quot;, redshift.toggle)

Создайте пункт меню, который запускает gimp и автоматически инвертирует цвета монитора:
 mymainmenu = awful.menu({ items = {
     ...
     { &quot;gimp&quot;, function()
         redshift.undim()
         awful.util.spawn(&quot;/usr/bin/gimp&quot;)
     end }
 }})

Если вам необходимо больше информации, смотрите [https://github.com/YoRyan/awesome-redshift страницу проекта].</text>
      <sha1>avqza0b4chx55oj5lgwlaojg7swpcr7</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Uzsolt TaskCoach information</title>
    <ns>0</ns>
    <id>267</id>
    <revision>
      <id>3330</id>
      <parentid>2723</parentid>
      <timestamp>2009-07-14T09:43:31Z</timestamp>
      <contributor>
        <username>Uzsolt</username>
        <id>13</id>
      </contributor>
      <comment>Added tasks and tc_db_tasks reset</comment>
      <text xml:space="preserve" bytes="4716">If you use [http://www.taskcoach.org/ TaskCoach], maybe want to know small information about your tasks without running TaskCoach. So, here is the solution.
You'll need [http://luaforge.net/projects/etree/ Lua Element Tree] only (and of course, its dependency [http://luaforge.net/projects/luaexpat/ LuaExpat]). And of course a textbox with name &quot;tb_todo&quot; (you can use other name ;) ).

 TC_SUBJECT=&quot;subject&quot;
 TC_ID=&quot;id&quot;
 TC_TASKLIST=&quot;categorizables&quot;
 TC_COLOR=&quot;color&quot;
 TC_PRIOR=&quot;priority&quot;
 
 tasks = {}
 tc_db_tasks = {}
 
 function hook_taskcoach_reload()
    local nrtasks=1
    f = io.open(&quot;YourTaskCoachFile&quot;,&quot;r&quot;)
    if f then
        s = f:read(&quot;*all&quot;)
        f:close()
    end
   
    tasks = {}
    tc_db_tasks = {}
    
    i = string.find(s,&quot;&lt;category&quot;)
    tc_tasks = string.sub(s,1,i-1) .. &quot;&lt;/tasks&gt;&quot;
    tc_cat = string.sub(s,1,string.find(s,&quot;&lt;tasks&gt;&quot;)-1) .. &quot;&lt;tasks&gt;&quot; .. string.sub(s,i,string.find(s,&quot;&lt;syncml&quot;)-1) .. &quot;&lt;/tasks&gt;&quot;
    tc_db_tasks = etree.fromstring(tc_tasks)
 
    for i=1,#tc_db_tasks do
        if not tc_db_tasks[i].attr[&quot;completiondate&quot;] then
            tasks[nrtasks] = {}
            tasks[nrtasks].subject = tc_db_tasks[i].attr[TC_SUBJECT]
            tasks[nrtasks].id = tc_db_tasks[i].attr[TC_ID]
            if tc_db_tasks[i].attr[TC_PRIOR] then
                tasks[nrtasks].priority = tonumber(tc_db_tasks[i].attr[TC_PRIOR])
            else
                tasks[nrtasks].priority = 0
            end
            tasks[nrtasks].category = {}
            nrtasks = nrtasks + 1
        end
    end
 
    tc_db_cat = etree.fromstring(tc_cat)
    taskcoach_walk(tc_db_cat,&quot;&quot;,&quot;&quot;)
    table.sort(tasks,function(a,b) return a.priority &gt; b.priority end)
 end
 
 function hook_taskcoach_print()
    tb_todo.text = #tasks
 end
 
 function taskcoach_walk(where,cat,color)
    if where then
        local i
        for i=1,#where do
            local tmp = cat
            local tmp_color
            if where[i] then if where[i].attr then
                if where[i].attr[TC_COLOR] then
                    tmp_color = where[i].attr[TC_COLOR]
                else
                    tmp_color = color
                end
                if where[i].attr[TC_SUBJECT] then
                    if tmp ~= &quot;&quot; then
                        tmp = tmp .. &quot;/&quot;
                    else
                        tmp = &quot;(&quot;
                    end
                    tmp = tmp ..  where[i].attr[TC_SUBJECT]
                    for j=1,#tasks do
                        if where[i].attr[TC_TASKLIST] then
                            k = string.find(where[i].attr[TC_TASKLIST],tasks[j].id)
                            if k then
                                tasks[j].category[#tasks[j].category+1]=tmp .. &quot;)&quot;
                                local color_dec = {}
                                local TMP_COLOR = tmp_color
                                for l=1,3 do
                                    color_b, color_e = string.find(TMP_COLOR,&quot;%d+,&quot;)
                                    color_dec[l] = string.sub(TMP_COLOR,color_b,color_e-1)
                                    TMP_COLOR = string.sub(TMP_COLOR,color_e+1,-1)
                                end
                                tasks[j].color = string.format(&quot;#%.2X%.2X%.2X&quot;,color_dec[1],color_dec[2],color_dec[3])
                            end
                        end
                    end
                end
            end end
            taskcoach_walk(where[i],tmp,tmp_color)
        end
    end
 end
 
 awful.hooks.timer.register(60, hook_taskcoach_reload)
 awful.hooks.timer.register(10, hook_taskcoach_print)

And maybe you can create a mouse-binding to ''tb_todo'':

 tb_todo:buttons({
    button({},1,function() hook_print_tasks() end)
 })
 
 notify_tasks = nil 
 function hook_print_tasks ()
    if not notify_tasks then 
        local msg = &quot;&quot;
        for i=1,#tasks do
            tmp = tasks[i].subject
            for j=1,#tasks[i].category do
                if tasks[i].priority then msg = msg .. tasks[i].priority .. &quot; &quot; end 
                msg = msg .. &quot;&lt;span color='&quot; .. tasks[i].color .. &quot;'&gt;&quot;
                msg = msg .. tasks[i].subject .. &quot; &quot; ..  tasks[i].category[j] .. &quot;&lt;/span&gt;\n&quot;
            end 
        end 
        notify_tasks = naughty.notify({ 
            text = msg, 
            title = &quot;Teendők&quot;,
            timeout = 0,  
            position = pos,
            width = 600,
            bg = &quot;#000000cc&quot;,
            border_color = &quot;#aa0000&quot;,
            border_width = 7,
            run = function() naughty.destroy(notify_tasks) notify_tasks = nil end
        })  
    else
        naughty.destroy(notify_tasks)
        notify_tasks = nil 
    end 
 end

[[Category:Awesome3]]</text>
      <sha1>pe51tqeuoc4i5tqgw7tsro0ir96euyq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Uzsolt moc widget</title>
    <ns>0</ns>
    <id>189</id>
    <revision>
      <id>2789</id>
      <parentid>2705</parentid>
      <timestamp>2009-05-23T11:26:46Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Widgets]]</comment>
      <text xml:space="preserve" bytes="1322">Only a skeleton to create a hook to [http://moc.daper.net/ moc] (music on console):


 function hook_moc()
        moc_info = io.popen(&quot;mocp -i&quot;):read(&quot;*all&quot;)
        moc_state = string.gsub(string.match(moc_info, &quot;State: %a*&quot;),&quot;State: &quot;,&quot;&quot;)
        if moc_state == &quot;PLAY&quot; or moc_state == &quot;PAUSE&quot; then
            moc_artist = string.gsub(string.match(moc_info, &quot;Artist: %C*&quot;), &quot;Artist: &quot;,&quot;&quot;)
            moc_title = string.gsub(string.match(moc_info, &quot;SongTitle: %C*&quot;), &quot;SongTitle: &quot;,&quot;&quot;)
            moc_curtime = string.gsub(string.match(moc_info, &quot;CurrentTime: %d*:%d*&quot;), &quot;CurrentTime: &quot;,&quot;&quot;)
            moc_totaltime = string.gsub(string.match(moc_info, &quot;TotalTime: %d*:%d*&quot;), &quot;TotalTime: &quot;,&quot;&quot;)
            if moc_artist == &quot;&quot; then 
                moc_artist = &quot;unknown artist&quot; 
            end
            if moc_title == &quot;&quot; then 
                moc_title = &quot;unknown title&quot; 
            end
            moc_string = &quot;MOC: &quot; .. moc_artist .. &quot; - &quot; .. moc_title .. &quot;(&quot; .. moc_curtime .. &quot;/&quot; .. moc_totaltime .. &quot;)&quot;
            if moc_state == &quot;PAUSE&quot; then 
                moc_string = &quot; &lt;nowiki&gt;[[&lt;/nowiki&gt; &quot; .. moc_string .. &quot; &lt;nowiki&gt;]]&lt;/nowiki&gt;&quot;
            end
        else
            moc_string = &quot;-- not playing --&quot;
        end
        tb_moc.text = moc_string
 end

[[Category:Awesome3]]
[[Category:Widgets]]</text>
      <sha1>1d9l3zzkcvzc0vlujj4abq7j2uz8h0y</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Uzsolt newsreader (newsbeuter, liferea) information</title>
    <ns>0</ns>
    <id>192</id>
    <revision>
      <id>5483</id>
      <parentid>5438</parentid>
      <timestamp>2012-05-12T13:37:01Z</timestamp>
      <contributor>
        <username>Uzsolt</username>
        <id>13</id>
      </contributor>
      <comment>Add newsbeuter support</comment>
      <text xml:space="preserve" bytes="10579">An external solution is [http://awesome.naquadah.org/wiki/index.php?title=News_reader_in_Status_Bar here] (you'll need overwrite to use in awesome 3.x). But if you want it with lua, see above.

You'll need [http://www.mroth.net/lua-sqlite3/ lua-sqlite3], and add ''require(&quot;sqlite3&quot;)'' to your ''rc.lua'', and a textbox (e.g. tb_rss).
Create a hook e.g. hook_rss_*.

== [http://www.newsbeuter.org/ Newsbeuter] &quot;version&quot; ==

 function hook_rss_newsbeuter()
     db = sqlite3.open(&quot;/home/zsolt/.newsbeuter/cache.db&quot;)
     row = db:first_irow(&quot;SELECT COUNT(*) FROM rss_item WHERE unread=1;&quot;)
     tb_rss.text = &quot;Unread items: &quot; .. row[1]
     db:close()
 end

== [http://liferea.sourceforge.net Liferea] &quot;version&quot; ==

 function hook_rss_liferea()
     db = sqlite3.open(&quot;/home/zsolt/.liferea_1.7/liferea.db&quot;)
     row = db:first_irow(&quot;SELECT COUNT(*) FROM items where read = 0 and comment = 0;&quot;)
     tb_rss.text = &quot;Unread items: &quot; .. row[1]
     db:close()
 end

You should change ''/home/zsolt'' to your home directory, or use os.getenv(&quot;HOME&quot;).

And register it:

 awful.hooks.timer.register(60,hook_rss_newsbeuter)

I think, that refresh in every minutes (60 secs) is enough. But if you want more, you can overwrite 60 ;)

== Another and complicated version ==

In this case you '''don't need''' any external lua library!

You should create a script, named by ''liferea-unread-items'':

 #!/bin/bash
 LOGFILE=$HOME/logfiles/liferea-unread-items
 
 sqlite3 ~/.liferea_1.8/liferea.db &quot;SELECT COUNT(*) FROM items WHERE read=0 AND comment=0 ; \
    SELECT node.title,GROUP_CONCAT(items.title,'@') \
        FROM items JOIN node ON node.node_id=items.node_id \
        WHERE items.read=0 AND items.comment=0 \
        GROUP BY items.node_id ORDER BY node.title;&quot; &gt; $LOGFILE

If you prefer ''newsbeuter'':

 #!/bin/bash                                                                                                                                                             
 LOGFILE=$HOME/logfiles/newsbeuter-unread-items                                                                                                                          
                                                                                                                                                                 
 sqlite3 ~/.config/newsbeuter/cache.db &quot;SELECT COUNT(*) FROM rss_item WHERE unread=1; \                                                                                  
    SELECT                                                                                                                                                              
        rss_feed.title,                                                                                                                                                 
        GROUP_CONCAT(rss_item.title,'@')                                                                                                                                
    FROM rss_item \                                                                                                                                                     
    JOIN rss_feed ON rss_feed.rssurl=rss_item.feedurl \                                                                                                                 
    WHERE unread=1                                                                                                                                                      
    GROUP BY rss_feed.rssurl;&quot; &gt; $LOGFILE 

These scripts will feeds the ''LOGFILE'' file (see in ''hook_rss()'' and ''tooltip.timer_function()'' too): first line is the unread items, after this unread items grouped by folder: ''FolderName|UnreadItems'' (items are separated by ''@'' character). Each line is each folder.

Put this script to crontab (per user)! In my case it runs in every minutes.

You should create a textbox (''textboxes[&quot;rss&quot;]'' in my case) to display number of unread items and create a timer to fill textbox's field (if your ''LOGFILE'' is ''newsbeuter-unread-items'' please change it):

 function hook_rss()                                                                                                                                                     
    local f = io.open(os.getenv(&quot;HOME&quot;) .. &quot;/logfiles/liferea-unread-items&quot;)                                                                                                
    local s = f:read(&quot;*line&quot;)                                                                                                                                           
    f:close()                                                                                                                                                           
    textboxes[&quot;rss&quot;].text = coloring(s,&quot;#00ff00&quot;)                                                                                                                       
 end                                                            

You can create a tooltip to ''textboxes[&quot;rss&quot;]'':

 tooltip[&quot;rss&quot;] = awful.tooltip({                                                                                                                                        
    objects = { iconboxes[&quot;rss&quot;], textboxes[&quot;rss&quot;] },                                                                                                                   
    timer_function = function()                                                                                                                                         
        local maximum_per_node = 3
        local f = io.open(os.getenv(&quot;HOME&quot;) .. &quot;/logfiles/liferea-unread-items&quot;)                                                                                                                                      
        local line = f:read(&quot;*line&quot;)                                                                                                                                                 
        if (line==&quot;0&quot;) then
            return awful.util.escape(&quot; &lt;&lt; No unread news &gt;&gt; &quot;)
        end
        local line = f:read(&quot;*line&quot;)                                                                                        
        local ret = &quot;&quot;                                                                                                                                    
        while (line~=nil) do                                                                                                                                            
            local i,j = line:find(&quot;|&quot;)                                                                                                                                  
            local tag = line:sub(1,j-1)                                                                                                                                 
            ret = ( (ret==&quot;&quot;) and &quot;&quot; or (ret .. &quot;\n&quot;) ) ..                                                                                                              
                awful.util.escape( &quot; &lt;&lt; &quot; .. tag .. &quot; &gt;&gt;&quot;)                                                                                          
            line = line:sub(j+1,-1)                                                                                                                                     
            local item_number = 0                                                                                                                                       
            while (line~=&quot;&quot;) do                                                                                                                                         
                local ii,ij = line:find(&quot;@&quot;)                                                                                                                            
                ij = ij and ij or 0    
                ret = ret .. &quot;\n\t&quot; .. awful.util.escape(line:sub(1,ij-1))                                                                                             
                line = (ij==0) and &quot;&quot; or line:sub( ij+1,-1)                                                                                                             
                item_number = item_number + 1                                                                                                                           
                if (item_number==maximum_per_node) then                                                                                                                 
                    if (line~=&quot;&quot;) then                                                                                                                                  
                        line = &quot;&quot;                                                                                                                                       
                        ret = ret .. &quot;\n\t [ ... ]&quot;                                                                                                                     
                    end                                                                                                                                                 
                end                                                                                                                                                     
            end                                                                                                                                                         
            line = f:read(&quot;*line&quot;)                                                                                                                                      
        end                                                                                                                                                             
        f:close()                                                                                                                                                       
        return ret                                                                                                                                                      
    end,                                                                                                                                                                
 })

It will displays unread items grouped by folder (max. ''maximum_per_node'' per folder).

[[Category:Awesome3]]</text>
      <sha1>gzdrcqiuq4rfr5mkbdd2eysa17m3vq8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Vain/ru</title>
    <ns>0</ns>
    <id>1118</id>
    <revision>
      <id>6775</id>
      <timestamp>2014-06-11T20:01:55Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>Перевод Vain (translating page)</comment>
      <text xml:space="preserve" bytes="41895">{{DISPLAYTITLE:Vain - альтернативные схемы}}

На сегодняшний день существует 2 версии Vain.
* версия для Awesome &lt;= 3.4 https://github.com/vain/awesome-vain
* версия для Awesome 3.5 https://github.com/copycat-killer/vain-again
Версия для 3.5 является портом от copycat-killer, так как автор пользуется 3.4 и пока не произвел обновления.(я думаю, теперь уже и не будет).

== Установка Vain ==
Awesome 3.4
  git clone https://github.com/vain/awesome-vain.git ~/.config/awesome/vain
Awesome 3.5
  git clone https://github.com/copycat-killer/vain-again.git ~/.config/awesome/vain

== Использование ==

В принципе, все, что вам нужно сделать это подключить модуль:
&lt;pre&gt;
require(&quot;vain&quot;)
vain.widgets.terminal = &quot;xterm&quot;
&lt;/pre&gt;
Некоторым виджетам в Vain необходим терминал, поэтому вам необходимо настроить эту возможность. Вызов терминала может быть функцией Lua, которая принимает один параметр. Что то похожее на: 

&lt;pre&gt;
function footerm(cmd)
    awful.util.spawn(&quot;xterm -e &quot; .. cmd)
end

vain.widgets.terminal = footerm
&lt;/pre&gt;

Хотя это вариант довольно бесполезен, но вы можете придумать что то лучшее.

Каталог vain должен находится в том же месте, что и ваш файл rc.lua
&lt;pre&gt;
$ pwd
/home/void/.config/awesome
$ tree -l
.
|-- rc.lua
|-- themes -&gt; ../.awesome-themes/
|   |-- ...
|   `-- ...
`-- vain -&gt; ../.awesome-vain/vain
    |-- init.lua
    |-- layout
    |   |-- browse.lua
    |   |-- gimp.lua
    |   |-- init.lua
    |   |-- termfair.lua
    |   `-- uselessfair.lua
    |-- util.lua
    `-- widgets.lua
&lt;/pre&gt;

== Layouts ==
===Как вообще работают layouts? ===

&quot;layout&quot; это просто таблица lua или модуль, которая имеет название и вызываемую функцию arrange(). Таким образом, самый простой layout может выглядеть следующим образом:

&lt;pre&gt;
mylayout = {}
mylayout.name = &quot;hurz&quot;
mylayout.arrange = function(p) end
&lt;/pre&gt;

Для использования этого layout в теге, вам необходимо написать:
&lt;pre&gt;
awful.layout.set(mylayout, tags[1][7])
&lt;/pre&gt;

(Конечно, вы можете просто добавить его в стандартную таблицу layouts.)

Теперь функция arrange принимает параметр 'p', который является другой таблицей. Наиболее важными элементами этой таблицы являются workarea и clients. Вот как может выглядеть таблица 'p':
&lt;pre&gt;
p = {
    workarea = { x, y, width, height },
    clients = { ... },
    ...
}
&lt;/pre&gt;

Задачей функции arrange является перебор всех клиентов и установка их геометрии. То есть, для каждого клиента вы вызываете установщик geometry:
&lt;pre&gt;
mylayout.arrange = arrange(p)

    local wa = p.workarea
    local cls = p.clients

    for k, c in ipairs(cls)
    do
        local g = {}

        g.width = ...
        g.height = ...
        g.x = wa.x + ...
        g.y = wa.y + ...

        c:geometry(g)
    end
end
&lt;/pre&gt;

Это все! А обработчик Awesome берет на себя всю остальную (трудоемкую) работу, вроде сворачивания клиента, плавающего режима клиента, порядка расположения клиентов, фокус, отрисовка границ окна, и т.д.

=== Иконки ===

Благодарю Nicolas Estibals (https://github.com/nestibal) за создание иконок для стандартной темы Awesome!

Вам необходимо расширить ваш theme.lua следующим образом. Для этого создайте файл, и предположим назовите его ~/.config/awesome/extended_default_theme.lua):
&lt;pre&gt;
dofile(&quot;/usr/share/awesome/themes/default/theme.lua&quot;)   --здесь мы добавляем данные из стандартной темы
...
theme.layout_termfair      = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/vain/themes/default/layouts/termfairw.png&quot;
theme.layout_browse        = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/vain/themes/default/layouts/browsew.png&quot;
theme.layout_gimp          = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/vain/themes/default/layouts/gimpw.png&quot;
theme.layout_cascade       = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/vain/themes/default/layouts/cascadew.png&quot;
theme.layout_cascadebrowse = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/vain/themes/default/layouts/cascadebrowsew.png&quot;
theme.layout_centerwork    = os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/vain/themes/default/layouts/centerworkw.png&quot;
...
return theme
&lt;/pre&gt;
Лучше использовать отдельный файл для расширенных layout, т.к. если в дальнейшем вы удалите vain, или что то еще поменяете, то сложно будет вернуть все назад. Затем, необходимо настроить beautiful для использования этой, расширенной темы:
&lt;pre&gt;
beautiful.init(os.getenv(&quot;HOME&quot;) .. &quot;/.config/awesome/extended_default_theme.lua&quot;)
&lt;/pre&gt;

Иконки для стандартной темы доступны в двух цветах: белом и черном. Также доступны иконки для темы &quot;zenburn&quot; theme.

=== Новые схемы ===

Скриншоты схем вы можете найти на странице http://www.uninformativ.de/projects/?q=awesome-vain
====termfair====

Я очень много работаю в терминале. Стандартные тайлинговые алгоритмы обычно разворачивают окно на весь экран, так, что вы получаете терминал с количеством столбцов около 200 или даже более. Это слишком много. Вы пробовали читать страницы руководства(manpage) в терминале такого размера?

Данный layout ограничивает размер каждого окна. Каждое окно будет иметь одинаковую ширину, но может изменяться по высоте. Кроме того, окна выровнены по левому краю. Основная рабочая схема следующая (число над экраном это число открытых окон, число в клетке, это фиксированный номер клиента):
&lt;pre&gt;
     (1)                (2)                (3)
+---+---+---+      +---+---+---+      +---+---+---+
|   |   |   |      |   |   |   |      |   |   |   |
| 1 |   |   |  -&gt;  | 2 | 1 |   |  -&gt;  | 3 | 2 | 1 |  -&gt;
|   |   |   |      |   |   |   |      |   |   |   |
+---+---+---+      +---+---+---+      +---+---+---+

     (4)                (5)                (6)
+---+---+---+      +---+---+---+      +---+---+---+
| 4 |   |   |      | 5 | 4 |   |      | 6 | 5 | 4 |
+---+---+---+  -&gt;  +---+---+---+  -&gt;  +---+---+---+
| 3 | 2 | 1 |      | 3 | 2 | 1 |      | 3 | 2 | 1 |
+---+---+---+      +---+---+---+      +---+---+---+
&lt;/pre&gt;
Первый клиент будет размещен в левом столбце. При открытии нового окна, это новое окно будет размещено в левом столбце, а предыдущее, первое окно будет перемещено в средний столбец. После заполнения ряда, новый ряд будет создан над ним.

Число столбцов является фиксированным и управляется значением nmaster тега. Число рядов обычно меняется, но вы можете установить минимальное значение установив значение ncol тега.

Следующие настройки устанавливают termfair layout на 7й тег 1го экрана, и устанавливают 3 столбца и как минимум 2 строки:
&lt;pre&gt;
awful.layout.set(vain.layout.termfair, tags[1][7])
awful.tag.setnmaster(3, tags[1][7])
awful.tag.setncol(2, tags[1][7])
&lt;/pre&gt;

====browse====

Очень широкое окно браузера может раздражать глаза. Некоторые страницы ограничивают ширину колонок, но многие этого не делают. Последние будут не очень хорошо восприниматься, так как ваши глаза постоянно будут бегать туда-сюда вдоль длинных строк.

Схема 'browse' имеет фиксированное количество столбцов, где левый столбец предназначен для браузера. Его размер контролируется mwfact тега. Дополнительные окна будут открываться в другом столбце, справа от вашего браузера. Новые окна будут располагаться над старыми.
&lt;pre&gt;
    (1)              (2)              (3)              (4)
+-----+---+      +-----+---+      +-----+---+      +-----+---+
|     |   |      |     |   |      |     | 3 |      |     | 4 |
|     |   |      |     |   |      |     |   |      |     +---+
|  1  |   |  -&gt;  |  1  | 2 |  -&gt;  |  1  +---+  -&gt;  |  1  | 3 |
|     |   |      |     |   |      |     | 2 |      |     +---+
|     |   |      |     |   |      |     |   |      |     | 2 |
+-----+---+      +-----+---+      +-----+---+      +-----+---+
&lt;/pre&gt;
На своем ноутбуке, я размещаю правую колонку поверх(top) колонки браузера: Дополнительные окна в этом случае перекрывают окно браузера. Это необычно для тайлинговой схемы, но мне это необходимо: При серфинге в интернете, я часто открываю окно терминала (обычно на несколько минут, после чего закрываю их). Как правило, при изменении размера окна браузера, большинство браузеров &quot;съезжают&quot; с текущей позиции. Таким образом, мне приходилось бы прокручивать страницу, чтобы найти место, на котором я открыл терминал. А это раздражает.

Будет ли вторичный столбец размещаться поверх окна браузера или нет, управляется значением ncol тега. Значение равное 1 означает, &quot;перекрывание вторичным столбцом&quot;(overlapping slave column), а все прочие значение означают &quot;не перекрывать окна&quot;(don't overlap windows).

Таким образом, следующий код, установит схему ''browse'' в теге 7 экрана 1. Главный столбец будет иметь половину ширины экрана, а в другой половине будут размещаться вторичные окна.
&lt;pre&gt;
awful.layout.set(vain.layout.browse, tags[1][7])
awful.tag.setmwfact(0.5, tags[1][2])
awful.tag.setncol(1, tags[1][7])
vain.layout.browse.extra_padding = 5
&lt;/pre&gt;

extra_padding уменьшает размер главного окна, если активировано &quot;overlapping slave column&quot;. Это позволяет вам видеть, если есть какие то окна во вторичном столбце.

====gimp====

''Обратите внимание: С версии Gimp 2.8, эта схема устарела и больше не поддерживается. Может быть она и будет работать, но я ее больше не использую.  В Gimp 2.8 есть &quot;single window mode&quot;, который делает все что нужно.''

Gimp это нечто особенное. Многие люди не используют Gimp, потому что в нем &quot;слишком много окон&quot;. Используя специальную схему для Awesome, вы можете решить эту &quot;проблему&quot;. (на самом деле я не считаю это проблемой.)

В схема gimp используется один большой слот для окна изображения Gimp'а. Справа, одни слот для каждого toolbox или dock. Окнам не являющимся окнами Gimp устанавливается плавающий(floating) режим.
&lt;pre&gt;
+-------+---+---+
|       |   |   |
| Image | T | D |
|       |   |   |
+-------+---+---+
&lt;/pre&gt;
По умолчанию (т.е., если ncol = 1), при открытии еще одного изображения, его окно будет размещено поверх первого изображения, перекрывая его. Так обычно, вы видете только одно изображение, потому что работаете только ним. Вы можете использовать переключатель приложения или горячие клавиши, чтобы переключится на другое изображение (смотрите menu_clients_current_tags в секции &quot;Utility functions&quot;).

Иногда вам может понадобится получить лучшее представление от открытых изображениях. Установив значение ncol = 2, вы можете переключиться в &quot;каскадный режим&quot;:
&lt;pre&gt;
+-------------+---+---+
|     +-----+ |   |   |
|     |     | |   |   |
|   +-| Img | |   |   |
|   | |     | |   |   |
| +-| +-----+ | T | D |
| | |     |   |   |   |
| | +-----+   |   |   |
| |     |     |   |   |
| +-----+     |   |   |
+-------------+---+---|
&lt;/pre&gt;
Вы можете управлять смещением каждого окна установив глобальную переменную vain.layout.gimp.cascade_offset. По умолчанию значение равно 16 пикселям.

Если значение ncol равно 2, все изображения будут сложены в стопку в главном слоте:
&lt;pre&gt;
+-------+---+---+
| Image |   |   |
+-------+   |   |
| Image | T | D |
+-------+   |   |
| Image |   |   |
+-------+---+---+
&lt;/pre&gt;
Опять же,mwfact контролирует ширину главного слота. Следующий пример демонстрирует использование схемы 'gimp' в 7-м теге 1-го экрана, по умолчанию в  &quot;stacking mode&quot; и главным слотом имеющим ширину 75% от экрана:
&lt;pre&gt;
awful.layout.set(vain.layout.gimp, tags[1][7])
awful.tag.setmwfact(0.75, tags[1][2])
awful.tag.setncol(3, tags[1][7])
&lt;/pre&gt;
Однако, этого не достаточно. Стандатные правила(rules) в Awesome устанавливают плавающий режим(floating) для toolboxes и docks, так как они являются служебными окнами. Но: Схема не может управлять плавающими окнами. Так что вам понадобится установить rules которые устанавливают toolboxes обратно в нормальный режим. Вы должны добавить эти правила к вашему разделу rules:
&lt;pre&gt;
awful.rules.rules = awful.util.table.join(
    awful.rules.rules,
    vain.layout.gimp.rules
)
&lt;/pre&gt;
Вы также можете использовать свои собственные rules, например, чтобы перемещать окна Gimp на определенный тег.

====cascade====

Размещает все окна каскадом (смотрит схему 'gimp' в теге.

Вы можете управлять смещением изменяя значения двух переменных:
&lt;pre&gt;
vain.layout.cascade.cascade_offset_x = 64
vain.layout.cascade.cascade_offset_y = 16
&lt;/pre&gt;
Следующий пример резервирует место под 5 окон:
&lt;pre&gt;
awful.tag.setnmaster(5, tags[s][1])
&lt;/pre&gt;
До тех пор пока не будет создано 5 окон, их размеры не будут изменяться.

====cascadebrowse====

Аналогично обычной схеме 'browse', однако, клиенты на вторичной колонке расположены каскадом. Таким образом используются аналогичные настройки:

&lt;pre&gt;
vain.layout.cascadebrowse.cascade_offset_x = 2
vain.layout.cascadebrowse.cascade_offset_y = 32
vain.layout.cascadebrowse.extra_padding = 5
awful.tag.setnmaster(5, tags[s][1])
awful.tag.setncol(1, tags[s][1])
&lt;/pre&gt;

Я рекомендую устанавливать cascade_offset_x на малое значение или даже 0, чтобы избежать потери места.

Смотрите схему 'browse' для разъяснения значений extra_padding и ncol.

====uselessfair====

Это схема является дубликатом стоковой схемы  ''fair''. Но, дополнительно я добавил &quot;бесполезные пробелы&quot;(useless gaps) (подробнее смотри ниже) к этой схеме. Использование будет выглядеть следующим образом:
&lt;pre&gt;
awful.layout.set(vain.layout.uselessfair, tags[1][7])
&lt;/pre&gt;

====centerwork====

Вы начинаете с одним окном, расположенным по центру горизонтально:
&lt;pre&gt;
+--------------------------+
|       +----------+       |
|       |          |       |
|       |          |       |
|       |          |       |
|       |   MAIN   |       |
|       |          |       |
|       |          |       |
|       |          |       |
|       |          |       |
|       +----------+       |
+--------------------------+
&lt;/pre&gt;

Это главное рабочее окно. Большую часть работы вы делаете здесь. Иногда, вы можете открывать дополнительные окна. Они будут располагаться в следующих четырех слотах:
&lt;pre&gt;
+--------------------------+
| +---+ +----------+ +---+ |
| |   | |          | |   | |
| | 0 | |          | | 1 | |
| |   | |          | |   | |
| +---+ |   MAIN   | +---+ |
| +---+ |          | +---+ |
| |   | |          | |   | |
| | 2 | |          | | 3 | |
| |   | |          | |   | |
| +---+ +----------+ +---+ |
+--------------------------+
&lt;/pre&gt;
Да, число &quot;четыре&quot; фиксировано. В общей сложности, вы можете открыть пять окон с этой схемой. Дополнительные окна не поддерживаются и им устанавливается плавающий режим(floating). Это сделано намерено.

Установите схему на одном из ваших тегов:
&lt;pre&gt;
awful.layout.set(vain.layout.centerwork, tags[s][t])
&lt;/pre&gt;
Вы можете определить порядок четырех дополнительных окон. Это стандартная конфигурация:
&lt;pre&gt;
vain.layout.centerwork.top_left = 0
vain.layout.centerwork.top_right = 1
vain.layout.centerwork.bottom_left = 2
vain.layout.centerwork.bottom_right = 3
&lt;/pre&gt;
Это означает: Нижний левый слот будет присвоен третьему окну (не считаю главного окна). Предположим, вы хотите, чтобы ваши окна располагались в следующем порядке:
&lt;pre&gt;
+--------------------------+
| +---+ +----------+ +---+ |
| |   | |          | |   | |
| | 3 | |          | | 0 | |
| |   | |          | |   | |
| +---+ |   MAIN   | +---+ |
| +---+ |          | +---+ |
| |   | |          | |   | |
| | 2 | |          | | 1 | |
| |   | |          | |   | |
| +---+ +----------+ +---+ |
+--------------------------+
&lt;/pre&gt;
Для этого вам потребуется использовать следующие настройки:
&lt;pre&gt;
vain.layout.centerwork.top_left = 3
vain.layout.centerwork.top_right = 0
vain.layout.centerwork.bottom_left = 2
vain.layout.centerwork.bottom_right = 1
&lt;/pre&gt;
Примечание: Если вы используете стандартую конфигурацию Awesome, навигация в этой схеме может быть весьма запутанной. Как перейти из главного окна на нижнее левое окно? Это зависит от порядка в котором эти окна были открыты! Таким образом, я предлагаю вам использовать функцию  awful.client.focus.bydirection():
&lt;pre&gt;
globalkeys = awful.util.table.join(
    awful.key({ modkey }, &quot;j&quot;,
        function()
            awful.client.focus.bydirection(&quot;down&quot;)
            if client.focus then client.focus:raise() end
        end),
    awful.key({ modkey }, &quot;k&quot;,
        function()
            awful.client.focus.bydirection(&quot;up&quot;)
            if client.focus then client.focus:raise() end
        end),
    awful.key({ modkey }, &quot;h&quot;,
        function()
            awful.client.focus.bydirection(&quot;left&quot;)
            if client.focus then client.focus:raise() end
        end),
    awful.key({ modkey }, &quot;l&quot;,
        function()
            awful.client.focus.bydirection(&quot;right&quot;)
            if client.focus then client.focus:raise() end
        end),
    -- ...
)
&lt;/pre&gt;

===Промежутки между окнами===

&quot;Useless gaps&quot; это промежуток между окнами. Они &quot;бесполезны&quot; потому что не имеют специального назначения, несмотря на улучшение обзора. Я обнаружил, что проще обнаружить границы окон, если они располагаются немного раздельно. 

Схема ''uselessfair'' например, выглядит следующим образом:
&lt;pre&gt;
+================+
#                #
#  +---+  +---+  #
#  | 1 |  |   |  #
#  +---+  |   |  #
#         | 3 |  #
#  +---+  |   |  #
#  | 2 |  |   |  #
#  +---+  +---+  #
#                #
+================+
&lt;/pre&gt;
Все мои схемы поддерживают &quot;useless gaps&quot;. Для настройки ширины разрывов, вам необходимо расширить вашу тему beautiful. Она должна содержать пункт под названием useless_gap_width в таблице темы. Если этот параметр отсутсвует, ширина по умолчиню становится равной 0.
&lt;pre&gt;
...
theme.useless_gap_width = &quot;5&quot;
...
&lt;/pre&gt;

==Виджеты==

Каждая функция возвращает виджет, который может быть использован в wiboxes. Большинство виджетов периодически обновляются; смотри код, чтобы узнать значение таймера.

===systemload===

Отображает текущий уровень нагрузки системы в textbox. Данные считываются непосредственно /proc/loadavg.
&lt;pre&gt;
mysysload = vain.widgets.systemload()
&lt;/pre&gt;
Нажатие на виджет откроет терминал с htop.

Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.refresh_timeout=: По умолчанию 10 секунд
*.show_all: Отображать все три значения (true) или только первое значение (false)? По умолчанию значение равно false.

===cpuusage===

Отображает среднюю загрузку процессора в данный момент времени. Это то, что делает htop.
&lt;pre&gt;
mycpuusage = vain.widgets.cpuusage()
&lt;/pre&gt;
Нажатие на виджет откроет терминал с htop.

Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.refresh_timeout: По умолчанию 10 секунд.

===memusage===

Отображает использование памяти и общую память в MiB. Данные считываются из /proc/meminfo.

mymemusage = vain.widgets.memusage()

Нажатие на виджет откроет терминал с htop.

Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.refresh_timeout: По умолчанию 10 секунд.
*.show_swap: Отображать использование swap? По умолчанию равно false.

===mailcheck===

Проверяет каталог Maildirs и отображает результат в textbox. Например, у меня Maildirs расположен ~/Mail:
&lt;pre&gt;
$ pwd
/home/void/Mail
$ tree -ad
.
|-- bugs
|   |-- cur
|   |-- new
|   `-- tmp
|-- lists
|   |-- cur
|   |-- new
|   `-- tmp
|-- system
|   |-- cur
|   |-- new
|   `-- tmp
.
.
.
&lt;/pre&gt;
Виджет ''mailcheck'' проверяет имеются ли файлы в каталогах new. Для выполнения вызывается ''find''. Если есть новые письма, textbox отобразит, что то вроде этого &quot;mail: bugs(3), system(1)&quot;, в противном случае &quot;no mail&quot;.
&lt;pre&gt;
mymailcheck = vain.widgets.mailcheck()
&lt;/pre&gt;
Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.refresh_timeout: По умолчанию каждые 30 секунд.
*.mailpath: Путь к каталогу с почтой, по умолчанию ~/Mail.
*.ignore_boxes: Другая таблица, которая содержит список ящиков (just the last part, like lists) для пропуска. По умолчанию нет значений.
*.initial_update: Проверять почту при старте Awesome (true) или ожидать первого периода обновления (false)? По умолчанию равно true.

При щелчке на виджете, вызывается bash alias с названием smail. Это оболочка скрипта для mutt который я использую: он автоматически отсылает(commits) в репозиторий git, после прочтения почты.

beautiful.mailcheck_new может исполользовать цвета. new-mail-message отображается с использованием этого цвета. По умолчанию используется красный, если не определен.

===battery===

Отображает оставшееся время и емкость батареи вашего ноутбука, а также текущую мощьность(wattage). Используется файловая система /sys.

mybattery = vain.widgets.battery()

Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.refresh_timeout: По умолчанию 30 секунд.
*.battery: Идентификатор батареи, за которой ведется наблюдение, по умолчанию ''BAT0''.

===volume===

Отображает и контролирует текущий уровень громности в textbox. Периодически вызывается скрипт control_volume для получения текущего значения громкости. Похожий скрипт используется и для установки громкости. Смотри ниже.

*Щелчок левой кнопки: Включить/выключить звук.
*Щелчок правой кнопки: Включить/выключить звук.
*Щелчок средней кнопки: Запускает alsamixer в вашем терминале.
*Колесо мыши: Увеличение/Уменьшение громкости.
&lt;pre&gt;
    myvolume = vain.widgets.volume()
&lt;/pre&gt;
Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.refresh_timeout: По умолчанию 2 секунды.
*.mixer_channel: По умолчанию канал Master.

Я в настоящее время использую скрипт похожий на control_volume:
&lt;pre&gt;
#!/bin/bash
channel=${2:-Master}
case $1 in
    up)
        mpc volume +2
        ;;
    down)
        mpc volume -2
        ;;
    toggle)
        amixer set $channel toggle
        ;;
    get)
        mpc volume | sed -r 's/^volume: ?([^%]+)%.*/\1/'

        echo -n ' '

        amixer get $channel |
        sed -rn 's/.*\[([a-z]+)\]/\1/p' |
        head -1
        ;;
esac
&lt;/pre&gt;
То есть, я узнаю и устанавливаю громкость через mpd. Раньше я использовал все эти возможности через amixer, но этоа программа все больше и больше ломается и частенько работает не как надо. Например, когда громкость уменьшается до 0%, amixer не может получить значение обратно.

Это не очень красивое решение. Я решил использовать скрипт, поскольку я не хочу трогать конфигурацию Awesome когда мне удастся найти лучшее решение.

===mpd===

Предоставляет набор imageboxes для контроля запущенного экземпляра mpd на вашем локальном компьютере. Также обеспечивается контроль похожий на виджет громкости. Для контроля mpd используется mpc.

*Щелчок правой кнопкой на любой иконке: Включение/выключение звука через control_volume. Описание смотри выше.
*Щелчок средней кнопкой на любой иконке: Открывает ncmpcpp в терминале.

Эта функция возвращает не один виджет, а таблицу виджетов. В настоящее время, если вы захотите добавить их, нужно добавить только эту таблицу в wibox:
&lt;pre&gt;
mpdtable = vain.widgets.mpd()
...
mywibox[s].widgets = {
    ...
    mpdtable[1],
    mpdtable[2],
    mpdtable[3],
    mpdtable[4],
    mpdtable[5],
    mpdtable[6],
    ...
}
&lt;/pre&gt;
Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.mixer_channel: По умолчанию Master.
*.show_label: Определяет, является ли mpd: отображается перед иконками управления. По умолчанию равно true.

===net===

Мониторит сетевые интерфейсы и отображает текущий трафик в виде textbox. Если сетевого интерфейса не существует или если еще не достоточно данный, вы увидите, что то похожее на wlan0: -. В противном случае, текущий трафик отображается в килобайтах в секунду, следующим образом eth0: ↑(00,010.2), ↓(01,037.8).
&lt;pre&gt;
neteth0 = vain.widgets.net()
&lt;/pre&gt;
Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.refresh_timeout: По умолчанию 2 секунды.
*.iface: По умолчанию eth0.

===gitodo===

Это интеграция gitodo в Awesome.
&lt;pre&gt;
todolist = vain.widgets.gitodo()
&lt;/pre&gt;
Функция принимает таблицу в качестве дополнительного аргумента. Эта таблица может содержать:

*.refresh_timeout: По умолчанию 120 секунд
*.initial_update: Проверяет список todo при запуске Awesome (true) или ожидает первого интервала обновления (false)? По умолчанию равно true.

''beautiful.gitodo_normal'' используемый цвет для не просроченных задач, ''beautiful.gitodo_warning'' для элементов близких к завершению и  ''beautiful.gitodo_outdated'' цвет для просроченных задач.

===borderbox===

Создает тонкий wibox в позиции относительно другого wibox. Это позволяет вам создавать &quot;separators&quot; или &quot;borders&quot; для ваших wibox. Например, представьте себе, что это wibox:
&lt;pre&gt;
[======================]
&lt;/pre&gt;
Если args.position = 'above', то вы получите дополнительный wibox ниже существующего wibox:
&lt;pre&gt;
________________________
[======================]
&lt;/pre&gt;
Он будет соответсвовать позиции и размеру существующего wibox.

Если ваши основные wiboxes находятся в таблице которая называется mywibox (один wibox для каждого экрана) и располагается в нижней части вашего экрана, то следующий код добавит borderbox поверх него:
&lt;pre&gt;
for s = 1, screen.count()
do
    -- Most likely, you'll want to do this as well:
    awful.screen.padding(screen[s], { bottom = 1 })

    -- Создаем box и размещаем ее над существующим box.
    vain.widgets.borderbox(mywibox[s], s, { position = 'above' } )
end
&lt;/pre&gt;
borderbox() определена следующим образом:
&lt;pre&gt;
function borderbox(relbox, s, args)
&lt;/pre&gt;
relbox и s (число) необходимые аргументы, args не является обязательным. args может содеражать:

*.position: Один из вариантов above, below, left and right. По умолчанию above.
*.color: Цвет дополнительного box. По умолчанию равно #FFFFFF.
*.size: Размер дополнительного box, измеряется в пикселях. По умолчанию 1.

==Служебные функции==

Здесь я объясню только наиболее сложные функции из файла ''init.lua''. Смотрите исходный код для изучения остальных.

===menu_clients_current_tags===

Эта функция подобна awful.menu.clients(), но отображает клиентов только для текущего тега. Используйте следующим образом:
&lt;pre&gt;
globalkeys = awful.util.table.join(
    ...
    awful.key({ &quot;Mod1&quot; }, &quot;Tab&quot;, function()
        awful.menu.menu_keys.down = { &quot;Down&quot;, &quot;Alt_L&quot;, &quot;Tab&quot;, &quot;j&quot; }
        awful.menu.menu_keys.up = { &quot;Up&quot;, &quot;k&quot; }
        vain.util.menu_clients_current_tags({ width = 350 }, { keygrabber = true })
    end),
    ...
)
&lt;/pre&gt;

===magnify_client===

Устанавливает клиенту плавающий режим(floating) и изменяет его размеры так же, как это сделано в схеме &quot;magnifier&quot;. Размещает клиент на &quot;текущем&quot; экране (зависит от положения мыши). Это позволяет вам увеличить любой клиент, независимо от используемой схемы. Используйте функцию клавиатурной привязки клиента следующим образом:
&lt;pre&gt;
clientkeys = awful.util.table.join(
    ...
    awful.key({ modkey, &quot;Control&quot; }, &quot;m&quot;, vain.util.magnify_client),
    ...
)
&lt;/pre&gt;
Если вы хотите &quot;de-magnify&quot; клиент, просто сбросьте клиенту плавающий режим на false (обычно Mod+CTRL+Space).

==Цвет границы окон в зависимости от значения приоритета==
'''Для установки приоритета используется утилита nice. Для ознакомления с ней и ее возможностями читайте руководство.'''

По умолчанию ваш rc.lua содержит что то похожее на:
&lt;pre&gt;
client.add_signal(&quot;focus&quot;, function(c) c.border_color = beautiful.border_focus end)
client.add_signal(&quot;unfocus&quot;, function(c) c.border_color = beautiful.border_normal end)
&lt;/pre&gt;
Вы можете изменить это на:
&lt;pre&gt;
client.add_signal(&quot;focus&quot;, vain.util.niceborder_focus)
client.add_signal(&quot;unfocus&quot;, vain.util.niceborder_unfocus)
&lt;/pre&gt;
Теперь, при фокусировке или потере фокуса клиентом, Awesome будет искать его значение nice в /proc/&lt;pid&gt;/stat. Если значение меньше 0, это окно классифицируется как имеющее &quot;high priority&quot;; если оно больше 0, окно классифицируется как имеющее &quot;low priority&quot;. Если оно равно 0, ничего особенного не происходит.

Это требует определить дополнительные цвета в theme.lua. Вот те, которые использую я:
&lt;pre&gt;
theme.border_focus_highprio  = &quot;#FF0000&quot;
theme.border_normal_highprio = &quot;#A03333&quot;

theme.border_focus_lowprio   = &quot;#3333FF&quot;
theme.border_normal_lowprio  = &quot;#333366&quot;
&lt;/pre&gt;

==tag_view{next,prev}_nonempty==

Возможно вы используете taglist, который отображает только не пустые теги:
&lt;pre&gt;
mytaglist = awful.widget.taglist(s, awful.widget.taglist.label.noempty, mytaglist.buttons)
--                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
&lt;/pre&gt;
В таком случае, настройка по умолчанию будет выглядеть так:
&lt;pre&gt;
globalkeys = awful.util.table.join(
    -- Стандартная навигация
    awful.key({ modkey }, &quot;Left&quot;,   awful.tag.viewprev),
    awful.key({ modkey }, &quot;Right&quot;,  awful.tag.viewnext),
    ...
&lt;/pre&gt;
Так при нажатии modkey + right, вы переходите на следующий тег. Однако, при отображении только не пустых тегов, целевой(намеченный) тег может быть пуст! Мне это не нравится. Я всегда хочу переходить на следующий не пустой тег, пропуская пустые.

tag_viewnext_nonempty() и tag_viewprev_nonempty() делают именно это. Для их использования, заменить указанный выше код на следующий:
&lt;pre&gt;
globalkeys = awful.util.table.join(
    -- Standard navigation
    awful.key({ modkey }, &quot;Left&quot;,   vain.util.tag_viewprev_nonempty),
    awful.key({ modkey }, &quot;Right&quot;,  vain.util.tag_viewnext_nonempty),
    ...
&lt;/pre&gt;
'''Note:''' Для перехода на пустой тег, вы должны вызывать непосредственно его. То есть, используйте modkey + 4 или аналогичное.</text>
      <sha1>mxf0ngcz478f5ui5xrdgtbzxks6avod</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Variety</title>
    <ns>0</ns>
    <id>1316</id>
    <revision>
      <id>7422</id>
      <timestamp>2016-01-16T21:13:52Z</timestamp>
      <contributor>
        <username>EchoLynx</username>
        <id>4315</id>
      </contributor>
      <comment>First edition.</comment>
      <text xml:space="preserve" bytes="1160">[[Variety|http://peterlevi.com/variety/]] is an automatic wallpaper changer. It doesn't currently support awesome, though a patch was [https://code.launchpad.net/~echolynx/variety/variety-with-awesomewm-support just submitted]. The patch does exactly what is suggested below.
== Installing Variety ==
# Install variety with your package manager.
# Run variety once, then close it. Be sure to complete the configuration wizard.
# Add the following to ~/.config/variety/scripts/set_wallpaper:
 &lt;nowiki&gt;
# Awesome Window Manager
# Set the path to the wallpaper using awesome-client, which communicates with awesome using D-Bus. Be sure to start variety when you start awesome, such as by adding it to ~/.xinitrc in Arch Linux.

# NOTE: This config will change the wallpaper after your current awesome theme sets it. As such, the theme's wallpaper will briefly appear before being replaced with variety's wallpaper.

echo &quot;local gears = require(\&quot;gears\&quot;) gears.wallpaper.maximized(\&quot;$1\&quot;, s, true)&quot; | awesome-client&lt;/nowiki&gt;
== Start variety with awesome ==
Add the following to ~/.xinitrc. Be sure to add it above '''exec awesome'''.
 &lt;nowiki&gt;
variety &amp;&lt;/nowiki&gt;</text>
      <sha1>j0h19hie0url5e1tuor885se21gyvb6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Vicious</title>
    <ns>0</ns>
    <id>482</id>
    <revision>
      <id>6801</id>
      <parentid>6765</parentid>
      <timestamp>2014-06-17T03:55:54Z</timestamp>
      <contributor>
        <username>Laika117</username>
        <id>3310</id>
      </contributor>
      <comment>/* On Archlinux */</comment>
      <text xml:space="preserve" bytes="8437">{{Languages|Vicious}}

Vicious is a modular widget library for awesome, derived from the [[Wicked|Wicked]] widget library. It has some of the old Wicked widget types, a few of them rewritten, and a good number of new ones.

== Understanding Vicious ==
Vicious widget types are a framework for creating your own awesome widgets. Vicious contains modules that gather data about your system, and a few helper functions that make it easier to register timers, suspend widgets and so on.

* What about Wicked?
** It wasn't modular.
* What about Obvious?
** By design it's the opposite of vicious.
* What about Bashets?
** Targets a different profile of users.

* ''Vicious guidelines'':
** Widgets should be modular, you plug-in widgets that you need and ignore the rest.
** Widget type is small, 10+ lines, module with a worker function that crunches data and returns it raw.
*** How data will be formatted, colored red or blue, should be defined somewhere else (''rc.lua'' most likely).
*** Likewise, it is not our job to register button bindings, tooltips or naughty notifications.
** Widgets should not be expensive for system resources, especially when running on battery power.
** Widgets should be easy to install, so at this point they don't rely on third party Lua libraries.

== Getting Vicious ==
Vicious is hosted on http://git.sysphere.org/vicious/ where you can download the tarball of the latest release/tag, or get the development code with git. Git access is provided over http, you can clone the repo with:

    $ git clone &lt;nowiki&gt;http://git.sysphere.org/vicious&lt;/nowiki&gt;

Once you extract the tarball, or clone the repository, you should move vicious to your awesome configuration directory in $XDG_CONFIG_HOME (usually ~/.config).

    $ mv vicious $XDG_CONFIG_HOME/awesome/

==== On Ubuntu ====

Ubuntu repository contains a package called &quot;awesome-extra&quot;, which includes Vicious library. Just type:

   $ sudo aptitude install awesome-extra

==== On Arch Linux ====

Arch Community repository contains the package vicious. Just type:

   $ sudo pacman -S vicious

=== Older awesome versions ===
Vicious tag v1.0.11 is the last release compatible with awesome versions prior to 3.4. In v1.0.12 vicious was ported to the new timers infrastructure and awful widgets, there is no backward compatibility. However, bug fixes and improvements were backported and last recommended release to use with older awesome versions is '''v1.0.11.4'''.

== Using Vicious ==
Vicious loads only widget types you intend to use, and register in your awesome configuration, to avoid having useless modules sitting in your memory. To start using Vicious add the following to the top of your ''rc.lua'':

    vicious = require(&quot;vicious&quot;)

From there you can register any (textbox, graph or a progressbar) widget by calling the vicious.register() function. Included [http://git.sysphere.org/vicious/tree/README '''README'''] file explains all of this in more detail, and covers everything from available functions and a description of widget types to actual examples.

=== Example widgets ===
* Start with a simple widget, like ''date''. Then build your setup from there, one widget at a time.
* Remember that besides creating widgets you have to add them to a '''wibox''' (statusbar) to actually display them.

==== Date (textbox) ====
This widget displays date and time. In this example it is updated every 60 seconds.

&lt;b&gt;For awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
datewidget = widget({ type = &quot;textbox&quot; })
-- Register widget
vicious.register(datewidget, vicious.widgets.date, &quot;%b %d, %R&quot;, 60)
&lt;/pre&gt;

&lt;b&gt;For awesome 3.5&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
datewidget = wibox.widget.textbox()
-- Register widget
vicious.register(datewidget, vicious.widgets.date, &quot;%b %d, %R&quot;, 60)
&lt;/pre&gt;


To get a list of all the available date formats, type '''man strftime''' in a shell

==== Memory usage (textbox) ====
This example displays the relative memory usage, usage in MB and total system memory, updated every 13 seconds.

&lt;b&gt;For awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
memwidget = widget({ type = &quot;textbox&quot; })
-- Register widget
vicious.register(memwidget, vicious.widgets.mem, &quot;$1% ($2MB/$3MB)&quot;, 13)
&lt;/pre&gt;

&lt;b&gt;For awesome 3.5&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
memwidget = wibox.widget.textbox()
-- Register widget
vicious.register(memwidget, vicious.widgets.mem, &quot;$1% ($2MB/$3MB)&quot;, 13)
&lt;/pre&gt;

==== Memory usage (progressbar) ====
This example displays the relative memory usage in a progressbar, updated every 13 seconds.

&lt;b&gt;For awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
memwidget = awful.widget.progressbar()
-- Progressbar properties
memwidget:set_width(8)
memwidget:set_height(10)
memwidget:set_vertical(true)
memwidget:set_background_color(&quot;#494B4F&quot;)
memwidget:set_border_color(nil)
memwidget:set_color(&quot;#AECF96&quot;)
memwidget:set_gradient_colors({ &quot;#AECF96&quot;, &quot;#88A175&quot;, &quot;#FF5656&quot; })
-- Register widget
vicious.register(memwidget, vicious.widgets.mem, &quot;$1&quot;, 13)
&lt;/pre&gt;

&lt;b&gt;For awesome 3.5 &lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
memwidget = awful.widget.progressbar()
-- Progressbar properties
memwidget:set_width(8)
memwidget:set_height(10)
memwidget:set_vertical(true)
memwidget:set_background_color(&quot;#494B4F&quot;)
memwidget:set_border_color(nil)
memwidget:set_color({ type = &quot;linear&quot;, from = { 0, 0 }, to = { 10,0 }, stops = { {0, &quot;#AECF96&quot;}, {0.5, &quot;#88A175&quot;}, 
                    {1, &quot;#FF5656&quot;}}})
-- Register widget
vicious.register(memwidget, vicious.widgets.mem, &quot;$1&quot;, 13)
&lt;/pre&gt;

==== CPU usage (textbox) ====
This example displays CPU usage of all available CPUs/cores, updated every 2 seconds (the default interval).

&lt;b&gt;For awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
cpuwidget = widget({ type = &quot;textbox&quot; })
-- Register widget
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1%&quot;)
&lt;/pre&gt;

&lt;b&gt;For awesome 3.5&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
cpuwidget = wibox.widget.textbox()
-- Register widget
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1%&quot;)
&lt;/pre&gt;

==== CPU usage (graph) ====
This example displays a graph with CPU usage of all available CPUs/cores, updated every 2 seconds (the default interval).

&lt;b&gt;For awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
cpuwidget = awful.widget.graph()
-- Graph properties
cpuwidget:set_width(50)
cpuwidget:set_background_color(&quot;#494B4F&quot;)
cpuwidget:set_color(&quot;#FF5656&quot;)
cpuwidget:set_gradient_colors({ &quot;#FF5656&quot;, &quot;#88A175&quot;, &quot;#AECF96&quot; })
-- Register widget
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1&quot;)
&lt;/pre&gt;

&lt;b&gt;For awesome 3.5&lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
cpuwidget = awful.widget.graph()
-- Graph properties
cpuwidget:set_width(50)
cpuwidget:set_background_color(&quot;#494B4F&quot;)
cpuwidget:set_color({ type = &quot;linear&quot;, from = { 0, 0 }, to = { 10,0 }, stops = { {0, &quot;#FF5656&quot;}, {0.5, &quot;#88A175&quot;}, 
                    {1, &quot;#AECF96&quot; }}})
-- Register widget
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1&quot;)
&lt;/pre&gt;

==== MPD Status (textbox) ====
This example displays the artist and the song which that are currently playing with MPD. This example also shows how a format function can be used to manipulate the output.

&lt;b&gt; For awesome 3.4 &lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
mpdwidget = widget({ type = &quot;textbox&quot; })
-- Register widget
vicious.register(mpdwidget, vicious.widgets.mpd,
    function (widget, args)
        if args[&quot;{state}&quot;] == &quot;Stop&quot; then 
            return &quot; - &quot;
        else 
            return args[&quot;{Artist}&quot;]..' - '.. args[&quot;{Title}&quot;]
        end
    end, 10)
&lt;/pre&gt;

&lt;b&gt; For awesome 3.5 &lt;/b&gt;

&lt;pre&gt;
-- Initialize widget
mpdwidget = wibox.widget.textbox()
-- Register widget
vicious.register(mpdwidget, vicious.widgets.mpd,
    function (mpdwidget, args)
        if args[&quot;{state}&quot;] == &quot;Stop&quot; then 
            return &quot; - &quot;
        else 
            return args[&quot;{Artist}&quot;]..' - '.. args[&quot;{Title}&quot;]
        end
    end, 10)
&lt;/pre&gt;

=== Wicked widgets ===
Switching from Wicked to Vicious is straightforward. There are small differences in the API:

* Caching is entirely controlled by users.
* Using a string widget type is not allowed.
* Padding is not provided by vicious helpers.

=== Awesome widgets ===
If you want to know more about awesome widget types and objects, how they work, their properties and so on... read the [[Widgets in awesome]] page. If you plan to use graph or progressbar widgets then you must read it, vicious users always make the same mistake when adding these widget types to the ''wibox''.

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>8zocybtswzty49e816g50eufzovqzx6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Vicious/ru</title>
    <ns>0</ns>
    <id>1029</id>
    <revision>
      <id>7096</id>
      <parentid>6766</parentid>
      <timestamp>2014-11-01T20:35:59Z</timestamp>
      <contributor>
        <username>Sooqua</username>
        <id>3852</id>
      </contributor>
      <comment>/* Использование Vicious */</comment>
      <text xml:space="preserve" bytes="13875">{{Languages|Vicious}}

Vicious это модульная библиотека виджетов для awesome, которая происходят от библиотеки виджетов [[Wicked|Wicked]]. Это одна из старейших типов видежтов Wicked, многие из которых были переписаны, и добавлено множество новых.

== Соглашение Vicious ==
Типовые виджеты Vicious являются основой для создания ваших собственных виджетов в awesome. Vicious содержат модули, которые собирают данные о вашей системе, и многие вспомогательные функции которые облегчают регистрацию таймеров, приостановку виджетов, и т.д.

* Почему не использовать Wicked?
** Он не является модульным.
* Почему не использовать Obvious?
** Для разработчиков он является противоположным vicious.
* Почему не использовать Bashets?
** У него другая целевая категория пользователей.

* ''Цели Vicious'':
** Виджеты должны быть модульными, вы подключаете только то, что нужно именно вам, игнорируя все остальное.
** Виджеты очень маленькие, чуть больше 10 строк, модули выполняющие функции получают данные и возвращают их в необработанном (сыром) виде.
*** Как данные будут отформатированны, какого цвета красного или синего, должно быть описано в другом месте (обычно в ''rc.lua'').
*** Кроме того, в нашу задачу не входит регистрация, привязка к кнопкам, подсказкам или уведомлениям naughty.
** Виджеты не должны нагружать систему, особенно при работе от аккумулятора.
** Виджеты должны быть легки в установке, поэтому они не должны зависеть от каких то сторонних библиотек Lua.

== Установка Vicious ==
Vicious располагается http://git.sysphere.org/vicious/ где вы можете скачать архив с последней релизной версией, или текущей разрабатываемой версией с помощью git. 
where you can download the tarball of the latest release/tag, or get the development code with git. Git доступен через http, вы можете клонировать репозитарий используя:

    $ git clone &lt;nowiki&gt;http://git.sysphere.org/vicious&lt;/nowiki&gt;

После извлечения из архива, или клонирования из репозитория, вам необходимо переместить папку vicious в папку awesome $XDG_CONFIG_HOME (обычно ~/.config/awesome).

    $ mv vicious $XDG_CONFIG_HOME/awesome/

==== Установка в Ubuntu ====

Репозиторий Ubuntu содержит пакет называемый &quot;awesome-extra&quot;, который включает библиотеку Vicious . Наберите:

   $ sudo aptitude install awesome-extra

==== On Archlinux ====

Репозиторий Arch Community содержит пакет vicious. Просто наберите:

   $ sudo pacman -S vicious


=== Старые версии awesome ===
Vicious версии v1.0.11 это последний релиз поддерживающий awesome с версией меньше 3.4. В версию v1.0.12 vicious и новее, была портированна новая инфраструктура таймеров и виджетов awful, поэтому старые версии awesome в ней не поддерживаются. Тем не менее, исправление ошибок и улучшения, были бэкпортированны в старую релизную версию с номером '''v1.0.11.4'''.

== Использование Vicious ==
Vicious загружает только тот тип виджетов, которые вы планируете использовать, и зарегистрированы в вашем файле конфигурации awesome, чтобы избежать безполезных модулей висящих в памяти. Для того, чтобы начать использовать Vicious добавьте следующую строку в ''rc.lua'':

    vicious = require(&quot;vicious&quot;)

После этого вы можете регистрировать любые виджеты (textbox, graph или progressbar) вызывая функцию vicious.register().

'''Внимание!''' Если вы планируете использовать несколько виджетов одного типа, необходимо включить кеширование возвращаемых этим типом значений перед их инициализацией вызовом функции '''vicious.cache(wtype)'''. Например:
&lt;pre&gt;
-- Включение кеширования возвращаемых значений vicious.widgets.cpu
vicious.cache(vicious.widgets.cpu)
-- Инициализация виджета
cpuwidget = wibox.widget.textbox()
-- Регистрация виджета
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1%&quot;)
&lt;/pre&gt;

Прочтите файл [http://git.sysphere.org/vicious/tree/README '''README'''], в котором все разъяснено более детально, и описывает все доступные функции и описание различных виджетов на актуальных примерах.

=== Примеры виджетов ===
* Начните с простого виджета, например ''date''. Затем настройте его.
* Помните, что помимо создания виджета, вам необходимо добавить его в секцию '''wibox''' (statusbar) для отображения его на экране.

==== Date (textbox) ====
Этот виджет отображает время и дату. В этом примере интервал обновления данных составляет 60 секунд.

&lt;b&gt;Для awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
datewidget = widget({ type = &quot;textbox&quot; })
-- Регистрация
vicious.register(datewidget, vicious.widgets.date, &quot;%b %d, %R&quot;, 60)
&lt;/pre&gt;

&lt;b&gt;Для awesome 3.5&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
datewidget = wibox.widget.textbox()
-- Регистрация
vicious.register(datewidget, vicious.widgets.date, &quot;%b %d, %R&quot;, 60)
&lt;/pre&gt;


Для получения списка доступных форматов для даты, наберите в консоли '''man strftime'''

==== Memory usage (textbox) ====
Данный пример отображает использование памяти в MB и общую память системы, с обновление раз в 13 секунд.

&lt;b&gt;Для awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
memwidget = widget({ type = &quot;textbox&quot; })
-- Регистрация виджета
vicious.register(memwidget, vicious.widgets.mem, &quot;$1% ($2MB/$3MB)&quot;, 13)
&lt;/pre&gt;

&lt;b&gt;Для awesome 3.5&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
memwidget = wibox.widget.textbox()
-- Регистрация виджета
vicious.register(memwidget, vicious.widgets.mem, &quot;$1% ($2MB/$3MB)&quot;, 13)
&lt;/pre&gt;

==== Memory usage (progressbar) ====
Данный пример отображает использование памяти в процентах в виде индикатора, с обновлением раз в 13 секунд.

&lt;b&gt;Для awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
memwidget = awful.widget.progressbar()
-- Свойства индикатора
memwidget:set_width(8)
memwidget:set_height(10)
memwidget:set_vertical(true)
memwidget:set_background_color(&quot;#494B4F&quot;)
memwidget:set_border_color(nil)
memwidget:set_color(&quot;#AECF96&quot;)
memwidget:set_gradient_colors({ &quot;#AECF96&quot;, &quot;#88A175&quot;, &quot;#FF5656&quot; })
-- Регистрация виджета
vicious.register(memwidget, vicious.widgets.mem, &quot;$1&quot;, 13)
&lt;/pre&gt;

&lt;b&gt;Для awesome 3.5 &lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
memwidget = awful.widget.progressbar()
-- Свойства индикатора
memwidget:set_width(8)
memwidget:set_height(10)
memwidget:set_vertical(true)
memwidget:set_background_color(&quot;#494B4F&quot;)
memwidget:set_border_color(nil)
memwidget:set_color({ type = &quot;linear&quot;, from = { 0, 0 }, to = { 10,0 }, stops = { {0, &quot;#AECF96&quot;}, {0.5, &quot;#88A175&quot;}, 
                    {1, &quot;#FF5656&quot;}}})
-- Регистрация виджета
vicious.register(memwidget, vicious.widgets.mem, &quot;$1&quot;, 13)
&lt;/pre&gt;

==== CPU usage (textbox) ====
Данный пример отображает использование всех доступных процессоров/ядер (CPUs/cores), с интервалом обновления 2 секунды (интервал по умолчанию).

&lt;b&gt;Для awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
cpuwidget = widget({ type = &quot;textbox&quot; })
-- Регистрация виджета
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1%&quot;)
&lt;/pre&gt;

&lt;b&gt;Для awesome 3.5&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
cpuwidget = wibox.widget.textbox()
-- Регистрация виджета
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1%&quot;)
&lt;/pre&gt;

==== CPU usage (graph) ====
Данный пример отображает использование процессора с использованием всех доступных процессоров/ядер, с интервалом обновления в 2 секунды (стандартный интервал).

&lt;b&gt;Для awesome 3.4&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
cpuwidget = awful.widget.graph()
-- Свойства графика
cpuwidget:set_width(50)
cpuwidget:set_background_color(&quot;#494B4F&quot;)
cpuwidget:set_color(&quot;#FF5656&quot;)
cpuwidget:set_gradient_colors({ &quot;#FF5656&quot;, &quot;#88A175&quot;, &quot;#AECF96&quot; })
-- Регистрация виджета
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1&quot;)
&lt;/pre&gt;

&lt;b&gt;Для awesome 3.5&lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
cpuwidget = awful.widget.graph()
-- Свойства графика
cpuwidget:set_width(50)
cpuwidget:set_background_color(&quot;#494B4F&quot;)
cpuwidget:set_color({ type = &quot;linear&quot;, from = { 0, 0 }, to = { 10,0 }, stops = { {0, &quot;#FF5656&quot;}, {0.5, &quot;#88A175&quot;}, 
                    {1, &quot;#AECF96&quot; }}})
-- Регистрация виджета
vicious.register(cpuwidget, vicious.widgets.cpu, &quot;$1&quot;)
&lt;/pre&gt;

==== MPD Status (textbox) ====
Этот пример выведет название песни и исполнителя, которая сейчас воспроизводится с использованием [[http://help.ubuntu.ru/wiki/mpd MPD]] (music player daemon). Данный пример также показывает как функции форматирования могут быть использованы для управления выводом.

&lt;b&gt; Для awesome 3.4 &lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
mpdwidget = widget({ type = &quot;textbox&quot; })
-- Регистрация виджета
vicious.register(mpdwidget, vicious.widgets.mpd,
    function (widget, args)
        if args[&quot;{state}&quot;] == &quot;Stop&quot; then 
            return &quot; - &quot;
        else 
            return args[&quot;{Artist}&quot;]..' - '.. args[&quot;{Title}&quot;]
        end
    end, 10)
&lt;/pre&gt;

&lt;b&gt; Для awesome 3.5 &lt;/b&gt;

&lt;pre&gt;
-- Инициализация виджета
mpdwidget = wibox.widget.textbox()
-- Регистрация виджета
vicious.register(mpdwidget, vicious.widgets.mpd,
    function (mpdwidget, args)
        if args[&quot;{state}&quot;] == &quot;Stop&quot; then 
            return &quot; - &quot;
        else 
            return args[&quot;{Artist}&quot;]..' - '.. args[&quot;{Title}&quot;]
        end
    end, 10)
&lt;/pre&gt;

=== Виджеты из Wicked ===
Переход из Wicked на Vicious достаточно просто. Есть лишь небольшие различия в API:

* Кэширование полностью контролируется пользователем.
* Использование строковых виджетов не поддерживается.
* Дополнения/изменения не поддерживаются разработчиками vicious.

=== Виджеты Awesome ===
Если вы хотите узнать больше о различных типах виджетов и объектах, как они работают, их свойства и прочее ... прочтите страницу [[Widgets in awesome/ru|Виджеты в awesome]]. Если вы планируете использовать виджеты графиков(graph) или индикаторов(progressbar) вы просто обязаны прочить ее. Пользователи vicious часто допускают ошибки когда добавляют свои виджеты в секцию ''wibox''.

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>l1ile2zb3vc77sl157x5qth6hhfmiha</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Video wallpaper</title>
    <ns>0</ns>
    <id>574</id>
    <revision>
      <id>7259</id>
      <parentid>7258</parentid>
      <timestamp>2015-01-07T18:11:24Z</timestamp>
      <contributor>
        <username>Y2kbugger</username>
        <id>3137</id>
      </contributor>
      <text xml:space="preserve" bytes="1020">{{Languages}}

Using mplayer you can display a video as your wallpaper.
&lt;pre&gt;
mplayer video.ogv -rootwin -vf scale=1280:800 -noconsolecontrols
&lt;/pre&gt;

Where your desktop is 1280x800. If you wish to crop video you can also use -vf scale=A:B,crop=W:H:X:Y... Check out the manual pages for mplayer!

This can be placed in your theme.lua

&lt;pre&gt;
-- this is actually a command calling the program awsetbg
-- which you can call yourself from the commandline manually
theme.wallpaper_cmd = { &quot;awsetbg /home/genjix/Pictures/wall/ghost-in-the-shell.jpg&quot; }
&lt;/pre&gt;

Note: older mplayer versions might need -input nodefault-binds:conf=/dev/null instead of -noconsolecontrols.

On the default mplayer version for mplayer I couldn't get either way to disable interaction with the background, but newer mplayer versions work.

as of jan2015 using this method for making the webcam the background, the video is overtop all other windows if xcompmgr is running

the problem also occurs with &lt;pre&gt;/usr/lib/xscreensaver/glmatrix -root&lt;/pre&gt;</text>
      <sha1>obod1du7vcjfgbfhasri6z01e5jm8ye</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Video wallpaper/ru</title>
    <ns>0</ns>
    <id>1056</id>
    <revision>
      <id>7300</id>
      <parentid>6547</parentid>
      <timestamp>2015-01-25T17:07:42Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>translate last changes</comment>
      <text xml:space="preserve" bytes="1939">{{DISPLAYTITLE:Видеообои}}
{{Languages|Video wallpaper}}

Используя mplayer вы можете отобразить видео как ваши обои.
&lt;pre&gt;
mplayer video.ogv -rootwin -vf scale=1280:800 -noconsolecontrols
&lt;/pre&gt;

Где 1280:800 это разрешение вашего дисплея. Если вы хотите обрезать видео, вы также можете использовать -vf scale=A:B,crop=W:H:X:Y... Проверьте документацию для mplayer!

Также вы можете разместить это в вашем theme.lua . Для этого замените следующий код:
&lt;pre&gt;
-- this is actually a command calling the program awsetbg
-- which you can call yourself from the commandline manually
theme.wallpaper_cmd = { &quot;awsetbg /home/genjix/Pictures/wall/ghost-in-the-shell.jpg&quot; }
&lt;/pre&gt;

На следующий:
&lt;pre&gt;
theme.wallpaper_cmd = { &quot;mplayer video.ogv -rootwin -vf scale=1280:800 -noconsolecontrols&quot; }
&lt;/pre&gt;

Примечание: старым версиям mplayer требуются следующие параметры -input nodefault-binds:conf=/dev/null instead of -noconsolecontrols.

На версиях mplayer по умолчанию, мне не удалось найти другого способа для отключения взаимодействия с фоном, но более новые версии должны работать корректно.

По состоянию на январь 2015г. использование этого метода для создания фона в виде захвата видео с веб-камеры приводит к перекрытию всех остальных окон, если запущен xcompmgr.

Проблема также может возникать и при использовании &lt;pre&gt;/usr/lib/xscreensaver/glmatrix -root&lt;/pre&gt;</text>
      <sha1>grquseb96s9tnpwfc022j2msnvbnr3r</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Vmware</title>
    <ns>0</ns>
    <id>886</id>
    <revision>
      <id>6624</id>
      <parentid>5739</parentid>
      <timestamp>2014-05-23T12:29:27Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="330">{{Languages}}

=== vmware tools ===
out of the box the vmware-tools aren't running.
You have to start the vmware tools on your own.

make sure that your ~/.xprofile contains:
 /usr/bin/vmware-user

for example:
 cat ~/.xprofile
 #!/bin/sh
 /usr/bin/vmware-user

after that you have to restart your x session (logout, restart, ...)</text>
      <sha1>9f89i12tuxbca64w5wh8jh20xba1p9s</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Vmware/ru</title>
    <ns>0</ns>
    <id>1078</id>
    <revision>
      <id>6626</id>
      <timestamp>2014-05-23T12:35:44Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Vmware (translating page)</comment>
      <text xml:space="preserve" bytes="528">{{Languages|Vmware}}

=== Утилита vmware ===
По умолчанию, из коробки, утилита Vmware не работает. Вам необходимо запускать утилиту Vmware с вашими настройками.

Убедитесь, что файл  ~/.xprofile содержит:
 /usr/bin/vmware-user

Например:
 cat ~/.xprofile
 #!/bin/sh
 /usr/bin/vmware-user

После этого, вам необходимо перезапустить Х сессию (logout, restart, ...)</text>
      <sha1>96wu9w6c5ipb08kypir8uscpmgbbmk8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Volume Widget icon</title>
    <ns>0</ns>
    <id>1310</id>
    <revision>
      <id>7378</id>
      <parentid>7377</parentid>
      <timestamp>2015-10-16T20:56:03Z</timestamp>
      <contributor>
        <username>Akik</username>
        <id>4304</id>
      </contributor>
      <comment>/* Credits */ fixed link to vicious</comment>
      <text xml:space="preserve" bytes="6250">=Introduction=

I like and use a lot of vicious widgets (cpu, network, weather,...); unfortunately I had bad experience with the volume widget: 
* It misses the real time update. Even with [[Rman's Simple Volume Widget]] trick to use the vicious.force()
* I disabled flat volume (e.g. modifying vlc volume will not change master volume) and I change the master volume only through the widget or with the keys. So why should I update the widget every X seconds (even with a very big value of X)

Rman's or [[Farhavens volume widget]] uses text or bar widgets, while I like icons. 

=Credits=

No contradiction, I use code from the [http://git.sysphere.org/vicious/tree/widgets/volume.lua vicious volume widget] (GPLv2).

And large inspiration from [[Rman's Simple Volume Widget]] and [[Farhavens volume widget]].

=Installation=

==Package Dependencies==
* '''alsa-utils''' (for ''amixer'' command)
* Freedesktop Standard Status Icons (e.g. in '''mate-icon-theme''' or '''gnome-icon-theme''' package in debian/ubuntu/arch (and very luckily in most other distro too))

==Awesome 3.4==

in rc.lua
&lt;pre&gt;
---- ALSA volume widget
alsa_channel = &quot;Master&quot; -- Adapt if needed
i_dir = &quot;/usr/share/icons/mate/24x24/status/&quot; -- Adapt to the location of your freedesktop icon
alsawidget = widget({ type = &quot;imagebox&quot; })
alsawidget_tip = awful.tooltip({ objects = { alsawidget }})

function volume(action)
  local mixer	
  if action == &quot;+&quot; or action == &quot;-&quot; then
    mixer = awful.util.pread(&quot;amixer sset &quot; .. alsa_channel .. &quot; 5%&quot; .. action) --change the step to you taste
  elseif action == &quot;toggle&quot; then
    mixer = awful.util.pread(&quot;amixer sset &quot; .. alsa_channel .. &quot; &quot; .. action)
  else
    mixer = awful.util.pread(&quot;amixer get &quot; .. alsa_channel)
  end
  local volu, mute = string.match(mixer, &quot;([%d]+)%%.*%[([%l]*)&quot;)
  if volu == nil or (mute == &quot;&quot; and volu == &quot;0&quot;) or mute == &quot;off&quot; then
    alsawidget.image = image(i_dir .. &quot;audio-volume-muted.png&quot;)
    alsawidget_tip:set_text(&quot;[Muted]&quot;)
  else
    if tonumber(volu) &gt;= 66 then
      alsawidget.image = image(i_dir .. &quot;audio-volume-high.png&quot;)
    elseif tonumber(volu) &gt;= 33 then
      alsawidget.image = image(i_dir .. &quot;audio-volume-medium.png&quot;)
    else
      alsawidget.image = image(i_dir .. &quot;audio-volume-low.png&quot;)
    end
    alsawidget_tip:set_text(alsa_channel .. &quot;: &quot; .. volu .. &quot;%&quot;)
  end
end

volume(&quot;set&quot;) -- set the icon and tooltip at startup or restart

-- mouse bindings
alsawidget:buttons(awful.util.table.join(
  awful.button({ }, 1, function() --click to (un)mute
    volume(&quot;toggle&quot;)
  end),
  awful.button({ }, 4, function() --wheel to rise or reduce volume
    volume(&quot;+&quot;)
  end),
  awful.button({ }, 5, function()
    volume(&quot;-&quot;)
  end)
))
&lt;/pre&gt;

Then add '''alsawidget''' to your wibox layout(s). 

===Multimedia Keys===

If you want to use multimedia keys to control the volume level, use the following code to set the [[Global Keybindings|keybindings]]:
&lt;pre&gt;
  --ALSA VOLUME
  awful.key({ }, &quot;XF86AudioRaiseVolume&quot;, function() volume(&quot;+&quot;) end),
  awful.key({ }, &quot;XF86AudioLowerVolume&quot;, function() volume(&quot;-&quot;) end),
  awful.key({ }, &quot;XF86AudioMute&quot;,        function() volume(&quot;toggle&quot;) end),
&lt;/pre&gt;

==Awesome 3.5==

in rc.lua
&lt;pre&gt;
---- ALSA volume widget
alsa_channel = &quot;Master&quot; -- Adapt if needed
i_dir = &quot;/usr/share/icons/mate/24x24/status/&quot; -- Adapt to the location of your freedesktop icon
alsawidget = wibox.widget.imagebox()
alsawidget_tip = awful.tooltip({ objects = { alsawidget }})

function volume(action)
  local mixer	
  if action == &quot;+&quot; or action == &quot;-&quot; then
    mixer = awful.util.pread(&quot;amixer sset &quot; .. alsa_channel .. &quot; 5%&quot; .. action) --change the step to you taste
  elseif action == &quot;toggle&quot; then
    mixer = awful.util.pread(&quot;amixer sset &quot; .. alsa_channel .. &quot; &quot; .. action)
  else
    mixer = awful.util.pread(&quot;amixer get &quot; .. alsa_channel)
  end
  local volu, mute = string.match(mixer, &quot;([%d]+)%%.*%[([%l]*)&quot;)
  if volu == nil or (mute == &quot;&quot; and volu == &quot;0&quot;) or mute == &quot;off&quot; then
    alsawidget:set_image(i_dir .. &quot;audio-volume-muted.png&quot;)
    alsawidget_tip:set_text(&quot;[Muted]&quot;)
  else
    if tonumber(volu) &gt;= 66 then
      alsawidget:set_image(i_dir .. &quot;audio-volume-high.png&quot;)
    elseif tonumber(volu) &gt;= 33 then
      alsawidget:set_image(i_dir .. &quot;audio-volume-medium.png&quot;)
    else
      alsawidget:set_image(i_dir .. &quot;audio-volume-low.png&quot;)
    end
    alsawidget_tip:set_text(alsa_channel .. &quot;: &quot; .. volu .. &quot;%&quot;)
  end
end

volume(&quot;set&quot;) -- set the icon and tooltip at startup or restart

-- mouse bindings
alsawidget:buttons(awful.util.table.join(
  awful.button({ }, 1, function() --click to (un)mute
    volume(&quot;toggle&quot;)
  end),
  awful.button({ }, 4, function() --wheel to rise or reduce volume
    volume(&quot;+&quot;)
  end),
  awful.button({ }, 5, function()
    volume(&quot;-&quot;)
  end)
))
&lt;/pre&gt;

Then add '''alsawidget''' to your wibox layout(s).

For the Multimedia Keys, it is the same code as Awesome 3.4

=Extra=

==Update on Mouse Over==

If you update the volume from another place than the widget or the keys, one way to update the widget (and tooltip) could be to do it when mouse overing it.

===Awesome 3.4===

in rc.lua
&lt;pre&gt;
  alsawidget:add_signal('mouse::enter', function() volume(&quot;update&quot;) end)
&lt;/pre&gt;


===Awesome 3.5===

in rc.lua
&lt;pre&gt;
  alsawidget:connect_signal(&quot;mouse::enter&quot;, function() volume(&quot;update&quot;) end)
&lt;/pre&gt;

==Timer Update==

If you update the volume from another place than the widget or the keys, one way to update the widget (and tooltip) could be to use a timer, so at least, after few seconds/minutes the icon and tooltip would be up to date.

===Awesome 3.4===

in rc.lua
&lt;pre&gt;
  alsatimer  = timer({ timeout = 13 }) -- Update every 13 sec. 
  alsatimer:add_signal(&quot;timeout&quot;, function() volume(&quot;update&quot;) end)
  alsatimer:start()
&lt;/pre&gt;

===Awesome 3.5===

in rc.lua
&lt;pre&gt;
  alsatimer  = timer({ timeout = 13 }) -- Update every 13 sec.  
  alsatimer:connect_signal(&quot;timeout&quot;, function() volume(&quot;update&quot;) end)
  alsatimer:start()
&lt;/pre&gt;

==Sound Mixer==

To open the sound mixer on right click, add the following in mouse bindings (same code for Awesome 3.4 and 3.5)

&lt;pre&gt;
  awful.button({ }, 3, function()
    awful.util.spawn(terminal .. &quot; -e alsamixer&quot;) -- or whatever your preferred sound mixer is
  end),
&lt;/pre&gt;</text>
      <sha1>gr4vqc2883p9k8puz6mh11rflgqhphh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Volume control and display</title>
    <ns>0</ns>
    <id>618</id>
    <revision>
      <id>7473</id>
      <parentid>7387</parentid>
      <timestamp>2016-07-08T16:56:13Z</timestamp>
      <contributor>
        <username>Evgeny</username>
        <id>4324</id>
      </contributor>
      <comment>Added an example that uses D-Bus</comment>
      <text xml:space="preserve" bytes="6552">This tutorial will get you a small inconspicious square which fades in and out. When muted a red M will display:

[[File:volume.png]]

&lt;pre&gt;
    volume_widget = widget({ type = &quot;textbox&quot;, name = &quot;tb_volume&quot;,
                             align = &quot;right&quot; })

    function update_volume(widget)
        local fd = io.popen(&quot;amixer sget Master&quot;)
        local status = fd:read(&quot;*all&quot;)
        fd:close()
        
        local volume = tonumber(string.match(status, &quot;(%d?%d?%d)%%&quot;)) / 100
        -- volume = string.format(&quot;% 3d&quot;, volume)

        status = string.match(status, &quot;%[(o[^%]]*)%]&quot;)

        -- starting colour
        local sr, sg, sb = 0x3F, 0x3F, 0x3F
        -- ending colour
        local er, eg, eb = 0xDC, 0xDC, 0xCC

        local ir = math.floor(volume * (er - sr) + sr)
        local ig = math.floor(volume * (eg - sg) + sg)
        local ib = math.floor(volume * (eb - sb) + sb)
        interpol_colour = string.format(&quot;%.2x%.2x%.2x&quot;, ir, ig, ib)
        if string.find(status, &quot;on&quot;, 1, true) then
            volume = &quot; &lt;span background='#&quot; .. interpol_colour .. &quot;'&gt;   &lt;/span&gt;&quot;
        else
            volume = &quot; &lt;span color='red' background='#&quot; .. interpol_colour .. &quot;'&gt; M &lt;/span&gt;&quot;
        end
        widget.text = volume
     end

    update_volume(volume_widget)
    awful.hooks.timer.register(1, function () update_volume(volume_widget) end)
&lt;/pre&gt;

Save that file in ~/.config/awesome/volume.lua

In rc.lua at the top add:

  require(&quot;volume&quot;)

Add the widget to your taskbar:


    mywibox[s].widgets = {
        --  .... 
        volume_widget,
        -- ... ^ don't forget to add the widget to your taskbar!
    }

Finally add the keyboard keys for controlling/muting your volume:


    awful.key({ }, &quot;XF86AudioRaiseVolume&quot;, function ()
        awful.util.spawn(&quot;amixer set Master 9%+&quot;) end),
    awful.key({ }, &quot;XF86AudioLowerVolume&quot;, function ()
        awful.util.spawn(&quot;amixer set Master 9%-&quot;) end),
    awful.key({ }, &quot;XF86AudioMute&quot;, function ()
        awful.util.spawn(&quot;amixer sset Master toggle&quot;) end),

Should work now.


If you are annoyed by the stopwatch/busy mouse cursor, give the second parameter a false value to disable the startup-notification.[https://awesome.naquadah.org/wiki/Disable_startup-notification_globally]

    awful.key({ }, &quot;XF86AudioRaiseVolume&quot;, function ()
        awful.util.spawn(&quot;amixer set Master 9%+&quot;, false) end),
    awful.key({ }, &quot;XF86AudioLowerVolume&quot;, function ()
        awful.util.spawn(&quot;amixer set Master 9%-&quot;, false) end),
    awful.key({ }, &quot;XF86AudioMute&quot;, function ()
        awful.util.spawn(&quot;amixer set Master toggle&quot;, false) end),


If you have pulse installed (Ubuntu users) change this line:

        awful.util.spawn(&quot;amixer set Master toggle&quot;, false) end),

Too:

        awful.util.spawn(&quot;amixer -q -D default sset Master toggle&quot;, false) end),

This works for Ubuntu 14.04

        awful.util.spawn(&quot;amixer -D pulse set Master 1+ toggle&quot;, false) end),


&lt;b&gt;For awesome 3.5.x&lt;/b&gt;

volume.lua
&lt;pre&gt;
local wibox = require(&quot;wibox&quot;)
local awful = require(&quot;awful&quot;)

volume_widget = wibox.widget.textbox()
volume_widget:set_align(&quot;right&quot;)

function update_volume(widget)
   local fd = io.popen(&quot;amixer sget Master&quot;)
   local status = fd:read(&quot;*all&quot;)
   fd:close()

   local volume = tonumber(string.match(status, &quot;(%d?%d?%d)%%&quot;)) / 100
   -- volume = string.format(&quot;% 3d&quot;, volume)

   status = string.match(status, &quot;%[(o[^%]]*)%]&quot;)

   -- starting colour
   local sr, sg, sb = 0x3F, 0x3F, 0x3F
   -- ending colour
   local er, eg, eb = 0xDC, 0xDC, 0xCC

   local ir = math.floor(volume * (er - sr) + sr)
   local ig = math.floor(volume * (eg - sg) + sg)
   local ib = math.floor(volume * (eb - sb) + sb)
   interpol_colour = string.format(&quot;%.2x%.2x%.2x&quot;, ir, ig, ib)
   if string.find(status, &quot;on&quot;, 1, true) then
       volume = &quot; &lt;span background='#&quot; .. interpol_colour .. &quot;'&gt;   &lt;/span&gt;&quot;
   else
       volume = &quot; &lt;span color='red' background='#&quot; .. interpol_colour .. &quot;'&gt; M &lt;/span&gt;&quot;
   end
   widget:set_markup(volume)
end

update_volume(volume_widget)

mytimer = timer({ timeout = 1 })
mytimer:connect_signal(&quot;timeout&quot;, function () update_volume(volume_widget) end)
mytimer:start()
&lt;/pre&gt;

&lt;b&gt;rc.lua&lt;/b&gt;

At the top add

&lt;pre&gt;require(&quot;volume&quot;)&lt;/pre&gt;

Before &quot;right_layout:add(mytextclock)&quot; paste

&lt;pre&gt;
right_layout:add(volume_widget)
&lt;/pre&gt;


&lt;b&gt;For a numeric volume display:  &lt;/b&gt;


[[File:Normalvolume.png]]

[[File:Mute.png]]


There are a few things to change to the code:
&lt;pre&gt;
local wibox = require(&quot;wibox&quot;)
local awful = require(&quot;awful&quot;)
 
volume_widget = wibox.widget.textbox()
volume_widget:set_align(&quot;right&quot;)
 
function update_volume(widget)
   local fd = io.popen(&quot;amixer sget Master&quot;)
   local status = fd:read(&quot;*all&quot;)
   fd:close()
 
   -- local volume = tonumber(string.match(status, &quot;(%d?%d?%d)%%&quot;)) / 100
   local volume = string.match(status, &quot;(%d?%d?%d)%%&quot;)
   volume = string.format(&quot;% 3d&quot;, volume)
 
   status = string.match(status, &quot;%[(o[^%]]*)%]&quot;)

   if string.find(status, &quot;on&quot;, 1, true) then
       -- For the volume numbers
       volume = volume .. &quot;%&quot;
   else
       -- For the mute button
       volume = volume .. &quot;M&quot;
       
   end
   widget:set_markup(volume)
end
 
update_volume(volume_widget)
 
mytimer = timer({ timeout = 0.2 })
mytimer:connect_signal(&quot;timeout&quot;, function () update_volume(volume_widget) end)
mytimer:start()
&lt;/pre&gt;

&lt;pre&gt;https://github.com/esn89/volumetextwidget&lt;/pre&gt;

&lt;b&gt;Update an indicator in real time using D-Bus and ALSA&lt;/b&gt;

Previous examples are built using timers and polling to keep the indicator information relevant. It is not very beautiful and efficient though. 

Another approach is to use a helper program that listens to the events that ALSA emits when something changes (e.g. volume) and translates it to D-Bus signals. An example of such program is https://github.com/evgeniyzinoviev/alsa-volume-monitor.

Lua widget can listen to those D-Bus signals then and update itself immediately. Below is a quick example for Awesome 3.5.

First we need to launch the program at startup. For example, put this in your &lt;b&gt;.xinitrc&lt;/b&gt; (or whatever you're using to autostart applications on login):
&lt;pre&gt;
alsa-volume-monitor hw:0 &amp;
&lt;/pre&gt;

&lt;b&gt;hw:0&lt;/b&gt; is the name of your sound card.

Then make the widget listen to D-Bus signals:
&lt;pre&gt;
dbus.request_name(&quot;session&quot;, &quot;com.ch1p.avm&quot;)
dbus.add_match(&quot;session&quot;, &quot;interface='com.ch1p.avm',member='valueChanged'&quot;)
dbus.connect_signal(&quot;com.ch1p.avm&quot;, function()
        update_volume(volume_widget)
    end
)
&lt;/pre&gt;

[[Category:Widgets]]
[[Category:awesome3]]</text>
      <sha1>j1gxwsuxldo49wzkupemrfuqcewgodm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Volume control for PulseAudio</title>
    <ns>0</ns>
    <id>940</id>
    <revision>
      <id>6195</id>
      <parentid>5967</parentid>
      <timestamp>2014-01-04T12:42:05Z</timestamp>
      <contributor>
        <username>Jlep</username>
        <id>3141</id>
      </contributor>
      <comment>Added a version that works for awesome 3.4</comment>
      <text xml:space="preserve" bytes="1335">{{VersionSpecific
| goodversions = 3.4, 3.5
| otherversions = not tested
}}

The [https://github.com/mokasin/apw Awesome PulseAudio Widget] is just a little widget to control and display the default sink of PulseAudio using awful ProgressBar.
[[File:Example.jpg]]
[[Image:APW.png|right|thumb|Widget on the wibox.]]

== Get it ==

    cd $XDG_CONFIG_HOME/awesome/
    git clone https://github.com/mokasin/apw.git

== Use it ==


Just put these line to the appropriate places in ''$XDG_CONFIG_HOME/awesome/rc.lua''.

    -- Load the widget.
    local APW = require(&quot;apw/widget&quot;)
    
    -- Example: Add to wibox. Here to the right. Do it the way you like it.
    right_layout:add(APW)
    
    -- Configure the hotkeys.
    awful.key({ }, &quot;XF86AudioRaiseVolume&quot;,  APW.Up),
    awful.key({ }, &quot;XF86AudioLowerVolume&quot;,  APW.Down),
    awful.key({ }, &quot;XF86AudioMute&quot;,         APW.ToggleMute),


=== Tip ===

You could update the widget periodically if you'd like. In case, the volume is changed from somewhere else.

    APWTimer = timer({ timeout = 0.5 }) -- set update interval in s
    APWTimer:connect_signal(&quot;timeout&quot;, AWP.Update)
    APWTimer:start()

== Problems? ==
File an issue on Github.

== Awesome 3.4 ==

A version of this widget that works for awesome 3.4 can be found at
https://github.com/jlep/apw.git

[[Category:Widgets]]</text>
      <sha1>37qw0wbeoznmg0mezg4ubkm1gtqhlkh</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Volume in Status Bar</title>
    <ns>0</ns>
    <id>18</id>
    <revision>
      <id>1304</id>
      <timestamp>2008-10-16T15:12:37Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="2091">== Volume in Status Bar ==

In my system I've a ''/proc/asound/card0/codec97#0/ac97#0-0+regs'' file that stores the current volume values. I think that on other systems have similar file.

So, if you run this:

 $ cat '/proc/asound/card0/codec97#0/ac97#0-0+regs' &gt; a
 $ alsamixer # change the specified chanell's volume
 $ cat '/proc/asound/card0/codec97#0/ac97#0-0+regs' &gt; b
 $ diff a b

you'll know what is the desired channel's register (e.g. PCM, Headphone, Master,...). My PCM channel is reg. ''0:18'' and the Main is ''0:04''.

In that file (and my system) the volumes are two pair byte (left and right). The left and right volumes are always equal (by me) so the first pair byte is enough. 

Please note: the lower value is the louder and the highest value is quieter.

The awk-script:
 #!/bin/awk -f
 function print_data()
 {
    data =  &quot;0 widget_tell pb_volume_pcm &quot; pcm_vol &quot;\n&quot;\
            &quot;0 widget_tell pb_volume_master &quot; master_vol&quot;\n&quot;
    print data;
 }
 BEGIN {
   INTERVAL = 1;             # in seconds
 }
 { 
  while (!system(&quot;sleep &quot; INTERVAL))
  {
 
    while ( (getline &lt; &quot;/proc/asound/card0/codec97#0/ac97#0-0+regs&quot;)&gt;0 ) {
                if ($1~/0:18/) {
                        hex=strtonum(&quot;0x&quot;$3);
                        pcm_vol=(31-hex/256)*100;
                        pcm_vol/=31;
                } else if ($1~/0:04/) {
                        hex=strtonum(&quot;0x&quot;$3);
                        master_vol=(31-hex/256)*100;
                        master_vol/=31;
                }
        }
    close(&quot;/proc/asound/card0/codec97#0/ac97#0-0+regs&quot;);
  }
 }

You must have ''pb_volume_pcm'' and ''pb_volume_master'' progress bars - of course.

Remark: you can use this method to handle &quot;output signal level&quot; so you can create &quot;volume meter&quot;. Of course, in this case you must send information in every (about) 0.1 sec (10 fps).
[http://udvzsolt.extra.hu/e107_plugins/coppermine_menu/displayimage.php?pid=78&amp;fullsize=1 Example screenshot], see the bottom statusbar, about center, before &quot;Offspring - Want you so bad&quot; text.


[[Category:Widgets]]
[[Category:awesome2]]</text>
      <sha1>8ld48ktol6wdcesp5nwrtzijwvk208k</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Volume in Status Bar (better)</title>
    <ns>0</ns>
    <id>51</id>
    <redirect title="Woffles Volume Widget" />
    <revision>
      <id>294</id>
      <timestamp>2008-04-02T10:33:30Z</timestamp>
      <contributor>
        <username>Rowanjl</username>
        <id>20</id>
      </contributor>
      <comment>[[Volume in Status Bar (better)]] moved to [[Woffles Volume Widget]]</comment>
      <text xml:space="preserve" bytes="35">#REDIRECT [[Woffles Volume Widget]]</text>
      <sha1>rcg2lm73ujiorv22v73v1f2no01tz4j</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Volume in Status Bar (simpler way)</title>
    <ns>0</ns>
    <id>38</id>
    <revision>
      <id>1308</id>
      <timestamp>2008-10-16T15:14:17Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="1601">I'm using Ubuntu 7.10.

We'll start by installing '''amixer'''

 sudo apt-get install amixer

Then, we add these 2 textboxes to the &quot;statusbar&quot; part of our ''.awesomerc''

 textbox &quot;vol_up&quot; {
   text = &quot; UP &quot;
   mouse {
     modkey = {}
     button = &quot;1&quot;
     command = &quot;spawn&quot;
     arg = &quot;amixer -q -c 0 sset PCM,0 10%+&quot;
   }
 }

and

 textbox &quot;vol_down&quot; {
   text = &quot; DOWN &quot;
   mouse {
     modkey = {}
     button = &quot;1&quot;
     command = &quot;spawn&quot;
     arg = &quot;amixer -q -c 0 sset PCM,0 10%-&quot;
   }
 }

Et voilà ! You will probably have to adjust &quot;arg&quot; to suit your config. Anyway, here is a description of the important stuff in mine:

 -q     : quiet
 -c 0   : the sound card, &quot;0&quot; if only one card or for the first, &quot;1&quot; for the second and so on...
 PCM,0  : depends on your config, man amixer for more on this
 10%+   : increment by appending &quot;+&quot; to the value or decrement with a &quot;-&quot;

'''amixer''' has lots of options for you to play with. You definetly should have a look at 

 man amixer

----

If you don't have a fancy multimedia keyboard you can use the same commands from the keyboard by adding these definitions to the &quot;keys&quot; part of your ''.awesomerc''

 key{
   modkey = {&quot;Mod4&quot;}
   key = &quot;KP_Add&quot;
   command = &quot;spawn&quot;
   arg = &quot;amixer -q -c 0 sset PCM,0 10%+&quot;
 }

and

 key{
   modkey = {&quot;Mod4&quot;}
   key = &quot;KP_Subtract&quot;
   command = &quot;spawn&quot;
   arg = &quot;amixer -q -c 0 sset PCM,0 10%-&quot;
 }

Cool.

question:

everything works for me except for the last part - 

what is key = &quot;KP_Add&quot; ?

even when I replace it with + sign, nothing happened.

any clue?


[[Category:Widgets]]
[[Category:awesome2]]</text>
      <sha1>j6p68uahlqouxtffpbfk6kbcwfe0f67</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>WMII-like tag management</title>
    <ns>0</ns>
    <id>324</id>
    <revision>
      <id>6541</id>
      <parentid>6540</parentid>
      <timestamp>2014-05-18T12:48:23Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="7784">{{Languages}}

== WMII - like tag management ==

'''Note:''' You can also accomplish the below more easily with the [[Shifty]] library for Awesome.

WMII [http://wmii.suckless.org/] deals with tags in a bit more dynamic way than awesome does.
On the beginning of session only one tag is created (named '1'). If we enter a tag that didn't exist before, it's
created, when we leave an empty tag, it's destroyed.

It's a behaviour that I (a WMII refugee) missed a lot. Luckly it was not too hard to implement with some lua code and help of Garoth and psychon on IRC.

Note: all bits and pieces of the config file are for awesome 3.3-rc2. Other versions may require some tweaking.

First, we need some utility functions we'll use later on:

    function dictlen(tbl)
        local result = 0
        for _, __ in pairs(tbl) do
            result = result + 1
        end
        return result
    end

    function get_keys(tbl)
        local result = {}
        for key, _ in pairs(tbl) do
            if key then table.insert(result, key) end
        end
        return result
    end

    function make_completer(choices)
        return function(cmd, cur_pos, ncomp)
            local matches = {}
            -- abort completion under certain circumstances
            if #cmd == 0 or (cur_pos ~= #cmd + 1 and cmd:sub(cur_pos, cur_pos) ~= &quot; &quot;) then
                return cmd, cur_pos
            end     
            -- match
            for _, match in pairs(choices) do
                if match:find(&quot;^&quot; .. cmd:sub(1,cur_pos)) then
                    table.insert(matches, match)
                end     
            end       
            -- if there are no matches
            if #matches == 0 then
                return cmd, cur_pos
            end 
            -- cycle
            while ncomp &gt; #matches do
                ncomp = ncomp - #matches
            end     
            -- return match and position
            return matches[ncomp], cur_pos
        end
    end

Replace loop that add MOD+number keybindings (it's shown below):

    -- Compute the maximum number of digit we need, limited to 9
    keynumber = 0
    for s = 1, screen.count() do
       keynumber = math.min(9, math.max(#tags[s], keynumber));
    end

    for i = 1, keynumber do
        table.foreach(awful.key({ modkey }, i,
                      function () -- [cut]
                            end), function(_, k) table.insert(globalkeys, k) end)
        -- [cut]
    end

with something like this:

    for i = 0, 9 do
        table.foreach(awful.key({ modkey }, i,
                      function ()
                            local screen = mouse.screen
                            awful.tag.viewonly(get_tag(screen, i))
                      end), function(_, k) table.insert(globalkeys, k) end)
        table.foreach(awful.key({ modkey, &quot;Control&quot; }, i,
                      function ()
                          local screen = mouse.screen
                          local tag = get_tag(screen, i)
                          if tag then
                              tag.selected = not tag.selected
                          end
                      end), function(_, k) table.insert(globalkeys, k) end)
        table.foreach(awful.key({ modkey, &quot;Shift&quot; }, i,
                      function ()
                          if client.focus then
                              awful.client.movetotag(get_tag(client.focus.screen, i))
                          end
                      end), function(_, k) table.insert(globalkeys, k) end)
        table.foreach(awful.key({ modkey, &quot;Control&quot;, &quot;Shift&quot; }, i,
                      function ()
                          if client.focus then
                              awful.client.toggletag(get_tag(client.focus.screen, i))
                          end
                      end), function(_, k) table.insert(globalkeys, k) end)
        if i &gt; 0 then
            table.foreach(awful.key({ modkey, &quot;Shift&quot; }, &quot;F&quot; .. i,
                          function ()
                              local screen = mouse.screen
                              if tags[screen][i] then
                                  for k, c in pairs(awful.client.getmarked()) do
                                      awful.client.movetotag(get_tag(screen, i), c)
                                  end
                              end
                           end), function(_, k) table.insert(globalkeys, k) end)
        end
    end

Having that we can move on and create some tag-manipulating functions.
Replace all of the &quot;-- {{{ Tags&quot; fold in your rc.lua with this:

    -- {{{ Tags
    -- Define tags table.
    tags = {}
    
    -- put all clients with no tags to &quot;0&quot; tag on screen 1
    function handle_orphans()
        for _, c in pairs(client.get()) do
            if #c:tags() == 0 then
                c:tags({get_tag(1, &quot;0&quot;)})
            end
        end
    end
    
    function sort_tags(screen_no)
        local all_tags = screen[screen_no]:tags()
        table.sort(all_tags, function (a, b) return a.name &lt; b.name end)
        screen[screen_no]:tags(all_tags)
    end
    
    function delete_tag(screen_no, name)
        local strname = '' .. name
        if protected_tag == screen_no .. strname then return end
        local result = tags[screen_no][strname]
        if result ~= nil then
            result.screen = nil
            tags[screen_no][strname] = nil
        end
    end
    
    -- gets or creates tag
    function get_tag(screen_no, name)
        local strname = '' .. name
        local result = tags[screen_no][strname]
        if not tags[screen_no][strname] then
            protected_tag = screen_no .. strname
            result = tag(strname)
            result.screen = screen_no
            tags[screen_no][strname] = result
            awful.layout.set(layouts[1], result)
        end
        protected_tag = nil
        return result
    end
    
    for s = 1, screen.count() do
        -- Each screen has its own tag table.
        tags[s] = {}
        get_tag(s, 1).selected = true
    end
    
    -- }}}


To make unused tags disappear and have them nicely sorted, add the following
at the end of '''awful.hooks.arrange.register''' hook

    if screen == mouse.screen then
        for n, t in pairs(tags[screen]) do
            if #t:clients() == 0 and t ~= awful.tag.selected() and dictlen(tags[screen]) &gt; 1 then
                delete_tag(screen, n)
            end
        end
    end
    
    sort_tags(screen)
    handle_orphans()


Now, let's have a prompt for our tag manipulation:

    function tag_prompt(txt, callback)
        return function()
            local screen = client.focus and client.focus.screen or mouse.screen
            awful.prompt.run({ prompt = txt }, 
            mypromptbox[screen].widget,
            function(t) callback(screen, t) end,
            make_completer(get_keys(tags[screen])),
            awful.util.getdir(&quot;cache&quot;) .. &quot;/history_tags&quot;)
        end
    end

Let's bind it to keys (check if those bindings conflict with ones you already have!)

    awful.key({ modkey,           },       &quot;t&quot;, tag_prompt(&quot;go to tag: &quot;,   function (screen, tag) awful.tag.viewonly(get_tag(screen, tag)) end)),
    awful.key({ modkey, &quot;Shift&quot;   },       &quot;t&quot;, tag_prompt(&quot;move to tag: &quot;, function (screen, tag) awful.client.movetotag(get_tag(screen, tag)) end)),
    awful.key({ modkey, &quot;Ctrl&quot;, &quot;Shift&quot; }, &quot;t&quot;, tag_prompt(&quot;toggle tag: &quot;,  function (screen, tag) awful.tag.toggletag(get_tag(screen, tag)) end))

That's it, enjoy!

=== Further work ===
There are some obvious places that you can change/improve this, like:
  * '''+tag''' and '''-tag''' should be supported
  * dmenu can be used for tag selection instead of awesome's prompt for more WMII - like experience

[[Category:Awesome3]]</text>
      <sha1>ifonoiqp44xvtobl1cre5ddq9w72lea</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>WMII-like tag management/ru</title>
    <ns>0</ns>
    <id>1055</id>
    <revision>
      <id>6543</id>
      <timestamp>2014-05-18T12:57:54Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода WMII-like tag management</comment>
      <text xml:space="preserve" bytes="9555">{{DISPLAYTITLE:Управление тегами в стиле WMII}}
{{Languages|WMII-like tag management}}

== Введение ==

'''Примечание:''' Вы можете выполнить все нижеописанное намного проще, если будете использовать библиотеку [[Shifty]] для Awesome.

WMII [http://wmii.suckless.org/] реализует более динамичную работу с тегами, чем в  awesome.
При запуске сессии создается только один тег (с именем '1'). Если мы переключаемся на тег, который еще не существует, он создается. После закрытия всех приложений на каком либо теге, он уничтожается.

Эту возможность, которое я, как пришедший с WMII не обнаружил. Ее было не сложно реализовать испльзуя код Lua, очень пригодилась помощь Garoth и psychon в IRC-канале.

Примечание: все части и куски конфигурационного файла разработанны для awesome 3.3. Для других версий могут потребовать корректировки.

Во первых, нам потребуются несколько вспомогательных функций, которые мы будем использовать в дальнейшем:

    function dictlen(tbl)
        local result = 0
        for _, __ in pairs(tbl) do
            result = result + 1
        end
        return result
    end

    function get_keys(tbl)
        local result = {}
        for key, _ in pairs(tbl) do
            if key then table.insert(result, key) end
        end
        return result
    end

    function make_completer(choices)
        return function(cmd, cur_pos, ncomp)
            local matches = {}
            -- завершаем выполнение при определнных обстоятельствах
            if #cmd == 0 or (cur_pos ~= #cmd + 1 and cmd:sub(cur_pos, cur_pos) ~= &quot; &quot;) then
                return cmd, cur_pos
            end     
            -- сопоставление
            for _, match in pairs(choices) do
                if match:find(&quot;^&quot; .. cmd:sub(1,cur_pos)) then
                    table.insert(matches, match)
                end     
            end       
            -- если соотвествий не найдено
            if #matches == 0 then
                return cmd, cur_pos
            end 
            -- цикл
            while ncomp &gt; #matches do
                ncomp = ncomp - #matches
            end     
            -- возвращаем соотвествие и позицию
            return matches[ncomp], cur_pos
        end
    end

Замените цикл в котором обрабатываются нажатие клавиша MOD+number (как показано ниже):

    -- Вычисление максимального числа цифр, мы должны ограничить девятью
    keynumber = 0
    for s = 1, screen.count() do
       keynumber = math.min(9, math.max(#tags[s], keynumber));
    end

    for i = 1, keynumber do
        table.foreach(awful.key({ modkey }, i,
                      function () -- [cut]
                            end), function(_, k) table.insert(globalkeys, k) end)
        -- [cut]
    end

что то вроде этого:

    for i = 0, 9 do
        table.foreach(awful.key({ modkey }, i,
                      function ()
                            local screen = mouse.screen
                            awful.tag.viewonly(get_tag(screen, i))
                      end), function(_, k) table.insert(globalkeys, k) end)
        table.foreach(awful.key({ modkey, &quot;Control&quot; }, i,
                      function ()
                          local screen = mouse.screen
                          local tag = get_tag(screen, i)
                          if tag then
                              tag.selected = not tag.selected
                          end
                      end), function(_, k) table.insert(globalkeys, k) end)
        table.foreach(awful.key({ modkey, &quot;Shift&quot; }, i,
                      function ()
                          if client.focus then
                              awful.client.movetotag(get_tag(client.focus.screen, i))
                          end
                      end), function(_, k) table.insert(globalkeys, k) end)
        table.foreach(awful.key({ modkey, &quot;Control&quot;, &quot;Shift&quot; }, i,
                      function ()
                          if client.focus then
                              awful.client.toggletag(get_tag(client.focus.screen, i))
                          end
                      end), function(_, k) table.insert(globalkeys, k) end)
        if i &gt; 0 then
            table.foreach(awful.key({ modkey, &quot;Shift&quot; }, &quot;F&quot; .. i,
                          function ()
                              local screen = mouse.screen
                              if tags[screen][i] then
                                  for k, c in pairs(awful.client.getmarked()) do
                                      awful.client.movetotag(get_tag(screen, i), c)
                                  end
                              end
                           end), function(_, k) table.insert(globalkeys, k) end)
        end
    end

Имея это, мы уже можем удалять и создавать некоторые управляющие тегами функции.
Замените весь &quot;-- {{{ Tags&quot; на следующий код в rc.lua:

    -- {{{ Tags
    -- Define tags table.
    tags = {}
    
    -- поместить все приложения без тегов как &quot;0&quot; тег на screen 1
    function handle_orphans()
        for _, c in pairs(client.get()) do
            if #c:tags() == 0 then
                c:tags({get_tag(1, &quot;0&quot;)})
            end
        end
    end
    
    function sort_tags(screen_no)
        local all_tags = screen[screen_no]:tags()
        table.sort(all_tags, function (a, b) return a.name &lt; b.name end)
        screen[screen_no]:tags(all_tags)
    end
    
    function delete_tag(screen_no, name)
        local strname = '' .. name
        if protected_tag == screen_no .. strname then return end
        local result = tags[screen_no][strname]
        if result ~= nil then
            result.screen = nil
            tags[screen_no][strname] = nil
        end
    end
    
    -- получаем или создаем тег
    function get_tag(screen_no, name)
        local strname = '' .. name
        local result = tags[screen_no][strname]
        if not tags[screen_no][strname] then
            protected_tag = screen_no .. strname
            result = tag(strname)
            result.screen = screen_no
            tags[screen_no][strname] = result
            awful.layout.set(layouts[1], result)
        end
        protected_tag = nil
        return result
    end
    
    for s = 1, screen.count() do
        -- Каждый экран имеет собтвенную таблицу тегов.
        tags[s] = {}
        get_tag(s, 1).selected = true
    end
    
    -- }}}


Для того чтобы неиспользуемые теги красиво исчезали и сортировались, добавьте следующий код в конец hook'а '''awful.hooks.arrange.register'''

    if screen == mouse.screen then
        for n, t in pairs(tags[screen]) do
            if #t:clients() == 0 and t ~= awful.tag.selected() and dictlen(tags[screen]) &gt; 1 then
                delete_tag(screen, n)
            end
        end
    end
    
    sort_tags(screen)
    handle_orphans()


Теперь создадим код для управления нашими тегами:

    function tag_prompt(txt, callback)
        return function()
            local screen = client.focus and client.focus.screen or mouse.screen
            awful.prompt.run({ prompt = txt }, 
            mypromptbox[screen].widget,
            function(t) callback(screen, t) end,
            make_completer(get_keys(tags[screen])),
            awful.util.getdir(&quot;cache&quot;) .. &quot;/history_tags&quot;)
        end
    end

Теперь привяжем его к клавишам (проверьте с существующими клавишами, чтобы не было конфликтов!)

    awful.key({ modkey,           },       &quot;t&quot;, tag_prompt(&quot;go to tag: &quot;,   function (screen, tag) awful.tag.viewonly(get_tag(screen, tag)) end)),
    awful.key({ modkey, &quot;Shift&quot;   },       &quot;t&quot;, tag_prompt(&quot;move to tag: &quot;, function (screen, tag) awful.client.movetotag(get_tag(screen, tag)) end)),
    awful.key({ modkey, &quot;Ctrl&quot;, &quot;Shift&quot; }, &quot;t&quot;, tag_prompt(&quot;toggle tag: &quot;,  function (screen, tag) awful.tag.toggletag(get_tag(screen, tag)) end))

Это всё, наслаждайтесь!

=== Запланированная работа ===
Есть некоторы очевидные места, котрые вы можете изменить/улучшить, такие как:
  * Поддержка '''+tag''' и '''-tag'''
  * dmenu может использоваться для выбора тега, вместо строки awesome, как это сделано в WMII - как опыт

[[Category:Awesome3]]</text>
      <sha1>bsdnhv6f4hqf7fl73bsk57bym54ast0</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>WWII Theme</title>
    <ns>0</ns>
    <id>507</id>
    <revision>
      <id>3828</id>
      <parentid>3819</parentid>
      <timestamp>2009-11-22T14:05:54Z</timestamp>
      <contributor>
        <username>Anrxc</username>
        <id>258</id>
      </contributor>
      <minor/>
      <comment>Screenshot added to WWII theme page.</comment>
      <text xml:space="preserve" bytes="5636">[[Image:Screenshot-WWII.png|thumb|Screenshot]]
&lt;pre&gt;
--------------------------------
--    &quot;WWII&quot; awesome theme    --
--------------------------------
--  Author: Adrian C. (anrxc) --
--  * inspired by wmii colors --
--------------------------------


-- {{{ Main
theme = {}
theme.wallpaper_cmd = { &quot;awsetbg /usr/share/awesome/themes/zenburn/zenburn-background.png&quot; }
-- }}}


-- {{{ Styles
theme.font          = &quot;Profont 8&quot;

-- {{{ Colors
theme.fg_normal     = &quot;#000000&quot;
theme.fg_focus      = &quot;#000000&quot;
theme.fg_urgent     = &quot;#CF6171&quot;
--theme.fg_minimize = &quot;#000000&quot;
theme.bg_normal     = &quot;#C1C48B&quot;
theme.bg_focus      = &quot;#81654F&quot;
theme.bg_urgent     = &quot;#C1C48B&quot;
--theme.bg_minimize = &quot;#81654F&quot;
-- }}}

-- {{{ Borders
theme.border_width  = &quot;1&quot;
theme.border_normal = &quot;#81654F&quot;
theme.border_focus  = &quot;#000000&quot;
theme.border_marked = &quot;#CF6171&quot;
-- }}}

-- {{{ Titlebars
theme.titlebar_bg_focus  = &quot;#81654F&quot;
theme.titlebar_bg_normal = &quot;#C1C48B&quot;
-- theme.titlebar_[normal|focus]
-- }}}

-- {{{ Other
-- There are other variable sets
-- overriding the default one when
-- defined, the sets are:
-- [taglist|tasklist]_[bg|fg]_[focus|urgent]
-- titlebar_[normal|focus]
-- tooltip_[font|opacity|fg_color|bg_color|border_width|border_color]
-- Example:
--theme.taglist_bg_focus = &quot;#CF6171&quot;
-- }}}

-- {{{ Widgets
-- You can add as many variables as
-- you wish and access them by using
-- beautiful.variable in your rc.lua
--theme.fg_widget        = &quot;#AECF96&quot;
--theme.fg_center_widget = &quot;#88A175&quot;
--theme.fg_end_widget    = &quot;#FF5656&quot;
--theme.bg_widget        = &quot;#494B4F&quot;
--theme.border_widget    = &quot;#3F3F3F&quot;
-- }}}

-- {{{ Mouse finder
theme.mouse_finder_color = &quot;#CF6171&quot;
-- theme.mouse_finder_[timeout|animate_timeout|radius|factor]
-- }}}

-- {{{ Menu
-- Variables set for theming the menu:
-- menu_[bg|fg]_[normal|focus]
-- menu_[border_color|border_width]
theme.menu_height = &quot;15&quot;
theme.menu_width  = &quot;100&quot;
-- }}}
-- }}}

-- {{{ Icons
-- {{{ Taglist
theme.taglist_squares_sel   = &quot;/usr/share/awesome/themes/default/taglist/squarefw.png&quot;
theme.taglist_squares_unsel = &quot;/usr/share/awesome/themes/default/taglist/squarew.png&quot;
--theme.taglist_squares_resize = &quot;false&quot;
-- }}}

-- {{{ Misc
theme.awesome_icon           = &quot;/usr/share/awesome/icons/awesome16.png&quot;
theme.menu_submenu_icon      = &quot;/usr/share/awesome/themes/default/submenu.png&quot;
theme.tasklist_floating_icon = &quot;/usr/share/awesome/themes/default/tasklist/floating.png&quot;
-- }}}

-- {{{ Layout
theme.layout_fairh      = &quot;/usr/share/awesome/themes/default/layouts/fairh.png&quot;
theme.layout_fairv      = &quot;/usr/share/awesome/themes/default/layouts/fairv.png&quot;
theme.layout_floating   = &quot;/usr/share/awesome/themes/default/layouts/floating.png&quot;
theme.layout_magnifier  = &quot;/usr/share/awesome/themes/default/layouts/magnifier.png&quot;
theme.layout_max        = &quot;/usr/share/awesome/themes/default/layouts/max.png&quot;
theme.layout_fullscreen = &quot;/usr/share/awesome/themes/default/layouts/fullscreen.png&quot;
theme.layout_tilebottom = &quot;/usr/share/awesome/themes/default/layouts/tilebottom.png&quot;
theme.layout_tileleft   = &quot;/usr/share/awesome/themes/default/layouts/tileleft.png&quot;
theme.layout_tile       = &quot;/usr/share/awesome/themes/default/layouts/tile.png&quot;
theme.layout_tiletop    = &quot;/usr/share/awesome/themes/default/layouts/tiletop.png&quot;
theme.layout_spiral     = &quot;/usr/share/awesome/themes/default/layouts/spiral.png&quot;
theme.layout_dwindle    = &quot;/usr/share/awesome/themes/default/layouts/dwindle.png&quot;
-- }}}

-- {{{ Titlebar
theme.titlebar_close_button_normal = &quot;/usr/share/awesome/themes/default/titlebar/close_normal.png&quot;
theme.titlebar_close_button_focus  = &quot;/usr/share/awesome/themes/default/titlebar/close_focus.png&quot;

theme.titlebar_ontop_button_normal_inactive = &quot;/usr/share/awesome/themes/default/titlebar/ontop_normal_inactive.png&quot;
theme.titlebar_ontop_button_focus_inactive  = &quot;/usr/share/awesome/themes/default/titlebar/ontop_focus_inactive.png&quot;
theme.titlebar_ontop_button_normal_active   = &quot;/usr/share/awesome/themes/default/titlebar/ontop_normal_active.png&quot;
theme.titlebar_ontop_button_focus_active    = &quot;/usr/share/awesome/themes/default/titlebar/ontop_focus_active.png&quot;

theme.titlebar_sticky_button_normal_inactive = &quot;/usr/share/awesome/themes/default/titlebar/sticky_normal_inactive.png&quot;
theme.titlebar_sticky_button_focus_inactive  = &quot;/usr/share/awesome/themes/default/titlebar/sticky_focus_inactive.png&quot;
theme.titlebar_sticky_button_normal_active   = &quot;/usr/share/awesome/themes/default/titlebar/sticky_normal_active.png&quot;
theme.titlebar_sticky_button_focus_active    = &quot;/usr/share/awesome/themes/default/titlebar/sticky_focus_active.png&quot;

theme.titlebar_floating_button_normal_inactive = &quot;/usr/share/awesome/themes/default/titlebar/floating_normal_inactive.png&quot;
theme.titlebar_floating_button_focus_inactive  = &quot;/usr/share/awesome/themes/default/titlebar/floating_focus_inactive.png&quot;
theme.titlebar_floating_button_normal_active   = &quot;/usr/share/awesome/themes/default/titlebar/floating_normal_active.png&quot;
theme.titlebar_floating_button_focus_active    = &quot;/usr/share/awesome/themes/default/titlebar/floating_focus_active.png&quot;

theme.titlebar_maximized_button_normal_inactive = &quot;/usr/share/awesome/themes/default/titlebar/maximized_normal_inactive.png&quot;
theme.titlebar_maximized_button_focus_inactive  = &quot;/usr/share/awesome/themes/default/titlebar/maximized_focus_inactive.png&quot;
theme.titlebar_maximized_button_normal_active   = &quot;/usr/share/awesome/themes/default/titlebar/maximized_normal_active.png&quot;
theme.titlebar_maximized_button_focus_active    = &quot;/usr/share/awesome/themes/default/titlebar/maximized_focus_active.png&quot;
-- }}}
-- }}}

return theme
&lt;/pre&gt;
[[Category:Themes]]
[[Category:awesome3]]</text>
      <sha1>80tre3h00417ot3xuoybi4o1j9caopp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Weather</title>
    <ns>0</ns>
    <id>19</id>
    <revision>
      <id>7092</id>
      <parentid>7005</parentid>
      <timestamp>2014-10-29T22:04:00Z</timestamp>
      <contributor>
        <username>Pchyolki</username>
        <id>3829</id>
      </contributor>
      <minor/>
      <comment>/* Awesome 3.5 */</comment>
      <text xml:space="preserve" bytes="6769">==Awesome 2==

===w3m and bash===
You'll need: w3m, a ''tb_weather'' textbox and an internet-connection...

 #!/bin/bash
 
 if [ $# -ne 1 ]; then
         echo Usage: $(basename $0) city
         exit 1
 fi
 
 CITY=$1
 FILE=$(mktemp)
 w3m -dump &quot;http://www.google.com/search?hl=en&amp;q=${CITY}+weather&quot; &gt; $FILE
 FIRST=$(grep -n iGoogle $FILE | awk -F &quot;:&quot; {'print $1'})
 FIRST=$((FIRST+1))
 LAST=$((FIRST+14))
 
 sed -n -i &quot;$FIRST,$LAST p&quot; $FILE
 TEMP=$(sed -n &quot;1 p&quot; $FILE)
 WIND=$(sed -n &quot;2 p&quot; $FILE)
 HUM=$(sed -n &quot;3 p&quot; $FILE)
 SUN=$(sed -n &quot;5 p&quot; $FILE)
 MIN_MAX=$(sed -n &quot;6 p&quot; $FILE | awk {'print $4$5&quot; - &quot;$1$2'})
 MIN_MAX_TOMORROW=$(sed -n &quot;9 p&quot; $FILE | awk {'print $4$5&quot; - &quot;$1$2'})
 SUN_TOMORROW=$(sed -n &quot;8 p&quot; $FILE)
 
 echo 0 widget_tell tb_weather $SUN, $TEMP&quot;(&quot;$MIN_MAX&quot;)  - &quot; $WIND --- Tomorrow: $SUN_TOMORROW, $MIN_MAX_TOMORROW | awesome-client
 
 rm ${FILE}

This is a &quot;skeleton&quot;, you can modify this script.

--[[User:Uzsolt|Uzsolt]]

===bash script with wget for awesome 2.3===

Here's another example:

 #!/bin/bash
 # this script is for awesome 2.3
 
 LOCATION=KNYC
 # station list at: http://www.rap.ucar.edu/weather/surface/stations.txt
 
 while true; do
   if [ -S ~/.awesome_ctl.0 ]; then
     while true; do
       NEW=$(wget -qO- &quot;http://www.weather.gov/data/current_obs/${LOCATION}.xml&quot;\
         | sed -nr '/&lt;(weather|temp_f)&gt;/s/.*&gt;(.*)&lt;.*/\1/p' 2&gt;/dev/null)
       if [ &quot;x$NEW&quot; != x ]; then
         NEW=$(echo &quot;$NEW&quot; | awk 'BEGIN{RS=&quot;&quot;;FS=&quot;\n&quot;}{printf &quot;%s %s\xb0&quot;,$1,$2}')
         echo -e &quot;0 widget_tell mystatusbar weather text $NEW&quot;
         echo &quot;&quot; # an empty line flushes data inside awesome
       fi
       sleep 600
     done | awesome-client
   else
     sleep 1
   fi
 done
--[[User:Profjim|Profjim]] 16:19, 1 July 2008 (UTC)

===Perl===

This is a Perl example for XML weather from http://weather.com, you can change it.

 #!/usr/bin/perl
 use XML::Simple;
 use LWP::Simple;
 use strict;
 use warnings;
 my $wea=XMLin(get('http://xoap.weather.com/weather/local/RSXX0091?cc=*&amp;unit=m'));
 my $tmp=$wea-&gt;{'cc'}-&gt;{'tmp'};
 my $t=$wea-&gt;{'cc'}-&gt;{'t'};
 $t=~s/Light Rain Shower/LRS/;
 $t=~s/Light Rain/LR/;
 $t=~s/Light Snow Shower/LSS/;
 $t=~s/Light Snow/LS/;
 $t=~s/Light Freezing Rain/LFR/;
 $t=~s/Light/L/;
 $t=~s/Cloudy/C/;
 $t=~s/Windy/W/;
 #$t=~s/and/&amp;/;
 $t=~s/Partly/P/;
 $t=~s/Mostly/M/;
 if (length($t)&lt;=4) { $t=~s/ //g;}
 my $bar=$wea-&gt;{'cc'}-&gt;{'bar'}-&gt;{'r'};
 $bar*=0.75006; //converts to mmHg
 $bar=sprintf(&quot;%d&quot;,$bar);
 my $wind=$wea-&gt;{'cc'}-&gt;{'wind'}-&gt;{'s'};
 $wind/=3.6;    //converts to m/s and rounds it to nearest integer.
 $wind+=0.5;
 $wind=sprintf(&quot;%d&quot;,$wind);
 my $dir=$wea-&gt;{'cc'}-&gt;{'wind'}-&gt;{'t'};
 print $tmp . &quot;°C, &quot; . $bar . &quot; mmHg, &quot; . $wind . &quot; m/s, &quot; . $dir . &quot;, &quot; . $t . &quot;\n&quot;;

--[[User:IoGA|IoGA]] 15:22, 17 November 2008 (UTC)


==Awesome 3==

=== Yahoo Weather ===

Widget set, naughty notification, nice icon updating at forecast change and day/night cycle, localization support.

See https://github.com/copycat-killer/lain/wiki/yawn

--[[User:Luke bonham|Luke Bonham]] 10:47:00, 29 October 2013 (CEST)

=== Google API + awful ===

I wrote a solution that makes a simple HTTP request to Google's Weather API based on postal code. See https://github.com/jesseadams/weather

--[[User:Jesseadams|Jesseadams]] 06:15:38, 06 June 2011 (UTC)

=== Google API + libxslt + Naughty ===

Another solution, which shows [[Naughty]] notifications on mouse_hover at your widget (I use it for my text clock).
Data is taken from Google API using query string, such as town name, postal code, etc.
Futher reading at [https://github.com/ioga/perceptive github]

--[[User:IoGA|IoGA]] 11:02, 7 August 2011 (CEST)

===weather-util, awk, naughty and awful===

This widget uses [[Naughty]], [http://awesome.naquadah.org/doc/api/ awful], awk, the internet, and the commandline program &quot;[http://fungi.yuggoth.org/weather/ weather-util]&quot;, which is also in the Debian, Ubuntu and Archlinux repositories. The widget creates a simple text box with the temperature, which you can hover over to get the full weather information.

Replace METARID with the metar ID of the weather station for your area. this is a four letter code like LYBE for Belgrade, Serbia. Stations list at [http://www.rap.ucar.edu/weather/surface/stations.txt]

 --Create a weather widget
 
  weatherwidget = widget({ type = &quot;textbox&quot; })
 weatherwidget.text = awful.util.pread(
   &quot;weather -i '''METARID''' --headers=Temperature --quiet -m | awk '{print $2, $3}'&quot;
 ) -- replace METARID with the metar ID for your area. This uses metric. If you prefer Fahrenheit remove the &quot;-m&quot; in &quot;--quiet -m&quot;.
 weathertimer = timer(
   { timeout = 900 } -- Update every 15 minutes. 
 ) 
 weathertimer:add_signal(
   &quot;timeout&quot;, function() 
      weatherwidget.text = awful.util.pread(
      &quot;weather -i '''METARID''' --headers=Temperature --quiet -m | awk '{print $2, $3}' &amp;&quot;
    ) --replace METARID and remove -m if you want Fahrenheit
  end)
 
 weathertimer:start() -- Start the timer
 weatherwidget:add_signal(
 &quot;mouse::enter&quot;, function() 
   weather = naughty.notify(
     {title=&quot;Weather&quot;,text=awful.util.pread(&quot;weather -i '''METARID''' -m&quot;)})
   end) -- this creates the hover feature. replace METARID and remove -m if you want Fahrenheit
 weatherwidget:add_signal(
   &quot;mouse::leave&quot;, function() 
     naughty.destroy(weather) 
   end)
 -- I added some spacing because on my computer it is right next to my clock.
 awful.widget.layout.margins[weatherwidget] = { right = 5 } 



Now add the widget in with your other widgets, for example left of the text clock:

 mywibox[s].widgets = {
    ...
    mytextclock,
    weatherwidget,
    ...


--[[User:Pthalo|Pthalo]] 22:35, 12 April 2011 (UTC)


== Awesome 3.5 ==

Based on the above code using weather-util, but updated for Awesome 3.5 and using a simple ZIP code search instead of METARID.

 &lt;nowiki&gt;
--Create a weather widget
weatherwidget = wibox.widget.textbox()
weatherwidget:set_text(awful.util.pread(
   &quot;weather ZIP --headers=Temperature --quiet | awk '{print $2, $3}'&quot;
)) -- replace ZIP with the ID for your area. If you prefer Metric add &quot;-m&quot;.
weathertimer = timer(
   { timeout = 900 } -- Update every 15 minutes.
)
weathertimer:connect_signal(
   &quot;timeout&quot;, function()
      weatherwidget:set_text(awful.util.pread(
         &quot;weather ZIP --headers=Temperature --quiet | awk '{print $2, $3}' &amp;&quot;
      ))end)

weathertimer:start() -- Start the timer
weatherwidget:connect_signal(
   &quot;mouse::enter&quot;, function()
      weather = naughty.notify(
         {title=&quot;Weather&quot;,text=awful.util.pread(&quot;weather ZIP&quot;)})
end) -- this creates the hover feature.

weatherwidget:connect_signal(
   &quot;mouse::leave&quot;, function()
      naughty.destroy(weather)
end)
&lt;/nowiki&gt;
[[Category:Widgets]]
[[Category:awesome2]]
[[Category:awesome3]]</text>
      <sha1>phfs4rm7f4i5xsoqx0fwkc86035seev</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Wibox Raise/Lower</title>
    <ns>0</ns>
    <id>1325</id>
    <revision>
      <id>7472</id>
      <timestamp>2016-05-23T19:32:47Z</timestamp>
      <contributor>
        <username>Johan widen</username>
        <id>4323</id>
      </contributor>
      <comment>Created page with &quot;I have for a while been bothered by windows that cover the Wibox when they open. I used to pull them away from the Wibox with the mouse, but it is possible to raise the Wibox...&quot;</comment>
      <text xml:space="preserve" bytes="405">I have for a while been bothered by windows that cover the Wibox when they open. I used to pull them away from the Wibox with the mouse, but it is possible to raise the Wibox above any window, or to let windows cover the Wibox.

 &lt;nowiki&gt;    -- Raise/Lower Wibox
    awful.key({ modkey, &quot;Shift&quot; }, &quot;b&quot;, function ()
          mywibox[mouse.screen].ontop = not mywibox[mouse.screen].ontop
    end),&lt;/nowiki&gt;</text>
      <sha1>ezlbp0rqyb3m7rm1qphdstso0ti1ery</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Wicked</title>
    <ns>0</ns>
    <id>93</id>
    <revision>
      <id>4328</id>
      <parentid>3615</parentid>
      <timestamp>2010-06-24T00:44:07Z</timestamp>
      <contributor>
        <username>Brendel</username>
        <id>486</id>
      </contributor>
      <comment>/* Lenny x86 */</comment>
      <text xml:space="preserve" bytes="11498">{{Languages}}

Note: Wicked has been deprecated in favour of the new [[Vicious]] library, which has more features and is updated more often.

Wicked is a lua library, which means you can require() it from within [[Awesome_3_configuration#Files|rc.lua]], and set up all your widgets from inside the same config file, without having to run a separate program with separate config files.

== Getting Wicked ==
===Debian===
==== Lenny x86 ====
Awesome3 is available in sid. It has been backported to lenny. To use it, become root and:
* Add the repository to /etc/apt/sources.list:
&lt;pre&gt;
deb http://corvix.eu testing ware
&lt;/pre&gt;
* And install it
&lt;pre&gt;
apt-get update
apt-get upgrade
apt-get install awesome awesome-wicked
&lt;/pre&gt;

* To get rid of the warning about the key signature add the key
&lt;pre&gt;
gpg --keyserver pgpkeys.mit.edu --recv-key 974E7D68
gpg -a --export 974E7D68 | sudo apt-key add -
&lt;/pre&gt;
Its fingerprint should be:
0189 4F9A 5CFD 0242 5BEA 39E6 37A4 6DF5 974E 7D68

=== Arch Linux ===
If you are using Arch Linux, a PKGBUILD is already available over at the aur, get it here: [http://aur.archlinux.org/packages.php?ID=17232 http://aur.archlinux.org/packages.php?ID=17232].

Repositories:
&lt;pre&gt;
[awesome]
#awesome3
Server = http://www.camazotz.de/awesome/
&lt;/pre&gt;
&lt;pre&gt;
[deelab]
#awesome-git
Server = http://www.deelab.org/arch/i686
&lt;/pre&gt;

=== Source Mage GNU/Linux ===

All you have to do is &quot;cast wicked&quot;

=== Gentoo Linux ===
A gentoo package is available here [http://overlays.gentoo.org/dev/matsuu/browser/awesome/x11-plugins/wicked/wicked-9999.ebuild wicked-9999.ebuild].

=== Manually ===
If you are not using Arch or would like to fetch the library separately, you can fetch it from the git repository at [http://git.glacicle.com/?p=awesome/wicked.git;a=summary http://git.glacicle.com/?p=awesome/wicked.git;a=summary].

Install it manually as such:
&lt;pre&gt;
git clone git://git.glacicle.com/awesome/wicked.git
sudo cp wicked/wicked.lua /usr/share/awesome/lib/
sudo cp wicked/wicked.7.gz /usr/share/man/man7/
&lt;/pre&gt;

== Setting Up Wicked ==
Setting up wicked is easy, just add the following line to the top of your [[Awesome_3_configuration#Files|rc.lua]] and you're ready to go.
&lt;pre&gt;
require(&quot;wicked&quot;)
&lt;/pre&gt;

== Creating Widgets ==
Creating widgets is as simple as adding one function call to your [[Awesome_3_configuration#Files|rc.lua]], below are a few examples you can use, for more information on possible widget types and options, see `man wicked` after installing wicked. Don't forget that you still need to add the widgets to the statusbar later.

Best to learn by example.  Check out the author's [http://git.glacicle.com/other/configs.git/.config/awesome/rc_31.lua current config].

=== Date Widget Example ===
The following widget displays the current date (output of the `date` command) in the statusbar.
&lt;pre&gt;
datewidget = widget({
    type = 'textbox',
    name = 'datewidget'
})

wicked.register(datewidget, wicked.widgets.date,
    ' &lt;span color=&quot;white&quot;&gt;Date:&lt;/span&gt; %c')
&lt;/pre&gt;

=== MPD `Now Playing` Example ===
The following widget is a simple widget showing the song that is currently playing through the Music Playing Daemon.
&lt;pre&gt;
mpdwidget = widget({
    type = 'textbox',
    name = 'mpdwidget'
})

wicked.register(mpdwidget, wicked.widgets.mpd,
    ' &lt;span color=&quot;white&quot;&gt;Now Playing:&lt;/span&gt; $1')
&lt;/pre&gt;

If you want to get a little more fancy and show the current song only when it's playing, change the register call to this:

&lt;pre&gt;
wicked.register(mpdwidget, wicked.widgets.mpd, 
	function (widget, args)
		   if args[1]:find(&quot;volume:&quot;) == nil then
		      return ' &lt;span color=&quot;white&quot;&gt;Now Playing:&lt;/span&gt; '..args[1]
		   else
                      return ''
                   end
		end)
&lt;/pre&gt;

=== Memory Usage Monitor Example ===
The following widget shows the current memory usage in percentage and in megabytes out of the total available.
&lt;pre&gt;
memwidget = widget({
    type = 'textbox',
    name = 'memwidget'
})

wicked.register(memwidget, wicked.widgets.mem,
    ' &lt;span color=&quot;white&quot;&gt;Memory:&lt;/span&gt; $1 ($2Mb/$3Mb)')
&lt;/pre&gt;

If you wanted to padd the values to 2, 4 and 4 digits respectively, you would use:
&lt;pre&gt;
memwidget = widget({
    type = 'textbox',
    name = 'memwidget'
})

wicked.register(memwidget, wicked.widgets.mem,
    ' &lt;span color=&quot;white&quot;&gt;Memory:&lt;/span&gt; $1 ($2Mb/$3Mb)',
nil, nil, {2, 4, 4})
&lt;/pre&gt;

=== Memory Usage Progressbar Example ===
The following widget displays the relative memory usage in a progressbar.
&lt;pre&gt;
membarwidget = widget({
    type = 'progressbar',
    name = 'membarwidget',
    align = 'right'
})

membarwidget:properties_set('mem', {
width = 40,
height = 0.65,
gap = 0,
border_padding = 1,
border_width = 1,
ticks_count = 0,
ticks_gap = 0,
vertical = false
})

membarwidget:bar_properties_set('mem', {
bg = '#222222',
fg = '#285577',
fg_center = '#285577',
fg_end = '#285577',
fg_off = '#222222',
reverse = false,
min_value = 0,
max_value = 100
})

wicked.register(membarwidget, wicked.widgets.mem, '$1', 1, 'mem')
&lt;/pre&gt;

=== CPU Usage Example ===
The following widget displays the current CPU usage in percentages.
&lt;pre&gt;
cpuwidget = widget({
    type = 'textbox',
    name = 'cpuwidget'
})

wicked.register(cpuwidget, wicked.widgets.cpu,
    ' &lt;span color=&quot;white&quot;&gt;CPU:&lt;/span&gt; $1%')
&lt;/pre&gt;

=== CPU Usage Graph Example ===
The following widget displays a graph with your current CPU usage.
&lt;pre&gt;
cpugraphwidget = widget({
    type = 'graph',
    name = 'cpugraphwidget',
    align = 'right'
})

cpugraphwidget.height = 0.85
cpugraphwidget.width = 45
cpugraphwidget.bg = '#333333'
cpugraphwidget.border_color = '#0a0a0a'
cpugraphwidget.grow = 'left'

cpugraphwidget:plot_properties_set('cpu', {
    fg = '#AEC6D8',
    fg_center = '#285577',
    fg_end = '#285577',
    vertical_gradient = false
})

wicked.register(cpugraphwidget, wicked.widgets.cpu, '$1', 1, 'cpu')
&lt;/pre&gt;

=== Filesystem Usage Example ===
The following widget displays the space used out of the total space available on the partition mounted as /, as well as the usage percentage.
&lt;pre&gt;
fswidget = widget({
    type = 'textbox',
    name = 'fswidget'
})

wicked.register(fswidget, wicked.widgets.fs,
    ' &lt;span color=&quot;white&quot;&gt;FS:&lt;/span&gt; ${/ used}/${/ size} (${/ usep} used)', 120)
&lt;/pre&gt;

=== Network Interface Monitor Example ===
The following widget displays the current speed on eth0, as well as connection transfer totals.
The final argument padds all values to at least 3 digits.
&lt;pre&gt;
netwidget = widget({
    type = 'textbox',
    name = 'netwidget'
})

wicked.register(netwidget, wicked.widgets.net, 
    ' &lt;span color=&quot;white&quot;&gt;NET&lt;/span&gt;: ${eth0 down} / ${eth0 up} [ ${eth0 rx} //  ${eth0 tx} ]',
nil, nil, 3)
&lt;/pre&gt;

=== Battery Charge Example ===
The following widget displays the charge of your batteries:

&lt;pre&gt;
batteries = 2

-- Function to extract charge percentage
function read_battery_life(number)
   return function(format)
             local fh = io.popen('acpi')
             local output = fh:read(&quot;*a&quot;)
             fh:close()

             count = 0
             for s in string.gmatch(output, &quot;(%d+)%%&quot;) do
                if number == count then
                   return {s}
                end
                count = count + 1
             end
          end
end

-- Display one vertical progressbar per battery
for battery=0, batteries-1 do
   batterygraphwidget = widget({ type = 'progressbar',
                                 name = 'batterygraphwidget',
                                 align = 'right' })
   batterygraphwidget.height = 0.85
   batterygraphwidget.width = 8
   batterygraphwidget.bg = '#333333'
   batterygraphwidget.border_color = '#0a0a0a'
   batterygraphwidget.vertical = true
   batterygraphwidget:bar_properties_set('battery',
                                         { fg = '#AEC6D8',
                                           fg_center = '#285577',
                                           fg_end = '#285577',
                                           fg_off = '#222222',
                                           vertical_gradient = true,
                                           horizontal_gradient = false,
                                           ticks_count = 0,
                                           ticks_gap = 0 })

   wicked.register(batterygraphwidget, read_battery_life(battery), '$1', 1, 'battery')
end
&lt;/pre&gt;

== Custom Widgets ==
You can create your own custom widgets by passing your own functions as the type parameter, using this, you can specify any arbitrary command to be outputted into a widget at any interval. The following example displays the volume from alsa (gotten by running the `amixer` command and parsing the output), every 4 seconds. (Note: requires alsa-utils)
&lt;pre&gt;
volumewidget = widget({
    type = 'textbox',
    name = 'volumewidget'
})

function amixer_volume(format)
   local f = io.popen('amixer get PCM')
   local l = f:lines()
   local v = ''

   for line in l do
       if line:find('Front Left:') ~= nil then
            pend = line:find('%]', 0, true)
            pstart = line:find('[', 0, true)
            v = line:sub(pstart+1, pend)
       end
   end

   f:close()

   return {v}
end


wicked.register(volumewidget, amixer_volume, &quot;&lt;span color='white'&gt;Volume&lt;/span&gt;: $1&quot;, 4)&lt;/pre&gt;

You can use the following to run any external script you might have written that collects data and outputs it:
&lt;pre&gt;
mywidget = widget({
    type = 'textbox',
    name = 'mywidget'
})
 
function run_script()
    local filedescriptor = io.popen('my_nifty_script.py')
    local value = filedescriptor:read()
    filedescriptor:close()

    return {value}
end
 
-- Runs 'my_nifty_script.py' every 10 seconds and puts its output into the widget
wicked.register(mywidget, run_script, &quot;$1&quot;, 10)
&lt;/pre&gt;

== Awesome Freezing ==
Because awesome waits for the lua code to finish before resuming, running a slow script might bog down or freeze your awesome, you can use a background process and a temporary file to circumvent this.
Use the code below to run a slow script you might have, without freezing awesome.
&lt;pre&gt;
mywidget = widget({
    type = 'textbox',
    name = 'mywidget'
})

function run_slow_script (widget, args) 
   -- Read the temporary file left by the script
   local filedescriptor = io.open('/tmp/script-temp-file')
   local value = nil

   if filedescriptor ~= nil then
      value = filedescriptor:read()
   end

   filedescriptor:close()

   if value == nil then
      return {''}
   else
      return {value}
   end
end

-- Runs 'my_slow_script.py' every 10 seconds and puts its output into the widget
wicked.register(mywidget, run_slow_script, &quot;$1&quot;, 10)

-- Register a timer to run every 9 seconds
awful.hooks.timer.register(9, mywidget_timer)

-- Use the timer to fill the temporary file
function mywidget_timer ()
   os.execute('my_slow_script.py &gt; /tmp/script-temp-file &amp;')
end
&lt;/pre&gt;

== Temporarily Suspending Wicked ==
If you are paranoid about battery usage, and you would prefer if wicked didn't run commands in the background all the time while you are on battery power, you could temporarily suspend all wicked updates by using &quot;wicked.suspend()&quot; in a keybinding. You can reactivate everything that was suspended by using &quot;wicked.activate()&quot;.

Using awesome-client you could call these automatically, from, for example, a hal script. You would do this as such:
&lt;pre&gt;
#!/bin/bash
echo &quot;wicked.suspend()&quot; | awesome-client
&lt;/pre&gt;

Substitute suspend for activate where appropriate.

[[Category:awesome3]]</text>
      <sha1>cyztoe5m0kk78sude6z6wi1vnpv3k64</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Wicked/fr</title>
    <ns>0</ns>
    <id>392</id>
    <revision>
      <id>4331</id>
      <parentid>3387</parentid>
      <timestamp>2010-06-24T01:06:08Z</timestamp>
      <contributor>
        <username>Brendel</username>
        <id>486</id>
      </contributor>
      <comment>/* Debian */</comment>
      <text xml:space="preserve" bytes="12572">{{DISPLAYTITLE:Wicked}}
{{Languages|Wicked}}
Wicked est une bibliothèque Lua, ce qui signifie que vous pouvez l’inclure dans '''[[Awesome 3 configuration/fr|rc.lua]]''' à l’aide de ''require()'' et mettre en place vos widgets depuis le même fichier de configuration sans avoir à lancer un programme annexe avec des fichiers de configuration extérieurs.
__TOC__
== Récupérer Wicked ==

=== Debian ===
Wicked est disponible pour awesome 3 ''via'' le paquet ''awesome-extra'' disponible pour ''testing'' (actuellement « Squeeze ») et ''sid''. Pour la version stable actuelle de Debian (« Lenny »), vous pouvez utiliser un ''backport''. Pour cela, en ''root'' :
* ajoutez le dépôt suivant à /etc/apt/sources.list :
 deb http://corvix.eu testing ware
* et installez wicked par :
 aptitude update
 aptitude safe-upgrade
 aptitude install awesome awesome-wicked
* pour vous débarrasser de l’avertissement concernant la clé de signature, ajoutez la clé :
 gpg --keyserver pgpkeys.mit.edu --recv-key 974E7D68
 gpg -a --export 974E7D68 | sudo apt-key add -
Son empreinte devrait être : 0189 4F9A 5CFD 0242 5BEA 39E6 37A4 6DF5 974E 7D68

=== Arch Linux ===
Si vous utilisez Arch Linux, un PKGBUILD est déjà disponible sur aur, récupérez-le [http://aur.archlinux.org/packages.php?ID=17232 ici].

Dépôts :
 [awesome]
 #awesome3
 Server = http://www.camazotz.de/awesome/

 [deelab]
 #awesome-git
 Server = http://www.deelab.org/arch/i686

=== Source Mage GNU–Linux ===

Tout ce que vous avez à faire est ''cast wicked''.

=== Gentoo Linux ===
Un paquet pour Gentoo est disponible [http://overlays.gentoo.org/dev/matsuu/browser/awesome/x11-plugins/wicked/wicked-9999.ebuild ici].

=== Manuellement ===
Si vous voulez récupérer la bibliothèque séparément, vous pouvez la télécharger depuis le dépôt git à l’adresse [http://git.glacicle.com/?p=awesome/wicked.git;a=summary http://git.glacicle.com/?p=awesome/wicked.git;a=summary].

Pour l’installer manuellement :
 git clone git://git.glacicle.com/awesome/wicked.git
 sudo cp wicked/wicked.lua /usr/share/awesome/lib/
 sudo cp wicked/wicked.7.gz /usr/share/man/man7/

== Mettre en place Wicked ==
Pour mettre en place wicked, c’est simple ; ajoutez simplement la ligne suivante au début de votre fichier de configuration '''[[Awesome 3 configuration/fr|rc.lua]]''' et vous êtes prêt pour la suite :
 require(&quot;wicked&quot;)

== Créer des widgets ==
Il est aisé de créer des widgets en ajouter des appels de fonction à votre '''[[Awesome 3 configuration/fr|rc.lua]]'''. Vous trouverez des exemples ci-dessous ; pour plus d’information sur les types et options de widgets disponibles, regardez le manuel de wicked après l’avoir installée. N’oubliez pas que vous devrez ensuite ajouter les widgets à la barre de statut.

Il est mieux d’apprendre par l’exemple ; vous pouvez récupérer la [http://git.glacicle.com/other/configs.git/.config/awesome/rc_31.lua configuration actuelle] de l’auteur.

=== Exemple de widget de date ===
Le widget suivant affiche la date actuelle dans la barre de statut, en ayant recours à la commande ''date''.
&lt;pre&gt;
datewidget = widget({
    type = 'textbox',
    name = 'datewidget'
})

wicked.register(datewidget, wicked.widgets.date,
    ' &lt;span color=&quot;white&quot;&gt;Date :&lt;/span&gt; %c')
&lt;/pre&gt;

=== Exemple de « lecture en cours » pour MPD ===
Le widget suivant est un widget simple qui affiche la musique actuellement en cours de lecture dans Music Playing Daemon.
&lt;pre&gt;
mpdwidget = widget({
    type = 'textbox',
    name = 'mpdwidget'
})

wicked.register(mpdwidget, wicked.widgets.mpd,
    ' &lt;span color=&quot;white&quot;&gt;En cours de lecture :&lt;/span&gt; $1')
&lt;/pre&gt;

Si vous voulez un peu plus de fantaisie et n’afficher la musique actuelle que lorsqu’elle est effectivement diffusée, changez l’appel :

&lt;pre&gt;
wicked.register(mpdwidget, wicked.widgets.mpd, 
	function (widget, args)
		   if args[1]:find(&quot;volume:&quot;) == nil then
		      return ' &lt;span color=&quot;white&quot;&gt;En cours de lecture :&lt;/span&gt; '..args[1]
		   else
                      return ''
                   end
		end)
&lt;/pre&gt;

=== Exemple de moniteur d’utilisation mémoire ===
Le widget suivant affiche l’utilisation actuelle en pourcentage et méga-octets de la mémoire par rapport au total disponible :
&lt;pre&gt;
memwidget = widget({
    type = 'textbox',
    name = 'memwidget'
})

wicked.register(memwidget, wicked.widgets.mem,
    ' &lt;span color=&quot;white&quot;&gt;Mémoire :&lt;/span&gt; $1 ($2Mo/$3Mo)')
&lt;/pre&gt;

Si vous voulez que les valeurs aient deux, quatre et quatre chiffres respectivement, vous pouvez utiliser :
&lt;pre&gt;
memwidget = widget({
    type = 'textbox',
    name = 'memwidget'
})

wicked.register(memwidget, wicked.widgets.mem,
    ' &lt;span color=&quot;white&quot;&gt;Mémoire :&lt;/span&gt; $1 ($2Mo/$3Mo)',
nil, nil, {2, 4, 4})
&lt;/pre&gt;

=== Exemple de barre d’utilisation de mémoire ===
Le widget suivant affiche l’utilisation relative de la mémoire sous forme de barre de progression :
&lt;pre&gt;
membarwidget = widget({
    type = 'progressbar',
    name = 'membarwidget',
    align = 'right'
})

membarwidget:properties_set('mem', {
width = 40,
height = 0.65,
gap = 0,
border_padding = 1,
border_width = 1,
ticks_count = 0,
ticks_gap = 0,
vertical = false
})

membarwidget:bar_properties_set('mem', {
bg = '#222222',
fg = '#285577',
fg_center = '#285577',
fg_end = '#285577',
fg_off = '#222222',
reverse = false,
min_value = 0,
max_value = 100
})

wicked.register(membarwidget, wicked.widgets.mem, '$1', 1, 'mem')
&lt;/pre&gt;

=== Exemple d’utilisation du processeur ===
Le widget suivant affiche l’utilisation actuelle du processeur, en pourcentage :
&lt;pre&gt;
cpuwidget = widget({
    type = 'textbox',
    name = 'cpuwidget'
})

wicked.register(cpuwidget, wicked.widgets.cpu,
    ' &lt;span color=&quot;white&quot;&gt;CPU :&lt;/span&gt; $1%')
&lt;/pre&gt;

=== Exemple de graphe d’utilisation du processeur ===
Le widget suivant affiche un graphique avec l’utilisation actuelle du processeur :
&lt;pre&gt;
cpugraphwidget = widget({
    type = 'graph',
    name = 'cpugraphwidget',
    align = 'right'
})

cpugraphwidget.height = 0.85
cpugraphwidget.width = 45
cpugraphwidget.bg = '#333333'
cpugraphwidget.border_color = '#0a0a0a'
cpugraphwidget.grow = 'left'

cpugraphwidget:plot_properties_set('cpu', {
    fg = '#AEC6D8',
    fg_center = '#285577',
    fg_end = '#285577',
    vertical_gradient = false
})

wicked.register(cpugraphwidget, wicked.widgets.cpu, '$1', 1, 'cpu')
&lt;/pre&gt;

=== Exemple d’utilisation d’un système de fichiers ===
Le widget suivant affiche l’espace utilisé sur la partition montée en '''/''' sur l’espace total, ainsi que le pourcentage utilisé :
&lt;pre&gt;
fswidget = widget({
    type = 'textbox',
    name = 'fswidget'
})

wicked.register(fswidget, wicked.widgets.fs,
    ' &lt;span color=&quot;white&quot;&gt;Système :&lt;/span&gt; ${/ used}/${/ size} (${/ usep} utilisé)', 120)
&lt;/pre&gt;

=== Exemple de moniteur d’interface réseau ===
Le widget suivant affiche la vitesse actuelle sur '''eth0''', ainsi que les totaux de transfert de la connexion. Le dernier argument force l’affichage des nombres avec trois chiffres :
&lt;pre&gt;
netwidget = widget({
    type = 'textbox',
    name = 'netwidget'
})

wicked.register(netwidget, wicked.widgets.net, 
    ' &lt;span color=&quot;white&quot;&gt;NET&lt;/span&gt; : ${eth0 down} / ${eth0 up} [ ${eth0 rx} //  ${eth0 tx} ]',
nil, nil, 3)
&lt;/pre&gt;

=== Exemple de charge de batterie ===
Le widget suivant affiche la charge des batteries :
&lt;pre&gt;
batteries = 2

-- Fonction pour extraire le pourcentage de charge
function read_battery_life(number)
   return function(format)
             local fh = io.popen('acpi')
             local output = fh:read(&quot;*a&quot;)
             fh:close()

             count = 0
             for s in string.gmatch(output, &quot;(%d+)%%&quot;) do
                if number == count then
                   return {s}
                end
                count = count + 1
             end
          end
end

-- Affiche une barre de progression verticale par batterie
for battery=0, batteries-1 do
   batterygraphwidget = widget({ type = 'progressbar',
                                 name = 'batterygraphwidget',
                                 align = 'right' })
   batterygraphwidget.height = 0.85
   batterygraphwidget.width = 8
   batterygraphwidget.bg = '#333333'
   batterygraphwidget.border_color = '#0a0a0a'
   batterygraphwidget.vertical = true
   batterygraphwidget:bar_properties_set('battery',
                                         { fg = '#AEC6D8',
                                           fg_center = '#285577',
                                           fg_end = '#285577',
                                           fg_off = '#222222',
                                           vertical_gradient = true,
                                           horizontal_gradient = false,
                                           ticks_count = 0,
                                           ticks_gap = 0 })

   wicked.register(batterygraphwidget, read_battery_life(battery), '$1', 1, 'battery')
end
&lt;/pre&gt;

== Widgets personnalisés ==
Vous pouvez créer vos propres widgets personnalisés en passant vos fonctions en type « paramètre ». De cette façon, vous pouvez spécifier n’importe quelle commande à sortir sous forme de widget, à n’importe quel intervalle. L’exemple suivant affiche le volume d’alsa toutes les quatre secondes ; il est récupéré en lançant la commande ''amixer'' et en en interprétant la sortie. Cet exemple nécessite alsa-utils.
&lt;pre&gt;
volumewidget = widget({
    type = 'textbox',
    name = 'volumewidget'
})

function amixer_volume(format)
   local f = io.popen('amixer get PCM')
   local l = f:lines()
   local v = ''

   for line in l do
       if line:find('Front Left:') ~= nil then
            pend = line:find('%]', 0, true)
            pstart = line:find('[', 0, true)
            v = line:sub(pstart+1, pend)
       end
   end

   f:close()

   return {v}
end


wicked.register(volumewidget, amixer_volume, &quot;&lt;span color='white'&gt;Volume&lt;/span&gt; : $1&quot;, 4)
&lt;/pre&gt;

Vous pouvez utiliser ce qui suit pour lancer n’importe quel script externe que vous avez écrit, pour récupérer des données et les afficher :
&lt;pre&gt;
mywidget = widget({
    type = 'textbox',
    name = 'mywidget'
})
 
function run_script()
    local filedescriptor = io.popen('mon_petit_script_sympa.py')
    local value = filedescriptor:read()
    filedescriptor:close()

    return {value}
end
 
-- Exécute « mon_petit_script_sympa.py » toutes les 10 secondes et envoie sa sortie dans le widget
wicked.register(mywidget, run_script, &quot;$1&quot;, 10)
&lt;/pre&gt;

== Gel d’awesome ==
Awesome attend que le code Lua soit fini avant de se relancer, donc si un script lent s’exécute, cela peut potentiellement ralentir ou geler awesome. Dans ce cas, vous pouvez utiliser un processus de fond et un fichier temporaire pour remédier à ce problème.

Utilisez le code suivant pour lancer un script lent de votre choix, sans geler awesome :
&lt;pre&gt;
mywidget = widget({
    type = 'textbox',
    name = 'mywidget'
})

function run_slow_script (widget, args) 
   -- Lit le fichier temporaire laissé par le script
   local filedescriptor = io.open('/tmp/script-temp-file')
   local value = nil

   if filedescriptor ~= nil then
      value = filedescriptor:read()
   end

   filedescriptor:close()

   if value == nil then
      return {''}
   else
      return {value}
   end
end

-- Lance « mon_script_lent.py » toutes les 10 secondes et envoie son résultat dans le widget
wicked.register(mywidget, run_slow_script, &quot;$1&quot;, 10)

-- Demande à ce qu’un compteur soit lancé toutes les 9 secondes
awful.hooks.timer.register(9, mywidget_timer)

-- Utilise le compteur pour remplir le fichier temporaire
function mywidget_timer ()
   os.execute('mon_script_lent.py &gt; /tmp/script-temp-file &amp;')
end
&lt;/pre&gt;

== Suspendre temporairement Wicked ==
Si vous êtes paranoïaque sur l’utilisation de la batterie et que vous préférez que wicked ne lance pas de programme en fond à chaque fois que vous êtes sur la batterie, vous pouvez suspendre temporairement toute mise à jour de wicked en utilisant ''wicked.suspend()'' avec un raccourci. Vous pouvez relancer tout ce qui a été suspendu avec ''wicked.activate()''.

En utilisant ''awesome-client'', vous pouvez appeler tout cela automatiquement, disons par exemple depuis un script Hal. Vous pouvez par exemple faire ça de cette façon :
&lt;pre&gt;
#!/bin/bash
echo &quot;wicked.suspend()&quot; | awesome-client
&lt;/pre&gt;

Remplacez simplement « suspend » par « activate » là où il faut.

[[Category:awesome3]]</text>
      <sha1>4s0o1xn38nj4ccel9awgqb9vvie8kdd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Wicked/zh-hans</title>
    <ns>0</ns>
    <id>276</id>
    <revision>
      <id>2771</id>
      <parentid>2768</parentid>
      <timestamp>2009-05-23T11:07:37Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Add [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="12045">{{Languages|Wicked}}

Wicked是一个Lua库，你可以在rc.lua通过require加载它。通过使用wicked,你可以在同一个配置文件中设置好你的widget而不需要运行额外的程序。

==获取wicked==
=== Arch Linux ===

如果你正在使用Arch Linux，aur里面已经有了一个可以使用的包了，你可以在这里下载到：
[http://aur.archlinux.org/packages.php?ID=17232 http://aur.archlinux.org/packages.php?ID=17232].
Arch源:
&lt;pre&gt;
[awesome]
#awesome3
Server = http://www.camazotz.de/awesome/
&lt;/pre&gt;
&lt;pre&gt;
[deelab]
#awesome-git
Server = http://www.deelab.org/arch/i686
&lt;/pre&gt;

=== Source Mage GNU/Linux ===

你所需要做的仅仅是&quot;cast wicked&quot;

=== Gentoo Linux ===
你可以在这里下载到gentoo包[http://overlays.gentoo.org/dev/matsuu/browser/awesome/x11-plugins/wicked/wicked-9999.ebuild wicked-9999.ebuild].

=== Manually ===
如果你用的不是Arch或者你更喜欢单独下载这个库，你可以用git在这里下载到它：[http://git.glacicle.com/?p=awesome/wicked.git;a=summary http://git.glacicle.com/?p=awesome/wicked.git;a=summary].
然后手动安装它:
&lt;pre&gt;
git clone git://git.glacicle.com/awesome/wicked.git
sudo cp wicked/wicked.lua /usr/share/awesome/lib/
sudo cp wicked/wicked.7.gz /usr/share/man/man7/
&lt;/pre&gt;


==载入wicked==
要载入wicked很容易：
&lt;pre&gt;
require(&quot;wicked&quot;)
&lt;/pre&gt;

==创建widget==
创建一个widget和在rc.lua进行函数调用一样容易，下面是你可以使用的widget的例子。如果你想知道还有哪些更多的widget类型和选线，可以在安装wicket以后运行命令`man wicked`。不要忘记在创建widget以后将它添加到statusbar里面去。

要学习怎么创建widget，可以看看在作者的配置文件中的例子[http://git.glacicle.com/other/configs.git/.config/awesome/rc_31.lua current config]。

例如你可以通过如下的代码创建显示内存使用情况的widget:
&lt;pre&gt;
 memwidget = widget({
 	type = 'textbox',
 	name = 'memwidget'
 })
 wicked.register(memwidget, wicked.widgets.mem,
	' &lt;span color=&quot;white&quot;&gt;Memory:&lt;/span&gt; $1 ($2Mb/$3Mb)')
&lt;/pre&gt;
然后你需要把你要的widget加入到一个已有的wibox或者新创建的wibox中去。比如说我创建了一个在屏幕下沿的状态栏：

&lt;pre&gt;
-- 设置状态栏的位置、颜色
mystatebar = wibox( {position = &quot;bottom&quot;, fg = beautiful.fg_normal, bg = beautiful.bg_normal} )
-- 把你创建过的widget添加进去，比如说上面所说的memwidget
mystatebar.widgets = {
    cpugraphwidget,
    memwidget,
    fswidget,
    netwidget
}
-- 设置状态栏所在的显示器，对于单显示器的机器来说设置为1就可以了
mystatebar.screen = 1
&lt;/pre&gt;
以上就是在statuesbar中加入一个widget所需要的所有步骤了。

==各种可用的widget==

wicked提供好几种widget可以使用，包括CPU占用率、内存使用率、文件系统空间、网络传输速率等。基本上wicked的使用方法就是先调用widget()函数创建一个widget，然后设置好参数调用wicked.register()，最后再创建一个wibox把先前创建的widget放在里面就好了。有的widget不能用，会导致awesome当掉（估计应该是bug)。经过我实验可以用的有：内存占用率、文件系统使用率、网络流量、CPU占用率和CPU图像。
日期

===显示现在的时间===
&lt;pre&gt;
datewidget = widget({
    type = 'textbox',
    name = 'datewidget'
})
wicked.register(datewidget, wicked.widgets.date,
    ' &lt;span color=&quot;white&quot;&gt;Date:&lt;/span&gt; %c')
&lt;/pre&gt;

===MPD 正在播放===

显示正在Music Playing Daemon中正在播放的歌曲
&lt;pre&gt;
mpdwidget = widget({
    type = 'textbox',
    name = 'mpdwidget'
})

wicked.register(mpdwidget, wicked.widgets.mpd,
    ' &lt;span color=&quot;white&quot;&gt;Now Playing:&lt;/span&gt; $1')
&lt;/pre&gt;

如果你想要它只是在播放歌曲的时候显示的话，可以把register函数的调用改为如下所示：
&lt;pre&gt;
wicked.register(mpdwidget, wicked.widgets.mpd,
        function (widget, args)
                   if args[1]:find(&quot;volume:&quot;) == nil then
                      return ' &lt;span color=&quot;white&quot;&gt;Now Playing:&lt;/span&gt; '..args[1]
                   else
                      return ''
                   end
                end)
&lt;/pre&gt;

===内存监视器===

在状态栏中显示已用/总共的内存量
&lt;pre&gt;
memwidget = widget({
    type = 'textbox',
    name = 'memwidget'
})

wicked.register(memwidget, wicked.widgets.mem,
    ' &lt;span color=&quot;white&quot;&gt;Memory:&lt;/span&gt; $1 ($2Mb/$3Mb)')
&lt;/pre&gt;

===内存占用率进度条===

用一个进度条显示内存的相对使用情况
&lt;pre&gt;
membarwidget = widget({
    type = 'progressbar',
    name = 'membarwidget',
    align = 'right'
})

membarwidget:properties_set('mem', {
width = 40,
height = 0.65,
gap = 0,
border_padding = 1,
border_width = 1,
ticks_count = 0,
ticks_gap = 0,
vertical = false
})

membarwidget:bar_properties_set('mem', {
bg = '#222222',
fg = '#285577',
fg_center = '#285577',
fg_end = '#285577',
fg_off = '#222222',
reverse = false,
min_value = 0,
max_value = 100
})

wicked.register(membarwidget, wicked.widgets.mem, '$1', 1, 'mem')
&lt;/pre&gt;

===CPU占用率===

显示CPU占用率的百分比
&lt;pre&gt;
cpuwidget = widget({
    type = 'textbox',
    name = 'cpuwidget'
})

wicked.register(cpuwidget, wicked.widgets.cpu,
    ' &lt;span color=&quot;white&quot;&gt;CPU:&lt;/span&gt; $1%')
&lt;/pre&gt;

===CPU占用率图像===

用一个图像来显示CPU占用率的变化
&lt;pre&gt;
cpugraphwidget = widget({
    type = 'graph',
    name = 'cpugraphwidget',
    align = 'right'
})

cpugraphwidget.height = 0.85
cpugraphwidget.width = 45
cpugraphwidget.bg = '#333333'
cpugraphwidget.border_color = '#0a0a0a'
cpugraphwidget.grow = 'left'

cpugraphwidget:plot_properties_set('cpu', {
    fg = '#AEC6D8',
    fg_center = '#285577',
    fg_end = '#285577',
    vertical_gradient = false
})

wicked.register(cpugraphwidget, wicked.widgets.cpu, '$1', 1, 'cpu')
&lt;/pre&gt;

===文件系统===

显示已用/总共的文件空间，以及百分比
&lt;pre&gt;
fswidget = widget({
    type = 'textbox',
    name = 'fswidget'
})

wicked.register(fswidget, wicked.widgets.fs,
    ' &lt;span color=&quot;white&quot;&gt;FS:&lt;/span&gt; ${/ used}/${/ size} (${/ usep} used)', 120)
&lt;/pre&gt;

===网络监视器===

显示eth0的网络流量
&lt;pre&gt;
netwidget = widget({
    type = 'textbox',
    name = 'netwidget'
})

wicked.register(netwidget, wicked.widgets.net,
    ' &lt;span color=&quot;white&quot;&gt;NET&lt;/span&gt;: ${eth0 down} / ${eth0 up} [ ${eth0 rx} //  ${eth0 tx} ]',
nil, nil, 3)
&lt;/pre&gt;

===电池电量===

显示电池的电量
&lt;pre&gt;
settings.batteries = 2

-- Label
batterywidget = widget({type = 'textbox',
                        name = 'batterywidget',
                        align = 'right'})
wicked.register(batterywidget, function() return {} end,
                settings.widget_separator ..
                   beautiful.markup.heading('Bat') ..
                settings.widget_spacer,
                nil, nil, 500)
table.insert(settings.widgets, {1, batterywidget})

-- Function to extract charge percentage
function read_battery_life(number)
   return function(format)
             local fh = io.popen('acpi')
             output = fh:read(&quot;*a&quot;)
             fh:close()

             count = 0
             for s in string.gmatch(output, &quot;(%d+)%%&quot;) do
                if number == count then
                   return {s}
                end
                count = count + 1
             end
          end
end

-- Display one vertical progressbar per battery
for battery=0, settings.batteries-1 do
   batterygraphwidget = widget({ type = 'progressbar',
                                 name = 'batterygraphwidget',
                                 align = 'right' })
   batterygraphwidget.height = 0.85
   batterygraphwidget.width = 8
   batterygraphwidget.bg = '#333333'
   batterygraphwidget.border_color = '#0a0a0a'
   batterygraphwidget.vertical = true
   batterygraphwidget:bar_properties_set('battery',
                                         { fg = '#AEC6D8',
                                           fg_center = '#285577',
                                           fg_end = '#285577',
                                           fg_off = '#222222',
                                           vertical_gradient = true,
                                           horizontal_gradient = false,
                                           ticks_count = 0,
                                           ticks_gap = 0 })

   wicked.register(batterygraphwidget, read_battery_life(battery), '$1', 1, 'battery')
   table.insert(settings.widgets, {1, batterygraphwidget})

   spacewidget = widget({type = 'textbox',
                           name = 'spacewidget',
                           align = 'right'})
   wicked.register(spacewidget, function() return {} end,
                   settings.widget_spacer,
                   nil, nil, 500)
   table.insert(settings.widgets, {1, spacewidget})
end
&lt;/pre&gt;
== 自定义Widgets ==
You can create your own custom widgets by passing your own functions as the type parameter, using this, you can specify any arbitrary command to be outputted into a widget at any interval. The following example displays the volume from alsa (gotten by running the `amixer` command and parsing the output), every 4 seconds. (Note: requires alsa-utils)
&lt;pre&gt;
volumewidget = widget({
    type = 'textbox',
    name = 'volumewidget'
})

function amixer_volume(format)
   local f = io.popen('amixer get PCM')
   local l = f:lines()
   local v = ''

   for line in l do
       if line:find('Front Left:') ~= nil then
            pend = line:find('%]', 0, true)
            pstart = line:find('[', 0, true)
            v = line:sub(pstart+1, pend)
       end
   end

   f:close()

   return {v}
end


wicked.register(volumewidget, amixer_volume, &quot;&lt;span color='white'&gt;Volume&lt;/span&gt;: $1&quot;, 4)&lt;/pre&gt;

You can use the following to run any external script you might have written that collects data and outputs it:
&lt;pre&gt;
mywidget = widget({
    type = 'textbox',
    name = 'mywidget'
})
 
function run_script()
    local filedescriptor = io.popen('my_nifty_script.py')
    local value = filedescriptor:read()
    filedescriptor:close()

    return {value}
end
 
-- Runs 'my_nifty_script.py' every 10 seconds and puts its output into the widget
wicked.register(mywidget, run_script, &quot;$1&quot;, 10)
&lt;/pre&gt;

== Awesome假死 ==
因为awesome在继续运行之前会等待lua脚本借书，因此运行一个缓慢的脚本很可能会让你的整个awesome反应迟钝。你可以用一个后台线程或者是临时文件来避免这个问题。通过下面的方法来运行一个缓慢的脚本可以避免阻塞awesome:

&lt;pre&gt;
mywidget = widget({
    type = 'textbox',
    name = 'mywidget'
})

function run_slow_script (widget, args) 
   -- Read the temporary file left by the script
   local filedescriptor = io.open('/tmp/script-temp-file')
   local value = nil

   if filedescriptor ~= nil then
      value = filedescriptor:read()
   end

   filedescriptor:close()

   if value == nil then
      return {''}
   else
      return {value}
   end
end

-- Runs 'my_slow_script.py' every 10 seconds and puts its output into the widget
wicked.register(mywidget, run_slow_script, &quot;$1&quot;, 10)

-- Register a timer to run every 9 seconds
awful.hooks.timer.register(9, mywidget_timer)

-- Use the timer to fill the temporary file
function mywidget_timer ()
   os.execute('my_slow_script.py &gt; /tmp/script-temp-file &amp;')
end
&lt;/pre&gt;

== 临时挂起Wicked ==
如果你很在意电池的使用时间，那么你可能更希望wicked在你的电脑处于电池供电状态的时候不要一直运行命令。你可以通过绑定命令&quot;wicked.suspend()&quot;来临时停止所有wicked的更新。你可以使用&quot;wicked.activate()&quot;来重新激活被挂起的wicked。

你可以在hal脚本之类的地方使用awesome-cliend来自动调用这些命令。你可以像这么调用：
&lt;pre&gt;
#!/bin/bash
echo &quot;wicked.suspend()&quot; | awesome-client
&lt;/pre&gt;

把suspend在hal脚本的适当的地方换成activate就可以自动唤醒挂起的wicked了。

[[Category:awesome3]]</text>
      <sha1>rrdsnnsg0uder92w2o3ihqpybxoo7j5</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Wicked (Simplified Chinese)</title>
    <ns>0</ns>
    <id>346</id>
    <redirect title="Wicked/zh-hans" />
    <revision>
      <id>2769</id>
      <timestamp>2009-05-23T11:06:07Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Wicked (Simplified Chinese)]] to [[Wicked/zh-hans]]:&amp;#32;Make this compatible with [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="28">#REDIRECT [[Wicked/zh-hans]]</text>
      <sha1>35nutaq0j107wo9w2rm335th9yr2vjp</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Widget Layouts</title>
    <ns>0</ns>
    <id>987</id>
    <revision>
      <id>6815</id>
      <parentid>6338</parentid>
      <timestamp>2014-06-23T10:53:45Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="9771">{{Languages}}

{{VersionSpecific
| goodversions = &gt;=3.6
}}
Complex widget layouts can be interesting and really add to the power and flexibility of Awesome. This functionality is implemented through layout widgets, which are mainly designed to contain and modify the positioning of one or more other widgets. These other widgets can be those generated by [[Widgets in awesome#Widget types|awesome itself]], [[Widgets in awesome#awful widget types|awful]], or external libraries like [[Vicious]]. These instructions use code after these commits: [http://git.naquadah.org/?p=awesome.git;a=commit;h=fbba41ddaa3012720819e4c803542a73adf854e8 fbba41d],[http://git.naquadah.org/?p=awesome.git;a=commit;h=601dc232db6a812594ab0ba5ab1e524b1c438e83 601dc23], and [http://git.naquadah.org/?p=awesome.git;a=commit;h=ceaeaedb5b1cd98b9ae1e04d6011219a3a11e228 ceaeaed].
==Basic Usage==
To use a layout widget, you must call its constructor, add one or more widgets to it, and set any special properties that you want to modify. Generally, the top most layout widget will be placed in a [[Widgets in awesome#Controlling widgets|wibox]] to be displayed.

To create a layout widget, call its constructor.
 local mymargin = wibox.layout.margin()

Then add a widget.
 mylauncher = awful.widget.launcher({ image = beautiful.awesome_icon,
                                     menu = mymainmenu })
 mymargin:set_widget(mylauncher)

As you can see, the &lt;code&gt;widget:set_widget()&lt;/code&gt; function adds the widget to this layout. This is typical for layouts that only accept a single widget. For layouts that accept an arbitrary number of widgets, the &lt;code&gt;widget:add()&lt;/code&gt; function is used, and for widgets that accept a finite number of widgets, the &lt;code&gt;widget:set_item()&lt;/code&gt; function is used, where item generally describes where the widget will go.

Finally, set any properties you wish to change.
 mymargin:set_margins(1)

The order of these functions is not critical: as long as the layout widget is created before any of its functions are used, the results will be the same.
==Available Layout Types==
All layout widgets and their callable functions are described fully in the [http://awesome.naquadah.org/doc/api/index.html Awesome Lua API documentation] in the wibox.layout.* sections.
===[http://awesome.naquadah.org/doc/api/modules/wibox.layout.align.html Align]===
Used to place widgets in on the Left, Right, Top, Bottom or Middle of a given space.
====Direction====
The align layout should not be called directly, but should be called using either of the directional functions:
 myalign = wibox.layout.align.horizontal()
or
 myalign = wibox.layout.align.vertical()

Horizontal will layout widgets in a Left, Middle, Right format:
 myalign:set_left(widget_left)
 myalign:set_middle(widget_middle)
 myalign:set_right(widget_right)
while vertical will place them Top, Middle, Bottom:
 myalign:set_top(widget_top)
 myalign:set_middle(widget_middle)
 myalign:set_bottom(widget_bottom)
Note that not all of these widgets have to be assigned, the align layout deals smartly with placing widgets if any are missing.
====Expand Mode====
By default, the middle widget will expand or contract (even to the point of disappearing) to take up any room left by the outside widgets. This isn't always the desired case. The &lt;code&gt;align_widget:set_expand(&quot;expand mode&quot;)&lt;/code&gt; function is used to change this behavior.
{{wide image|align_widget_expand_modes.png|1024|Example of different expand modes in action.|alt=Example of different expand modes in action.}}
=====Inside=====
Use &lt;code&gt;align_widget:set_expand(&quot;inside&quot;)&lt;/code&gt; to cause the middle widget to expand to fill the space left over by the outside widgets. Note that if there is no space left over, the middle widget will not be shown. In this mode the top or left widget gets first priority on the available space, then the right or bottom widget, and finally the middle widget. This is the default behavior.
=====Outside=====
Use &lt;code&gt;align_widget:set_expand(&quot;outside&quot;)&lt;/code&gt; to center the middle widget in the available space and cause the outside widgets (left, right, top or bottom) to expand to fill any space left over on the applicable side of the widget. In this mode the middle widget gets first priority on space, and the other two widgets expand into whatever is left over on their side. Widgets should be written to handle not being given as much space as they ask for, so this shouldn't break them. If the middle widget takes up all the available space, the outside widgets won't be shown.
=====None=====
Using &lt;code&gt;align_widget:set_expand(&quot;none&quot;)&lt;/code&gt; will leave any left over space empty. The middle widget will be centered, and is given first priority on available space. The other two widgets may use whatever is left over on their side, but will not expand to fill that space. If the middle widget takes up all the available space, the outside widgets won't be shown.

===[http://awesome.naquadah.org/doc/api/modules/wibox.layout.constraint.html Constraint]===
This widget will limit the size of its daughter widget. Set the daughter widget with &lt;code&gt;myconstraint:set_widget(widget)&lt;/code&gt;. Set the constraint height and/or width with &lt;code&gt;myconstraint:set_height(n)&lt;/code&gt; and &lt;code&gt;myconstraint:set_width(n)&lt;/code&gt; respectively, where integer &lt;code&gt;n&lt;/code&gt; is the size in pixels. If you use &lt;code&gt;nil&lt;/code&gt; instead of an integer it will remove the constraint in that direction. Using &lt;code&gt;myconstraint:reset()&lt;/code&gt; will set the strategy to &quot;max&quot; and clear both constraint directions.
====Constraint Strategies====
The constraint strategy defines how to apply the constraint. Note that these describe the &lt;i&gt;constraint&lt;/i&gt; not the widget it is constraining.If you want to apply a different strategy to each direction, carefully use nested constraint widgets.{{Testing needed}}
=====Exact=====
This will force the height and/or width to match the constraint exactly.
 myconstraint:set_strategy(&quot;exact&quot;)
=====Min=====
This will force the height and/or width to be larger than the constraint values.
 myconstraint:set_strategy(&quot;min&quot;)
=====Max=====
This will force the height and/or width to be smaller than the constraint values.
 myconstraint:set_strategy(&quot;max&quot;)

===[http://awesome.naquadah.org/doc/api/modules/wibox.layout.fixed.html Fixed]===
===[http://awesome.naquadah.org/doc/api/modules/wibox.layout.flex.html Flex]===
===[http://awesome.naquadah.org/doc/api/modules/wibox.layout.margin.html Margin]===
This adds padding all the way around the widget it contains. Use &lt;code&gt;widget:set_widget(subwidget)&lt;/code&gt; to set the sub widget. If n is an integer, &lt;code&gt;widget:set_margin(n)&lt;/code&gt; will set a margin of n pixels all the way around the widget and &lt;code&gt;widget:set_left(n)&lt;/code&gt;, &lt;code&gt;widget:set_right(n)&lt;/code&gt;, &lt;code&gt;widget:set_top(n)&lt;/code&gt;, and &lt;code&gt;widget:set_bottom(n)&lt;/code&gt; will set a margin of n pixels on just the specified side.

===[http://awesome.naquadah.org/doc/api/modules/wibox.layout.mirror.html Mirror]===
===[http://awesome.naquadah.org/doc/api/modules/wibox.layout.rotate.html Rotate]===

==Best Practices==
Widget layouts can grow quite complex very quickly, as you add more things to display and arrange things in interesting ways. The default layout includes 6 widgets to begin with and after adding more it can easily become difficult to figure out where you are in your layout. To help with this, organizing your widgets consistently in your code and adding plenty of comments can help immensely. Here are some suggestions:
*Use comments to denote exactly what a widget is for and where it goes.
*Name layout widgets based on their parent and location.
*Use indentation to denote what level you are working at.
*Build the layout like it is HTML:
**Declare your outer most layout.
**Set its options.
**Declare a subwidget.
**Set its options.
**Declare and add any additional sub widgets.
**Add widget to outer layout.
**Add outer layout to wibox.
*For complex layouts, draw a mock-up of what you want it to look like before you start.
*Read the documentation on available layouts before you start so you understand what is possible.

==Techniques==
===Labeling===
[[File:Battery Widgets.png|frame|Labeling example]]
To label a widget that shows data, such as a progress bar, you can use an align widget with two sub widgets: the data widget and a textbox widget.
 &lt;pre&gt;
internal_battery = awful.widget.align.vertical()

    internal_battery_pb = awful.widget.progressbar()
        internal_battery_pb:set_vertical(true)
        internal_battery_pb:set_width(8)
        internal_battery_pb:set_height(20)
        internal_battery_pb:set_background_color(beautiful.bg_normal)
        internal_battery_pb:set_border_color(beautiful.fg_normal)
        internal_battery_pb:set_color({ type = &quot;linear&quot;, from = { 0, 0 }, to = { 0, 20 },
                                        stops = { { 0,   beautiful.fg_focus},
                                        { 0.2, beautiful.fg_focus},
                                        { 1,   beautiful.bg_focus}
                                    } })
        vicious.register(internal_battery_pb, vicious.widgets.bat, &quot;$2&quot;, 20, &quot;CMB1&quot;)
    internal_battery:set_middle(internal_battery_pb)

    internal_battery_label = wibox.widget.textbox()
        internal_battery_label:set_text(&quot;I&quot;)
        internal_battery_label:set_align(&quot;center&quot;)
    internal_battery:set_bottom(internal_battery_label)
&lt;/pre&gt;
Note that the progress bar widget is set as the middle widget. By default the middle widget expands to take as much space, and because there is no top widget, it will use any space that the label does not. If you want the label on the top, you would just use &lt;code&gt;set_top&lt;/code&gt; instead of &lt;code&gt;set_bottom&lt;/code&gt;.

==Examples==</text>
      <sha1>9flz9cnzz9bbgvdgtpjetqxf0olwrco</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Widget Layouts/ru</title>
    <ns>0</ns>
    <id>1128</id>
    <revision>
      <id>6820</id>
      <parentid>6819</parentid>
      <timestamp>2014-06-24T16:56:17Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавил перевод для Widget Layouts in Awesome 3.5</comment>
      <text xml:space="preserve" bytes="21337">== Widget Layouts в Awesome 3.4 ==

Одним из самых крупных изменений в Awesome 3.4 стало введение ''widget layouts''(схемы виджетов). Схемы позволяют контролировать размещение виджетов с использованием Lua, намного удобнее чем в ранних редакциях, когда использовались свойства виджетов ''align''.

=== Как они работают? ===

Каждая таблица/массив виджетов содержит поле ''layout''. Это поле указывает на функцию которая принимает таблицу содержащую виджеты и место, где эти виджеты должны быть размещены в качестве параметров и возвращает таблицу содержащую геометрическое расположение (т.е. width, height, x и y позиции) для всех виджетов. Эта функция просто вызывается с таблицей виджетов в качестве аргументов. Невероятно просто, не правда ли?

=== Как я могу использовать их? ===
Разместите виджеты, которые должны иметь одинаковое свойство  align в таблицу и вызовите в поле таблицы layout нужную функцию выравнивания (которые описаны ниже). Разместите эти таблицы в таблицу виджетов вашего wibox и соответственно установите его поле layout.

Удостоверьтесь, что ваш виджет tasklist является последним в таблице виджетов, поскольку он использует flex layout по умолчанию.

=== Какие доступны layouts? ===

На данный момент доступны следующие схемы для виджетов:
; awful.widget.layout.horizontal.leftright:
: все виджеты содержащиеся в таблице будут размещены слева направо.

; awful.widget.layout.horizontal.rightleft:
: виджеты размещаются справа налево. Т.е. виджет расположенный последним в таблице, будет крайним левым, а первый соответственно крайним правым.

; awful.widget.layout.horizontal.flex:
: Должен располагаться последим в таблице виджетов, так как используется все доступное пространство по горизонтали.

; awful.widget.layout.vertical.flex:
: Эта layout позволяет разместить виджеты из таблицы, друг над другом, что например позволяет стыковать imagebox и textbox поверх друг друга, чтобы получить иконку с подписью.

===Примеры использования===
Взято из rc.lua
&lt;pre&gt;
mywibox[s].widgets = {
        {
            mylauncher,
            mytaglist[s],
            mypromptbox[s],
            layout = awful.widget.layout.horizontal.leftright  -- &lt;&lt;-- схема размещения для виджетов прописанных выше, слева на право
        },
        mylayoutbox[s],spacewidget,                       -- &lt;&lt;-- виджет переключателя режимов окон, он будет крайним правым
        mytextclock,                                      -- &lt;&lt;-- виджет часов
        separator,                                        -- &lt;&lt;-- разделитель
        kbdwidget,                                        -- &lt;&lt;-- виджет переключатель клавиатуры
        ...
        s == 1 and mysystray or nil,
        mytasklist[s],                                    -- &lt;&lt;-- виджет списка задач, он будет крайним левым
        layout = awful.widget.layout.horizontal.rightleft      -- &lt;&lt;-- схема размещения для виджетов прописанных выше, слева на право слева на право
    }
&lt;/pre&gt;
Я думаю разобраться здесь не сложно. Сначала создается таблица mywibox, в которой прописаны все виджеты которые мы будем отображать. 
В нем мы создаем подтаблицу в которой прописываем виджеты (mylauncher, mytaglist,mypromptbox) которые у нас будут располагаться с левой стороны и имеющие выравнивание слева направо. А затем идут все остальные виджеты, но для них используется метод выравнивания справа налево. Если для вас сложно это воспринять попробуйте создать свой собственный виджет, например:
&lt;pre&gt;
mywidget = widget ({&quot;textbox&quot;})
mywidget.text = &quot;test&quot; 
&lt;/pre&gt;
и попробуйте его вставить поочередно в разные места приведенного выше кода mywibox. И для вас сразу все встанет на свои места. 

Помимо этого, есть не задокументированная(унаследованная) функция margins(), которая позволяет оставить свободное место с какой либо стороны от вашего виджета, или таблицы виджетов.
&lt;pre&gt; 
awful.widget.layout.margins[mywidget] = { left = 10 }
&lt;/pre&gt;
Данный код позволяет оставить место в 10 пикселей слева от вашего виджета. 

== Widget Layouts в Awesome 3.5 ==
 https://awesome.naquadah.org/wiki/Widget_Layouts - оригинал статьи

Комплекс layout для виджетов может стать интересным и добавляющим мощности и гибкости в Awesome. Эта функциональность реализуется через layout widget, которые в основном предназначены для содержания и изменения расположения одного или нескольких виджетов. Эти виджеты могут быть созданы как с использованием [[Widgets in awesome/ru#Типы виджетов|самого awesome]], [[Widgets in awesome/ru#Типы виджетов использующих awful|awful]], так и внешних библиотек, например [[Vicious/ru|Vicious]]. 

===Основы===
Для использования схем виджетов, вам необходимо вызывать конструктор, добавить один или несколько виджетов в него, и установить свойства, которые вы хотите изменить. В основном, большая часть ''layout widget'' будет размещаться в секции [[Widgets in awesome/ru#Управление виджетами|wibox]].

Итак, для создания ''layout widget'', вызываем его конструктор:
 local mymargin = wibox.layout.margin()

Затем добавляем виджет:
 mylauncher = awful.widget.launcher({ image = beautiful.awesome_icon,
                                     menu = mymainmenu })
 mymargin:set_widget(mylauncher)

Как вы можете видеть, функция &lt;code&gt;widget:set_widget()&lt;/code&gt; добавляет виджет к этому layout. Это характерно для layouts, что принимается только один виджет. Для того, чтобы layouts принимал произвольное количество виджетов, используется функция &lt;code&gt;widget:add()&lt;/code&gt;, а для layout в которых принимаются заданное количество виджетов используется функция &lt;code&gt;widget:set_item()&lt;/code&gt;, где item в общих чертах описывает где будут располагаться виджеты.

В завершение, установите те свойства, которые хотите изменить.
 mymargin:set_margins(1)

Порядок вызова этих функций не важен, главное сначала создать ''layout widget''.
===Доступные типы layout===
Все ''layout widgets'' и их функции полностью описаны в [http://awesome.naquadah.org/doc/api/index.html Awesome Lua API documentation] в секции wibox.layout.*
====[http://awesome.naquadah.org/doc/api/modules/wibox.layout.align.html Align]====
Используется для размещения виджетов слева, справа, сверху, снизу или в середине выделенного пространства. Кстати виджетов в этой схеме должно быть не более 3х.

Схема ''align'' не должна вызываться напрямую, для этого используются другие подфункции, указывающие направление (горизонтальное или вертикальное расположение):
 myalign = wibox.layout.align.horizontal()
или
 myalign = wibox.layout.align.vertical()

Горизонтальная схема виджетов располагает виджеты по направлениям Left, Middle, Right:
 myalign:set_left(widget_left)
 myalign:set_middle(widget_middle)
 myalign:set_right(widget_right)
А вертикальная располагает виджеты по направлениям Top, Middle, Bottom:
 myalign:set_top(widget_top)
 myalign:set_middle(widget_middle)
 myalign:set_bottom(widget_bottom)
Обратите внимание, что все используемые виджеты должны быть уже определены и описаны, иначе схема align может неправильно выделить место под них.
=====Режим Expand=====
По умолчанию, средний виджет будет сжиматься или наоборот растягиваться (даже до превращения в точку), чтобы выделить место виджетам находящимся по краям. Это не всегда желательно. Функция &lt;code&gt;align_widget:set_expand(&quot;expand mode&quot;)&lt;/code&gt; используется, чтобы изменить это поведение.
{{wide image|align_widget_expand_modes.png|1024|Примеры различных режимов expand в действии.|alt=Example of different expand modes in action.}}
======Inside======
Используйте &lt;code&gt;align_widget:set_expand(&quot;inside&quot;)&lt;/code&gt; чтобы заставить средний виджет расширившись, заполнить все пространство между левым и правым виджетами.  Обратите внимание, что если нет свободного места, то средний виджет не будет отображен. В этом режиме верхний или левый виджет получает главный приоритет на доступное место, затем правый или нижний, и только затем выделяется место для среднего виджета. Это поведение по умолчанию.
======Outside======
Используйте &lt;code&gt;align_widget:set_expand(&quot;outside&quot;)&lt;/code&gt; для размещения среднего виджета по центру доступного пространства и заставляет внешние виджеты (левый,правый, верхний или нижний) расширившись заполнить все пространство, оставшимся на  соответствующей стороне виджетом. В этом режиме средний виджет имеет главный приоритет на размещение, а другие два виджета оставшееся на их стороне место. Виджеты описанные в handle не получают столько места, сколько они запрашивают, поэтому это не должно сломать их. Если средний виджет займет все доступное место, то остальные виджеты не будут отображены.
======None======
Использование &lt;code&gt;align_widget:set_expand(&quot;none&quot;)&lt;/code&gt; не оставляет пустого пространства. Средний виджет располагается по центру, и отдает главный приоритет доступному пространству. Оставшиеся два виджета используют все что им осталось, но не расширяется для заполнения всего свободного места. Если средний виджет занимает все свободное пространство, то оставшиеся виджеты не будут показаны. 

====[http://awesome.naquadah.org/doc/api/modules/wibox.layout.constraint.html Constraint]====
Этот виджет ограничивает размер его дочерних виджетов. Уставовка дочернего виджета делается так &lt;code&gt;myconstraint:set_widget(widget)&lt;/code&gt;. Настройка высоты и/или ширины constraint осущесвляется вызовом функций &lt;code&gt;myconstraint:set_height(n)&lt;/code&gt; и &lt;code&gt;myconstraint:set_width(n)&lt;/code&gt; соответсвенно, где целое &lt;code&gt;n&lt;/code&gt; это размер в пикселях. Если вы используете &lt;code&gt;nil&lt;/code&gt; вместо числа, то ограничение по данному направлению будет игнорироваться. Использование &lt;code&gt;myconstraint:reset()&lt;/code&gt; установит strategy на &quot;max&quot; и очистит оба значения высоты и ширины в constraint.
=====Constraint Strategies=====
''constraint strategy'' определяет как используется constraint. Помните, что эти описания &lt;i&gt;constraint&lt;/i&gt; not the widget it is constraining. Если вы хотите применить разные стратегии по каждому направлению, будьте осторожны, используйте вложенные виджеты constraint.
======Exact======
Это значение заставляет использовать точно те значения высоты и/или ширины, которые установлены в constraint.
 myconstraint:set_strategy(&quot;exact&quot;)
======Min======
Это значение позволит использовать высоту и/или ширину больше чем установленные в constraint значения.
 myconstraint:set_strategy(&quot;min&quot;)
======Max======
Это значение установит высоту и/или ширину меньше чем значения установленные в constraint.
 myconstraint:set_strategy(&quot;max&quot;)

====[http://awesome.naquadah.org/doc/api/modules/wibox.layout.fixed.html Fixed]====
====[http://awesome.naquadah.org/doc/api/modules/wibox.layout.flex.html Flex]====
====[http://awesome.naquadah.org/doc/api/modules/wibox.layout.margin.html Margin]====
Эта схема добавляет оболочку вокруг виджета который содержит эту схему. Используйте &lt;code&gt;widget:set_widget(subwidget)&lt;/code&gt; для установки под виджета. Если n целое число, &lt;code&gt;widget:set_margin(n)&lt;/code&gt; будет установлена полоса в n пикселей вокруг виджета и &lt;code&gt;widget:set_left(n)&lt;/code&gt;, &lt;code&gt;widget:set_right(n)&lt;/code&gt;, &lt;code&gt;widget:set_top(n)&lt;/code&gt;, и &lt;code&gt;widget:set_bottom(n)&lt;/code&gt; установит полосу в n пикселей на указанной стороне.

====[http://awesome.naquadah.org/doc/api/modules/wibox.layout.mirror.html Mirror]====
====[http://awesome.naquadah.org/doc/api/modules/wibox.layout.rotate.html Rotate]====

==Как облегчить себе жизнь?==
Схемы виджетов могут довольно быстро усложняться, при добавлении новых виджетов. Стандартная схема включает 6 виджетов в начале и после добавления еще нескольких можно довольно легко запутаться где именно вы находитесь в вашем layout. Чтобы помочь в этом, организуйте ваши виджеты в коде последовательно с добавлением обширных комментариев. Вот несколько советов:
*Используйте комментарии, чтобы обозначить к какому именно виджету он относится и что делает.
*Название layout виджета основывайте на их родителе и/или положении.
*Используйте отступы, для обозначения уровня на котором работаете.
*Стройте layout как это сделано в HTML:
**Объявите все ваши внешние layout.
**Установите его опции.
**Объявите под виджеты.
**Установите его опции.
**Объявите и добавьте другие дополнительные под виджеты.
**Добавьте виджет во внешний layout.
**Добавьте внешний layout в wibox.
*Для сложных layouts, нарисуйте макет, как вы хотите чтобы он выглядел перед началом работы.
*Прочтите документацию по доступным схемам перед началом, чтобы понимать что возможно, а что нет.

===Технические приемы===
====Labeling====
[[File:Battery Widgets.png|frame|Labeling example]]
Чтобы пометить виджет, который отображает данные, такие как прогресс бар, вы можете использовать виджет с align с двумя под виджетами: виджетом данных и текстовым.
 &lt;pre&gt;
internal_battery = awful.widget.align.vertical()

    internal_battery_pb = awful.widget.progressbar()
        internal_battery_pb:set_vertical(true)
        internal_battery_pb:set_width(8)
        internal_battery_pb:set_height(20)
        internal_battery_pb:set_background_color(beautiful.bg_normal)
        internal_battery_pb:set_border_color(beautiful.fg_normal)
        internal_battery_pb:set_color({ type = &quot;linear&quot;, from = { 0, 0 }, to = { 0, 20 },
                                        stops = { { 0,   beautiful.fg_focus},
                                        { 0.2, beautiful.fg_focus},
                                        { 1,   beautiful.bg_focus}
                                    } })
        vicious.register(internal_battery_pb, vicious.widgets.bat, &quot;$2&quot;, 20, &quot;CMB1&quot;)
    internal_battery:set_middle(internal_battery_pb)

    internal_battery_label = wibox.widget.textbox()
        internal_battery_label:set_text(&quot;I&quot;)
        internal_battery_label:set_align(&quot;center&quot;)
    internal_battery:set_bottom(internal_battery_label)
&lt;/pre&gt;
Обратите внимание, что виджет progress bar установлен как средний виджет. По умолчанию средний виджет расширяется, чтобы занять как можно больше места, и поэтому не используется верхний виджет(только средний и нижний), он использует все пространстов, что для label места уже нет. Если вы хотите использовать label сверху, вам необходимо использовать &lt;code&gt;set_top&lt;/code&gt; вместо &lt;code&gt;set_bottom&lt;/code&gt;.

===Примеры===</text>
      <sha1>kxbltq67bqkmgdiwgnkihbkz1s40pij</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Widgets dans awesome</title>
    <ns>0</ns>
    <id>406</id>
    <redirect title="Widgets in awesome/fr" />
    <revision>
      <id>3037</id>
      <timestamp>2009-06-25T20:24:28Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Widgets dans awesome]] to [[Widgets in awesome/fr]] over redirect: Fix for [[Template:Languages]]</comment>
      <text xml:space="preserve" bytes="35">#REDIRECT [[Widgets in awesome/fr]]</text>
      <sha1>o54z75y9y9cbcjs0t465ht5iwn8uf7c</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Widgets in awesome</title>
    <ns>0</ns>
    <id>47</id>
    <revision>
      <id>7014</id>
      <parentid>6937</parentid>
      <timestamp>2014-09-26T11:27:48Z</timestamp>
      <contributor>
        <username>Nikita</username>
        <id>3583</id>
      </contributor>
      <comment>/* textbox */</comment>
      <text xml:space="preserve" bytes="7988">{{Languages}}

== What are widgets ==
Widgets in awesome are objects you can add to any ''wibox'' (statusbars and titlebars), they can provide various information about your system, window manager and X clients right from your desktop. Widgets are simple to use and offer a great deal of flexibility.

== Widget creation ==

'''For awesome 3.4'''

  mysystray = widget({ type = &quot;systray&quot; })

  myicon = widget({ type = &quot;imagebox&quot; })
  myicon.image = image(awful.util.getdir(&quot;config&quot;) .. &quot;/myicon.png&quot;)

  mytextbox = widget({ type = &quot;textbox&quot; })

'''For awesome 3.5'''

  mysystray = wibox.widget.systray()

  myicon = wibox.widget.imagebox()
  myicon:set_image(awful.util.getdir(&quot;config&quot;) .. &quot;/myicon.png&quot;)

  mytextbox = wibox.widget.textbox()

== Widget types ==
The following widget types currently exist:

=== systray ===
Displays the system tray, which follows the ''freedesktop'' specification. Programs can put their tray icons here.

=== imagebox ===
Displays an image, of a format ''Imlib2'' can handle (png, jpeg...). Combine it with textbox widgets to create launchers, icons and separators.

=== textbox ===
Textbox widgets display a piece of text, they are the most common widgets. By creating a textbox widget, as shown in the above example, the ''mytextbox'' now contains a widget object. You can set or change the text of this textbox widget by modifying its ''.text'' field in version 3.4 or using the ''set_text'' method in 3.5:

'''Awesome 3.4:'''

 mytextbox.text = &quot;Hello, world!&quot;

'''Awesome 3.5:'''

 mytextbox:set_text(&quot;Hello, world!&quot;)

This will set the text printed by the widget to ''Hello, world!''. Some of you will now remember the ''awesome-client'' utility, and ask if it's possible to change widget text using it. The answer is yes, you only need to change the ''.text'' field or use the ''set_text'' method depending on your version of Awesome the and the widget will be updated:

'''Awesome 3.4:'''

  $ echo &quot;mytextbox.text = \&quot;Foo Bar!\&quot;&quot; | awesome-client

'''Awesome 3.5:'''

  $ echo &quot;mytextbox:set_text(\&quot;Foo Bar!\&quot;)&quot; | awesome-client

However with awesome you don't have to use external scripts to ''feed'' your widgets with data. Awesome doesn't only allow writing system monitors in Lua but also provides the [http://awesome.naquadah.org/doc/api/modules/timer.html awesome timer API] which will help you setup timers that periodically execute, and update, your widgets. Let's see a timer example:


'''Awesome 3.4:'''

  mytimer = timer({ timeout = 30 })
  mytimer:add_signal(&quot;timeout&quot;, function() mytextbox.text = &quot;Hello awesome world!&quot; end)
  mytimer:start()


'''Awesome 3.5:'''

  mytimer = timer({ timeout = 30 })
  mytimer:connect_signal(&quot;timeout&quot;, function() mytextbox:set_text(&quot;Hello awesome world!&quot;) end)
  mytimer:start()


One of the most frequently asked questions is about textbox widget colors. When talking about a textbox widget the color applies to the actual font, and in awesome you can change font properties by applying standard [http://en.wikipedia.org/wiki/Pango Pango markup]. In 3.5 the markup will be ignored by the ''set_text'' method, instead use the ''set_markup'' method for the same effect



'''Awesome 3.4:'''

&lt;pre&gt;
  mytextbox.text = '&lt;span color=&quot;white&quot;&gt;Sacrebleu, I have seen a ghost!&lt;/span&gt; '
&lt;/pre&gt;

'''Awesome 3.5:'''

&lt;pre&gt;
  mytextbox:set_markup( '&lt;span color=&quot;white&quot;&gt;Sacrebleu, I have seen a ghost!&lt;/span&gt; ')
&lt;/pre&gt;

Changing the background can be achived by using a background widget

'''Awesome 3.5:'''

  local datewidget_text = wibox.widget.textbox()
  local datewidget = wibox.widget.background()
  datewidget:set_widget(datewidget_text)
  datewidget:set_bg(&quot;#df7401&quot;)

=== awful widget functions ===
Awesome is distributed with several widget function helpers, as part of the '''awful''' library, that use the above widget types to create complex widgets which provide irreplaceable functionality. Some examples of these are the ''awful.widget.taglist'' function - creating taglist widgets, and ''awful.widget.tasklist'' function - creating taskbar widgets. Other useful awful widget functions are the ''button'', ''launcher'', ''prompt'' and ''layoutbox''.

=== awful widget types ===

==== Graph ====
The '''awful.widget.graph''' module creates and displays a graph with varying data over time.

Example graph configuration:
  mygraph = awful.widget.graph()
  mygraph:set_width(50)
  mygraph:set_background_color('#494B4F')
  mygraph:set_color('#FF5656')
  mygraph:set_gradient_colors({ '#FF5656', '#88A175', '#AECF96' })

''mygraph'' now contains a widget object, a graph, stored in its ''.widget'' field. You can add data to your graph using the ''add_value()'' function:

  mygraph:add_value(0.5)

==== Progressbar ====
The '''awful.widget.progressbar''' module creates and displays progresssbar widgets.

Example progressbar configuration:
  myprogressbar = awful.widget.progressbar()
  myprogressbar:set_width(8)
  myprogressbar:set_height(10)
  myprogressbar:set_vertical(true)
  myprogressbar:set_background_color('#494B4F')
  myprogressbar:set_color('#AECF96')
  myprogressbar:set_gradient_colors({ '#AECF96', '#88A175', '#FF5656' })

''myprogressbar'' now contains a widget object, a progressbar, stored in its ''.widget'' field. You can add data to your progressbar using the ''set_value()'' function:

  myprogressbar:set_value(0.5)

Remember the ''textbox'' example, ''awesome-client'' and timers. The same applies here, using the ''add_value()'' (graph) and ''set_value()'' (progressbar) functions you can dynamically fill these widgets by sending them numbers in range 0.1 - 1. You can find other available functions and progressbar/graph properties in the [http://awesome.naquadah.org/doc/api/modules/awful.widget.graph.html API] [http://awesome.naquadah.org/doc/api/modules/awful.widget.progressbar.html documentation].

== Widget buttons ==
You can attach button bindings to widgets, let's see an example:

  mytextbox:buttons(awful.util.table.join(
    awful.button({ }, 1, function () awful.util.spawn(&quot;echo Left mouse button pressed.&quot;) end)
  ))

The following example shows how to add button bindings to progressbar and graph widgets, by attaching them to the actual widget object stored in its ''.widget'' field:
  mygraph.widget:buttons(awful.util.table.join(
    awful.button({ }, 1, function () awful.util.spawn(&quot;echo Left mouse button pressed again.&quot;) end)
  ))

== Controlling widgets ==
In previous sections we covered everything about widget initialization, but remember; a widget needs to be added to a ''wibox'' in order to be '''displayed'''. In your [[Awesome_3_configuration#Files|rc.lua]] a ''wibox'' is created by looping over each physical [[Awesome_3_configuration#screen|screen]]. You can control where your widget will be displayed by placing it on a particular wibox, and one widget can be added to multiple wibox' and screens.

You can also control on which screen the widget is placed on (by default they are placed on all screens on which the wibox is visible). One existing example of this functionality is the ''systray'' widget, which because of specification limitations can only be displayed once:

  s == 1 and mysystray or nil,

In the above example systray will only appear on screen 1. You can use the same code with other widgets:

  s == 2 and mytextbox or nil,

Like in the above buttons example, when adding progressbar and graph widgets to your wibox you need to reference the actual widget object:
  mytextclock,          -- awesome clock widget, textbox
  mygraph.widget,       -- users customized graph widget
  myprogressbar.widget, -- users customized prbar widget

=== Widget layouts ===
Widget layouts allow controlling the placement of widgets, from Lua, to a much bigger degree than with the &quot;old&quot; widget ''.align'' property. You should read the [http://awesome.naquadah.org/wiki/Awesome_3.3_to_3.4#Widget_Layouts introduction to widget layouts] and [[Widget Layouts]] to learn more.

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>t48na8o12be8ix4ncf7sceiqtq96oah</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Widgets in awesome/fr</title>
    <ns>0</ns>
    <id>394</id>
    <revision>
      <id>3388</id>
      <parentid>3345</parentid>
      <timestamp>2009-07-27T10:08:53Z</timestamp>
      <contributor>
        <username>SGC.Alex</username>
        <id>324</id>
      </contributor>
      <comment>ajout d’info depuis page anglaise</comment>
      <text xml:space="preserve" bytes="3633">{{DISPLAYTITLE:Widgets dans awesome}}
{{Languages|Widgets in awesome}}

== Un widget, c’est quoi ? ==
Les widgets dans awesome sont des objets que vous pouvez ajouter aux barres de statut et aux barres de titres. Ils peuvent fournir de nombreuses informations sur votre système et sont utiles pour accéder à ces informations depuis votre gestionnaire de fenêtres. Les widgets sont faciles à utiliser et offrent un très grand atout niveau flexibilité.

== Création de widgets ==
Les widgets, comme les onglets, si on ne les ajoute nulle part, ils ne servent à rien du tout. Pour créer un widget, utilisez la fonction ''widget()'' :

 mytextbox = widget({ type = &quot;textbox&quot;, name = &quot;mytextbox&quot; })

''mytextbox'' contient maintenant un objet « widget ». Dans le cas présent d’une boîte textuelle, vous pouvez changer le paramètre de texte de cette façon :

 mytextbox.text = &quot;Hello, world!&quot;

Cette ligne a pour effet d’affecter la chaîne « Hello, world! » au texte à afficher par le widget.

== Contrôler des widgets ==

Dans le fichier '''[[Awesome 3 configuration/fr|rc.lua]]''', les widgets sont d’habitude créés en les liant à chaque écran physique. Si vous voulez contrôler sur quel écran ils sont placés, alors vous pouvez modifier le code qui les lie aux écrans.

Par exemple, si vous voulez que la barre de statut apparaisse sur l’écran nº2 au lieu du nº1, vous pouvez changer la ligne du fichier '''rc.lua''' qui mentionne la barre de statut en remplaçant :

 s == 1 and mysystray or nil }

par

 s == 2 and mysystray or nil }

== Types de widgets ==
Les types suivants de widget existent actuellement :

;textbox
:affiche un morceau de texte. C’est le type de widget le plus courant.

;imagebox
:affiche une image au format '''.png'''.

;appicon
:une icône que vous pouvez mettre sur une barre de statut en tant que lanceur.

;graph
:affiche un ou plusieurs graphiques avec des données qui fluctuent au cours du temps.
:Exemple de configuration :
&lt;pre style=&quot;padding-left:25px;&quot;&gt;
mygraph = widget({ type = &quot;graph&quot;, align = &quot;right&quot; })
mygraph.width = 70
mygraph.height = 0.90
mygraph.grow = &quot;left&quot;
mygraph.bg = beautiful.mygraph_bg
mygraph.border_color = beautiful.mygraph_border_color

mygraph:plot_properties_set(&quot;total&quot;, 
{ 
  [&quot;fg&quot;] = &quot;#336699cc&quot;,
  [&quot;fg_center&quot;] = beautiful.mygraph_total_center,
  [&quot;fg_end&quot;] = beautiful.mygraph_total_end,
  [&quot;vertical_gradient&quot;] = true,
  [&quot;scale&quot;] = false,
  [&quot;max_value&quot;] = &quot;100.0&quot;,
  [&quot;style&quot;] = &quot;bottom&quot;
})
&lt;/pre&gt;

;progressbar
:affiche une ou plusieurs barres de progression.
:Exemple de configuration :
&lt;pre style=&quot;padding-left:25px;&quot;&gt;
myprogressbar =  widget({ type = &quot;progressbar&quot;, align = &quot;right&quot; })
myprogressbar.width = 28
myprogressbar.height = 0.90
myprogressbar.gap = 0
myprogressbar.border_padding = 0
myprogressbar.border_width = 1
myprogressbar.ticks_count = 0
myprogressbar.vertical = true

myprogressbar:bar_properties_set(&quot;root&quot;, 
{ 
  [&quot;bg&quot;] = beautiful.myprogressbar_root_bg,
  [&quot;fg&quot;] = beautiful.myprogressbar_root_fg,
  [&quot;fg_center&quot;] = beautiful.myprogressbar_root_fg_center,
  [&quot;fg_end&quot;] = beautiful.myprogressbar_root_fg_end,
  [&quot;fg_off&quot;] = beautiful.myprogressbar_root_fg_off,
  [&quot;border_color&quot;] = beautiful.myprogressbar_root_border_color,
  [&quot;min_value&quot;] = &quot;50.0&quot;,
  [&quot;max_value&quot;] = &quot;100.0&quot;,
  [&quot;reverse&quot;] = false
})
&lt;/pre&gt;

;systray
:affiche une zone de notification, où les programmes peuvent mettre leurs icônes.

;taglist
:Liste tous les onglets assignés à l’écran actuel.

;tasklist
:Liste un ensemble des fenêtres, en général seulement celles sur l’onglet actuel.

[[Category:awesome3]]</text>
      <sha1>crcos9khi9fzrwjvfpyl7ob9c5f83qd</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Widgets in awesome/ru</title>
    <ns>0</ns>
    <id>453</id>
    <revision>
      <id>7152</id>
      <parentid>6938</parentid>
      <timestamp>2014-12-15T05:51:01Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* textbox */ some changing</comment>
      <text xml:space="preserve" bytes="14017">{{DISPLAYTITLE: Виджеты в Awesome}}
{{Template:Languages|Widgets in awesome}}

== Что такое виджеты ==
Виджеты в Awesome - это объекты, которые можно размещать на панелях и в заголовках окон, они могут предоставлять различную информацию о системе и очень полезны для получения доступа к этой информации прямо из оконного менеджера. Виджеты легко использовать и они обладают большой гибкостью.

== Создание виджета ==

'''Для awesome 3.4'''

  mysystray = widget({ type = &quot;systray&quot; })

  myicon = widget({ type = &quot;imagebox&quot; })
  myicon.image = image(awful.util.getdir(&quot;config&quot;) .. &quot;/myicon.png&quot;)

  mytextbox = widget({ type = &quot;textbox&quot; })

'''Для awesome 3.5'''

  mysystray = wibox.widget.systray()

  myicon = wibox.widget.imagebox()
  myicon:set_image(awful.util.getdir(&quot;config&quot;) .. &quot;/myicon.png&quot;)

  mytextbox = wibox.widget.textbox()

== Типы виджетов ==
В настоящее время существуют следующие типы виджетов:

=== systray ===
Отображает системный трей, в котором программы могут размещать свои значки.

=== imagebox ===
Отображает картинку в формате, поддерживаемых в Imlib2 (png, jpeg). Используйте вместе с textbox, чтобы создавать ярлыки, иконки и разделители.

=== textbox ===
Виджет для отображения текста, это наиболее часто используемый виджет. После создания виджета textbox, как указано в примере выше, переменная mytextbox, теперь содержит ссылку на виджет, с помощью которого вы можете управлять и изменять его значения. Вы можете установить или изменить текст виджета, с помощью модификации его поля ''.text'' в Awesome 3.4 или используйте метод ''set_text'' в 3.5

'''Awesome 3.4:'''
 mytextbox.text = &quot;Hello, world!&quot;

'''Awesome 3.5:'''
 mytextbox:set_text(&quot;Hello, world!&quot;)

Данный код изменит отображаемый виджетом текст на ''Hello, world!''. 
Некоторые могут вспомнить утилиту ''awesome-client'', и спросить, а можно ли изменить значение текста с его помощью. Да, с его помощью можно изменить значение поля '.text'' или используйте метод ''set_text'' в зависимости от вашей версии Awesome, и значение будет обновлено:

'''Awesome 3.4:'''
  $ echo &quot;mytextbox.text = \&quot;Foo Bar!\&quot;&quot; | awesome-client
'''Awesome 3.5:'''	
  $ echo &quot;mytextbox:set_text(\&quot;Foo Bar!\&quot;)&quot; | awesome-client

Однако в ''awesome'' вам нет необходимости использовать сторонние (внешние) скрипты, для передачи данных вашим виджетам. Awesome не только предоставляет описание системы мониторинга в Lua, но и предоставляет [http://awesome.naquadah.org/doc/api/modules/timer.html awesome timer API] который позволяет настроить таймеры, периодически выполняющие или обновляющие ваши виджеты. Рассмотрим работу таймера на примере:
	
'''Awesome 3.4:'''
  mytimer = timer({ timeout = 30 })
  mytimer:add_signal(&quot;timeout&quot;, function() mytextbox.text = &quot;Hello awesome world!&quot; end)
  mytimer:start()
'''Awesome 3.5:'''	
  mytimer = timer({ timeout = 30 })	
  mytimer:connect_signal(&quot;timeout&quot;, function() mytextbox:set_text(&quot;Hello awesome world!&quot;) end)
  mytimer:start()

Очень часто можно встретить вопрос об изменении цвета текста в виджете textbox. По умолчанию в виджете textbox, используются значения текущего шрифта, однако вы можете изменять свойства шрифта используя стандарт [http://en.wikipedia.org/wiki/Pango Pango markup].  В Awesome 3.5 разметка будет проигнорированна методом ''set_text'', для использования разметки, используйте метод ''set_markup''.
'''Awesome 3.4:'''
&lt;pre&gt;
  mytextbox.text = '&lt;span color=&quot;white&quot;&gt;Sacrebleu, I have seen a ghost!&lt;/span&gt; '
&lt;/pre&gt;
'''Awesome 3.5:'''
&lt;pre&gt;
  mytextbox:set_markup( '&lt;span color=&quot;white&quot;&gt;Sacrebleu, I have seen a ghost!&lt;/span&gt; ')
&lt;/pre&gt;
Для изменения фона, можно использовать фоновый виджет:
'''Awesome 3.5:'''
&lt;pre&gt;
local datewidget_text = wibox.widget.textbox()
local datewidget = wibox.widget.background()
datewidget:set_widget(datewidget_text)
datewidget:set_bg(&quot;#df7401&quot;)
&lt;/pre&gt;

=== Функциональность виджетов awful ===

Awesome распространяется с несколькими облегчающими разработку виджетов библиотеками, такими как '''awful''', которая использовалась вышеописанными типами виджетов для создания необходимой функциональности. Например ''awful.widget.taglist'' - создает виджет тегов, а функция ''awful.widget.tasklist'' - создает виджет панели задач. Другими вариантами использования функциональности awful являются виджеты ''button'', ''launcher'', ''prompt'' и ''layoutbox''.

=== Типы виджетов использующих awful ===

==== Graph ====

Модуль '''awful.widget.graph''' создает и отображает графики с изменяющимися во времени данными.
Пример настройки graph:

''' Старые версии Awesome без библиотеки awful'''
 mygraph = widget({ type = &quot;graph&quot;, align = &quot;right&quot; })
 mygraph.width = 70
 mygraph.height = 0.90
 mygraph.grow = &quot;left&quot;
 mygraph.bg = beautiful.mygraph_bg
 mygraph.border_color = beautiful.mygraph_border_color

 mygraph:plot_properties_set(&quot;total&quot;, 
 { 
   [&quot;fg&quot;] = &quot;#336699cc&quot;,
   [&quot;fg_center&quot;] = beautiful.mygraph_total_center,
   [&quot;fg_end&quot;] = beautiful.mygraph_total_end,
   [&quot;vertical_gradient&quot;] = true,
   [&quot;scale&quot;] = false,
   [&quot;max_value&quot;] = &quot;100.0&quot;,
   [&quot;style&quot;] = &quot;bottom&quot;
 })


'''Awesome с библиотекой awful'''
  mygraph = awful.widget.graph()
  mygraph:set_width(50)
  mygraph:set_background_color('#494B4F')
  mygraph:set_color('#FF5656')
  mygraph:set_gradient_colors({ '#FF5656', '#88A175', '#AECF96' })

Переменная ''mygraph'' теперь содержит виджет объекта graph, сохраненную в его поле ''widget''. Вы можете добавить данные в ваш graph, используя функцию ''add_value()'': 

  mygraph:add_value(0.5)


==== Progressbar ====
Модуль '''awful.widget.progressbar''' создает и отображает виджет индикатора выполнения.

Пример использования индикатора:

''' Awesome без awful '''

  myprogressbar =  widget({ type = &quot;progressbar&quot;, align = &quot;right&quot; })
  myprogressbar.width = 28
  myprogressbar.height = 0.90
  myprogressbar.gap = 0
  myprogressbar.border_padding = 0
  myprogressbar.border_width = 1
  myprogressbar.ticks_count = 0
  myprogressbar.vertical = true

  myprogressbar:bar_properties_set(&quot;root&quot;, 
  { 
    [&quot;bg&quot;] = beautiful.myprogressbar_root_bg,
    [&quot;fg&quot;] = beautiful.myprogressbar_root_fg,
    [&quot;fg_center&quot;] = beautiful.myprogressbar_root_fg_center,
    [&quot;fg_end&quot;] = beautiful.myprogressbar_root_fg_end,
    [&quot;fg_off&quot;] = beautiful.myprogressbar_root_fg_off,
    [&quot;border_color&quot;] = beautiful.myprogressbar_root_border_color,
    [&quot;min_value&quot;] = &quot;50.0&quot;,
    [&quot;max_value&quot;] = &quot;100.0&quot;,
    [&quot;reverse&quot;] = false
  })

''' Awesome с библиотекой awful '''

  myprogressbar = awful.widget.progressbar()
  myprogressbar:set_width(8)
  myprogressbar:set_height(10)
  myprogressbar:set_vertical(true)
  myprogressbar:set_background_color('#494B4F')
  myprogressbar:set_color('#AECF96')
  myprogressbar:set_gradient_colors({ '#AECF96', '#88A175', '#FF5656' })

Переменная ''myprogressbar'' теперь содержит объект виджета progressbar, сохраненную в его поле ''.widget''. Вы можете добавить данный в индикатора используя функцию ''set_value()'':

  myprogressbar:set_value(0.5)

Помните примеры ''textbox'', ''awesome-client'' и таймеры. Некоторые возможности используются и здесь, такие как ''add_value()'' (в graph) и ''set_value()'' (в progressbar). Используя эти функции вы можете динамически посылать значения в диапазоне 0.1 - 1. Вы можете найти остальные доступные функции и свойства progressbar/graph в [http://awesome.naquadah.org/doc/api/modules/awful.widget.graph.html API] и [http://awesome.naquadah.org/doc/api/modules/awful.widget.progressbar.html документации].

=== appicon ===
Значок, который можно поместить на панель и использовать для запуска приложения.

== Виджет кнопок(buttons) ==

Вы можете привязать кнопку к уже существующему виджету (в данном случае textbox). Давайте взглянем на пример: 

  mytextbox:buttons(awful.util.table.join(
    awful.button({ }, 1, function () awful.util.spawn(&quot;echo Нажата левая кнопка мыши.&quot;) end)
  ))


Следующий пример показывает, как добавить кнопку к виджетам progressbar и graph, привязав ее к существующему виджету, сохраненному в поле ''.widget'':
  mygraph.widget:buttons(awful.util.table.join(
    awful.button({ }, 1, function () awful.util.spawn(&quot;echo Снова нажата левая кнопка мыши.&quot;) end)
  ))




== Управление виджетами ==

В предыдущих разделах, мы рассмотрели все об инициализации виджета, но помните, виджет должен быть добавлен в секцию ''wibox'', иначе он не будет отображен. 
В файле [[Awesome_3_configuration/ru#Files|rc.lua]] ''wibox'' создается в цикле для каждого физического экрана [[Awesome_3_configuration/ru#Screen|(screen)]]. Вы можете управлять где именно ваш виджет будет размещен, на также на каком экране, в какой части секции wibox. Один и тот же виджет может быть много раз добавлен в различные wibox и экраны (screens), для этого вам нужно соответвенно изменить тело цикла.

Вы можете также контролировать на скольких экранах будут размещены виджеты (по уполчанию они располагаются на всех экранах, на которых отображается wibox). Ниже описан пример, позволяющий отобразить ''systray'' только на одном экране:

  s == 1 and mysystray or nil,

Теперь, чтобы виджет системного трея (systray) помещался на 2-й экран вместо 1-го, измените в [[Awesome_3_configuration/ru#Files|rc.lua]] в строке, относящейся к трею, с s == 1 на s == 2, то есть строка примет вид:

 s == 2 and mysystray or nil }

В приведенном выше примере системный лоток (systray) появиться только на 2м экране. Подобный код вы можете также использовать и для других виджетов:

  s == 2 and mytextbox or nil,

Как и в приведенном выше примере для кнопки, при добавлении виджетов progressbar и graph в вашу секцию wibox, необходимо ссылаться на реально созданный объект:
  mytextclock,          -- awesome clock widget, textbox
  mygraph.widget,       -- users customized graph widget
  myprogressbar.widget, -- users customized prbar widget

=== Схематика(layout) виджетов ===
Использование layout позволяет контролировать размещение виджетов, с помощью Lua, более гибко, чем в &quot;старых&quot; виджетах c помощью свойства ''.align''. Вы можете прочитать [http://awesome.naquadah.org/wiki/Awesome_3.3_to_3.4#Widget_Layouts introduction to widget layouts] и [[Widget Layouts]] чтобы узнать больше.

[[Category:Awesome3]][[Category:Widgets]]</text>
      <sha1>0vgb63ve8vkiee9x9r4g7h6arn1avj6</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Woffles Rhythmbox Widget</title>
    <ns>0</ns>
    <id>52</id>
    <revision>
      <id>1310</id>
      <timestamp>2008-10-16T15:15:16Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <minor/>
      <text xml:space="preserve" bytes="3299">=== Introduction ===

Thankfully controlling Rhythmbox remotely is a fairly tast thanks to
the ''rhythmbox-client'' tool. This tutorial shows you how to make a
textbot that displays &quot;Playing: whatever&quot; and how to control Rhythmbox
using mouse actions.

Programs you will need:

* pcregrep -- grep using the PCRE syntax.
* rhythmbox-client -- well, duhh.

=== Create the widget ===

 textbox widget_rhythmbox {
 	# Next track:
 	mouse {
 		modkey = {}
 		button = &quot;4&quot;
 		command = &quot;spawn&quot;
 		arg = &quot;~/.awesome/rhythmbox-adjust.sh next&quot;
 	}
 	
 	# Previous track:
 	mouse {
 		modkey = {}
 		button = &quot;5&quot;
 		command = &quot;spawn&quot;
 		arg = &quot;~/.awesome/rhythmbox-adjust.sh previous&quot;
 	}
 	
 	# Play/pause
 	mouse {
 		modkey = {}
 		button = &quot;1&quot;
 		command = &quot;spawn&quot;
 		arg = &quot;~/.awesome/rhythmbox-adjust.sh pause&quot;
 	}	
 }

=== Create the scripts ===

First we need to make a script to store the configuration in:

'''~/.awesome/rhythmbox-values.sh'''
 handle() {
 	if [ &quot;$1&quot; == &quot;&quot; ]
 	then
 		echo &quot;  Stopped. &quot;
 	else
 		echo &quot;  Playing: $1 &quot;
 	fi
 }
 
 flags=&quot;&quot;
 #flags=&quot;--no-start&quot;
 widget=&quot;widget_rhythmbox&quot;
 speed=5

This script lets you adjust which widget is drawn, how often it's drawn
(''speed'') and what to draw (''handle()''). There's also ''flags''
which lets you pass extra flags to ''rhythmbox-client''.

By default ''rhythmbox-client'' will start an instance of Rhythmbox when
called, to disable this use the ''--no-start'' flag.

Also, keep in mind that the higher you set the speed the heavier the
load on your system, a value between 2-10 is probably best.

The next script does the actual widget updating:

'''~/.awesome/rhythmbox-update.sh'''
 . ~/.awesome/rhythmbox-values.sh
 
 playing=`rhythmbox-client --no-start --print-playing 2&gt; /dev/null`
 
 echo &quot;0 widget_tell $widget `handle \&quot;$playing\&quot;`&quot; | awesome-client

Next is the script for triggering ''rhythmbox-client'' events:

'''~/.awesome/rhythmbox-adjust.sh'''
 . ~/.awesome/rhythmbox-values.sh
 
 if [ &quot;$1&quot; == &quot;next&quot; ]
 then
 	`rhythmbox-client $flags --next 2&gt; /dev/null`
 fi
 
 if [ &quot;$1&quot; == &quot;previous&quot; ]
 then
 	`rhythmbox-client $flags --previous 2&gt; /dev/null`
 fi
 
 if [ &quot;$1&quot; == &quot;pause&quot; ]
 then
 	`rhythmbox-client $flags --play-pause 2&gt; /dev/null`
 fi
 
 # Force awesome to update:
 ~/.awesome/rhythmbox-update.sh

The last script monitors ''rhythmbox-client'' for changes:

'''~/.awesome/rhythmbox-monitor.sh'''
 while true
 do
 	if [ -S ~/.awesome_ctl.0 ]
 	then
 		while true
 		do
 			. ~/.awesome/rhythmbox-update.sh
 			
 			sleep $speed
 		done
 	else
 		sleep 1
 	fi
 done

To make sure the scripts can be executed run:

 chmod +x ~/.awesome/rhythmbox-*

=== Final steps ===

The last thing you need to do is find a way to automatically run
''~/.awesome/rhythmbox-monitor.sh'' every time you start an X session.

The usual way is to edit your ''~/.xinitrc'' file to include the script,
this might look something line:

 ~/.awesome/rhythmbox-monitor.sh &amp;
 exec awesome

However, you'll probably need to figure something else out if you're
using a display manager like xdm, gdm or kdm.

Finally, tell awesome to reload your configuration, the usual way is to
press ''Control-Mod4-R''.

That just about covers everything, if you have any question I'm
''woffle'' on IRC.


[[Category:Widgets]]
[[Category:awesome2]]</text>
      <sha1>b821pwgmuyhjzfbx7cfl844sf597ihz</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Woffles Uptime Widget</title>
    <ns>0</ns>
    <id>49</id>
    <revision>
      <id>1300</id>
      <timestamp>2008-10-16T15:10:42Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <text xml:space="preserve" bytes="2491">=== Introduction ===

The load average is a good indicator of current system stress, having it
available for quick reference is essential. This tutorial will make a
load average indicator that when clicked on will bring up the task
manager of your choice.

Programs you will need:

* pcregrep -- grep using the PCRE syntax.
* uptime -- should be available everywhere.

=== Create the widget ===

 textbox load_average {
 	text_align = &quot;right&quot;
 	align = &quot;right&quot;
 	
 	# Task manager
 	mouse {
 		modkey = {}
 		button = &quot;1&quot;
 		command = &quot;spawn&quot;
 		arg = &quot;xterm -e top&quot;
 	}
 }

To use a different tool than ''top' just change the value of ''arg''.

=== Create the scripts ===

The first script you need contains the widget name, the text format
to use and the speed which the widget should update in seconds:

'''~/.awesome/uptime-values.sh'''
 handle() {
 	# $1 -- Uptime
 	# $2 -- Users
 	# $3 -- Load
 	
 	echo &quot; Load: $1 - $2 - $3 &quot;
 }
 
 widget=&quot;load_average&quot;
 speed=5

Next we need a script to periodically update the widget:

'''~/.awesome/uptime-monitor.sh'''
 while true
 do
 	if [ -S ~/.awesome_ctl.0 ]; then
 		while true
 		do
 			. ~/.awesome/uptime-values.sh
 			
 			uptime=`uptime`;
 			up=`echo $uptime | pcregrep -o 'up\s+[0-9]+:[0-9]+' | pcregrep -o '[0-9]+:[0-9]+'`
 			users=`echo $uptime | pcregrep -o '[0-9]+\s+users' | pcregrep -o '[0-9]+'`
 			load=`echo $uptime | pcregrep -o '[0-9\.]+,\s+[0-9\.]+,\s+[0-9\.]+$'`
 			
 			echo &quot;0 widget_tell $widget &quot; &quot;`handle \&quot;$up\&quot; \&quot;$users\&quot; \&quot;$load\&quot;`&quot; | awesome-client
 			
 			sleep $speed
 		done
 	else
 		sleep 1
 	fi
 done

Now, you might be wondering why that needed two scripts; I wrote it this
way so that you can change the way the script works without needing to
restart ''~/.awesome/uptime-monitor.sh''.

To make sure the scripts can be executed run:

 chmod +x ~/.awesome/uptime-*

=== Final steps ===

The last thing you need to do is find a way to automatically run ~/.awesome/uptime-monitor.sh every time you start an X session.

The usual way is to edit your ~/.xinitrc file to include the script, this might look something line:

 ~/.awesome/uptime-monitor.sh &amp;
 exec awesome

However, you'll probably need to figure something else out if you're using a display manager like xdm, gdm or kdm.

Finally, tell awesome to reload your configuration, the usual way is to press Control-Mod4-R.

That just about covers everything, if you have any question I'm woffle on IRC.


[[Category:Widgets]]
[[Category:awesome2]]</text>
      <sha1>gnkt3duno74712yhu2ukluo77irwrko</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Woffles Volume Widget</title>
    <ns>0</ns>
    <id>48</id>
    <revision>
      <id>1305</id>
      <timestamp>2008-10-16T15:12:50Z</timestamp>
      <contributor>
        <username>Tomdeb</username>
        <id>152</id>
      </contributor>
      <comment>/* Final steps */</comment>
      <text xml:space="preserve" bytes="4378">=== Introduction ===

Having a usable volume control in my status bar was very important, I
needed to be able to adjust the volume if needed, or mute it quickly.

By following this tutorial you'll end up with a widget in your status
bar that looks like &quot;Volume: 50%&quot; which responds to mouse actions:

* Mouse wheel adjusts volume up / down.
* Left clicking on the volume mutes it.

This tutorial is aimed at systems using alsa, you'll need to confirm
that you have the following programs installed:

* alsamixer -- Ncurses based volume control.
* amixer -- Tool for adjusting alsa on the fly.
* pcregrep -- grep using the PCRE syntax.

=== Preparation ===

Before we start we need to know which audio channel you want to control,
usually &quot;Master&quot; or &quot;PCM&quot;. To get a list of available channels:

 amixer -c 0 | pcregrep &quot;control&quot;

To test and make sure the value will do what we need run:

 amixer -c 0 -- sget Master | pcregrep &quot;[0-9]+%&quot;

The output should look like:

 Front Left: Playback 6 [19%] [-37.50dB] [on]
 Front Right: Playback 6 [19%] [-37.50dB] [on]

''Note: Your card ID (the -c 0 bit) might be different if you have
more than one sound card available.''

=== Create the widget ===

Put this in whichever status bar you want them:

 textbox volume_control {
 	text_align = &quot;right&quot;
 	align = &quot;right&quot;
 	
 	# Volume up:
 	mouse {
 		modkey = {}
 		button = &quot;4&quot;
 		command = &quot;spawn&quot;
 		arg = &quot;~/.awesome/volume-adjust.sh up&quot;
 	}
 	
 	# Volume down:
 	mouse {
 		modkey = {}
 		button = &quot;5&quot;
 		command = &quot;spawn&quot;
 		arg = &quot;~/.awesome/volume-adjust.sh down&quot;
 	}
 	
 	# Soft mute:
 	mouse {
 		modkey = {}
 		button = &quot;1&quot;
 		command = &quot;spawn&quot;
 		arg = &quot;~/.awesome/volume-adjust.sh mute&quot;
 	}
 }

=== Create the scripts ===

The first shell script we make simply contains the values of our card ID
, the name of the channel we want to control, the percent of adjustment
we want when using the mouse wheel, the name of the widget to update and
finally the speed to update at in seconds:

'''~/.awesome/volume-values.sh:'''
 handle() {
 	# Hard mute:
 	if [ &quot;$1&quot; == &quot;0&quot; ]
 	then
 		`amixer -c $cardid sset $channel mute &gt; /dev/null`
 	else
 		`amixer -c $cardid sset $channel unmute &gt; /dev/null`
 	fi
 	
 	# Set widget text:
 	echo &quot; Volume: $1% &quot;
 }
 
 cardid=0
 channel=&quot;Master&quot;
 adjust=5
 widget=&quot;volume_control&quot;
 speed=10

If you don't have an ''~/.awesome'' folder, feel free to create one (~
is equal to your home directory.)

If you find that updating once every 10 seconds (''speed=10'') isn't
enough feel free to change the value. Just be warned however that the
smaller the value the higher your CPU usage will get.

Next we create a script to update the awesome widget:

'''~/.awesome/volume-update.sh:'''
 . ~/.awesome/volume-values.sh
 
 volume=`amixer -c $cardid -- sget $channel | pcregrep 'Left:.+[0-9]+%' | pcregrep -o '[0-9]+%' | pcregrep -o '[0-9]+'`
 
 echo &quot;0 widget_tell $widget `handle \&quot;$volume\&quot;`&quot; | awesome-client

Now we need a script to handle the volume adjustment:

'''~/.awesome/volume-adjust.sh:'''
 . ~/.awesome/volume-values.sh
 
 if [ &quot;$1&quot; == &quot;up&quot; ]
 then
 	amixer -q -c $cardid sset $channel $adjust%+
 fi
 
 if [ &quot;$1&quot; == &quot;down&quot; ]
 then
 	amixer -q -c $cardid sset $channel $adjust%-
 fi
 
 if [ &quot;$1&quot; == &quot;mute&quot; ]
 then
 	amixer -q -c $cardid sset $channel 0%
 fi
 
 # Force awesome to update:
 ~/.awesome/volume-update.sh

And finally we need a script to monitor the volume, in case another
program changes it:

'''~/.awesome/volume-monitor.sh:'''
 while true
 do
 	if [ -S ~/.awesome_ctl.0 ]; then
 		while true
 		do
 			. ~/.awesome/volume-update.sh
 			
 			sleep $speed
 		done
 	else
 		sleep 1
 	fi
 done

To make sure the scripts can be executed run:

 chmod +x ~/.awesome/volume-*

=== Final steps ===

The last thing you need to do is find a way to automatically run
''~/.awesome/volume-monitor.sh'' every time you start an X session.

The usual way is to edit your ''~/.xinitrc'' file to include the script,
this might look something line:

 ~/.awesome/volume-monitor.sh &amp;
 exec awesome

However, you'll probably need to figure something else out if you're
using a display manager like xdm, gdm or kdm.

Finally, tell awesome to reload your configuration, the usual way is to
press ''Control-Mod4-R''.

That just about covers everything, if you have any question I'm
''woffle'' on IRC.


[[Category:Widgets]]
[[Category:awesome2]]</text>
      <sha1>iczpa4tj9qmvn3vslognypnb9b2pvsk</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Workaround plugins that steal the keyboard focus</title>
    <ns>0</ns>
    <id>686</id>
    <revision>
      <id>6617</id>
      <parentid>5441</parentid>
      <timestamp>2014-05-23T06:49:26Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1167">{{Languages}}

There is a very long-standing [https://bugzilla.mozilla.org/show_bug.cgi?id=78414 bug in firefox] that allows plugins (Flash, Acrobat, etc) to steal all of the keyboard shortcuts for the window.  This is a simple workaround to return the keyboard focus to the top level window:

&lt;code&gt;
     -- Escape from keyboard focus trap (eg Flash plugin in Firefox)
     awful.key({ modkey, &quot;Control&quot; }, &quot;Escape&quot;, function ()
          awful.util.spawn(&quot;xdotool getactivewindow mousemove --window %1 0 0 click --clearmodifiers 2&quot;)
     end),
&lt;/code&gt;

[http://www.semicomplete.com/projects/xdotool/ xdotool] must be installed.

== Alternative method (without xdotool) ==

For example, use [https://awesome.naquadah.org/wiki/Move_Mouse Move Mouse] to move mouse pointer to a safe location (any area with no links or embedded Flash elements), then call the function below to simulate a mouse click (that brings the focus back).

&lt;pre&gt;
-- Simulate mouse click
local function simulateClick()
    root.fake_input(&quot;button_press&quot;, 1)
    root.fake_input(&quot;button_release&quot;, 1)
end

-- Bind it to a key
    awful.key({ modkey, }, &quot;n&quot;, function() simulateClick() end),
&lt;/pre&gt;</text>
      <sha1>s2qgtp731ywwbfbeo3wodwju3kcnjj8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Workaround plugins that steal the keyboard focus/ru</title>
    <ns>0</ns>
    <id>1076</id>
    <revision>
      <id>6619</id>
      <timestamp>2014-05-23T08:37:53Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Workaround plugins that steal the keyboard focus (translating page)</comment>
      <text xml:space="preserve" bytes="2417">{{Languages|Workaround plugins that steal the keyboard focus}}
{{DISPLAYTITLE:Обход плагинов перехватывающих клавиатуру}} 

Существует очень старый [https://bugzilla.mozilla.org/show_bug.cgi?id=78414 баг/особенность в firefox] который позволяет плагинам (Flash, Acrobat, и др.) перехватывать ВСЕ нажатия клавиш для окна. Т.е. при запущенном например Flash у вас например не сработают клавиши Ctrl+5, нажатие на которую вызывает обработчик Awesome. Поэтому некоторый возможности оконного менеджера, да и просто определенные вами действия могут не работать. Этот простой способ позволяет вернуть фокус ввода клавиатуры для окон верхнего уровня:

&lt;code&gt;
     -- уход из ловушки фокуса клавиатурного фокус (например для Flash плагина в Firefox)
     awful.key({ modkey, &quot;Control&quot; }, &quot;Escape&quot;, function ()
          awful.util.spawn(&quot;xdotool getactivewindow mousemove --window %1 0 0 click --clearmodifiers 2&quot;)
     end),
&lt;/code&gt;

Для использования этого способа у вас должен быть установлен [http://www.semicomplete.com/projects/xdotool/ xdotool].

== Альтернативный способ (без xdotool) ==

Например можно использвать [https://awesome.naquadah.org/wiki/Move_Mouse Move Mouse/ru| перемещение курсора] в свободную от контроля плагина зону (т.е. вне зоны действия ссылок или Flash элементов), обработать нажатие, а затем вызывать функцию описанную ниже, для имитации щелчка мыши уже в зоне действия плагина.

&lt;pre&gt;
-- Симуляция нажатия мыши
local function simulateClick()
    root.fake_input(&quot;button_press&quot;, 1)
    root.fake_input(&quot;button_release&quot;, 1)
end

-- Привязываем ее к клавишам
    awful.key({ modkey, }, &quot;n&quot;, function() simulateClick() end),
&lt;/pre&gt;</text>
      <sha1>rx55vgp2w6abchnp8ijek847c0w8dim</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Worm Theme</title>
    <ns>0</ns>
    <id>510</id>
    <revision>
      <id>3835</id>
      <parentid>3832</parentid>
      <timestamp>2009-11-24T02:16:28Z</timestamp>
      <contributor>
        <username>Anrxc</username>
        <id>258</id>
      </contributor>
      <minor/>
      <comment>Screenshot added to Worm theme page.</comment>
      <text xml:space="preserve" bytes="1011">[[Image:Screenshot-Worm.png|thumb|Screenshot]]
&lt;pre&gt;
--------------------------------
--    &quot;Worm&quot; awesome theme    --
--------------------------------
--   Inspired by Adobe Kuler  --
--------------------------------

-- {{{ Main
theme = {}
theme.wallpaper_cmd = { &quot;awsetbg /usr/share/awesome/themes/zenburn/zenburn-background.png&quot; }
-- }}}

-- {{{ Styles
theme.font          = &quot;Profont 8&quot;

-- {{{ Colors
theme.fg_normal     = &quot;#54534B&quot;
theme.fg_focus      = &quot;#54534B&quot;
theme.fg_urgent     = &quot;#562630&quot;
--theme.fg_minimize = &quot;#000000&quot;
theme.bg_normal     = &quot;#7D8C7C&quot;
theme.bg_focus      = &quot;#BCBDA5&quot;
theme.bg_urgent     = &quot;#DACEB1&quot;
--theme.bg_minimize = &quot;#81654F&quot;
-- }}}

-- {{{ Borders
theme.border_width  = &quot;1&quot;
theme.border_normal = &quot;#7D8C7C&quot;
theme.border_focus  = &quot;#BCBDA5&quot;
theme.border_marked = &quot;#562630&quot;
-- }}}

-- {{{ Titlebars
theme.titlebar_bg_focus  = &quot;#BCBDA5&quot;
theme.titlebar_bg_normal = &quot;#BCBDA5&quot; --&quot;#7D8C7C&quot;
-- }}}
-- }}}

-- {{{ Icons / Misc.
--
--     Choose your own.
--
-- }}}

return theme
&lt;/pre&gt;</text>
      <sha1>lslqb7qhkwrskb4x69t7mh6yduhniuc</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Writing own widgets</title>
    <ns>0</ns>
    <id>865</id>
    <revision>
      <id>6252</id>
      <parentid>6251</parentid>
      <timestamp>2014-02-11T21:29:24Z</timestamp>
      <contributor>
        <username>Alex.yakushev</username>
        <id>541</id>
      </contributor>
      <minor/>
      <comment>add categories</comment>
      <text xml:space="preserve" bytes="3365">{{VersionSpecific
| goodversions = 3.5
}}
With awesome 3.5 it becomes  possible to write your own widgets, without (ab)using the imagebox widget. We will do this by writing a widget that shows a simple cross in the wibox' foreground color.

== Full code ==

    local mycross = wibox.widget.base.make_widget()
    mycross.fit = function(mycross, width, height)
        local size = math.min(width, height)
        return size, size
    end
    mycross.draw = function(mycross, wibox, cr, width, height)
        cr:move_to(0, 0)
        cr:line_to(width, height)
        cr:move_to(width, 0)
        cr:line_to(0, height)
        cr:set_line_width(3)
        cr:stroke()
    end

That's it. We just needed to write two functions and now we got a simple widget which displays a cross.

== What the heck does it do? ==

Our widget consists of just two functions. Isn't that really easy?

=== The fit() function ===

The first function is called ''fit''. It is called whenever the widget needs to decide how large it should be. This function gets three arguments:
- The widget itself
- The available width
- The available height

Based on this information, this function has to decide how large the widget should be. In the example above, we just decide that the widget should be quadratic and its size should be the smaller one of the available width and height.

Please note that the ''fit'' function's result is only a hint and the widget may be drawn at different sizes, depending on the layout used. Some layouts don't even call the ''fit'' function at all. This means that your ''fit'' function should not do any important calculations and should not change any state.

=== The draw() function ===

The other function is called ''draw''. Obviously, it gets called to actually draw the widget. The arguments to this function are:
- Again, the widget itself
- The wibox or titlebar that the widget is being painted to
- A cairo context that should be used for drawing the widget
- The available width and height that the widget got allocated

The widget should then draw itself to the given cairo context in the area between the top-left corner (0, 0) and the bottom right corner at (width, height). The above example just draws a cross in this area. Please refer to cairo's documentation for more information about the available functions.

Notice that we did not specify any color for our cross. Which color gets used in this case? It is the wibox' foreground color. This is of course a nice thing and you should avoid setting specific colors in your own widgets, when possible.

Also, we did not draw any background for the widget. The widget's background is automatically filled with the wibox' background color. This means that your own widgets shouldn't draw their own background if they don't really have to.

=== Redrawing the widget ===

There is one last thing that is missing. Let's say we are writing an actual widget, for example a battery widget. How can the widget be forced to redraw itself?

This is as easy as ''mycross:emit_signal(&quot;widget::updated&quot;)''.

Now you should know enough so that you can write your own widgets. Have fun!

== Further reading ==

For more examples on cairo's API, you can read https://github.com/pavouk/lgi/blob/master/samples/cairo.lua and http://cairographics.org/manual/.

[[Category:Widgets]]

[[Category:Awesome3.5]]</text>
      <sha1>ob9wh2uuq2vmjinugw5lc9qafra905l</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>XRandR Screen Table</title>
    <ns>0</ns>
    <id>216</id>
    <revision>
      <id>6162</id>
      <parentid>6154</parentid>
      <timestamp>2013-11-01T00:04:26Z</timestamp>
      <contributor>
        <username>Klaernie</username>
        <id>3096</id>
      </contributor>
      <comment>add section for awesome3.5 with it's builtin solution</comment>
      <text xml:space="preserve" bytes="1899">{{Languages}}
 
=== XRandR Screen Table ===

==== awesome 3.5 ====

as of the commits 9393b2d1 and c08b9034 this functionality is builtin and documented (commit 29ecc609). Simply use it as in
&lt;pre&gt;client.focus.screen = screen[&quot;VGA&quot;].index&lt;/pre&gt;

This of course doesn't need any external utility.

==== awesome prior 3.5 ====

This small function can be used to address screens by their XRandR names instead of numbers. Paste it into your rc.lua.
 
Update by [[User:Klaernie|klaernie]]: the new version computes the screen numbers by their left edge instead of the order in '''xrandr -q'''. Also it respects the primary display as screen 1.
 
&lt;pre&gt;
function xrandr_screens ()
    local screens = {}
    local handle = io.popen(&quot;xrandr -q&quot;)
    for display,primary,left in handle:read(&quot;*all&quot;):gmatch(&quot;([%a%d-]+) connected (p*)r*i*m*a*r*y* *[%d]+x[%d]+%+([%d]+)%+[%d]+&quot;) do
        if primary == &quot;p&quot; then
            -- if this screen is the primary one it will get screen 1 in awesome
            -- so let's force it to be the first in the list by overriding it's 
            -- left edge
            screens[#screens+1] = {display=display,left=-1}
        else
            screens[#screens+1] = {display=display,left=tonumber(left)}
        end 
    end 
    handle:close()
   
    -- sort the screens by their left edge
    table.sort(screens,function(a,b)
                            return a.left&lt;b.left
                        end)
                            
    -- expand the temporary table back to
    -- screens[&quot;input&quot;]=screen id
    local tmpscreens = {}
    for index,spec in pairs(screens) do
        tmpscreens[spec.display] = index
    end 
    return tmpscreens
end
&lt;/pre&gt;
 
 
Then use it like this, for example:
&lt;pre&gt;
screens = xrandr_screens()
client.focus.screen = screens[&quot;VGA&quot;]
&lt;/pre&gt;
Please note that this function needs the '''xrandr''' tool installed.
[[Category:awesome3]]</text>
      <sha1>jfnlajhe7hp1ze71bhe79ubvsy5yvcj</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>XRandR Screen Table/fr</title>
    <ns>0</ns>
    <id>434</id>
    <revision>
      <id>3336</id>
      <parentid>3243</parentid>
      <timestamp>2009-07-15T18:14:22Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Use DISPLAYTITLE instead of Template:Title</comment>
      <text xml:space="preserve" bytes="775">{{DISPLAYTITLE:Tableau d’écrans XRandR}}
{{Languages|XRandR Screen Table}}

Cette petite fonction peut être utilisée pour indexer les écrans par leurs noms XRandR plutôt que par des numéros. En supposant que l’outil ''xrandr'' est installé sur votre système, vous n’avez qu’à copier–coller ceci dans votre '''rc.lua''' :

 function xrandr_screens ()
    local screens = {}
    local counter = 1
    local handle = io.popen(&quot;xrandr -q&quot;)
    for display in handle:read(&quot;*all&quot;):gmatch(&quot;([%a%d-]+) connected&quot;) do
        screens[display] = counter
        counter = counter + 1
    end
    handle:close()
    return screens
 end

Pour l’utiliser, mettez par exemple :
 screens = xrandr_screens()
 client.focus.screen = screens[&quot;VGA&quot;]

[[Category:awesome3]]</text>
      <sha1>jtple5cw3jbc41xpa56ims8jx0wb0dq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>XRandR Screen Table/ru</title>
    <ns>0</ns>
    <id>1049</id>
    <revision>
      <id>6517</id>
      <parentid>6516</parentid>
      <timestamp>2014-05-16T13:03:28Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>/* Таблица экранов XRandR */</comment>
      <text xml:space="preserve" bytes="2699">{{DISPLAYTITLE:Таблица экранов XRandR}}
{{Languages|XRandR Screen Table}}
 
=== Таблица экранов XRandR ===

==== awesome 3.5 ====

В commits 9393b2d1 и c08b9034 данная функциональност была строенна и задокументированна (commit 29ecc609). Поэтому просто используйте следующий код:
&lt;pre&gt;client.focus.screen = screen[&quot;VGA&quot;].index&lt;/pre&gt;

Данная функциональность теперь не нуждается во внешних утилитах.

==== awesome меньше 3.5 ====

Эта небольшая функция добавляет адресные экраны, исползуя их имена XRandR вместо обычных номеров. Вставьте этот код в ваш rc.lua.
 
Обновлено [[User:Klaernie|klaernie]]: новая версия вычисляет номер экрана по их левым краям, вместо последовательности в '''xrandr -q'''. Также она устанавливает основной экран как screen 1.
 
&lt;pre&gt;
function xrandr_screens ()
    local screens = {}
    local handle = io.popen(&quot;xrandr -q&quot;)
    for display,primary,left in handle:read(&quot;*all&quot;):gmatch(&quot;([%a%d-]+) connected (p*)r*i*m*a*r*y* *[%d]+x[%d]+%+([%d]+)%+[%d]+&quot;) do
        if primary == &quot;p&quot; then
            -- если этот экран является основным, ему присваивается 1 номер в awesome
            -- поэтому переопределим его для присваивания ему первого номера
            -- по левому краю
            screens[#screens+1] = {display=display,left=-1}
        else
            screens[#screens+1] = {display=display,left=tonumber(left)}
        end 
    end 
    handle:close()
   
    -- сортируем экраны по их левым краям
    table.sort(screens,function(a,b)
                            return a.left&lt;b.left
                        end)
                            
    -- снова расширяем временную таблицу 
    -- screens[&quot;input&quot;]=screen id
    local tmpscreens = {}
    for index,spec in pairs(screens) do
        tmpscreens[spec.display] = index
    end 
    return tmpscreens
end
&lt;/pre&gt;
 
 
Затем используйте его, например так:
&lt;pre&gt;
screens = xrandr_screens()
client.focus.screen = screens[&quot;VGA&quot;]
&lt;/pre&gt;
Пожалуйста помните, что для этой функции необходима установленная утилита '''xrandr'''.

[[Category:awesome3]]</text>
      <sha1>27f7vt18xvjeuglq8469ff0dzb9fgqe</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Xeno theme</title>
    <ns>0</ns>
    <id>182</id>
    <revision>
      <id>2780</id>
      <parentid>1411</parentid>
      <timestamp>2009-05-23T11:21:15Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>Adding to [[Category:Themes]]</comment>
      <text xml:space="preserve" bytes="659">&lt;pre&gt;
---------------------------
-- xeno awesome theme --
---------------------------

font          = fixed 8

bg_normal     = #000000
bg_focus      = #3465A4
bg_urgent     = #ff0000

fg_normal     = #ffffff
fg_focus      = #ffffff
fg_urgent     = #ffffff

border_width  = 1 
border_normal = #000055
border_focus  = #3465A4
border_marked = #91231c

# You can add as many variables as
# you wish and access them by using
# beautiful.variable in your rc.lua
#bg_widget    = #cc0000

# You can use your own command to set your wallpaper
#wallpaper_cmd = awsetbg /usr/share/awesome/themes/default-background.png
&lt;/pre&gt;

[[Category:Awesome3]]
[[Category:Themes]]</text>
      <sha1>9w77gwtjg4r05xa7ntet6egsrbialgr</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Xmms2 Widgets</title>
    <ns>0</ns>
    <id>10</id>
    <revision>
      <id>5958</id>
      <parentid>5565</parentid>
      <timestamp>2013-04-24T08:48:50Z</timestamp>
      <contributor>
        <username>Kierun</username>
        <id>1040</id>
      </contributor>
      <comment>/* Here is an alternative */</comment>
      <text xml:space="preserve" bytes="5167">== How to control xmms2d through widgets ==
{{Languages|Xmms2_Widgets}}

This article describes how to make a music player widget for xmms2. It contains play/pause, next and previous track buttons and displays artist - title of the current song. Preview[http://wakeup.rundumbonn.de/stuff/xmms2_widgets/awesome_widgets.jpg]

'''Requires:'''
* awesome &gt;= 2.1-rc1
* awesome-client
* xmms2 (daemon and default client)
* these icons [http://wakeup.rundumbonn.de/stuff/xmms2_widgets/next.png] [http://wakeup.rundumbonn.de/stuff/xmms2_widgets/prev.png] [http://wakeup.rundumbonn.de/stuff/xmms2_widgets/toggleplay.png]

'''Adjusting your .awesomerc'''

----

This is the part of my .awesomerc defining the widgets. I use a textbox for the status-display of xmms2d and iconboxes for the control buttons. As you can see I put the icons in ~/.config/awesome/icons/xmms2/, I suggest you to do it the same way, it is some standard and quite a good place for your awesome customizations. You can make your own icons of course, they have to be in .png format as far as I know. Remember that awesome will crash through clicking on a widget with a wrong image path.

        textbox nowplaying {
                text = &quot;-&quot; #the - will be replaced by `xmms2 current` piped to awesome-client
        }
        iconbox xmms2_prev {
                image = &quot;/home/wakeup/.config/awesome/icons/xmms2/prev.png&quot;
                #on left mouse button click xmms2 prev will be executed as if in a terminal
                mouse {
                        button = &quot;1&quot;
                        command = &quot;spawn&quot;
                        arg = &quot;xmms2 prev&quot;
                }
        }
        iconbox xmms2_toggleplay {
                image = &quot;/home/wakeup/.config/awesome/icons/xmms2/toggleplay.png&quot;
                mouse {
                        button = &quot;1&quot;
                        command = &quot;spawn&quot;
                        arg = &quot;xmms2 toggleplay&quot;
                }
        }
        iconbox xmms2_next {
                image = &quot;/home/wakeup/.config/awesome/icons/xmms2/next.png&quot;
                mouse {
                        button = &quot;1&quot;
                        command = &quot;spawn&quot;
                        arg = &quot;xmms2 next&quot;
                }
        }

'''Script to update &quot;artist - title&quot;'''

----
My update-script is located at ~/.config/awesome/scripts/nowplaying and of really simple nature. It is started through the following line in ~/.xinitrc

 /home/wakeup/.config/awesome/scripts/nowplaying &amp;

'''The script'''
 #!/bin/bash
 while true
 do
        song=`xmms2 current`
        echo &quot;0 widget_tell nowplaying $song&quot; | /usr/local/bin/awesome-client #tells the textbox-widget mentioned above to display the output of `xmms2 current`
        sleep 3
 done

Another option for the script is to use [http://alex.foxybanana.com/awesome-client.py]. This script supports on-broadcast/signal messaging, so that you don't have to wait 3 seconds for a song update. It also handles changing the icon of the play/pause button depending on the playback state. It also includes (commented out) support for working with cover art and playtime.

== Here is an alternative ==

=== Keyboard controls ===

I use my funky keyboard to control my player.  So, all I had to do is add the following to rc.lua: 

 awful.key({}, &quot;XF86AudioPlay&quot;, function () awful.util.spawn_with_shell(&quot;nyxmms2 toggle&quot;) end),
 awful.key({}, &quot;XF86AudioStop&quot;, function () awful.util.spawn_with_shell(&quot;nyxmms2 stop&quot;) end),
 awful.key({}, &quot;XF86AudioPrev&quot;, function () awful.util.spawn_with_shell(&quot;nyxmms2 prev&quot;) end),
 awful.key({}, &quot;XF86AudioNext&quot;, function () awful.util.spawn_with_shell(&quot;nyxmms2 next&quot;) end)

and I can then use the media part of my Logitech Wave keyboard.  Note that you may have to use xev and xmodmap to map the right key for your keyboard as the number will not be the same.

=== Dirty hack ===

For the status bar, I wanted a nice icon and the title which I ended up doing as:

 nowplaying = widget({ type = &quot;textbox&quot; })
 xmms2icon = widget({ type = &quot;imagebox&quot; })
 xmms2icon.image = image(beautiful.widget_xmms2)
 xmms2icon:buttons(awful.util.table.join(
    awful.button({ }, 1, function () awful.util.spawn_with_shell(&quot;~/bin/xmms2_status.sh&quot;) end)
  ))

where beautiful.widget_xmms2 is defined in my theme file and is the XMMS2 logo -- but you could change that to be whatever you liked. Finally, I wrote a small shell script to display the band and title based on the above code which works with newer versions of xmms2.

 #!/bin/bash
 while true
 do
     echo &quot;nowplaying.text = \&quot;`nyxmms2 status -f '${artist} - ${title}'`\&quot;&quot; | awesome-client
     sleep 5
 done

When the xmms2 icon is clicked, this shell script is run:

 #!/bin/sh
 urxvt256c-ml -geometry 256x7 -tr -e nyxmms2 status -r 1

which starts a shell with an interactive nyxmms2 session.

=== MPD Info ===

Note that you can use Donearm's [https://github.com/Donearm/Mpd-Info| Mpd-Info] script to display alerts that will show covert art and information about any new track played.  This is much much much better than the ugly hack above.  This is what you should use. 

[[Category:Widgets]]
[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>b547k57tmknilng0e2n8df5540vjpby</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Xmms2 Widgets/ru</title>
    <ns>0</ns>
    <id>691</id>
    <revision>
      <id>4934</id>
      <parentid>4932</parentid>
      <timestamp>2011-07-13T22:52:45Z</timestamp>
      <contributor>
        <username>Uchiro</username>
        <id>666</id>
      </contributor>
      <comment>/* Как управлять xmms2d посредством виджетов */</comment>
      <text xml:space="preserve" bytes="3608">== Как управлять xmms2d посредством виджетов ==
{{Languages|Xmms2_Widgets}}

В этой статье описывается, как создать виджет для музыкального плеера xmms2. Он содержит кнопки воспроизведение/пауза и следующий/предыдущий трек. Так же отображает текущее название песни и артиста. Предварительный просмотр[http://wakeup.rundumbonn.de/stuff/xmms2_widgets/awesome_widgets.jpg]

'''Требуется:'''
* awesome &gt;= 2.1-rc1
* awesome-client
* xmms2 (демон и обычный клиент)
* Эти иконки [http://wakeup.rundumbonn.de/stuff/xmms2_widgets/next.png] [http://wakeup.rundumbonn.de/stuff/xmms2_widgets/prev.png] [http://wakeup.rundumbonn.de/stuff/xmms2_widgets/toggleplay.png]

'''Настройки вашего .awesomerc'''

----

Это часть моего .awesomerc определяющего виджеты. Я использую textbox для статус-дисплея xmms2d и iconboxes для кнопок управления. Как вы можете видеть я положил иконки в ~/.config/awesome/icons/xmms2/, я предлагаю вам сделать так же, это некоторый стандарт и довольно хорошее место для настройки вашего awesome. Конечно вы можете сделать свои собственные иконки, но на сколько я знаю, они должны быть в формате .png. Помните, что awesome упадет если нажать на виджет с неверными путями изображения.

        textbox nowplaying {
                text = &quot;-&quot; #the - will be replaced by `xmms2 current` piped to awesome-client
        }
        iconbox xmms2_prev {
                image = &quot;/home/wakeup/.config/awesome/icons/xmms2/prev.png&quot;
                #on left mouse button click xmms2 prev will be executed as if in a terminal
                mouse {
                        button = &quot;1&quot;
                        command = &quot;spawn&quot;
                        arg = &quot;xmms2 prev&quot;
                }
        }
        iconbox xmms2_toggleplay {
                image = &quot;/home/wakeup/.config/awesome/icons/xmms2/toggleplay.png&quot;
                mouse {
                        button = &quot;1&quot;
                        command = &quot;spawn&quot;
                        arg = &quot;xmms2 toggleplay&quot;
                }
        }
        iconbox xmms2_next {
                image = &quot;/home/wakeup/.config/awesome/icons/xmms2/next.png&quot;
                mouse {
                        button = &quot;1&quot;
                        command = &quot;spawn&quot;
                        arg = &quot;xmms2 next&quot;
                }
        }

'''Скрипт обновления &quot;артиста - названия&quot;'''

----
Мой скрипт обновления размещен в ~/.config/awesome/scripts/nowplaying и действительно очень простой. Он запускается посредством добавления строки в ~/.xinitrc

 /home/wakeup/.config/awesome/scripts/nowplaying &amp;

'''Этот скрипт'''
 #!/bin/bash
 while true
 do
        song=`xmms2 current`
        echo &quot;0 widget_tell nowplaying $song&quot; | /usr/local/bin/awesome-client #tells the textbox-widget mentioned above to display the output of `xmms2 current`
        sleep 3
 done

[[Category:Widgets]]
[[Category:StatusBars]]
[[Category:awesome2]]</text>
      <sha1>9wqz1qm33ilk7w7ptungcopjezm8w8d</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Xscreensaver</title>
    <ns>0</ns>
    <id>547</id>
    <revision>
      <id>6731</id>
      <parentid>4580</parentid>
      <timestamp>2014-06-09T05:47:58Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <minor/>
      <comment>add languages tag</comment>
      <text xml:space="preserve" bytes="1082">{{Languages}}

== Xscreensaver ==
Desktop environments come with screensaver software which can be used to lock the screen when away from your machine. GNOME binds Alt-Ctrl-l to lock the screen. Awesome does not come with any screensaver or screen locking software. You can use use xscreensaver for this purpose.

*To install xscreensaver on Debian:
  sudo aptitude install xscreensaver

*Add the following to your .xinitrc to launch xscreensaver when starting X:
  xscreensaver -nosplash &amp;

*Set up a key binding( I use Alt-Ctrl-l ) in rc.lua:
    awful.key({ modkey, &quot;Control&quot; }, &quot;l&quot;, function () awful.util.spawn(&quot;xscreensaver-command -lock&quot;) end),

*Restart awesome.

== xautolock with xlockmore ==

An alternative to xscreensaver is a combo of the Debian packages xautolock and xlockmore.

What I love about xautolock is, that you can either disable or quickstart the screen lock by placing the mouse in one specific corner of the screen. - See the manpager of both packages.

== autolock with slock ==
Simple, just lock your screen (goes black), until you write your password.</text>
      <sha1>dlvm7sh2ip9jslk9ku85fe0iabwpuxu</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Xscreensaver/ru</title>
    <ns>0</ns>
    <id>1106</id>
    <revision>
      <id>6733</id>
      <timestamp>2014-06-09T05:59:13Z</timestamp>
      <contributor>
        <username>Faiver</username>
        <id>3296</id>
      </contributor>
      <comment>добавление страницы перевода Xscreensaver (translanting page)</comment>
      <text xml:space="preserve" bytes="1854">{{Languages|Xscreensaver}}

== Xscreensaver ==
Различные среды рабочего стола обычно укомплектованы скринсейверами, которые могут использоваться для блокировки экрана, когда вы отходите от компьютера. В GNOME используются клвиши Alt+Ctrl+l для блокировки экрана. В Awesome по умолчанию не стоит скринсейвер или программа блокировки. Поэтому вы можете использовать xscreensaver для этой цели.

*Для установки xscreensaver в Debian:
  sudo aptitude install xscreensaver

*Добавьте следующий код в .xinitrc для запуска xscreensaver при старте X:
  xscreensaver -nosplash &amp;

*Привяжите клавиши( я использую Alt-Ctrl-l ) в rc.lua:
    awful.key({ modkey, &quot;Control&quot; }, &quot;l&quot;, function () awful.util.spawn(&quot;xscreensaver-command -lock&quot;) end),

*Перезапустите Awesome.

== xautolock with xlockmore ==

В качестве альтернативы для xscreensaver можно использовать комбинация из 2х пакетов Debian xautolock и xlockmore.

Что мне нравится в xautolock, это то, что вы можете быстро отключить или запустить блокировку экрана, при размещении мыши в определенном углу экрана. Более подробно смотрите manpager этих двух пакетов.

== autolock with slock ==
Просто блокирует экран (он становится черным), до тех пор, пока вы не введете пароль.</text>
      <sha1>acjjkm83oeo8mqdzdoiwry4wc4jdfah</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Zenburn Theme</title>
    <ns>0</ns>
    <id>278</id>
    <revision>
      <id>3836</id>
      <parentid>3829</parentid>
      <timestamp>2009-11-24T02:22:55Z</timestamp>
      <contributor>
        <username>Anrxc</username>
        <id>258</id>
      </contributor>
      <minor/>
      <comment>Added link to theme icons.</comment>
      <text xml:space="preserve" bytes="5926">[[Image:Screenshot-anrxc.png|thumb|Screenshot]]

&lt;pre&gt;
-------------------------------
--  &quot;Zenburn&quot; awesome theme  --
--    By Adrian C. (anrxc)   --
--    License:  GNU GPL v2   --
-------------------------------


-- {{{ Main
theme = {}
theme.confdir = awful.util.getdir(&quot;config&quot;)
--theme.wallpaper_cmd   = { &quot;/usr/bin/nitrogen --restore&quot; }
theme.wallpaper_cmd = { &quot;awsetbg /usr/share/awesome/themes/zenburn/zenburn-background.png&quot; }
-- }}}


-- {{{ Styles
theme.font      = &quot;Profont 8&quot;

-- {{{ Colors
theme.fg_normal = &quot;#DCDCCC&quot;
theme.fg_focus  = &quot;#F0DFAF&quot;
theme.fg_urgent = &quot;#CC9393&quot;
theme.bg_normal = &quot;#3F3F3F&quot;
theme.bg_focus  = &quot;#1E2320&quot;
theme.bg_urgent = &quot;#3F3F3F&quot;
-- }}}

-- {{{ Borders
theme.border_width  = &quot;1&quot;
theme.border_normal = &quot;#3F3F3F&quot;
theme.border_focus  = &quot;#6F6F6F&quot;
theme.border_marked = &quot;#CC9393&quot;
-- }}}

-- {{{ Titlebars
theme.titlebar_bg_focus  = &quot;#3F3F3F&quot;
theme.titlebar_bg_normal = &quot;#3F3F3F&quot;
-- theme.titlebar_[normal|focus]
-- }}}

-- {{{ Widgets
theme.fg_widget        = &quot;#AECF96&quot;
theme.fg_center_widget = &quot;#88A175&quot;
theme.fg_end_widget    = &quot;#FF5656&quot;
theme.fg_off_widget    = &quot;#494B4F&quot;
theme.fg_netup_widget  = &quot;#7F9F7F&quot;
theme.fg_netdn_widget  = &quot;#CC9393&quot;
theme.bg_widget        = &quot;#3F3F3F&quot;
theme.border_widget    = &quot;#3F3F3F&quot;
-- }}}

-- {{{ Mouse finder
theme.mouse_finder_color = &quot;#CC9393&quot;
-- theme.mouse_finder_[timeout|animate_timeout|radius|factor]
-- }}}

-- {{{ Tooltips
-- theme.tooltip_[font|opacity|fg_color|bg_color|border_width|border_color]
-- }}}

-- {{{ Taglist and Tasklist
-- theme.[taglist|tasklist]_[bg|fg]_[focus|urgent]
-- }}}

-- {{{ Menu
-- theme.menu_[height|width]
-- theme.menu_[bg|fg]_[normal|focus]
-- theme.menu_[border_color|border_width]
-- }}}
-- }}}


-- {{{ Icons
--
-- {{{ Taglist icons
theme.taglist_squares_sel   = theme.confdir .. &quot;/icons/taglist/squarefz.png&quot;
theme.taglist_squares_unsel = theme.confdir .. &quot;/icons/taglist/squareza.png&quot;
--theme.taglist_squares_resize = &quot;false&quot;
-- }}}

-- {{{ Misc icons
--theme.awesome_icon           = theme.confdir .. &quot;/icons/awesome.png&quot;
--theme.menu_submenu_icon      = &quot;/usr/share/awesome/themes/default/submenu.png&quot;
--theme.tasklist_floating_icon = &quot;/usr/share/awesome/themes/default/tasklist/floatingw.png&quot;
-- }}}

-- {{{ Layout icons
theme.layout_tile       = theme.confdir .. &quot;/icons/layouts/tile.png&quot;
theme.layout_tileleft   = theme.confdir .. &quot;/icons/layouts/tileleft.png&quot;
theme.layout_tilebottom = theme.confdir .. &quot;/icons/layouts/tilebottom.png&quot;
theme.layout_tiletop    = theme.confdir .. &quot;/icons/layouts/tiletop.png&quot;
theme.layout_fairv      = theme.confdir .. &quot;/icons/layouts/fairv.png&quot;
theme.layout_fairh      = theme.confdir .. &quot;/icons/layouts/fairh.png&quot;
theme.layout_spiral     = theme.confdir .. &quot;/icons/layouts/spiral.png&quot;
theme.layout_dwindle    = theme.confdir .. &quot;/icons/layouts/dwindle.png&quot;
theme.layout_max        = theme.confdir .. &quot;/icons/layouts/max.png&quot;
theme.layout_fullscreen = theme.confdir .. &quot;/icons/layouts/fullscreen.png&quot;
theme.layout_magnifier  = theme.confdir .. &quot;/icons/layouts/magnifier.png&quot;
theme.layout_floating   = theme.confdir .. &quot;/icons/layouts/floating.png&quot;
-- }}}

-- {{{ Widget icons
theme.widget_cpu    = theme.confdir .. &quot;/icons/cpu.png&quot;
theme.widget_bat    = theme.confdir .. &quot;/icons/bat.png&quot;
theme.widget_mem    = theme.confdir .. &quot;/icons/mem.png&quot;
theme.widget_fs     = theme.confdir .. &quot;/icons/disk.png&quot;
theme.widget_net    = theme.confdir .. &quot;/icons/down.png&quot;
theme.widget_netup  = theme.confdir .. &quot;/icons/up.png&quot;
theme.widget_mail   = theme.confdir .. &quot;/icons/mail.png&quot;
theme.widget_vol    = theme.confdir .. &quot;/icons/vol.png&quot;
theme.widget_org    = theme.confdir .. &quot;/icons/cal.png&quot;
theme.widget_date   = theme.confdir .. &quot;/icons/time.png&quot;
theme.widget_crypto = theme.confdir .. &quot;/icons/crypto.png&quot;
-- }}}

-- {{{ Titlebar icons
theme.titlebar_close_button_focus  = theme.confdir .. &quot;/icons/titlebar/close_focus.png&quot;
theme.titlebar_close_button_normal = theme.confdir .. &quot;/icons/titlebar/close_normal.png&quot;

theme.titlebar_ontop_button_focus_active    = theme.confdir .. &quot;/icons/titlebar/ontop_focus_active.png&quot;
theme.titlebar_ontop_button_normal_active   = theme.confdir .. &quot;/icons/titlebar/ontop_normal_active.png&quot;
theme.titlebar_ontop_button_focus_inactive  = theme.confdir .. &quot;/icons/titlebar/ontop_focus_inactive.png&quot;
theme.titlebar_ontop_button_normal_inactive = theme.confdir .. &quot;/icons/titlebar/ontop_normal_inactive.png&quot;

theme.titlebar_sticky_button_focus_active    = theme.confdir .. &quot;/icons/titlebar/sticky_focus_active.png&quot;
theme.titlebar_sticky_button_normal_active   = theme.confdir .. &quot;/icons/titlebar/sticky_normal_active.png&quot;
theme.titlebar_sticky_button_focus_inactive  = theme.confdir .. &quot;/icons/titlebar/sticky_focus_inactive.png&quot;
theme.titlebar_sticky_button_normal_inactive = theme.confdir .. &quot;/icons/titlebar/sticky_normal_inactive.png&quot;

theme.titlebar_floating_button_focus_active    = theme.confdir .. &quot;/icons/titlebar/floating_focus_active.png&quot;
theme.titlebar_floating_button_normal_active   = theme.confdir .. &quot;/icons/titlebar/floating_normal_active.png&quot;
theme.titlebar_floating_button_focus_inactive  = theme.confdir .. &quot;/icons/titlebar/floating_focus_inactive.png&quot;
theme.titlebar_floating_button_normal_inactive = theme.confdir .. &quot;/icons/titlebar/floating_normal_inactive.png&quot;

theme.titlebar_maximized_button_focus_active    = theme.confdir .. &quot;/icons/titlebar/maximized_focus_active.png&quot;
theme.titlebar_maximized_button_normal_active   = theme.confdir .. &quot;/icons/titlebar/maximized_normal_active.png&quot;
theme.titlebar_maximized_button_focus_inactive  = theme.confdir .. &quot;/icons/titlebar/maximized_focus_inactive.png&quot;
theme.titlebar_maximized_button_normal_inactive = theme.confdir .. &quot;/icons/titlebar/maximized_normal_inactive.png&quot;
-- }}}
-- }}}


return theme
&lt;/pre&gt;

* [http://git.sysphere.org/awesome-configs/tree/icons Theme Icons].
* [http://slinky.imukuppi.org/zenburnpage/ Zenburn Home Page].

[[Category:Themes]]
[[Category:awesome3]]</text>
      <sha1>8r7fqlr8wk7luccz4ge0mn3sk7wdmk8</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Zh:</title>
    <ns>0</ns>
    <id>632</id>
    <redirect title="Main Page/zh" />
    <revision>
      <id>4660</id>
      <timestamp>2011-01-14T16:22:59Z</timestamp>
      <contributor>
        <username>Psychon</username>
        <id>312</id>
      </contributor>
      <comment>moved [[Zh:]] to [[Main Page/zh]]:&amp;#32;Move this to the right place</comment>
      <text xml:space="preserve" bytes="26">#REDIRECT [[Main Page/zh]]</text>
      <sha1>ai3qki6ln2yzm6yiz7a9md91k2ljgmm</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
  <page>
    <title>Zhuravlik theme</title>
    <ns>0</ns>
    <id>489</id>
    <revision>
      <id>3658</id>
      <timestamp>2009-10-10T22:10:01Z</timestamp>
      <contributor>
        <username>Zhuravlik</username>
        <id>372</id>
      </contributor>
      <comment>Created page with '[[Image:Zhuravlik_screen.png|thumb|Theme screenshot]]  Modified color scheme for default theme. For those who prefer light colors.   theme.bg_normal     = &quot;#f7f7f7ee&quot;  theme.bg_f…'</comment>
      <text xml:space="preserve" bytes="719">[[Image:Zhuravlik_screen.png|thumb|Theme screenshot]]

Modified color scheme for default theme. For those who prefer light colors.

 theme.bg_normal     = &quot;#f7f7f7ee&quot;
 theme.bg_focus      = &quot;#535d6cee&quot;
 theme.bg_urgent     = &quot;#ff0000ee&quot;
 theme.bg_minimize   = &quot;#444444ee&quot;

 theme.fg_normal     = &quot;#535d6c&quot;
 theme.fg_focus      = &quot;#ffffff&quot;
 theme.fg_urgent     = &quot;#ffffff&quot;
 theme.fg_minimize  = &quot;#ffffff&quot;

 theme.border_width  = &quot;1&quot;
 theme.border_normal = &quot;#000000&quot;
 theme.border_focus  = &quot;#535d6c&quot;

 theme.wallpaper_cmd = { &quot;/home/anton/.fehbg&quot; }

Weather, mpd, keyboard layout, volume level widgets are implemented through simple shellscripts and [http://code.google.com/p/bashets/ Bashets user-script widget library].</text>
      <sha1>2usixj64d7d63bvmqjqqpim8zzt84bq</sha1>
      <model>wikitext</model>
      <format>text/x-wiki</format>
    </revision>
  </page>
</mediawiki>
